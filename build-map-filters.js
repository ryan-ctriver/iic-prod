(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // bin/live-reload.js
  var init_live_reload = __esm({
    "bin/live-reload.js"() {
      new EventSource(`${"http://localhost:3000"}/esbuild`).addEventListener("change", () => location.reload());
    }
  });

  // node_modules/mapbox-gl/dist/mapbox-gl.js
  var require_mapbox_gl = __commonJS({
    "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
      init_live_reload();
      (function(global, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global.mapboxgl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, mapboxgl2;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "self.onerror = function() { console.error('An error occurred while parsing the WebWorker bundle. This is most likely due to improper transpilation by Babel; please see https://docs.mapbox.com/mapbox-gl-js/guides/install/#transpiling'); }; var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk); self.onerror = null;";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl2 = chunk(sharedChunk);
            if (typeof window !== "undefined" && window && window.URL && window.URL.createObjectURL) {
              mapboxgl2.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          var e = 1e-6, r = "undefined" != typeof Float32Array ? Float32Array : Array;
          function n(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = r2 * s2 - i2 * n2;
            return o2 ? (t2[0] = s2 * (o2 = 1 / o2), t2[1] = -n2 * o2, t2[2] = -i2 * o2, t2[3] = r2 * o2, t2) : null;
          }
          function i() {
            var t2 = new r(9);
            return r != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }
          function s(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = e2[4], a2 = e2[5], l2 = e2[6], u5 = e2[7], c2 = e2[8];
            return t2[0] = o2 * c2 - a2 * u5, t2[1] = i2 * u5 - n2 * c2, t2[2] = n2 * a2 - i2 * o2, t2[3] = a2 * l2 - s2 * c2, t2[4] = r2 * c2 - i2 * l2, t2[5] = i2 * s2 - r2 * a2, t2[6] = s2 * u5 - o2 * l2, t2[7] = n2 * l2 - r2 * u5, t2[8] = r2 * o2 - n2 * s2, t2;
          }
          function o(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = e2[4], l2 = e2[5], u5 = e2[6], c2 = e2[7], h2 = e2[8], p2 = r2[0], f2 = r2[1], d2 = r2[2], m2 = r2[3], y2 = r2[4], g2 = r2[5], x2 = r2[6], v3 = r2[7], b2 = r2[8];
            return t2[0] = p2 * n2 + f2 * o2 + d2 * u5, t2[1] = p2 * i2 + f2 * a2 + d2 * c2, t2[2] = p2 * s2 + f2 * l2 + d2 * h2, t2[3] = m2 * n2 + y2 * o2 + g2 * u5, t2[4] = m2 * i2 + y2 * a2 + g2 * c2, t2[5] = m2 * s2 + y2 * l2 + g2 * h2, t2[6] = x2 * n2 + v3 * o2 + b2 * u5, t2[7] = x2 * i2 + v3 * a2 + b2 * c2, t2[8] = x2 * s2 + v3 * l2 + b2 * h2, t2;
          }
          function a() {
            var t2 = new r(16);
            return r != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }
          function l(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function u4(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = e2[4], a2 = e2[5], l2 = e2[6], u5 = e2[7], c2 = e2[8], h2 = e2[9], p2 = e2[10], f2 = e2[11], d2 = e2[12], m2 = e2[13], y2 = e2[14], g2 = e2[15], x2 = r2 * a2 - n2 * o2, v3 = r2 * l2 - i2 * o2, b2 = r2 * u5 - s2 * o2, _2 = n2 * l2 - i2 * a2, w2 = n2 * u5 - s2 * a2, A2 = i2 * u5 - s2 * l2, M2 = c2 * m2 - h2 * d2, I2 = c2 * y2 - p2 * d2, S2 = c2 * g2 - f2 * d2, z2 = h2 * y2 - p2 * m2, k2 = h2 * g2 - f2 * m2, E2 = p2 * g2 - f2 * y2, P2 = x2 * E2 - v3 * k2 + b2 * z2 + _2 * S2 - w2 * I2 + A2 * M2;
            return P2 ? (t2[0] = (a2 * E2 - l2 * k2 + u5 * z2) * (P2 = 1 / P2), t2[1] = (i2 * k2 - n2 * E2 - s2 * z2) * P2, t2[2] = (m2 * A2 - y2 * w2 + g2 * _2) * P2, t2[3] = (p2 * w2 - h2 * A2 - f2 * _2) * P2, t2[4] = (l2 * S2 - o2 * E2 - u5 * I2) * P2, t2[5] = (r2 * E2 - i2 * S2 + s2 * I2) * P2, t2[6] = (y2 * b2 - d2 * A2 - g2 * v3) * P2, t2[7] = (c2 * A2 - p2 * b2 + f2 * v3) * P2, t2[8] = (o2 * k2 - a2 * S2 + u5 * M2) * P2, t2[9] = (n2 * S2 - r2 * k2 - s2 * M2) * P2, t2[10] = (d2 * w2 - m2 * b2 + g2 * x2) * P2, t2[11] = (h2 * b2 - c2 * w2 - f2 * x2) * P2, t2[12] = (a2 * I2 - o2 * z2 - l2 * M2) * P2, t2[13] = (r2 * z2 - n2 * I2 + i2 * M2) * P2, t2[14] = (m2 * v3 - d2 * _2 - y2 * x2) * P2, t2[15] = (c2 * _2 - h2 * v3 + p2 * x2) * P2, t2) : null;
          }
          function c(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = e2[4], l2 = e2[5], u5 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], m2 = e2[12], y2 = e2[13], g2 = e2[14], x2 = e2[15], v3 = r2[0], b2 = r2[1], _2 = r2[2], w2 = r2[3];
            return t2[0] = v3 * n2 + b2 * a2 + _2 * h2 + w2 * m2, t2[1] = v3 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[2] = v3 * s2 + b2 * u5 + _2 * f2 + w2 * g2, t2[3] = v3 * o2 + b2 * c2 + _2 * d2 + w2 * x2, t2[4] = (v3 = r2[4]) * n2 + (b2 = r2[5]) * a2 + (_2 = r2[6]) * h2 + (w2 = r2[7]) * m2, t2[5] = v3 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[6] = v3 * s2 + b2 * u5 + _2 * f2 + w2 * g2, t2[7] = v3 * o2 + b2 * c2 + _2 * d2 + w2 * x2, t2[8] = (v3 = r2[8]) * n2 + (b2 = r2[9]) * a2 + (_2 = r2[10]) * h2 + (w2 = r2[11]) * m2, t2[9] = v3 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[10] = v3 * s2 + b2 * u5 + _2 * f2 + w2 * g2, t2[11] = v3 * o2 + b2 * c2 + _2 * d2 + w2 * x2, t2[12] = (v3 = r2[12]) * n2 + (b2 = r2[13]) * a2 + (_2 = r2[14]) * h2 + (w2 = r2[15]) * m2, t2[13] = v3 * i2 + b2 * l2 + _2 * p2 + w2 * y2, t2[14] = v3 * s2 + b2 * u5 + _2 * f2 + w2 * g2, t2[15] = v3 * o2 + b2 * c2 + _2 * d2 + w2 * x2, t2;
          }
          function h(t2, e2, r2) {
            var n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2 = r2[0], y2 = r2[1], g2 = r2[2];
            return e2 === t2 ? (t2[12] = e2[0] * m2 + e2[4] * y2 + e2[8] * g2 + e2[12], t2[13] = e2[1] * m2 + e2[5] * y2 + e2[9] * g2 + e2[13], t2[14] = e2[2] * m2 + e2[6] * y2 + e2[10] * g2 + e2[14], t2[15] = e2[3] * m2 + e2[7] * y2 + e2[11] * g2 + e2[15]) : (i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = e2[4], l2 = e2[5], u5 = e2[6], c2 = e2[7], h2 = e2[8], p2 = e2[9], f2 = e2[10], d2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = s2, t2[3] = o2, t2[4] = a2, t2[5] = l2, t2[6] = u5, t2[7] = c2, t2[8] = h2, t2[9] = p2, t2[10] = f2, t2[11] = d2, t2[12] = n2 * m2 + a2 * y2 + h2 * g2 + e2[12], t2[13] = i2 * m2 + l2 * y2 + p2 * g2 + e2[13], t2[14] = s2 * m2 + u5 * y2 + f2 * g2 + e2[14], t2[15] = o2 * m2 + c2 * y2 + d2 * g2 + e2[15]), t2;
          }
          function p(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * s2, t2[9] = e2[9] * s2, t2[10] = e2[10] * s2, t2[11] = e2[11] * s2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }
          function f(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[4], o2 = e2[5], a2 = e2[6], l2 = e2[7], u5 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = s2 * i2 + u5 * n2, t2[5] = o2 * i2 + c2 * n2, t2[6] = a2 * i2 + h2 * n2, t2[7] = l2 * i2 + p2 * n2, t2[8] = u5 * i2 - s2 * n2, t2[9] = c2 * i2 - o2 * n2, t2[10] = h2 * i2 - a2 * n2, t2[11] = p2 * i2 - l2 * n2, t2;
          }
          function d(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], o2 = e2[1], a2 = e2[2], l2 = e2[3], u5 = e2[8], c2 = e2[9], h2 = e2[10], p2 = e2[11];
            return e2 !== t2 && (t2[4] = e2[4], t2[5] = e2[5], t2[6] = e2[6], t2[7] = e2[7], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 - u5 * n2, t2[1] = o2 * i2 - c2 * n2, t2[2] = a2 * i2 - h2 * n2, t2[3] = l2 * i2 - p2 * n2, t2[8] = s2 * n2 + u5 * i2, t2[9] = o2 * n2 + c2 * i2, t2[10] = a2 * n2 + h2 * i2, t2[11] = l2 * n2 + p2 * i2, t2;
          }
          function m(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), s2 = e2[0], o2 = e2[1], a2 = e2[2], l2 = e2[3], u5 = e2[4], c2 = e2[5], h2 = e2[6], p2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = s2 * i2 + u5 * n2, t2[1] = o2 * i2 + c2 * n2, t2[2] = a2 * i2 + h2 * n2, t2[3] = l2 * i2 + p2 * n2, t2[4] = u5 * i2 - s2 * n2, t2[5] = c2 * i2 - o2 * n2, t2[6] = h2 * i2 - a2 * n2, t2[7] = p2 * i2 - l2 * n2, t2;
          }
          function y(t2, e2) {
            return t2[0] = e2[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = e2[1], t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = e2[2], t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function g(t2, r2, n2) {
            var i2, s2, o2, a2 = n2[0], l2 = n2[1], u5 = n2[2], c2 = Math.hypot(a2, l2, u5);
            return c2 < e ? null : (a2 *= c2 = 1 / c2, l2 *= c2, u5 *= c2, i2 = Math.sin(r2), s2 = Math.cos(r2), t2[0] = a2 * a2 * (o2 = 1 - s2) + s2, t2[1] = l2 * a2 * o2 + u5 * i2, t2[2] = u5 * a2 * o2 - l2 * i2, t2[3] = 0, t2[4] = a2 * l2 * o2 - u5 * i2, t2[5] = l2 * l2 * o2 + s2, t2[6] = u5 * l2 * o2 + a2 * i2, t2[7] = 0, t2[8] = a2 * u5 * o2 + l2 * i2, t2[9] = l2 * u5 * o2 - a2 * i2, t2[10] = u5 * u5 * o2 + s2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2);
          }
          function x(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = r2 + r2, a2 = n2 + n2, l2 = i2 + i2, u5 = r2 * o2, c2 = n2 * o2, h2 = n2 * a2, p2 = i2 * o2, f2 = i2 * a2, d2 = i2 * l2, m2 = s2 * o2, y2 = s2 * a2, g2 = s2 * l2;
            return t2[0] = 1 - h2 - d2, t2[1] = c2 + g2, t2[2] = p2 - y2, t2[3] = 0, t2[4] = c2 - g2, t2[5] = 1 - u5 - d2, t2[6] = f2 + m2, t2[7] = 0, t2[8] = p2 + y2, t2[9] = f2 - m2, t2[10] = 1 - u5 - h2, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = 0, e2 = arguments.length; e2--; ) t2 += arguments[e2] * arguments[e2];
            return Math.sqrt(t2);
          });
          var v2 = c;
          function b() {
            var t2 = new r(3);
            return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2;
          }
          function _(t2) {
            var e2 = new r(3);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
          }
          function w(t2) {
            return Math.hypot(t2[0], t2[1], t2[2]);
          }
          function A(t2, e2, n2) {
            var i2 = new r(3);
            return i2[0] = t2, i2[1] = e2, i2[2] = n2, i2;
          }
          function M(t2, e2, r2) {
            return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
          }
          function I(t2, e2, r2) {
            return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
          }
          function S(t2, e2, r2) {
            return t2[0] = e2[0] * r2[0], t2[1] = e2[1] * r2[1], t2[2] = e2[2] * r2[2], t2;
          }
          function z(t2, e2, r2) {
            return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2;
          }
          function k(t2, e2, r2) {
            return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2;
          }
          function E(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
          }
          function P(t2, e2, r2, n2) {
            return t2[0] = e2[0] + r2[0] * n2, t2[1] = e2[1] + r2[1] * n2, t2[2] = e2[2] + r2[2] * n2, t2;
          }
          function T(t2, e2) {
            var r2 = e2[0] - t2[0], n2 = e2[1] - t2[1], i2 = e2[2] - t2[2];
            return r2 * r2 + n2 * n2 + i2 * i2;
          }
          function B2(t2) {
            var e2 = t2[0], r2 = t2[1], n2 = t2[2];
            return e2 * e2 + r2 * r2 + n2 * n2;
          }
          function V(t2, e2) {
            return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2;
          }
          function C(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = r2 * r2 + n2 * n2 + i2 * i2;
            return s2 > 0 && (s2 = 1 / Math.sqrt(s2)), t2[0] = e2[0] * s2, t2[1] = e2[1] * s2, t2[2] = e2[2] * s2, t2;
          }
          function D2(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
          }
          function F(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = r2[0], a2 = r2[1], l2 = r2[2];
            return t2[0] = i2 * l2 - s2 * a2, t2[1] = s2 * o2 - n2 * l2, t2[2] = n2 * a2 - i2 * o2, t2;
          }
          function L(t2, e2, r2, n2) {
            var i2 = e2[0], s2 = e2[1], o2 = e2[2];
            return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = o2 + n2 * (r2[2] - o2), t2;
          }
          function R(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15];
            return t2[0] = (r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12]) / (o2 = o2 || 1), t2[1] = (r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13]) / o2, t2[2] = (r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14]) / o2, t2;
          }
          function O(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2];
            return t2[0] = n2 * r2[0] + i2 * r2[3] + s2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + s2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + s2 * r2[8], t2;
          }
          function U(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], s2 = r2[2], o2 = e2[0], a2 = e2[1], l2 = e2[2], u5 = i2 * l2 - s2 * a2, c2 = s2 * o2 - n2 * l2, h2 = n2 * a2 - i2 * o2, p2 = i2 * h2 - s2 * c2, f2 = s2 * u5 - n2 * h2, d2 = n2 * c2 - i2 * u5, m2 = 2 * r2[3];
            return c2 *= m2, h2 *= m2, f2 *= 2, d2 *= 2, t2[0] = o2 + (u5 *= m2) + (p2 *= 2), t2[1] = a2 + c2 + f2, t2[2] = l2 + h2 + d2, t2;
          }
          function N(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2];
          }
          var j = I, $ = S, G = w;
          function q() {
            var t2 = new r(4);
            return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0), t2;
          }
          function H(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
          }
          function X(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = r2 * r2 + n2 * n2 + i2 * i2 + s2 * s2;
            return o2 > 0 && (o2 = 1 / Math.sqrt(o2)), t2[0] = r2 * o2, t2[1] = n2 * o2, t2[2] = i2 * o2, t2[3] = s2 * o2, t2;
          }
          function Z(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * s2 + r2[12] * o2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * s2 + r2[13] * o2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * s2 + r2[14] * o2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * s2 + r2[15] * o2, t2;
          }
          function W() {
            var t2 = new r(4);
            return r != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0), t2[3] = 1, t2;
          }
          function Y(t2) {
            return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2;
          }
          function K(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 + o2 * a2, t2[1] = i2 * l2 + s2 * a2, t2[2] = s2 * l2 - i2 * a2, t2[3] = o2 * l2 - n2 * a2, t2;
          }
          function J(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 - s2 * a2, t2[1] = i2 * l2 + o2 * a2, t2[2] = s2 * l2 + n2 * a2, t2[3] = o2 * l2 - i2 * a2, t2;
          }
          b(), q();
          var Q, tt, et, rt, nt, it = X, st = (Q = b(), tt = A(1, 0, 0), et = A(0, 1, 0), function(t2, e2, r2) {
            var n2 = D2(e2, r2);
            return n2 < -0.999999 ? (F(Q, tt, e2), G(Q) < 1e-6 && F(Q, et, e2), C(Q, Q), function(t3, e3, r3) {
              r3 *= 0.5;
              var n3 = Math.sin(r3);
              t3[0] = n3 * e3[0], t3[1] = n3 * e3[1], t3[2] = n3 * e3[2], t3[3] = Math.cos(r3);
            }(t2, Q, Math.PI), t2) : n2 > 0.999999 ? (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 1, t2) : (F(Q, e2, r2), t2[0] = Q[0], t2[1] = Q[1], t2[2] = Q[2], t2[3] = 1 + n2, it(t2, t2));
          });
          function ot() {
            var t2 = new r(2);
            return r != Float32Array && (t2[0] = 0, t2[1] = 0), t2;
          }
          function at(t2, e2) {
            var n2 = new r(2);
            return n2[0] = t2, n2[1] = e2, n2;
          }
          function lt(t2, e2, r2) {
            return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2;
          }
          function ut(t2, e2, r2) {
            return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2;
          }
          function ct(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2;
          }
          function ht(t2) {
            return Math.hypot(t2[0], t2[1]);
          }
          function pt(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = r2 * r2 + n2 * n2;
            return i2 > 0 && (i2 = 1 / Math.sqrt(i2)), t2[0] = e2[0] * i2, t2[1] = e2[1] * i2, t2;
          }
          function ft(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1];
          }
          function dt(t2) {
            return t2 && t2.__esModule && Object.prototype.hasOwnProperty.call(t2, "default") ? t2.default : t2;
          }
          W(), W(), i(), ot();
          var mt, yt, gt = function() {
            if (nt) return rt;
            function t2(t3, e2, r2, n2) {
              this.cx = 3 * t3, this.bx = 3 * (r2 - t3) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t3, this.p1y = e2, this.p2x = r2, this.p2y = n2;
            }
            return nt = 1, rt = t2, t2.prototype = { sampleCurveX: function(t3) {
              return ((this.ax * t3 + this.bx) * t3 + this.cx) * t3;
            }, sampleCurveY: function(t3) {
              return ((this.ay * t3 + this.by) * t3 + this.cy) * t3;
            }, sampleCurveDerivativeX: function(t3) {
              return (3 * this.ax * t3 + 2 * this.bx) * t3 + this.cx;
            }, solveCurveX: function(t3, e2) {
              if (void 0 === e2 && (e2 = 1e-6), t3 < 0) return 0;
              if (t3 > 1) return 1;
              for (var r2 = t3, n2 = 0; n2 < 8; n2++) {
                var i2 = this.sampleCurveX(r2) - t3;
                if (Math.abs(i2) < e2) return r2;
                var s2 = this.sampleCurveDerivativeX(r2);
                if (Math.abs(s2) < 1e-6) break;
                r2 -= i2 / s2;
              }
              var o2 = 0, a2 = 1;
              for (r2 = t3, n2 = 0; n2 < 20 && (i2 = this.sampleCurveX(r2), !(Math.abs(i2 - t3) < e2)); n2++) t3 > i2 ? o2 = r2 : a2 = r2, r2 = 0.5 * (a2 - o2) + o2;
              return r2;
            }, solve: function(t3, e2) {
              return this.sampleCurveY(this.solveCurveX(t3, e2));
            } }, rt;
          }(), xt = dt(gt);
          function vt() {
            if (yt) return mt;
            function t2(t3, e2) {
              this.x = t3, this.y = e2;
            }
            return yt = 1, mt = t2, t2.prototype = { clone: function() {
              return new t2(this.x, this.y);
            }, add: function(t3) {
              return this.clone()._add(t3);
            }, sub: function(t3) {
              return this.clone()._sub(t3);
            }, multByPoint: function(t3) {
              return this.clone()._multByPoint(t3);
            }, divByPoint: function(t3) {
              return this.clone()._divByPoint(t3);
            }, mult: function(t3) {
              return this.clone()._mult(t3);
            }, div: function(t3) {
              return this.clone()._div(t3);
            }, rotate: function(t3) {
              return this.clone()._rotate(t3);
            }, rotateAround: function(t3, e2) {
              return this.clone()._rotateAround(t3, e2);
            }, matMult: function(t3) {
              return this.clone()._matMult(t3);
            }, unit: function() {
              return this.clone()._unit();
            }, perp: function() {
              return this.clone()._perp();
            }, round: function() {
              return this.clone()._round();
            }, mag: function() {
              return Math.sqrt(this.x * this.x + this.y * this.y);
            }, equals: function(t3) {
              return this.x === t3.x && this.y === t3.y;
            }, dist: function(t3) {
              return Math.sqrt(this.distSqr(t3));
            }, distSqr: function(t3) {
              var e2 = t3.x - this.x, r2 = t3.y - this.y;
              return e2 * e2 + r2 * r2;
            }, angle: function() {
              return Math.atan2(this.y, this.x);
            }, angleTo: function(t3) {
              return Math.atan2(this.y - t3.y, this.x - t3.x);
            }, angleWith: function(t3) {
              return this.angleWithSep(t3.x, t3.y);
            }, angleWithSep: function(t3, e2) {
              return Math.atan2(this.x * e2 - this.y * t3, this.x * t3 + this.y * e2);
            }, _matMult: function(t3) {
              var e2 = t3[2] * this.x + t3[3] * this.y;
              return this.x = t3[0] * this.x + t3[1] * this.y, this.y = e2, this;
            }, _add: function(t3) {
              return this.x += t3.x, this.y += t3.y, this;
            }, _sub: function(t3) {
              return this.x -= t3.x, this.y -= t3.y, this;
            }, _mult: function(t3) {
              return this.x *= t3, this.y *= t3, this;
            }, _div: function(t3) {
              return this.x /= t3, this.y /= t3, this;
            }, _multByPoint: function(t3) {
              return this.x *= t3.x, this.y *= t3.y, this;
            }, _divByPoint: function(t3) {
              return this.x /= t3.x, this.y /= t3.y, this;
            }, _unit: function() {
              return this._div(this.mag()), this;
            }, _perp: function() {
              var t3 = this.y;
              return this.y = this.x, this.x = -t3, this;
            }, _rotate: function(t3) {
              var e2 = Math.cos(t3), r2 = Math.sin(t3), n2 = r2 * this.x + e2 * this.y;
              return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
            }, _rotateAround: function(t3, e2) {
              var r2 = Math.cos(t3), n2 = Math.sin(t3), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
              return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
            }, _round: function() {
              return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
            } }, t2.convert = function(e2) {
              return e2 instanceof t2 ? e2 : Array.isArray(e2) ? new t2(e2[0], e2[1]) : e2;
            }, mt;
          }
          var bt = dt(vt());
          function _t(t2, e2) {
            if (Array.isArray(t2)) {
              if (!Array.isArray(e2) || t2.length !== e2.length) return false;
              for (let r2 = 0; r2 < t2.length; r2++) if (!_t(t2[r2], e2[r2])) return false;
              return true;
            }
            if ("object" == typeof t2 && null !== t2 && null !== e2) {
              if ("object" != typeof e2) return false;
              if (Object.keys(t2).length !== Object.keys(e2).length) return false;
              for (const r2 in t2) if (!_t(t2[r2], e2[r2])) return false;
              return true;
            }
            return t2 === e2;
          }
          const wt = Math.PI / 180, At = 180 / Math.PI;
          function Mt(t2) {
            return t2 * wt;
          }
          function It(t2) {
            return t2 * At;
          }
          const St = [[0, 0], [1, 0], [1, 1], [0, 1]];
          function zt(t2) {
            if (t2 <= 0) return 0;
            if (t2 >= 1) return 1;
            const e2 = t2 * t2, r2 = e2 * t2;
            return 4 * (t2 < 0.5 ? r2 : 3 * (t2 - e2) + r2 - 0.75);
          }
          function kt(t2, e2, r2, n2) {
            const i2 = new xt(t2, e2, r2, n2);
            return function(t3) {
              return i2.solve(t3);
            };
          }
          const Et = kt(0.25, 0.1, 0.25, 1);
          function Pt(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function Tt(t2, e2, r2) {
            return (r2 = Pt((r2 - t2) / (e2 - t2), 0, 1)) * r2 * (3 - 2 * r2);
          }
          function Bt(t2, e2, r2) {
            const n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function Vt(t2, e2, r2) {
            if (!t2.length) return r2(null, []);
            let n2 = t2.length;
            const i2 = new Array(t2.length);
            let s2 = null;
            t2.forEach((t3, o2) => {
              e2(t3, (t4, e3) => {
                t4 && (s2 = t4), i2[o2] = e3, 0 == --n2 && r2(s2, i2);
              });
            });
          }
          function Ct(t2, ...e2) {
            for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
            return t2;
          }
          let Dt = 1;
          function Ft() {
            return Dt++;
          }
          function Lt(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }
          function Rt(t2, e2) {
            t2.forEach((t3) => {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function Ot(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2) n2[r3] = e2.call(this, t2[r3], r3, t2);
            return n2;
          }
          function Ut(t2, e2, r2) {
            const n2 = {};
            for (const r3 in t2) e2.call(this, t2[r3], r3, t2) && (n2[r3] = t2[r3]);
            return n2;
          }
          function Nt(t2) {
            return Array.isArray(t2) ? t2.map(Nt) : "object" == typeof t2 && t2 ? Ot(t2, Nt) : t2;
          }
          const jt = {};
          function $t(t2) {
            jt[t2] || ("undefined" != typeof console && console.warn(t2), jt[t2] = true);
          }
          function Gt(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function qt(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, o2 = s2 - 1; i2 < s2; o2 = i2++) r2 = t2[i2], n2 = t2[o2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function Ht([t2, e2, r2]) {
            const n2 = Mt(e2 + 90), i2 = Mt(r2);
            return { x: t2 * Math.cos(n2) * Math.sin(i2), y: t2 * Math.sin(n2) * Math.sin(i2), z: t2 * Math.cos(i2), azimuthal: e2, polar: r2 };
          }
          function Xt(t2) {
            return ("undefined" != typeof self || void 0 !== t2) && "undefined" != typeof WorkerGlobalScope && (void 0 !== t2 ? t2 : self) instanceof WorkerGlobalScope;
          }
          function Zt(t2) {
            const e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t3, r2, n2, i2) => {
              const s2 = n2 || i2;
              return e2[r2] = !s2 || s2.toLowerCase(), "";
            }), e2["max-age"]) {
              const t3 = parseInt(e2["max-age"], 10);
              isNaN(t3) ? delete e2["max-age"] : e2["max-age"] = t3;
            }
            return e2;
          }
          let Wt = null;
          function Yt(t2, e2) {
            return [t2[4 * e2], t2[4 * e2 + 1], t2[4 * e2 + 2], t2[4 * e2 + 3]];
          }
          function Kt(t2, e2, r2, n2) {
            for (; e2 < r2; ) {
              const i2 = e2 + r2 >> 1;
              t2[i2] < n2 ? e2 = i2 + 1 : r2 = i2;
            }
            return e2;
          }
          function Jt(t2, e2, r2, n2) {
            for (; e2 < r2; ) {
              const i2 = e2 + r2 >> 1;
              t2[i2] <= n2 ? e2 = i2 + 1 : r2 = i2;
            }
            return e2;
          }
          function Qt(t2) {
            return t2 > 0 ? 1 / (1.001 - t2) : 1 + t2;
          }
          function te(t2) {
            return t2 > 0 ? 1 - 1 / (1.001 - t2) : -t2;
          }
          function ee(t2, e2, r2) {
            return (t2 - e2.min) * (r2.max - r2.min) / (e2.max - e2.min) + r2.min;
          }
          const re = { API_URL: "https://api.mapbox.com", get API_URL_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          }, get API_TILEJSON_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/v[0-9]*\/.*\.json.*$)/i;
          }, get API_SPRITE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*\/sprite.*\..*$)/i;
          }, get API_FONTS_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/fonts\/v[0-9]*\/)(.*\.pbf.*$)/i;
          }, get API_STYLE_REGEX() {
            return /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/styles\/v[0-9]*\/)(.*$)/i;
          }, get API_CDN_URL_REGEX() {
            return /^((https?:)?\/\/)?api\.mapbox\.c(n|om)(\/mapbox-gl-js\/)(.*$)/i;
          }, get EVENTS_URL() {
            if (!re.API_URL) return null;
            try {
              const t2 = new URL(re.API_URL);
              return "api.mapbox.cn" === t2.hostname ? "https://events.mapbox.cn/events/v2" : "api.mapbox.com" === t2.hostname ? "https://events.mapbox.com/events/v2" : null;
            } catch (t2) {
              return null;
            }
          }, SESSION_PATH: "/map-sessions/v1", FEEDBACK_URL: "https://apps.mapbox.com/feedback", TILE_URL_VERSION: "v4", RASTER_URL_PREFIX: "raster/v1", RASTERARRAYS_URL_PREFIX: "rasterarrays/v1", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, DEFAULT_STYLE: "mapbox://styles/mapbox/standard", MAX_PARALLEL_IMAGE_REQUESTS: 16, DRACO_URL: "https://api.mapbox.com/mapbox-gl-js/draco_decoder_gltf_v1.5.6.wasm", MESHOPT_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_base_v0.20.wasm", MESHOPT_SIMD_URL: "https://api.mapbox.com/mapbox-gl-js/meshopt_simd_v0.20.wasm", GLYPHS_URL: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", TILES3D_URL_PREFIX: "3dtiles/v1" };
          function ne(t2) {
            return re.API_URL_REGEX.test(t2);
          }
          function ie(t2) {
            return re.API_SPRITE_REGEX.test(t2);
          }
          let se, oe, ae, le, ue, ce2;
          function he() {
            return null == se && (se = self.OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof self.createImageBitmap), se;
          }
          const pe = { now: () => void 0 !== le ? le : performance.now(), setNow(t2) {
            le = t2;
          }, restoreNow() {
            le = void 0;
          }, frame(t2) {
            const e2 = requestAnimationFrame(t2);
            return { cancel: () => cancelAnimationFrame(e2) };
          }, getImageData(t2, e2 = 0) {
            const { width: r2, height: n2 } = t2;
            ue || (ue = document.createElement("canvas"));
            const i2 = ue.getContext("2d", { willReadFrequently: true });
            if (!i2) throw new Error("failed to create canvas 2d context");
            return (r2 > ue.width || n2 > ue.height) && (ue.width = r2, ue.height = n2), i2.clearRect(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2), i2.drawImage(t2, 0, 0, r2, n2), i2.getImageData(-e2, -e2, r2 + 2 * e2, n2 + 2 * e2);
          }, resolveURL: (t2) => (oe || (oe = document.createElement("a")), oe.href = t2, oe.href), get devicePixelRatio() {
            return window.devicePixelRatio;
          }, get prefersReducedMotion() {
            return !!window.matchMedia && (null == ae && (ae = window.matchMedia("(prefers-reduced-motion: reduce)")), ae.matches);
          }, hasCanvasFingerprintNoise() {
            if (void 0 !== ce2) return ce2;
            if (!he()) return ce2 = false, false;
            const t2 = new OffscreenCanvas(85, 1), e2 = t2.getContext("2d", { willReadFrequently: true });
            let r2 = 0;
            for (let n3 = 0; n3 < t2.width; ++n3) e2.fillStyle = `rgba(${r2++},${r2++},${r2++}, 255)`, e2.fillRect(n3, 0, 1, 1);
            const n2 = e2.getImageData(0, 0, t2.width, t2.height);
            r2 = 0;
            for (let t3 = 0; t3 < n2.data.length; ++t3) if (t3 % 4 != 3 && r2++ !== n2.data[t3]) return ce2 = true, true;
            return ce2 = false, false;
          } };
          function fe(t2, e2) {
            const r2 = t2.indexOf("?");
            if (r2 < 0) return `${t2}?${new URLSearchParams(e2).toString()}`;
            const n2 = new URLSearchParams(t2.slice(r2));
            for (const t3 in e2) n2.set(t3, e2[t3]);
            return `${t2.slice(0, r2)}?${n2.toString()}`;
          }
          function de2(t2, e2 = { persistentParams: [] }) {
            const r2 = t2.indexOf("?");
            if (r2 < 0) return t2;
            const n2 = new URLSearchParams(), i2 = new URLSearchParams(t2.slice(r2));
            for (const t3 of e2.persistentParams) {
              const e3 = i2.get(t3);
              e3 && n2.set(t3, e3);
            }
            const s2 = n2.toString();
            return `${t2.slice(0, r2)}${s2.length > 0 ? `?${s2}` : ""}`;
          }
          const me = "mapbox-tiles";
          let ye = 500, ge = 50;
          const xe = ["language", "worldview", "jobid"];
          let ve, be;
          function _e() {
            try {
              return caches;
            } catch (t2) {
            }
          }
          function we() {
            const t2 = _e();
            t2 && null == ve && (ve = t2.open(me));
          }
          let Ae = 1 / 0;
          const Me = { supported: false, testSupport: function(t2) {
            !ze && Se && (ke ? Pe(t2) : Ie = t2);
          } };
          let Ie, Se, ze = false, ke = false;
          const Ee = "undefined" != typeof self ? self : {};
          function Pe(t2) {
            const e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, Se), t2.isContextLost()) return;
              Me.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), ze = true;
          }
          Ee.document && (Se = Ee.document.createElement("img"), Se.onload = function() {
            Ie && Pe(Ie), Ie = null, ke = true;
          }, Se.onerror = function() {
            ze = true, Ie = null;
          }, Se.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          const Te = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Iconset: "Iconset", Image: "Image", Model: "Model" };
          "function" == typeof Object.freeze && Object.freeze(Te);
          class Be extends Error {
            constructor(t2, e2, r2) {
              401 === e2 && ne(r2) && (t2 += ": you may have provided an invalid Mapbox access token. See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes"), super(t2), this.status = e2, this.url = r2;
            }
            toString() {
              return `${this.name}: ${this.message} (${this.status}): ${this.url}`;
            }
          }
          const Ve = Xt() ? () => self.worker.referrer : () => ("blob:" === location.protocol ? parent : self).location.href;
          const Ce = function(t2, e2) {
            if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(Ve()) && !/^\w+:/.test(r2))) {
              if (self.fetch && self.Request && self.AbortController && Request.prototype.hasOwnProperty("signal")) return function(t3, e3) {
                const r3 = new AbortController(), n2 = new Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: Ve(), referrerPolicy: t3.referrerPolicy, signal: r3.signal });
                let i2 = false, s2 = false;
                const o2 = (a2 = n2.url).indexOf("sku=") > 0 && ne(a2);
                var a2;
                "json" === t3.type && n2.headers.set("Accept", "application/json");
                const l2 = (r4, i3, a3) => {
                  if (s2) return;
                  if (r4 && "SecurityError" !== r4.message && $t(r4.toString()), i3 && a3) return u5(i3);
                  const l3 = Date.now();
                  fetch(n2).then((r5) => {
                    if (r5.ok) {
                      const t4 = o2 ? r5.clone() : null;
                      return u5(r5, t4, l3);
                    }
                    return e3(new Be(r5.statusText, r5.status, t3.url));
                  }).catch((r5) => {
                    "AbortError" !== r5.name && e3(new Error(`${r5.message} ${t3.url}`));
                  });
                }, u5 = (r4, o3, a3) => {
                  ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then((t4) => {
                    s2 || (o3 && a3 && function(t5, e4, r5) {
                      if (we(), null == ve) return;
                      const n3 = Zt(e4.headers.get("Cache-Control") || "");
                      if (n3["no-store"]) return;
                      const i3 = { status: e4.status, statusText: e4.statusText, headers: new Headers() };
                      e4.headers.forEach((t6, e5) => i3.headers.set(e5, t6)), n3["max-age"] && i3.headers.set("Expires", new Date(r5 + 1e3 * n3["max-age"]).toUTCString());
                      const s3 = i3.headers.get("Expires");
                      if (!s3) return;
                      if (new Date(s3).getTime() - r5 < 42e4) return;
                      let o4 = de2(t5.url, { persistentParams: xe });
                      if (206 === e4.status) {
                        const e5 = t5.headers.get("Range");
                        if (!e5) return;
                        i3.status = 200, o4 = fe(o4, { range: e5 });
                      }
                      !function(t6, e5) {
                        if (void 0 === be) try {
                          new Response(new ReadableStream()), be = true;
                        } catch (t7) {
                          be = false;
                        }
                        be ? e5(t6.body) : t6.blob().then(e5).catch((t7) => $t(t7.message));
                      }(e4, (t6) => {
                        const r6 = new Response(200 !== (n4 = e4.status) && 404 !== n4 && [101, 103, 204, 205, 304].includes(n4) ? null : t6, i3);
                        var n4;
                        we(), null != ve && ve.then((t7) => t7.put(o4, r6)).catch((t7) => $t(t7.message));
                      });
                    }(n2, o3, a3), i2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                  }).catch((t4) => {
                    s2 || e3(new Error(t4.message));
                  });
                };
                return o2 ? function(t4, e4) {
                  if (we(), null == ve) return e4(null);
                  ve.then((r4) => {
                    let n3 = de2(t4.url, { persistentParams: xe });
                    const i3 = t4.headers.get("Range");
                    i3 && (n3 = fe(n3, { range: i3 })), r4.match(n3).then((t5) => {
                      const i4 = function(t6) {
                        if (!t6) return false;
                        const e5 = new Date(t6.headers.get("Expires") || 0), r5 = Zt(t6.headers.get("Cache-Control") || "");
                        return Number(e5) > Date.now() && !r5["no-cache"];
                      }(t5);
                      r4.delete(n3).catch(e4), i4 && r4.put(n3, t5.clone()).catch(e4), e4(null, t5, i4);
                    }).catch(e4);
                  }).catch(e4);
                }(n2, l2) : l2(null, null), { cancel: () => {
                  s2 = true, i2 || r3.abort();
                } };
              }(t2, e2);
              if (Xt(self) && self.worker.actor) return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
            var r2;
            return function(t3, e3) {
              const r3 = new XMLHttpRequest();
              r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer");
              for (const e4 in t3.headers) r3.setRequestHeader(e4, t3.headers[e4]);
              return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = () => {
                e3(new Error(r3.statusText));
              }, r3.onload = () => {
                if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                  let n2 = r3.response;
                  if ("json" === t3.type) try {
                    n2 = JSON.parse(r3.response);
                  } catch (t4) {
                    return e3(t4);
                  }
                  e3(null, n2, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else e3(new Be(r3.statusText, r3.status, t3.url));
              }, r3.send(t3.body), { cancel: () => r3.abort() };
            }(t2, e2);
          }, De = function(t2, e2) {
            return Ce(Ct(t2, { type: "arrayBuffer" }), e2);
          };
          function Fe(t2) {
            const e2 = document.createElement("a");
            return e2.href = t2, e2.protocol === location.protocol && e2.host === location.host;
          }
          const Le = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          let Re, Oe;
          Re = [], Oe = 0;
          const Ue = function(t2, e2) {
            if (Me.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), Oe >= re.MAX_PARALLEL_IMAGE_REQUESTS) {
              const r3 = { requestParameters: t2, callback: e2, cancelled: false, cancel() {
                this.cancelled = true;
              } };
              return Re.push(r3), r3;
            }
            Oe++;
            let r2 = false;
            const n2 = () => {
              if (!r2) for (r2 = true, Oe--; Re.length && Oe < re.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                const t3 = Re.shift(), { requestParameters: e3, callback: r3, cancelled: n3 } = t3;
                n3 || (t3.cancel = Ue(e3, r3).cancel);
              }
            }, i2 = De(t2, (t3, r3, i3, s2) => {
              n2(), t3 ? e2(t3) : r3 && (self.createImageBitmap ? function(t4, e3) {
                const r4 = new Blob([new Uint8Array(t4)], { type: "image/png" });
                createImageBitmap(r4).then((t5) => {
                  e3(null, t5);
                }).catch((t5) => {
                  e3(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
                });
              }(r3, (t4, r4) => e2(t4, r4, i3, s2)) : function(t4, e3) {
                const r4 = new Image();
                r4.onload = () => {
                  e3(null, r4), URL.revokeObjectURL(r4.src), r4.onload = null, requestAnimationFrame(() => {
                    r4.src = Le;
                  });
                }, r4.onerror = () => e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
                r4.src = t4.byteLength ? URL.createObjectURL(n3) : Le;
              }(r3, (t4, r4) => e2(t4, r4, i3, s2)));
            });
            return { cancel: () => {
              i2.cancel(), n2();
            } };
          };
          var Ne, je, $e, Ge = { exports: {} }, qe = { exports: {} }, He = { exports: {} }, Xe = function() {
            if ($e) return Ge.exports;
            $e = 1;
            var t2 = (Ne || (Ne = 1, qe.exports = function(t3, e3) {
              var r2, n2, i2, s2, o2, a2, l2, u5;
              for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e3, o2 = 3432918353, a2 = 461845907, u5 = 0; u5 < n2; ) l2 = 255 & t3.charCodeAt(u5) | (255 & t3.charCodeAt(++u5)) << 8 | (255 & t3.charCodeAt(++u5)) << 16 | (255 & t3.charCodeAt(++u5)) << 24, ++u5, i2 = 27492 + (65535 & (s2 = 5 * (65535 & (i2 = (i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & l2) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (s2 >>> 16) & 65535) << 16);
              switch (l2 = 0, r2) {
                case 3:
                  l2 ^= (255 & t3.charCodeAt(u5 + 2)) << 16;
                case 2:
                  l2 ^= (255 & t3.charCodeAt(u5 + 1)) << 8;
                case 1:
                  i2 ^= l2 = (65535 & (l2 = (l2 = (65535 & (l2 ^= 255 & t3.charCodeAt(u5))) * o2 + (((l2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | l2 >>> 17)) * a2 + (((l2 >>> 16) * a2 & 65535) << 16) & 4294967295;
              }
              return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
            }), qe.exports), e2 = (je || (je = 1, He.exports = function(t3, e3) {
              for (var r2, n2 = t3.length, i2 = e3 ^ n2, s2 = 0; n2 >= 4; ) r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(s2) | (255 & t3.charCodeAt(++s2)) << 8 | (255 & t3.charCodeAt(++s2)) << 16 | (255 & t3.charCodeAt(++s2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++s2;
              switch (n2) {
                case 3:
                  i2 ^= (255 & t3.charCodeAt(s2 + 2)) << 16;
                case 2:
                  i2 ^= (255 & t3.charCodeAt(s2 + 1)) << 8;
                case 1:
                  i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(s2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
              }
              return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
            }), He.exports);
            return Ge.exports = t2, Ge.exports.murmur3 = t2, Ge.exports.murmur2 = e2, Ge.exports;
          }(), Ze = dt(Xe);
          class We {
            constructor(t2, ...e2) {
              Ct(this, e2[0] || {}), this.type = t2;
            }
          }
          class Ye extends We {
            constructor(t2, e2 = {}) {
              super("error", Ct({ error: t2 }, e2));
            }
          }
          function Ke(t2, e2, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function Je(t2, e2, r2) {
            if (r2 && r2[t2]) {
              const n2 = r2[t2].indexOf(e2);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          class Qe {
            on(t2, e2) {
              return this._listeners = this._listeners || {}, Ke(t2, e2, this._listeners), this;
            }
            off(t2, e2) {
              return Je(t2, e2, this._listeners), Je(t2, e2, this._oneTimeListeners), this;
            }
            once(t2, e2) {
              return e2 ? (this._oneTimeListeners = this._oneTimeListeners || {}, Ke(t2, e2, this._oneTimeListeners), this) : new Promise((e3) => {
                this.once(t2, e3);
              });
            }
            fire(t2, e2) {
              const r2 = "string" == typeof t2 ? new We(t2, e2) : t2, n2 = r2.type;
              if (this.listens(n2)) {
                r2.target = this;
                const t3 = this._listeners && this._listeners[n2] ? this._listeners[n2].slice() : [];
                for (const e4 of t3) e4.call(this, r2);
                const e3 = this._oneTimeListeners && this._oneTimeListeners[n2] ? this._oneTimeListeners[n2].slice() : [];
                for (const t4 of e3) Je(n2, t4, this._oneTimeListeners), t4.call(this, r2);
                const i2 = this._eventedParent;
                i2 && (Ct(r2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i2.fire(r2));
              } else r2 instanceof Ye && console.error(r2.error);
              return this;
            }
            listens(t2) {
              return !!(this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2));
            }
            setEventedParent(t2, e2) {
              return this._eventedParent = t2, this._eventedParentData = e2, this;
            }
          }
          class tr {
            constructor(t2) {
              "string" == typeof t2 ? this.name = t2 : (this.name = t2.name, this.iconsetId = t2.iconsetId);
            }
            static from(t2) {
              return new tr(t2);
            }
            static toString(t2) {
              return t2.iconsetId ? `${t2.name}${t2.iconsetId}` : t2.name;
            }
            static parse(t2) {
              const [e2, r2] = t2.split("");
              return new tr({ name: e2, iconsetId: r2 });
            }
            static isEqual(t2, e2) {
              return t2.name === e2.name && t2.iconsetId === e2.iconsetId;
            }
            toString() {
              return tr.toString(this);
            }
            serialize() {
              return { name: this.name, iconsetId: this.iconsetId };
            }
          }
          var er, rr = {}, nr = function() {
            if (er) return rr;
            er = 1;
            var t2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
            function e2(t3) {
              return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            function r2(t3) {
              return e2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
            }
            function n2(t3) {
              return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
              var e3;
            }
            function i2(t3, e3, r3) {
              return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
            }
            try {
              rr.parseCSSColor = function(s2) {
                var o2, a2 = s2.replace(/ /g, "").toLowerCase();
                if (a2 in t2) return t2[a2].slice();
                if ("#" === a2[0]) return 4 === a2.length ? (o2 = parseInt(a2.substr(1), 16)) >= 0 && o2 <= 4095 ? [(3840 & o2) >> 4 | (3840 & o2) >> 8, 240 & o2 | (240 & o2) >> 4, 15 & o2 | (15 & o2) << 4, 1] : null : 7 === a2.length && (o2 = parseInt(a2.substr(1), 16)) >= 0 && o2 <= 16777215 ? [(16711680 & o2) >> 16, (65280 & o2) >> 8, 255 & o2, 1] : null;
                var l2 = a2.indexOf("("), u5 = a2.indexOf(")");
                if (-1 !== l2 && u5 + 1 === a2.length) {
                  var c2 = a2.substr(0, l2), h2 = a2.substr(l2 + 1, u5 - (l2 + 1)).split(","), p2 = 1;
                  switch (c2) {
                    case "rgba":
                      if (4 !== h2.length) return null;
                      p2 = n2(h2.pop());
                    case "rgb":
                      return 3 !== h2.length ? null : [r2(h2[0]), r2(h2[1]), r2(h2[2]), p2];
                    case "hsla":
                      if (4 !== h2.length) return null;
                      p2 = n2(h2.pop());
                    case "hsl":
                      if (3 !== h2.length) return null;
                      var f2 = (parseFloat(h2[0]) % 360 + 360) % 360 / 360, d2 = n2(h2[1]), m2 = n2(h2[2]), y2 = m2 <= 0.5 ? m2 * (d2 + 1) : m2 + d2 - m2 * d2, g2 = 2 * m2 - y2;
                      return [e2(255 * i2(g2, y2, f2 + 1 / 3)), e2(255 * i2(g2, y2, f2)), e2(255 * i2(g2, y2, f2 - 1 / 3)), p2];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (t3) {
            }
            return rr;
          }();
          class ir {
            constructor(t2, e2, r2, n2 = 1) {
              this.r = t2, this.g = e2, this.b = r2, this.a = n2;
            }
            static parse(t2) {
              if (!t2) return;
              if (t2 instanceof ir) return t2;
              if ("string" != typeof t2) return;
              const e2 = nr.parseCSSColor(t2);
              return e2 ? new ir(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]) : void 0;
            }
            toStringPremultipliedAlpha() {
              const [t2, e2, r2, n2] = 0 === this.a ? [0, 0, 0, 0] : [255 * this.r / this.a, 255 * this.g / this.a, 255 * this.b / this.a, this.a];
              return `rgba(${Math.round(t2)},${Math.round(e2)},${Math.round(r2)},${n2})`;
            }
            toString() {
              const [t2, e2, r2, n2] = [this.r, this.g, this.b, this.a];
              return `rgba(${Math.round(255 * t2)},${Math.round(255 * e2)},${Math.round(255 * r2)},${n2})`;
            }
            toRenderColor(t2) {
              const { r: e2, g: r2, b: n2, a: i2 } = this;
              return new sr(t2, e2, r2, n2, i2);
            }
            clone() {
              return new ir(this.r, this.g, this.b, this.a);
            }
          }
          class sr {
            constructor(t2, e2, r2, n2, i2) {
              if (t2) {
                const s2 = t2.image.height, o2 = s2 * s2;
                e2 = 0 === i2 ? 0 : e2 / i2 * (s2 - 1), r2 = 0 === i2 ? 0 : r2 / i2 * (s2 - 1), n2 = 0 === i2 ? 0 : n2 / i2 * (s2 - 1);
                const a2 = Math.floor(e2), l2 = Math.floor(r2), u5 = Math.floor(n2), c2 = Math.ceil(e2), h2 = Math.ceil(r2), p2 = Math.ceil(n2), f2 = e2 - a2, d2 = r2 - l2, m2 = n2 - u5, y2 = t2.image.data, g2 = 4 * (a2 + l2 * o2 + u5 * s2), x2 = 4 * (a2 + l2 * o2 + p2 * s2), v3 = 4 * (a2 + h2 * o2 + u5 * s2), b2 = 4 * (a2 + h2 * o2 + p2 * s2), _2 = 4 * (c2 + l2 * o2 + u5 * s2), w2 = 4 * (c2 + l2 * o2 + p2 * s2), A2 = 4 * (c2 + h2 * o2 + u5 * s2), M2 = 4 * (c2 + h2 * o2 + p2 * s2);
                if (g2 < 0 || M2 >= y2.length) throw new Error("out of range");
                this.r = or(or(or(y2[g2], y2[x2], m2), or(y2[v3], y2[b2], m2), d2), or(or(y2[_2], y2[w2], m2), or(y2[A2], y2[M2], m2), d2), f2) / 255 * i2, this.g = or(or(or(y2[g2 + 1], y2[x2 + 1], m2), or(y2[v3 + 1], y2[b2 + 1], m2), d2), or(or(y2[_2 + 1], y2[w2 + 1], m2), or(y2[A2 + 1], y2[M2 + 1], m2), d2), f2) / 255 * i2, this.b = or(or(or(y2[g2 + 2], y2[x2 + 2], m2), or(y2[v3 + 2], y2[b2 + 2], m2), d2), or(or(y2[_2 + 2], y2[w2 + 2], m2), or(y2[A2 + 2], y2[M2 + 2], m2), d2), f2) / 255 * i2, this.a = i2;
              } else this.r = e2, this.g = r2, this.b = n2, this.a = i2;
            }
            toArray() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [255 * t2 / n2, 255 * e2 / n2, 255 * r2 / n2, n2];
            }
            toHslaArray() {
              if (0 === this.a) return [0, 0, 0, 0];
              const { r: t2, g: e2, b: r2, a: n2 } = this, i2 = Math.min(Math.max(t2 / n2, 0), 1), s2 = Math.min(Math.max(e2 / n2, 0), 1), o2 = Math.min(Math.max(r2 / n2, 0), 1), a2 = Math.min(i2, s2, o2), l2 = Math.max(i2, s2, o2), u5 = (a2 + l2) / 2;
              if (a2 === l2) return [0, 0, 100 * u5, n2];
              const c2 = l2 - a2, h2 = u5 > 0.5 ? c2 / (2 - l2 - a2) : c2 / (l2 + a2);
              let p2 = 0;
              return l2 === i2 ? p2 = (s2 - o2) / c2 + (s2 < o2 ? 6 : 0) : l2 === s2 ? p2 = (o2 - i2) / c2 + 2 : l2 === o2 && (p2 = (i2 - s2) / c2 + 4), p2 *= 60, [Math.min(Math.max(p2, 0), 360), Math.min(Math.max(100 * h2, 0), 100), Math.min(Math.max(100 * u5, 0), 100), n2];
            }
            toArray01() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [t2 / n2, e2 / n2, r2 / n2, n2];
            }
            toArray01Scaled(t2) {
              const { r: e2, g: r2, b: n2, a: i2 } = this;
              return 0 === i2 ? [0, 0, 0] : [e2 / i2 * t2, r2 / i2 * t2, n2 / i2 * t2];
            }
            toArray01PremultipliedAlpha() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return [t2, e2, r2, n2];
            }
            toArray01Linear() {
              const { r: t2, g: e2, b: r2, a: n2 } = this;
              return 0 === n2 ? [0, 0, 0, 0] : [Math.pow(t2 / n2, 2.2), Math.pow(e2 / n2, 2.2), Math.pow(r2 / n2, 2.2), n2];
            }
          }
          function or(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          function ar(t2, e2, r2) {
            return t2.map((t3, n2) => or(t3, e2[n2], r2));
          }
          function lr(t2) {
            return t2 * t2 * t2 * t2 * t2;
          }
          ir.black = new ir(0, 0, 0, 1), ir.white = new ir(1, 1, 1, 1), ir.transparent = new ir(0, 0, 0, 0), ir.red = new ir(1, 0, 0, 1), ir.blue = new ir(0, 0, 1, 1);
          var ur = Object.freeze({ __proto__: null, array: ar, color: function(t2, e2, r2) {
            return new ir(or(t2.r, e2.r, r2), or(t2.g, e2.g, r2), or(t2.b, e2.b, r2), or(t2.a, e2.a, r2));
          }, easeIn: lr, number: or });
          function cr(t2, ...e2) {
            for (const r2 of e2) for (const e3 in r2) t2[e3] = r2[e3];
            return t2;
          }
          class hr extends Error {
            constructor(t2, e2) {
              super(e2), this.message = e2, this.key = t2;
            }
          }
          class pr {
            constructor(t2, e2 = []) {
              this.parent = t2, this.bindings = {};
              for (const [t3, r2] of e2) this.bindings[t3] = r2;
            }
            concat(t2) {
              return new pr(this, t2);
            }
            get(t2) {
              if (this.bindings[t2]) return this.bindings[t2];
              if (this.parent) return this.parent.get(t2);
              throw new Error(`${t2} not found in scope.`);
            }
            has(t2) {
              return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
            }
          }
          const fr = { kind: "null" }, dr = { kind: "number" }, mr = { kind: "string" }, yr = { kind: "boolean" }, gr = { kind: "color" }, xr = { kind: "object" }, vr = { kind: "value" }, br = { kind: "collator" }, _r = { kind: "formatted" }, wr = { kind: "resolvedImage" };
          function Ar(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function Mr(t2) {
            if ("array" === t2.kind) {
              const e2 = Mr(t2.itemType);
              return "number" == typeof t2.N ? `array<${e2}, ${t2.N}>` : "value" === t2.itemType.kind ? "array" : `array<${e2}>`;
            }
            return t2.kind;
          }
          const Ir = [fr, dr, mr, yr, gr, _r, xr, Ar(vr), wr];
          function Sr(t2, e2) {
            if ("error" === e2.kind) return null;
            if ("array" === t2.kind) {
              if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Sr(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N)) return null;
            } else {
              if (t2.kind === e2.kind) return null;
              if ("value" === t2.kind) {
                for (const t3 of Ir) if (!Sr(t3, e2)) return null;
              }
            }
            return `Expected ${Mr(t2)} but found ${Mr(e2)} instead.`;
          }
          function zr(t2, e2) {
            return e2.some((e3) => e3.kind === t2.kind);
          }
          function kr(t2, e2) {
            return e2.some((e3) => "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2);
          }
          class Er {
            constructor(t2, e2, r2) {
              this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t2, e2) {
              return this.collator.compare(t2, e2);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Pr {
            constructor(t2, e2, r2, n2, i2) {
              this.text = t2.normalize ? t2.normalize() : t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
            }
          }
          class Tr {
            constructor(t2) {
              this.sections = t2;
            }
            static fromString(t2) {
              return new Tr([new Pr(t2, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t2) => 0 !== t2.text.length || !!t2.image && t2.image.hasPrimary());
            }
            static factory(t2) {
              return t2 instanceof Tr ? t2 : Tr.fromString(t2);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t2) => t2.text).join("");
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                if (e2.image) {
                  const r3 = e2.image.getPrimary().id.toString();
                  t2.push(["image", r3]);
                  continue;
                }
                t2.push(e2.text);
                const r2 = {};
                e2.fontStack && (r2["text-font"] = ["literal", e2.fontStack.split(",")]), e2.scale && (r2["font-scale"] = e2.scale), e2.textColor && (r2["text-color"] = ["rgba"].concat(e2.textColor.toRenderColor(null).toArray())), t2.push(r2);
              }
              return t2;
            }
          }
          class Br {
            constructor(t2, e2 = {}) {
              if (this.id = tr.from(t2), this.options = Object.assign({}, e2), e2.transform) {
                const { a: t3, b: r2, c: n2, d: i2, e: s2, f: o2 } = e2.transform;
                this.options.transform = new DOMMatrix([t3, r2, n2, i2, s2, o2]);
              } else this.options.transform = new DOMMatrix([1, 0, 0, 1, 0, 0]);
            }
            toString() {
              const { a: t2, b: e2, c: r2, d: n2, e: i2, f: s2 } = this.options.transform;
              return JSON.stringify({ name: this.id.name, iconsetId: this.id.iconsetId, params: this.options.params, transform: { a: t2, b: e2, c: r2, d: n2, e: i2, f: s2 } });
            }
            static parse(t2) {
              let e2, r2, n2, i2;
              try {
                ({ name: e2, iconsetId: r2, params: n2, transform: i2 } = JSON.parse(t2) || {});
              } catch (t3) {
                return null;
              }
              if (!e2) return null;
              const { a: s2, b: o2, c: a2, d: l2, e: u5, f: c2 } = i2 || {};
              return new Br({ name: e2, iconsetId: r2 }, { params: n2, transform: new DOMMatrix([s2, o2, a2, l2, u5, c2]) });
            }
            scaleSelf(t2, e2) {
              return this.options.transform.scaleSelf(t2, e2), this;
            }
          }
          class Vr {
            constructor(t2, e2, r2, n2, i2 = false) {
              this.primaryId = tr.from(t2), this.primaryOptions = e2, r2 && (this.secondaryId = tr.from(r2)), this.secondaryOptions = n2, this.available = i2;
            }
            toString() {
              return this.primaryId && this.secondaryId ? `[${this.primaryId.name},${this.secondaryId.name}]` : this.primaryId.name;
            }
            hasPrimary() {
              return !!this.primaryId;
            }
            getPrimary() {
              return new Br(this.primaryId, this.primaryOptions);
            }
            hasSecondary() {
              return !!this.secondaryId;
            }
            getSecondary() {
              return this.secondaryId ? new Br(this.secondaryId, this.secondaryOptions) : null;
            }
            static from(t2) {
              return "string" == typeof t2 ? Vr.build({ name: t2 }) : t2;
            }
            static build(t2, e2, r2, n2) {
              return !t2 || "object" == typeof t2 && !("name" in t2) ? null : new Vr(t2, r2, e2, n2);
            }
          }
          function Cr(t2, e2, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : `Invalid rgba value [${[t2, e2, r2, n2].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function Dr(t2) {
            if (null === t2) return true;
            if ("string" == typeof t2) return true;
            if ("boolean" == typeof t2) return true;
            if ("number" == typeof t2) return true;
            if (t2 instanceof ir) return true;
            if (t2 instanceof Er) return true;
            if (t2 instanceof Tr) return true;
            if (t2 instanceof Vr) return true;
            if (Array.isArray(t2)) {
              for (const e2 of t2) if (!Dr(e2)) return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (const e2 in t2) if (!Dr(t2[e2])) return false;
              return true;
            }
            return false;
          }
          function Fr(t2) {
            if (null === t2) return fr;
            if ("string" == typeof t2) return mr;
            if ("boolean" == typeof t2) return yr;
            if ("number" == typeof t2) return dr;
            if (t2 instanceof ir) return gr;
            if (t2 instanceof Er) return br;
            if (t2 instanceof Tr) return _r;
            if (t2 instanceof Vr) return wr;
            if (Array.isArray(t2)) {
              const e2 = t2.length;
              let r2;
              for (const e3 of t2) {
                const t3 = Fr(e3);
                if (r2) {
                  if (r2 === t3) continue;
                  r2 = vr;
                  break;
                }
                r2 = t3;
              }
              return Ar(r2 || vr, e2);
            }
            return xr;
          }
          function Lr(t2) {
            const e2 = typeof t2;
            return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof ir ? t2.toStringPremultipliedAlpha() : t2 instanceof Tr || t2 instanceof Vr ? t2.toString() : JSON.stringify(t2);
          }
          class Rr {
            constructor(t2, e2) {
              this.type = t2, this.value = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'literal' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (!Dr(t2[1])) return e2.error("invalid value");
              const r2 = t2[1];
              let n2 = Fr(r2);
              const i2 = e2.expectedType;
              return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new Rr(n2, r2);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof ir ? ["rgba"].concat(this.value.toRenderColor(null).toArray()) : this.value instanceof Tr ? this.value.serialize() : this.value;
            }
          }
          class Or {
            constructor(t2) {
              this.name = "ExpressionEvaluationError", this.message = t2;
            }
            toJSON() {
              return this.message;
            }
          }
          const Ur = { string: mr, number: dr, boolean: yr, object: xr };
          class Nr {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              let r2, n2 = 1;
              const i2 = t2[0];
              if ("array" === i2) {
                let i3, s3;
                if (t2.length > 2) {
                  const r3 = t2[1];
                  if ("string" != typeof r3 || !(r3 in Ur) || "object" === r3) return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i3 = Ur[r3], n2++;
                } else i3 = vr;
                if (t2.length > 3) {
                  if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2]))) return e2.error('The length argument to "array" must be a positive integer literal', 2);
                  s3 = t2[2], n2++;
                }
                r2 = Ar(i3, s3);
              } else r2 = Ur[i2];
              const s2 = [];
              for (; n2 < t2.length; n2++) {
                const r3 = e2.parse(t2[n2], n2, vr);
                if (!r3) return null;
                s2.push(r3);
              }
              return new Nr(r2, s2);
            }
            evaluate(t2) {
              for (let e2 = 0; e2 < this.args.length; e2++) {
                const r2 = this.args[e2].evaluate(t2);
                if (!Sr(this.type, Fr(r2))) return r2;
                if (e2 === this.args.length - 1) throw new Or(`The expression ${JSON.stringify(this.args[e2].serialize())} evaluated to ${Mr(Fr(r2))} but was expected to be of type ${Mr(this.type)}.`);
              }
              return null;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = this.type, e2 = [t2.kind];
              if ("array" === t2.kind) {
                const r2 = t2.itemType;
                if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                  e2.push(r2.kind);
                  const n2 = t2.N;
                  ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
                }
              }
              return e2.concat(this.args.map((t3) => t3.serialize()));
            }
          }
          class jr {
            constructor(t2) {
              this.type = _r, this.sections = t2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              const r2 = t2[1];
              if (!Array.isArray(r2) && "object" == typeof r2) return e2.error("First argument must be an image or text section.");
              const n2 = [];
              let i2 = false;
              for (let r3 = 1; r3 <= t2.length - 1; ++r3) {
                const s2 = t2[r3];
                if (i2 && "object" == typeof s2 && !Array.isArray(s2)) {
                  i2 = false;
                  let t3 = null;
                  if (s2["font-scale"] && (t3 = e2.parseObjectValue(s2["font-scale"], r3, "font-scale", dr), !t3)) return null;
                  let o2 = null;
                  if (s2["text-font"] && (o2 = e2.parseObjectValue(s2["text-font"], r3, "text-font", Ar(mr)), !o2)) return null;
                  let a2 = null;
                  if (s2["text-color"] && (a2 = e2.parseObjectValue(s2["text-color"], r3, "text-color", gr), !a2)) return null;
                  const l2 = n2[n2.length - 1];
                  l2.scale = t3, l2.font = o2, l2.textColor = a2;
                } else {
                  const s3 = e2.parse(t2[r3], r3, vr);
                  if (!s3) return null;
                  const o2 = s3.type.kind;
                  if ("string" !== o2 && "value" !== o2 && "null" !== o2 && "resolvedImage" !== o2) return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i2 = true, n2.push({ content: s3, scale: null, font: null, textColor: null });
                }
              }
              return new jr(n2);
            }
            evaluate(t2) {
              return new Tr(this.sections.map((e2) => {
                const r2 = e2.content.evaluate(t2);
                return Fr(r2) === wr ? new Pr("", r2, null, null, null) : new Pr(Lr(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
              }));
            }
            eachChild(t2) {
              for (const e2 of this.sections) t2(e2.content), e2.scale && t2(e2.scale), e2.font && t2(e2.font), e2.textColor && t2(e2.textColor);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["format"];
              for (const e2 of this.sections) {
                t2.push(e2.content.serialize());
                const r2 = {};
                e2.scale && (r2["font-scale"] = e2.scale.serialize()), e2.font && (r2["text-font"] = e2.font.serialize()), e2.textColor && (r2["text-color"] = e2.textColor.serialize()), t2.push(r2);
              }
              return t2;
            }
          }
          class $r {
            constructor(t2, e2, r2, n2) {
              this._imageWarnHistory = {}, this.type = wr, this.namePrimary = t2, this.nameSecondary = e2, r2 && (this.paramsPrimary = r2.params, this.iconsetIdPrimary = r2.iconset ? r2.iconset.id : void 0), n2 && (this.paramsSecondary = n2.params, this.iconsetIdSecondary = n2.iconset ? n2.iconset.id : void 0);
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected two or more arguments.");
              let r2 = 1;
              const n2 = [];
              function i2() {
                if (r2 < t2.length) {
                  const i3 = e2.parse(t2[r2], r2++, mr);
                  return i3 ? (n2.push({ image: i3, options: {} }), true) : (e2.error(n2.length ? "Secondary image variant is not a string." : "No image name provided."), false);
                }
                return true;
              }
              function s2() {
                if (r2 < t2.length) {
                  const s3 = t2[r2];
                  if (null === (i3 = s3) || "object" != typeof i3 || Array.isArray(i3)) return true;
                  const o2 = s3.params, a2 = s3.iconset, l2 = e2.concat(r2);
                  if (!o2 && !a2) return r2++, true;
                  if (o2) {
                    if ("object" != typeof o2 || o2.constructor !== Object) return l2.error('Image options "params" should be an object'), false;
                    const t3 = {}, e3 = l2.concat(void 0, "params");
                    for (const r3 in o2) {
                      if (!r3) return e3.error("Image parameter name should be non-empty"), false;
                      const n3 = e3.concat(void 0, r3).parse(o2[r3], void 0, gr, void 0, { typeAnnotation: "coerce" });
                      if (!n3) return false;
                      t3[r3] = n3;
                    }
                    n2[n2.length - 1].options.params = t3;
                  }
                  if (a2) {
                    if ("object" != typeof a2 || a2.constructor !== Object) return l2.error('Image options "iconset" should be an object'), false;
                    if (!a2.id) return l2.error('Image options "iconset" should have an "id" property'), false;
                    n2[n2.length - 1].options.iconset = a2;
                  }
                  return r2++, true;
                }
                var i3;
                return true;
              }
              for (let t3 = 0; t3 < 2; t3++) if (!i2() || !s2()) return;
              return new $r(n2[0].image, n2[1] ? n2[1].image : void 0, n2[0].options, n2[1] ? n2[1].options : void 0);
            }
            evaluateParams(t2, e2) {
              const r2 = {};
              if (e2) {
                for (const n2 in e2) if (e2[n2]) try {
                  r2[n2] = e2[n2].evaluate(t2);
                } catch (t3) {
                  continue;
                }
                if (0 !== Object.keys(r2).length) return { params: r2 };
              }
            }
            evaluate(t2) {
              const e2 = { name: this.namePrimary.evaluate(t2), iconsetId: this.iconsetIdPrimary }, r2 = this.nameSecondary ? { name: this.nameSecondary.evaluate(t2), iconsetId: this.iconsetIdSecondary } : void 0, n2 = Vr.build(e2, r2, this.paramsPrimary ? this.evaluateParams(t2, this.paramsPrimary) : void 0, this.paramsSecondary ? this.evaluateParams(t2, this.paramsSecondary) : void 0);
              if (n2 && t2.availableImages) {
                const e3 = n2.getPrimary().id;
                if (n2.available = t2.availableImages.some((t3) => tr.isEqual(t3, e3)), n2.available) {
                  const e4 = n2.getSecondary() ? n2.getSecondary().id : null;
                  e4 && (n2.available = t2.availableImages.some((t3) => tr.isEqual(t3, e4)));
                }
              }
              return n2;
            }
            eachChild(t2) {
              if (t2(this.namePrimary), this.paramsPrimary) for (const e2 in this.paramsPrimary) this.paramsPrimary[e2] && t2(this.paramsPrimary[e2]);
              if (this.nameSecondary && (t2(this.nameSecondary), this.paramsSecondary)) for (const e2 in this.paramsSecondary) this.paramsSecondary[e2] && t2(this.paramsSecondary[e2]);
            }
            outputDefined() {
              return false;
            }
            serializeOptions(t2, e2) {
              const r2 = {};
              if (e2 && (r2.iconset = { id: e2 }), t2) {
                r2.params = {};
                for (const e3 in t2) t2[e3] && (r2.params[e3] = t2[e3].serialize());
              }
              return Object.keys(r2).length > 0 ? r2 : void 0;
            }
            serialize() {
              const t2 = ["image", this.namePrimary.serialize()];
              if (this.paramsPrimary || this.iconsetIdPrimary) {
                const e2 = this.serializeOptions(this.paramsPrimary, this.iconsetIdPrimary);
                e2 && t2.push(e2);
              }
              if (this.nameSecondary && (t2.push(this.nameSecondary.serialize()), this.paramsSecondary || this.iconsetIdSecondary)) {
                const e2 = this.serializeOptions(this.paramsSecondary, this.iconsetIdSecondary);
                e2 && t2.push(e2);
              }
              return t2;
            }
          }
          function Gr(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          const qr = { "to-boolean": yr, "to-color": gr, "to-number": dr, "to-string": mr };
          class Hr {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expected at least one argument.");
              const r2 = t2[0], n2 = [];
              let i2 = fr;
              if ("to-array" === r2) {
                if (!Array.isArray(t2[1])) return null;
                const r3 = t2[1].length;
                if (e2.expectedType) {
                  if ("array" !== e2.expectedType.kind) return e2.error(`Expected ${e2.expectedType.kind} but found array.`);
                  i2 = Ar(e2.expectedType.itemType, r3);
                } else {
                  if (!(r3 > 0 && Dr(t2[1][0]))) return null;
                  i2 = Ar(Fr(t2[1][0]), r3);
                }
                for (let s2 = 0; s2 < r3; s2++) {
                  const r4 = t2[1][s2];
                  let o2;
                  if ("array" === Gr(r4)) o2 = e2.parse(r4, void 0, i2.itemType);
                  else {
                    const t3 = Gr(r4);
                    if (t3 !== i2.itemType.kind) return e2.error(`Expected ${i2.itemType.kind} but found ${t3}.`);
                    o2 = e2.registry.literal.parse(["literal", void 0 === r4 ? null : r4], e2);
                  }
                  if (!o2) return null;
                  n2.push(o2);
                }
              } else {
                if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length) return e2.error("Expected one argument.");
                i2 = qr[r2];
                for (let r3 = 1; r3 < t2.length; r3++) {
                  const i3 = e2.parse(t2[r3], r3, vr);
                  if (!i3) return null;
                  n2.push(i3);
                }
              }
              return new Hr(i2, n2);
            }
            evaluate(t2) {
              if ("boolean" === this.type.kind) return Boolean(this.args[0].evaluate(t2));
              if ("color" === this.type.kind) {
                let e2, r2;
                for (const n2 of this.args) {
                  if (e2 = n2.evaluate(t2), r2 = null, e2 instanceof ir) return e2;
                  if ("string" == typeof e2) {
                    const r3 = t2.parseColor(e2);
                    if (r3) return r3;
                  } else if (Array.isArray(e2) && (r2 = e2.length < 3 || e2.length > 4 ? `Invalid rbga value ${JSON.stringify(e2)}: expected an array containing either three or four numeric values.` : Cr(e2[0], e2[1], e2[2], e2[3]), !r2)) return new ir(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
                }
                throw new Or(r2 || `Could not parse color from value '${"string" == typeof e2 ? e2 : String(JSON.stringify(e2))}'`);
              }
              if ("number" === this.type.kind) {
                let e2 = null;
                for (const r2 of this.args) {
                  if (e2 = r2.evaluate(t2), null === e2) return 0;
                  const n2 = Number(e2);
                  if (!isNaN(n2)) return n2;
                }
                throw new Or(`Could not convert ${JSON.stringify(e2)} to number.`);
              }
              return "formatted" === this.type.kind ? Tr.fromString(Lr(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? Vr.build(Lr(this.args[0].evaluate(t2))) : "array" === this.type.kind ? this.args.map((e2) => e2.evaluate(t2)) : Lr(this.args[0].evaluate(t2));
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              if ("formatted" === this.type.kind) return new jr([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
              if ("resolvedImage" === this.type.kind) return new $r(this.args[0]).serialize();
              const t2 = "array" === this.type.kind ? [] : [`to-${this.type.kind}`];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          const Xr = ["Unknown", "Point", "LineString", "Polygon"];
          class Zr {
            constructor(t2, e2) {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null, this.featureTileCoord = null, this.featureDistanceData = null, this.scope = t2, this.options = e2;
            }
            id() {
              return this.feature && void 0 !== this.feature.id ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? Xr[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            measureLight(t2) {
              return this.globals.brightness || 0;
            }
            distanceFromCenter() {
              if (this.featureTileCoord && this.featureDistanceData) {
                const t2 = this.featureDistanceData.center, e2 = this.featureDistanceData.scale, { x: r2, y: n2 } = this.featureTileCoord;
                return this.featureDistanceData.bearing[0] * (r2 * e2 - t2[0]) + this.featureDistanceData.bearing[1] * (n2 * e2 - t2[1]);
              }
              return 0;
            }
            parseColor(t2) {
              let e2 = this._parseColorCache[t2];
              return e2 || (e2 = this._parseColorCache[t2] = ir.parse(t2)), e2;
            }
            getConfig(t2) {
              return this.options ? this.options.get(t2) : null;
            }
          }
          class Wr {
            constructor(t2, e2, r2, n2, i2) {
              this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2, this._overloadIndex = i2;
            }
            evaluate(t2) {
              if (!this._evaluate) {
                const t3 = Wr.definitions[this.name];
                this._evaluate = Array.isArray(t3) ? t3[2] : t3.overloads[this._overloadIndex][1];
              }
              return this._evaluate(t2, this.args);
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return [this.name].concat(this.args.map((t2) => t2.serialize()));
            }
            static parse(t2, e2) {
              const r2 = t2[0], n2 = Wr.definitions[r2];
              if (!n2) return e2.error(`Unknown expression "${r2}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i2 = Array.isArray(n2) ? n2[0] : n2.type, s2 = Array.isArray(n2) ? [[n2[1], n2[2]]] : n2.overloads, o2 = [];
              let a2 = null, l2 = -1;
              for (const [n3, u5] of s2) {
                if (Array.isArray(n3) && n3.length !== t2.length - 1) continue;
                o2.push(n3), l2++, a2 = new gi(e2.registry, e2.path, null, e2.scope, void 0, e2._scope, e2.options);
                const s3 = [];
                let c2 = false;
                for (let e3 = 1; e3 < t2.length; e3++) {
                  const r3 = t2[e3], i3 = Array.isArray(n3) ? n3[e3 - 1] : n3.type, o3 = a2.parse(r3, 1 + s3.length, i3);
                  if (!o3) {
                    c2 = true;
                    break;
                  }
                  s3.push(o3);
                }
                if (!c2) if (Array.isArray(n3) && n3.length !== s3.length) a2.error(`Expected ${n3.length} arguments, but found ${s3.length} instead.`);
                else {
                  for (let t3 = 0; t3 < s3.length; t3++) {
                    const e3 = Array.isArray(n3) ? n3[t3] : n3.type, r3 = s3[t3];
                    a2.concat(t3 + 1).checkSubtype(e3, r3.type);
                  }
                  if (0 === a2.errors.length) return new Wr(r2, i2, u5, s3, l2);
                }
              }
              if (1 === o2.length) e2.errors.push(...a2.errors);
              else {
                const r3 = (o2.length ? o2 : s2.map(([t3]) => t3)).map(Yr).join(" | "), n3 = [];
                for (let r4 = 1; r4 < t2.length; r4++) {
                  const i3 = e2.parse(t2[r4], 1 + n3.length);
                  if (!i3) return null;
                  n3.push(Mr(i3.type));
                }
                e2.error(`Expected arguments of type ${r3}, but found (${n3.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t2, e2) {
              Wr.definitions = e2;
              for (const r2 in e2) t2[r2] = Wr;
            }
          }
          function Yr(t2) {
            return Array.isArray(t2) ? `(${t2.map(Mr).join(", ")})` : `(${Mr(t2.type)}...)`;
          }
          class Kr {
            constructor(t2, e2, r2) {
              this.type = br, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error("Expected one argument.");
              const r2 = t2[1];
              if ("object" != typeof r2 || Array.isArray(r2)) return e2.error("Collator options argument must be an object.");
              const n2 = void 0 === r2["case-sensitive"] ? e2.parse(false, 1, yr) : e2.parseObjectValue(r2["case-sensitive"], 1, "case-sensitive", yr);
              if (!n2) return null;
              const i2 = void 0 === r2["diacritic-sensitive"] ? e2.parse(false, 1, yr) : e2.parseObjectValue(r2["diacritic-sensitive"], 1, "diacritic-sensitive", yr);
              if (!i2) return null;
              let s2 = null;
              return r2.locale && (s2 = e2.parseObjectValue(r2.locale, 1, "locale", mr), !s2) ? null : new Kr(n2, i2, s2);
            }
            evaluate(t2) {
              return new Er(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
            }
            eachChild(t2) {
              t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
            }
          }
          function Jr(t2, e2, r2 = 0, n2 = t2.length - 1, i2 = tn) {
            for (; n2 > r2; ) {
              if (n2 - r2 > 600) {
                const s3 = n2 - r2 + 1, o3 = e2 - r2 + 1, a3 = Math.log(s3), l2 = 0.5 * Math.exp(2 * a3 / 3), u5 = 0.5 * Math.sqrt(a3 * l2 * (s3 - l2) / s3) * (o3 - s3 / 2 < 0 ? -1 : 1);
                Jr(t2, e2, Math.max(r2, Math.floor(e2 - o3 * l2 / s3 + u5)), Math.min(n2, Math.floor(e2 + (s3 - o3) * l2 / s3 + u5)), i2);
              }
              const s2 = t2[e2];
              let o2 = r2, a2 = n2;
              for (Qr(t2, r2, e2), i2(t2[n2], s2) > 0 && Qr(t2, r2, n2); o2 < a2; ) {
                for (Qr(t2, o2, a2), o2++, a2--; i2(t2[o2], s2) < 0; ) o2++;
                for (; i2(t2[a2], s2) > 0; ) a2--;
              }
              0 === i2(t2[r2], s2) ? Qr(t2, r2, a2) : (a2++, Qr(t2, a2, n2)), a2 <= e2 && (r2 = a2 + 1), e2 <= a2 && (n2 = a2 - 1);
            }
          }
          function Qr(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function tn(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function en(t2) {
            let e2 = 0;
            for (let r2, n2, i2 = 0, s2 = t2.length, o2 = s2 - 1; i2 < s2; o2 = i2++) r2 = t2[i2], n2 = t2[o2], e2 += (n2.x - r2.x) * (r2.y + n2.y);
            return e2;
          }
          function rn(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function nn(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function sn(t2, e2, r2) {
            const n2 = t2[0] - e2[0], i2 = t2[1] - e2[1], s2 = t2[0] - r2[0], o2 = t2[1] - r2[1];
            return n2 * o2 - s2 * i2 == 0 && n2 * s2 <= 0 && i2 * o2 <= 0;
          }
          function on(t2, e2, r2 = false) {
            let n2 = false;
            for (let a2 = 0, l2 = e2.length; a2 < l2; a2++) {
              const l3 = e2[a2];
              for (let e3 = 0, a3 = l3.length, u5 = a3 - 1; e3 < a3; u5 = e3++) {
                const a4 = l3[u5], c2 = l3[e3];
                if (sn(t2, a4, c2)) return r2;
                (s2 = a4)[1] > (i2 = t2)[1] != (o2 = c2)[1] > i2[1] && i2[0] < (o2[0] - s2[0]) * (i2[1] - s2[1]) / (o2[1] - s2[1]) + s2[0] && (n2 = !n2);
              }
            }
            var i2, s2, o2;
            return n2;
          }
          function an(t2, e2, r2, n2) {
            const i2 = n2[0] - r2[0], s2 = n2[1] - r2[1], o2 = (t2[0] - r2[0]) * s2 - i2 * (t2[1] - r2[1]), a2 = (e2[0] - r2[0]) * s2 - i2 * (e2[1] - r2[1]);
            return o2 > 0 && a2 < 0 || o2 < 0 && a2 > 0;
          }
          function ln(t2, e2, r2, n2) {
            return 0 != (i2 = [n2[0] - r2[0], n2[1] - r2[1]])[0] * (s2 = [e2[0] - t2[0], e2[1] - t2[1]])[1] - i2[1] * s2[0] && !(!an(t2, e2, r2, n2) || !an(r2, n2, t2, e2));
            var i2, s2;
          }
          function un(t2) {
            const e2 = new bt(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY), r2 = new bt(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
            for (const n2 of t2[0]) e2.x > n2.x && (e2.x = n2.x), e2.y > n2.y && (e2.y = n2.y), r2.x < n2.x && (r2.x = n2.x), r2.y < n2.y && (r2.y = n2.y);
            return { min: e2, max: r2 };
          }
          const cn = 8192;
          function hn(t2, e2) {
            const r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * cn), Math.round(n2 * i2 * cn)];
          }
          function pn(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++) if (on(t2, e2[r2])) return true;
            return false;
          }
          function fn(t2, e2, r2) {
            for (const n2 of r2) for (let r3 = 0, i2 = n2.length, s2 = i2 - 1; r3 < i2; s2 = r3++) if (ln(t2, e2, n2[s2], n2[r3])) return true;
            return false;
          }
          function dn(t2, e2) {
            for (let r2 = 0; r2 < t2.length; ++r2) if (!on(t2[r2], e2)) return false;
            for (let r2 = 0; r2 < t2.length - 1; ++r2) if (fn(t2[r2], t2[r2 + 1], e2)) return false;
            return true;
          }
          function mn(t2, e2) {
            for (let r2 = 0; r2 < e2.length; r2++) if (dn(t2, e2[r2])) return true;
            return false;
          }
          function yn(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = [];
              for (let n3 = 0; n3 < t2[i2].length; n3++) {
                const o2 = hn(t2[i2][n3], r2);
                rn(e2, o2), s2.push(o2);
              }
              n2.push(s2);
            }
            return n2;
          }
          function gn(t2, e2, r2) {
            const n2 = [];
            for (let i2 = 0; i2 < t2.length; i2++) {
              const s2 = yn(t2[i2], e2, r2);
              n2.push(s2);
            }
            return n2;
          }
          function xn(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              const e3 = 0.5 * n2;
              let i2 = t2[0] - r2[0] > e3 ? -n2 : r2[0] - t2[0] > e3 ? n2 : 0;
              0 === i2 && (i2 = t2[0] - r2[2] > e3 ? -n2 : r2[2] - t2[0] > e3 ? n2 : 0), t2[0] += i2;
            }
            rn(e2, t2);
          }
          function vn(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * cn, s2 = [n2.x * cn, n2.y * cn], o2 = [];
            if (!t2) return o2;
            for (const n3 of t2) for (const t3 of n3) {
              const n4 = [t3.x + s2[0], t3.y + s2[1]];
              xn(n4, e2, r2, i2), o2.push(n4);
            }
            return o2;
          }
          function bn(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z) * cn, s2 = [n2.x * cn, n2.y * cn], o2 = [];
            if (!t2) return o2;
            for (const r3 of t2) {
              const t3 = [];
              for (const n3 of r3) {
                const r4 = [n3.x + s2[0], n3.y + s2[1]];
                rn(e2, r4), t3.push(r4);
              }
              o2.push(t3);
            }
            if (e2[2] - e2[0] <= i2 / 2) {
              (a2 = e2)[0] = a2[1] = 1 / 0, a2[2] = a2[3] = -1 / 0;
              for (const t3 of o2) for (const n3 of t3) xn(n3, e2, r2, i2);
            }
            var a2;
            return o2;
          }
          class _n {
            constructor(t2, e2) {
              this.type = yr, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'within' expression requires exactly one argument, but found ${t2.length - 1} instead.`);
              if (Dr(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type) for (let t3 = 0; t3 < e3.features.length; ++t3) {
                  const r2 = e3.features[t3].geometry.type;
                  if ("Polygon" === r2 || "MultiPolygon" === r2) return new _n(e3, e3.features[t3].geometry);
                }
                else if ("Feature" === e3.type) {
                  const t3 = e3.geometry.type;
                  if ("Polygon" === t3 || "MultiPolygon" === t3) return new _n(e3, e3.geometry);
                } else if ("Polygon" === e3.type || "MultiPolygon" === e3.type) return new _n(e3, e3);
              }
              return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t2) {
              if (null != t2.geometry() && null != t2.canonicalID()) {
                if ("Point" === t2.geometryType()) return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (!i2) return false;
                  if ("Polygon" === e2.type) {
                    const s2 = yn(e2.coordinates, n2, i2), o2 = vn(t3.geometry(), r2, n2, i2);
                    if (!nn(r2, n2)) return false;
                    for (const t4 of o2) if (!on(t4, s2)) return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = gn(e2.coordinates, n2, i2), o2 = vn(t3.geometry(), r2, n2, i2);
                    if (!nn(r2, n2)) return false;
                    for (const t4 of o2) if (!pn(t4, s2)) return false;
                  }
                  return true;
                }(t2, this.geometries);
                if ("LineString" === t2.geometryType()) return function(t3, e2) {
                  const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if (!i2) return false;
                  if ("Polygon" === e2.type) {
                    const s2 = yn(e2.coordinates, n2, i2), o2 = bn(t3.geometry(), r2, n2, i2);
                    if (!nn(r2, n2)) return false;
                    for (const t4 of o2) if (!dn(t4, s2)) return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    const s2 = gn(e2.coordinates, n2, i2), o2 = bn(t3.geometry(), r2, n2, i2);
                    if (!nn(r2, n2)) return false;
                    for (const t4 of o2) if (!mn(t4, s2)) return false;
                  }
                  return true;
                }(t2, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["within", this.geojson];
            }
          }
          const wn = { kilometers: 1, miles: 1e3 / 1609.344, nauticalmiles: 1e3 / 1852, meters: 1e3, metres: 1e3, yards: 1e3 / 0.9144, feet: 1e3 / 0.3048, inches: 1e3 / 0.0254 }, An = 1 / 298.257223563, Mn = An * (2 - An), In = Math.PI / 180;
          class Sn {
            static fromTile(t2, e2, r2) {
              const n2 = Math.PI * (1 - 2 * (t2 + 0.5) / Math.pow(2, e2)), i2 = Math.atan(0.5 * (Math.exp(n2) - Math.exp(-n2))) / In;
              return new Sn(i2, r2);
            }
            static get units() {
              return wn;
            }
            constructor(t2, e2) {
              if (void 0 === t2) throw new Error("No latitude given.");
              if (e2 && !wn[e2]) throw new Error(`Unknown unit ${e2}. Use one of: ${Object.keys(wn).join(", ")}`);
              const r2 = 6378.137 * In * (e2 ? wn[e2] : 1), n2 = Math.cos(t2 * In), i2 = 1 / (1 - Mn * (1 - n2 * n2)), s2 = Math.sqrt(i2);
              this.kx = r2 * s2 * n2, this.ky = r2 * s2 * i2 * (1 - Mn);
            }
            distance(t2, e2) {
              const r2 = En(t2[0] - e2[0]) * this.kx, n2 = (t2[1] - e2[1]) * this.ky;
              return Math.sqrt(r2 * r2 + n2 * n2);
            }
            bearing(t2, e2) {
              const r2 = En(e2[0] - t2[0]) * this.kx;
              return Math.atan2(r2, (e2[1] - t2[1]) * this.ky) / In;
            }
            destination(t2, e2, r2) {
              const n2 = r2 * In;
              return this.offset(t2, Math.sin(n2) * e2, Math.cos(n2) * e2);
            }
            offset(t2, e2, r2) {
              return [t2[0] + e2 / this.kx, t2[1] + r2 / this.ky];
            }
            lineDistance(t2) {
              let e2 = 0;
              for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += this.distance(t2[r2], t2[r2 + 1]);
              return e2;
            }
            area(t2) {
              let e2 = 0;
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2[r2];
                for (let t3 = 0, i2 = n2.length, s2 = i2 - 1; t3 < i2; s2 = t3++) e2 += En(n2[t3][0] - n2[s2][0]) * (n2[t3][1] + n2[s2][1]) * (r2 ? -1 : 1);
              }
              return Math.abs(e2) / 2 * this.kx * this.ky;
            }
            along(t2, e2) {
              let r2 = 0;
              if (e2 <= 0) return t2[0];
              for (let n2 = 0; n2 < t2.length - 1; n2++) {
                const i2 = t2[n2], s2 = t2[n2 + 1], o2 = this.distance(i2, s2);
                if (r2 += o2, r2 > e2) return kn(i2, s2, (e2 - (r2 - o2)) / o2);
              }
              return t2[t2.length - 1];
            }
            pointToSegmentDistance(t2, e2, r2) {
              let [n2, i2] = e2, s2 = En(r2[0] - n2) * this.kx, o2 = (r2[1] - i2) * this.ky;
              if (0 !== s2 || 0 !== o2) {
                const e3 = (En(t2[0] - n2) * this.kx * s2 + (t2[1] - i2) * this.ky * o2) / (s2 * s2 + o2 * o2);
                e3 > 1 ? (n2 = r2[0], i2 = r2[1]) : e3 > 0 && (n2 += s2 / this.kx * e3, i2 += o2 / this.ky * e3);
              }
              return s2 = En(t2[0] - n2) * this.kx, o2 = (t2[1] - i2) * this.ky, Math.sqrt(s2 * s2 + o2 * o2);
            }
            pointOnLine(t2, e2) {
              let r2 = 1 / 0, n2 = t2[0][0], i2 = t2[0][1], s2 = 0, o2 = 0;
              for (let a2 = 0; a2 < t2.length - 1; a2++) {
                let l2 = t2[a2][0], u5 = t2[a2][1], c2 = En(t2[a2 + 1][0] - l2) * this.kx, h2 = (t2[a2 + 1][1] - u5) * this.ky, p2 = 0;
                0 === c2 && 0 === h2 || (p2 = (En(e2[0] - l2) * this.kx * c2 + (e2[1] - u5) * this.ky * h2) / (c2 * c2 + h2 * h2), p2 > 1 ? (l2 = t2[a2 + 1][0], u5 = t2[a2 + 1][1]) : p2 > 0 && (l2 += c2 / this.kx * p2, u5 += h2 / this.ky * p2)), c2 = En(e2[0] - l2) * this.kx, h2 = (e2[1] - u5) * this.ky;
                const f2 = c2 * c2 + h2 * h2;
                f2 < r2 && (r2 = f2, n2 = l2, i2 = u5, s2 = a2, o2 = p2);
              }
              return { point: [n2, i2], index: s2, t: Math.max(0, Math.min(1, o2)) };
            }
            lineSlice(t2, e2, r2) {
              let n2 = this.pointOnLine(r2, t2), i2 = this.pointOnLine(r2, e2);
              if (n2.index > i2.index || n2.index === i2.index && n2.t > i2.t) {
                const t3 = n2;
                n2 = i2, i2 = t3;
              }
              const s2 = [n2.point], o2 = n2.index + 1, a2 = i2.index;
              !zn(r2[o2], s2[0]) && o2 <= a2 && s2.push(r2[o2]);
              for (let t3 = o2 + 1; t3 <= a2; t3++) s2.push(r2[t3]);
              return zn(r2[a2], i2.point) || s2.push(i2.point), s2;
            }
            lineSliceAlong(t2, e2, r2) {
              let n2 = 0;
              const i2 = [];
              for (let s2 = 0; s2 < r2.length - 1; s2++) {
                const o2 = r2[s2], a2 = r2[s2 + 1], l2 = this.distance(o2, a2);
                if (n2 += l2, n2 > t2 && 0 === i2.length && i2.push(kn(o2, a2, (t2 - (n2 - l2)) / l2)), n2 >= e2) return i2.push(kn(o2, a2, (e2 - (n2 - l2)) / l2)), i2;
                n2 > t2 && i2.push(a2);
              }
              return i2;
            }
            bufferPoint(t2, e2) {
              const r2 = e2 / this.ky, n2 = e2 / this.kx;
              return [t2[0] - n2, t2[1] - r2, t2[0] + n2, t2[1] + r2];
            }
            bufferBBox(t2, e2) {
              const r2 = e2 / this.ky, n2 = e2 / this.kx;
              return [t2[0] - n2, t2[1] - r2, t2[2] + n2, t2[3] + r2];
            }
            insideBBox(t2, e2) {
              return En(t2[0] - e2[0]) >= 0 && En(t2[0] - e2[2]) <= 0 && t2[1] >= e2[1] && t2[1] <= e2[3];
            }
          }
          function zn(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1];
          }
          function kn(t2, e2, r2) {
            const n2 = En(e2[0] - t2[0]);
            return [t2[0] + n2 * r2, t2[1] + (e2[1] - t2[1]) * r2];
          }
          function En(t2) {
            for (; t2 < -180; ) t2 += 360;
            for (; t2 > 180; ) t2 -= 360;
            return t2;
          }
          class Pn {
            constructor(t2 = [], e2 = (t3, e3) => t3 < e3 ? -1 : t3 > e3 ? 1 : 0) {
              if (this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0) for (let t3 = (this.length >> 1) - 1; t3 >= 0; t3--) this._down(t3);
            }
            push(t2) {
              this.data.push(t2), this._up(this.length++);
            }
            pop() {
              if (0 === this.length) return;
              const t2 = this.data[0], e2 = this.data.pop();
              return --this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
            peek() {
              return this.data[0];
            }
            _up(t2) {
              const { data: e2, compare: r2 } = this, n2 = e2[t2];
              for (; t2 > 0; ) {
                const i2 = t2 - 1 >> 1, s2 = e2[i2];
                if (r2(n2, s2) >= 0) break;
                e2[t2] = s2, t2 = i2;
              }
              e2[t2] = n2;
            }
            _down(t2) {
              const { data: e2, compare: r2 } = this, n2 = this.length >> 1, i2 = e2[t2];
              for (; t2 < n2; ) {
                let n3 = 1 + (t2 << 1);
                const s2 = n3 + 1;
                if (s2 < this.length && r2(e2[s2], e2[n3]) < 0 && (n3 = s2), r2(e2[n3], i2) >= 0) break;
                e2[t2] = e2[n3], t2 = n3;
              }
              e2[t2] = i2;
            }
          }
          var Tn = 8192;
          function Bn(t2, e2) {
            return e2.dist - t2.dist;
          }
          const Vn = 100, Cn = 50;
          function Dn(t2) {
            const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            if (e2.length !== t2.length) return false;
            for (let r2 = 0; r2 < e2.length; r2++) if (e2[r2] !== t2[r2]) return false;
            return true;
          }
          function Fn(t2) {
            return t2[1] - t2[0] + 1;
          }
          function Ln(t2, e2) {
            const r2 = t2[1] >= t2[0] && t2[1] < e2;
            return r2 || console.warn("Distance Expression: Index is out of range"), r2;
          }
          function Rn(t2, e2) {
            if (t2[0] > t2[1]) return [null, null];
            const r2 = Fn(t2);
            if (e2) {
              if (2 === r2) return [t2, null];
              const e3 = Math.floor(r2 / 2);
              return [[t2[0], t2[0] + e3], [t2[0] + e3, t2[1]]];
            }
            {
              if (1 === r2) return [t2, null];
              const e3 = Math.floor(r2 / 2) - 1;
              return [[t2[0], t2[0] + e3], [t2[0] + e3 + 1, t2[1]]];
            }
          }
          function On(t2, e2) {
            const r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            if (!Ln(e2, t2.length)) return r2;
            for (let n2 = e2[0]; n2 <= e2[1]; ++n2) rn(r2, t2[n2]);
            return r2;
          }
          function Un(t2) {
            const e2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
            for (let r2 = 0; r2 < t2.length; ++r2) for (let n2 = 0; n2 < t2[r2].length; ++n2) rn(e2, t2[r2][n2]);
            return e2;
          }
          function Nn(t2, e2, r2) {
            if (Dn(t2) || Dn(e2)) return NaN;
            let n2 = 0, i2 = 0;
            return t2[2] < e2[0] && (n2 = e2[0] - t2[2]), t2[0] > e2[2] && (n2 = t2[0] - e2[2]), t2[1] > e2[3] && (i2 = t2[1] - e2[3]), t2[3] < e2[1] && (i2 = e2[1] - t2[3]), r2.distance([0, 0], [n2, i2]);
          }
          function jn(t2) {
            return 360 * t2 - 180;
          }
          function $n(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function Gn(t2, e2) {
            const r2 = Math.pow(2, e2.z), n2 = (t2.y / Tn + e2.y) / r2;
            return [jn((t2.x / Tn + e2.x) / r2), $n(n2)];
          }
          function qn(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < t2.length; ++n2) r2.push(Gn(t2[n2], e2));
            return r2;
          }
          function Hn(t2, e2, r2) {
            const n2 = r2.pointOnLine(e2, t2).point;
            return r2.distance(t2, n2);
          }
          function Xn(t2, e2, r2, n2, i2) {
            const s2 = r2.slice(n2[0], n2[1] + 1);
            let o2 = 1 / 0;
            for (let r3 = e2[0]; r3 <= e2[1]; ++r3) if (0 === (o2 = Math.min(o2, Hn(t2[r3], s2, i2)))) return 0;
            return o2;
          }
          function Zn(t2, e2, r2, n2, i2) {
            const s2 = Math.min(i2.pointToSegmentDistance(t2, r2, n2), i2.pointToSegmentDistance(e2, r2, n2)), o2 = Math.min(i2.pointToSegmentDistance(r2, t2, e2), i2.pointToSegmentDistance(n2, t2, e2));
            return Math.min(s2, o2);
          }
          function Wn(t2, e2, r2, n2, i2) {
            if (!Ln(e2, t2.length) || !Ln(n2, r2.length)) return NaN;
            let s2 = 1 / 0;
            for (let o2 = e2[0]; o2 < e2[1]; ++o2) for (let e3 = n2[0]; e3 < n2[1]; ++e3) {
              if (ln(t2[o2], t2[o2 + 1], r2[e3], r2[e3 + 1])) return 0;
              s2 = Math.min(s2, Zn(t2[o2], t2[o2 + 1], r2[e3], r2[e3 + 1], i2));
            }
            return s2;
          }
          function Yn(t2, e2, r2, n2, i2) {
            if (!Ln(e2, t2.length) || !Ln(n2, r2.length)) return NaN;
            let s2 = 1 / 0;
            for (let o2 = e2[0]; o2 <= e2[1]; ++o2) for (let e3 = n2[0]; e3 <= n2[1]; ++e3) if (0 === (s2 = Math.min(s2, i2.distance(t2[o2], r2[e3])))) return s2;
            return s2;
          }
          function Kn(t2, e2, r2) {
            if (on(t2, e2, true)) return 0;
            let n2 = 1 / 0;
            for (const i2 of e2) {
              const e3 = i2.length;
              if (e3 < 2) return console.warn("Distance Expression: Invalid polygon!"), NaN;
              if (i2[0] !== i2[e3 - 1] && 0 === (n2 = Math.min(n2, r2.pointToSegmentDistance(t2, i2[e3 - 1], i2[0])))) return n2;
              if (0 === (n2 = Math.min(n2, Hn(t2, i2, r2)))) return n2;
            }
            return n2;
          }
          function Jn(t2, e2, r2, n2) {
            if (!Ln(e2, t2.length)) return NaN;
            for (let n3 = e2[0]; n3 <= e2[1]; ++n3) if (on(t2[n3], r2, true)) return 0;
            let i2 = 1 / 0;
            for (let s2 = e2[0]; s2 < e2[1]; ++s2) for (const e3 of r2) for (let r3 = 0, o2 = e3.length, a2 = o2 - 1; r3 < o2; a2 = r3++) {
              if (ln(t2[s2], t2[s2 + 1], e3[a2], e3[r3])) return 0;
              i2 = Math.min(i2, Zn(t2[s2], t2[s2 + 1], e3[a2], e3[r3], n2));
            }
            return i2;
          }
          function Qn(t2, e2) {
            for (const r2 of t2) for (let t3 = 0; t3 <= r2.length - 1; ++t3) if (on(r2[t3], e2, true)) return true;
            return false;
          }
          function ti(t2, e2, r2, n2 = 1 / 0) {
            const i2 = Un(t2), s2 = Un(e2);
            if (n2 !== 1 / 0 && Nn(i2, s2, r2) >= n2) return n2;
            if (nn(i2, s2)) {
              if (Qn(t2, e2)) return 0;
            } else if (Qn(e2, t2)) return 0;
            let o2 = n2;
            for (const n3 of t2) for (let t3 = 0, i3 = n3.length, s3 = i3 - 1; t3 < i3; s3 = t3++) for (const i4 of e2) for (let e3 = 0, a2 = i4.length, l2 = a2 - 1; e3 < a2; l2 = e3++) {
              if (ln(n3[s3], n3[t3], i4[l2], i4[e3])) return 0;
              o2 = Math.min(o2, Zn(n3[s3], n3[t3], i4[l2], i4[e3], r2));
            }
            return o2;
          }
          function ei(t2, e2, r2, n2, i2, s2, o2) {
            if (null === s2 || null === o2) return;
            const a2 = Nn(On(n2, s2), On(i2, o2), r2);
            a2 < e2 && t2.push({ dist: a2, range1: s2, range2: o2 });
          }
          function ri(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = Math.min(n2.distance(t2[0], r2[0][0]), i2);
            if (0 === s2) return s2;
            const o2 = new Pn([{ dist: 0, range1: [0, t2.length - 1], range2: [0, 0] }], Bn), a2 = e2 ? Cn : Vn, l2 = Un(r2);
            for (; o2.length; ) {
              const i3 = o2.pop();
              if (i3.dist >= s2) continue;
              const u5 = i3.range1;
              if (Fn(u5) <= a2) {
                if (!Ln(u5, t2.length)) return NaN;
                if (e2) {
                  const e3 = Jn(t2, u5, r2, n2);
                  if (0 === (s2 = Math.min(s2, e3))) return s2;
                } else for (let e3 = u5[0]; e3 <= u5[1]; ++e3) {
                  const i4 = Kn(t2[e3], r2, n2);
                  if (0 === (s2 = Math.min(s2, i4))) return s2;
                }
              } else {
                const r3 = Rn(u5, e2);
                if (null !== r3[0]) {
                  const e3 = Nn(On(t2, r3[0]), l2, n2);
                  e3 < s2 && o2.push({ dist: e3, range1: r3[0], range2: [0, 0] });
                }
                if (null !== r3[1]) {
                  const e3 = Nn(On(t2, r3[1]), l2, n2);
                  e3 < s2 && o2.push({ dist: e3, range1: r3[1], range2: [0, 0] });
                }
              }
            }
            return s2;
          }
          function ni(t2, e2, r2, n2, i2, s2 = 1 / 0) {
            let o2 = Math.min(s2, i2.distance(t2[0], r2[0]));
            if (0 === o2) return o2;
            const a2 = new Pn([{ dist: 0, range1: [0, t2.length - 1], range2: [0, r2.length - 1] }], Bn), l2 = e2 ? Cn : Vn, u5 = n2 ? Cn : Vn;
            for (; a2.length; ) {
              const s3 = a2.pop();
              if (s3.dist >= o2) continue;
              const c2 = s3.range1, h2 = s3.range2;
              if (Fn(c2) <= l2 && Fn(h2) <= u5) {
                if (!Ln(c2, t2.length) || !Ln(h2, r2.length)) return NaN;
                if (e2 && n2 ? o2 = Math.min(o2, Wn(t2, c2, r2, h2, i2)) : e2 || n2 ? e2 && !n2 ? o2 = Math.min(o2, Xn(r2, h2, t2, c2, i2)) : !e2 && n2 && (o2 = Math.min(o2, Xn(t2, c2, r2, h2, i2))) : o2 = Math.min(o2, Yn(t2, c2, r2, h2, i2)), 0 === o2) return o2;
              } else {
                const s4 = Rn(c2, e2), l3 = Rn(h2, n2);
                ei(a2, o2, i2, t2, r2, s4[0], l3[0]), ei(a2, o2, i2, t2, r2, s4[0], l3[1]), ei(a2, o2, i2, t2, r2, s4[1], l3[0]), ei(a2, o2, i2, t2, r2, s4[1], l3[1]);
              }
            }
            return o2;
          }
          function ii(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = i2;
            const o2 = On(t2, [0, t2.length - 1]);
            for (const i3 of r2) if (!(s2 !== 1 / 0 && Nn(o2, On(i3, [0, i3.length - 1]), n2) >= s2) && (s2 = Math.min(s2, ni(t2, e2, i3, true, n2, s2)), 0 === s2)) return s2;
            return s2;
          }
          function si(t2, e2, r2, n2, i2 = 1 / 0) {
            let s2 = i2;
            const o2 = On(t2, [0, t2.length - 1]);
            for (const i3 of r2) {
              if (s2 !== 1 / 0 && Nn(o2, Un(i3), n2) >= s2) continue;
              const r3 = ri(t2, e2, i3, n2, s2);
              if (isNaN(r3)) return r3;
              if (0 === (s2 = Math.min(s2, r3))) return s2;
            }
            return s2;
          }
          function oi(t2) {
            return "Point" === t2 || "MultiPoint" === t2 || "LineString" === t2 || "MultiLineString" === t2 || "Polygon" === t2 || "MultiPolygon" === t2;
          }
          class ai {
            constructor(t2, e2) {
              this.type = dr, this.geojson = t2, this.geometries = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`'distance' expression requires either one argument, but found ' ${t2.length - 1} instead.`);
              if (Dr(t2[1])) {
                const e3 = t2[1];
                if ("FeatureCollection" === e3.type) {
                  for (let t3 = 0; t3 < e3.features.length; ++t3) if (oi(e3.features[t3].geometry.type)) return new ai(e3, e3.features[t3].geometry);
                } else if ("Feature" === e3.type) {
                  if (oi(e3.geometry.type)) return new ai(e3, e3.geometry);
                } else if (oi(e3.type)) return new ai(e3, e3);
              }
              return e2.error("'distance' expression needs to be an array with format ['Distance', GeoJSONObj].");
            }
            evaluate(t2) {
              const e2 = t2.geometry(), r2 = t2.canonicalID();
              if (null != e2 && null != r2) {
                if ("Point" === t2.geometryType()) return function(t3, e3, r3) {
                  const n2 = [];
                  for (const r4 of t3) for (const t4 of r4) n2.push(Gn(t4, e3));
                  const i2 = new Sn(n2[0][1], "meters");
                  return "Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type ? ni(n2, false, "Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, i2) : "MultiLineString" === r3.type ? ii(n2, false, r3.coordinates, i2) : "Polygon" === r3.type || "MultiPolygon" === r3.type ? si(n2, false, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2) : null;
                }(e2, r2, this.geometries);
                if ("LineString" === t2.geometryType()) return function(t3, e3, r3) {
                  const n2 = [];
                  for (const r4 of t3) {
                    const t4 = [];
                    for (const n3 of r4) t4.push(Gn(n3, e3));
                    n2.push(t4);
                  }
                  const i2 = new Sn(n2[0][0][1], "meters");
                  if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return ii("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                  if ("MultiLineString" === r3.type) {
                    let t4 = 1 / 0;
                    for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                      const s2 = ii(r3.coordinates[e4], true, n2, i2, t4);
                      if (isNaN(s2)) return s2;
                      if (0 === (t4 = Math.min(t4, s2))) return t4;
                    }
                    return t4;
                  }
                  if ("Polygon" === r3.type || "MultiPolygon" === r3.type) {
                    let t4 = 1 / 0;
                    for (let e4 = 0; e4 < n2.length; e4++) {
                      const s2 = si(n2[e4], true, "Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, i2, t4);
                      if (isNaN(s2)) return s2;
                      if (0 === (t4 = Math.min(t4, s2))) return t4;
                    }
                    return t4;
                  }
                  return null;
                }(e2, r2, this.geometries);
                if ("Polygon" === t2.geometryType()) return function(t3, e3, r3) {
                  const n2 = [];
                  for (const r4 of function(t4, e4) {
                    const r5 = t4.length;
                    if (r5 <= 1) return [t4];
                    const n3 = [];
                    let i3, s2;
                    for (let e5 = 0; e5 < r5; e5++) {
                      const r6 = en(t4[e5]);
                      0 !== r6 && (t4[e5].area = Math.abs(r6), void 0 === s2 && (s2 = r6 < 0), s2 === r6 < 0 ? (i3 && n3.push(i3), i3 = [t4[e5]]) : i3.push(t4[e5]));
                    }
                    return i3 && n3.push(i3), n3;
                  }(t3)) {
                    const t4 = [];
                    for (let n3 = 0; n3 < r4.length; ++n3) t4.push(qn(r4[n3], e3));
                    n2.push(t4);
                  }
                  const i2 = new Sn(n2[0][0][0][1], "meters");
                  if ("Point" === r3.type || "MultiPoint" === r3.type || "LineString" === r3.type) return si("Point" === r3.type ? [r3.coordinates] : r3.coordinates, "LineString" === r3.type, n2, i2);
                  if ("MultiLineString" === r3.type) {
                    let t4 = 1 / 0;
                    for (let e4 = 0; e4 < r3.coordinates.length; e4++) {
                      const s2 = si(r3.coordinates[e4], true, n2, i2, t4);
                      if (isNaN(s2)) return s2;
                      if (0 === (t4 = Math.min(t4, s2))) return t4;
                    }
                    return t4;
                  }
                  return "Polygon" === r3.type || "MultiPolygon" === r3.type ? function(t4, e4, r4) {
                    let n3 = 1 / 0;
                    for (const i3 of t4) for (const t5 of e4) {
                      const e5 = ti(i3, t5, r4, n3);
                      if (isNaN(e5)) return e5;
                      if (0 === (n3 = Math.min(n3, e5))) return n3;
                    }
                    return n3;
                  }("Polygon" === r3.type ? [r3.coordinates] : r3.coordinates, n2, i2) : null;
                }(e2, r2, this.geometries);
                console.warn("Distance Expression: currently only evaluates valid Point/LineString/Polygon geometries.");
              } else console.warn("Distance Expression: requirs valid feature and canonical information.");
              return null;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["distance", this.geojson];
            }
          }
          function li(t2, e2) {
            switch (t2) {
              case "string":
                return Lr(e2);
              case "number":
                return +e2;
              case "boolean":
                return !!e2;
              case "color":
                return ir.parse(e2);
              case "formatted":
                return Tr.fromString(Lr(e2));
              case "resolvedImage":
                return Vr.build(Lr(e2));
            }
            return e2;
          }
          function ui(t2, e2, r2, n2) {
            return void 0 !== n2 && (t2 = n2 * Math.round(t2 / n2)), void 0 !== e2 && t2 < e2 && (t2 = e2), void 0 !== r2 && t2 > r2 && (t2 = r2), t2;
          }
          class ci {
            constructor(t2, e2, r2) {
              this.type = t2, this.key = e2, this.scope = r2;
            }
            static parse(t2, e2) {
              let r2 = e2.expectedType;
              if (null == r2 && (r2 = vr), t2.length < 2 || t2.length > 3) return e2.error("Invalid number of arguments for 'config' expression.");
              const n2 = e2.parse(t2[1], 1);
              if (!(n2 instanceof Rr)) return e2.error("Key name of 'config' expression must be a string literal.");
              if (t2.length >= 3) {
                const i2 = e2.parse(t2[2], 2);
                return i2 instanceof Rr ? new ci(r2, Lr(n2.value), Lr(i2.value)) : e2.error("Scope of 'config' expression must be a string literal.");
              }
              return new ci(r2, Lr(n2.value));
            }
            evaluate(t2) {
              const e2 = [this.key, this.scope, t2.scope].filter(Boolean).join(""), r2 = t2.getConfig(e2);
              if (!r2) return null;
              const { type: n2, value: i2, values: s2, minValue: o2, maxValue: a2, stepValue: l2 } = r2, u5 = r2.default.evaluate(t2);
              let c2 = u5;
              if (i2) {
                const e3 = t2.scope;
                t2.scope = (e3 || "").split("").slice(1).join(""), c2 = i2.evaluate(t2), t2.scope = e3;
              }
              return n2 && (c2 = li(n2, c2)), void 0 === c2 || void 0 === o2 && void 0 === a2 && void 0 === l2 || ("number" == typeof c2 ? c2 = ui(c2, o2, a2, l2) : Array.isArray(c2) && (c2 = c2.map((t3) => "number" == typeof t3 ? ui(t3, o2, a2, l2) : t3))), void 0 !== i2 && void 0 !== c2 && s2 && !s2.includes(c2) && (c2 = u5, n2 && (c2 = li(n2, c2))), (n2 && n2 !== this.type || void 0 !== c2 && Fr(c2) !== this.type) && (c2 = li(this.type.kind, c2)), c2;
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["config", this.key];
              return this.scope && t2.concat(this.key), t2;
            }
          }
          function hi(t2) {
            if (t2 instanceof Wr) {
              if ("get" === t2.name && 1 === t2.args.length) return false;
              if ("feature-state" === t2.name) return false;
              if ("has" === t2.name && 1 === t2.args.length) return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name) return false;
              if (/^filter-/.test(t2.name)) return false;
            }
            if (t2 instanceof _n) return false;
            if (t2 instanceof ai) return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !hi(t3) && (e2 = false);
            }), e2;
          }
          function pi(t2) {
            if (t2 instanceof Wr && "feature-state" === t2.name) return false;
            let e2 = true;
            return t2.eachChild((t3) => {
              e2 && !pi(t3) && (e2 = false);
            }), e2;
          }
          function fi(t2) {
            if (t2 instanceof ci) return /* @__PURE__ */ new Set([t2.key]);
            let e2 = /* @__PURE__ */ new Set();
            return t2.eachChild((t3) => {
              e2 = /* @__PURE__ */ new Set([...e2, ...fi(t3)]);
            }), e2;
          }
          function di(t2, e2) {
            if (t2 instanceof Wr && e2.indexOf(t2.name) >= 0) return false;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 && !di(t3, e2) && (r2 = false);
            }), r2;
          }
          class mi {
            constructor(t2, e2) {
              this.type = e2.type, this.name = t2, this.boundExpression = e2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length || "string" != typeof t2[1]) return e2.error("'var' expression requires exactly one string literal argument.");
              const r2 = t2[1];
              return e2.scope.has(r2) ? new mi(r2, e2.scope.get(r2)) : e2.error(`Unknown variable "${r2}". Make sure "${r2}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t2) {
              return this.boundExpression.evaluate(t2);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["var", this.name];
            }
          }
          class yi {
            constructor(t2, e2 = [], r2, n2 = new pr(), i2 = [], s2, o2) {
              this.registry = t2, this.path = e2, this.key = e2.map((t3) => "string" == typeof t3 ? `['${t3}']` : `[${t3}]`).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2, this._scope = s2, this.options = o2;
            }
            parse(t2, e2, r2, n2, i2 = {}) {
              return e2 || r2 ? this.concat(e2, null, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
            }
            parseObjectValue(t2, e2, r2, n2, i2, s2 = {}) {
              return this.concat(e2, r2, n2, i2)._parse(t2, s2);
            }
            _parse(t2, e2) {
              function r2(t3, e3, r3) {
                return "assert" === r3 ? new Nr(e3, [t3]) : "coerce" === r3 ? new Hr(e3, [t3]) : t3;
              }
              if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
                if (0 === t2.length) return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n2 = "string" == typeof t2[0] ? this.registry[t2[0]] : void 0;
                if (n2) {
                  let i2 = n2.parse(t2, this);
                  if (!i2) return null;
                  if (this.expectedType) {
                    const t3 = this.expectedType, n3 = i2.type;
                    if ("string" !== t3.kind && "number" !== t3.kind && "boolean" !== t3.kind && "object" !== t3.kind && "array" !== t3.kind || "value" !== n3.kind) if ("color" !== t3.kind && "formatted" !== t3.kind && "resolvedImage" !== t3.kind || "value" !== n3.kind && "string" !== n3.kind) {
                      if (this.checkSubtype(t3, n3)) return null;
                    } else i2 = r2(i2, t3, e2.typeAnnotation || "coerce");
                    else i2 = r2(i2, t3, e2.typeAnnotation || "assert");
                  }
                  if (!(i2 instanceof Rr) && "resolvedImage" !== i2.type.kind && xi(i2)) {
                    const t3 = new Zr(this._scope, this.options);
                    try {
                      i2 = new Rr(i2.type, i2.evaluate(t3));
                    } catch (t4) {
                      return this.error(t4.message), null;
                    }
                  }
                  return i2;
                }
                return Hr.parse(["to-array", t2], this);
              }
              return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t2} instead.`);
            }
            concat(t2, e2, r2, n2) {
              let i2 = "number" == typeof t2 ? this.path.concat(t2) : this.path;
              i2 = "string" == typeof e2 ? i2.concat(e2) : i2;
              const s2 = n2 ? this.scope.concat(n2) : this.scope;
              return new yi(this.registry, i2, r2 || null, s2, this.errors, this._scope, this.options);
            }
            error(t2, ...e2) {
              const r2 = `${this.key}${e2.map((t3) => `[${t3}]`).join("")}`;
              this.errors.push(new hr(r2, t2));
            }
            checkSubtype(t2, e2) {
              const r2 = Sr(t2, e2);
              return r2 && this.error(r2), r2;
            }
          }
          var gi = yi;
          function xi(t2) {
            if (t2 instanceof mi) return xi(t2.boundExpression);
            if (t2 instanceof Wr && "error" === t2.name) return false;
            if (t2 instanceof Kr) return false;
            if (t2 instanceof _n) return false;
            if (t2 instanceof ai) return false;
            if (t2 instanceof ci) return false;
            const e2 = t2 instanceof Hr || t2 instanceof Nr;
            let r2 = true;
            return t2.eachChild((t3) => {
              r2 = e2 ? r2 && xi(t3) : r2 && t3 instanceof Rr;
            }), !!r2 && hi(t2) && di(t2, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]);
          }
          function vi(t2, e2) {
            const r2 = t2.length - 1;
            let n2, i2, s2 = 0, o2 = r2, a2 = 0;
            for (; s2 <= o2; ) if (a2 = Math.floor((s2 + o2) / 2), n2 = t2[a2], i2 = t2[a2 + 1], n2 <= e2) {
              if (a2 === r2 || e2 < i2) return a2;
              s2 = a2 + 1;
            } else {
              if (!(n2 > e2)) throw new Or("Input is not a number.");
              o2 = a2 - 1;
            }
            return 0;
          }
          class bi {
            constructor(t2, e2, r2) {
              this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of r2) this.labels.push(t3), this.outputs.push(e3);
            }
            static parse(t2, e2) {
              if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if ((t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
              const r2 = e2.parse(t2[1], 1, dr);
              if (!r2) return null;
              const n2 = [];
              let i2 = null;
              e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
              for (let r3 = 1; r3 < t2.length; r3 += 2) {
                const s2 = 1 === r3 ? -1 / 0 : t2[r3], o2 = t2[r3 + 1], a2 = r3, l2 = r3 + 1;
                if ("number" != typeof s2) return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', a2);
                if (n2.length && n2[n2.length - 1][0] >= s2) return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', a2);
                const u5 = e2.parse(o2, l2, i2);
                if (!u5) return null;
                i2 = i2 || u5.type, n2.push([s2, u5]);
              }
              return new bi(i2, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length) return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0]) return r2[0].evaluate(t2);
              const i2 = e2.length;
              return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[vi(e2, n2)].evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs) t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["step", this.input.serialize()];
              for (let e2 = 0; e2 < this.labels.length; e2++) e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
              return t2;
            }
          }
          const _i = 0.95047, wi = 1.08883, Ai = 4 / 29, Mi = 6 / 29, Ii = 3 * Mi * Mi, Si = Mi * Mi * Mi, zi = Math.PI / 180, ki = 180 / Math.PI;
          function Ei(t2) {
            return t2 > Si ? Math.pow(t2, 1 / 3) : t2 / Ii + Ai;
          }
          function Pi(t2) {
            return t2 > Mi ? t2 * t2 * t2 : Ii * (t2 - Ai);
          }
          function Ti(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function Bi(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function Vi(t2) {
            const e2 = Bi(t2.r), r2 = Bi(t2.g), n2 = Bi(t2.b), i2 = Ei((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / _i), s2 = Ei((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * s2 - 16, a: 500 * (i2 - s2), b: 200 * (s2 - Ei((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / wi)), alpha: t2.a };
          }
          function Ci(t2) {
            let e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * Pi(e2), r2 = _i * Pi(r2), n2 = wi * Pi(n2), new ir(Ti(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), Ti(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), Ti(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function Di(t2, e2, r2) {
            const n2 = e2 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          const Fi = { forward: Vi, reverse: Ci, interpolate: function(t2, e2, r2) {
            return { l: or(t2.l, e2.l, r2), a: or(t2.a, e2.a, r2), b: or(t2.b, e2.b, r2), alpha: or(t2.alpha, e2.alpha, r2) };
          } }, Li = { forward: function(t2) {
            const { l: e2, a: r2, b: n2 } = Vi(t2), i2 = Math.atan2(n2, r2) * ki;
            return { h: i2 < 0 ? i2 + 360 : i2, c: Math.sqrt(r2 * r2 + n2 * n2), l: e2, alpha: t2.a };
          }, reverse: function(t2) {
            const e2 = t2.h * zi, r2 = t2.c;
            return Ci({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r2) {
            return { h: Di(t2.h, e2.h, r2), c: or(t2.c, e2.c, r2), l: or(t2.l, e2.l, r2), alpha: or(t2.alpha, e2.alpha, r2) };
          } };
          var Ri = Object.freeze({ __proto__: null, hcl: Li, lab: Fi });
          class Oi {
            constructor(t2, e2, r2, n2, i2) {
              this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
              for (const [t3, e3] of i2) this.labels.push(t3), this.outputs.push(e3);
            }
            static interpolationFactor(t2, e2, r2, n2) {
              let i2 = 0;
              if ("exponential" === t2.name) i2 = Ui(e2, t2.base, r2, n2);
              else if ("linear" === t2.name) i2 = Ui(e2, 1, r2, n2);
              else if ("cubic-bezier" === t2.name) {
                const s2 = t2.controlPoints;
                i2 = new xt(s2[0], s2[1], s2[2], s2[3]).solve(Ui(e2, 1, r2, n2));
              }
              return i2;
            }
            static parse(t2, e2) {
              let [r2, n2, i2, ...s2] = t2;
              if (!Array.isArray(n2) || 0 === n2.length) return e2.error("Expected an interpolation type expression.", 1);
              if ("linear" === n2[0]) n2 = { name: "linear" };
              else if ("exponential" === n2[0]) {
                const t3 = n2[1];
                if ("number" != typeof t3) return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
                n2 = { name: "exponential", base: t3 };
              } else {
                if ("cubic-bezier" !== n2[0]) return e2.error(`Unknown interpolation type ${String(n2[0])}`, 1, 0);
                {
                  const t3 = n2.slice(1);
                  if (4 !== t3.length || t3.some((t4) => "number" != typeof t4 || t4 < 0 || t4 > 1)) return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n2 = { name: "cubic-bezier", controlPoints: t3 };
                }
              }
              if (t2.length - 1 < 4) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length - 1 > 3 && (t2.length - 1) % 2 != 0) return e2.error("Expected an even number of arguments.");
              if (i2 = e2.parse(i2, 2, dr), !i2) return null;
              const o2 = [];
              let a2 = null;
              "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? a2 = gr : e2.expectedType && "value" !== e2.expectedType.kind && (a2 = e2.expectedType);
              for (let t3 = 0; t3 < s2.length; t3 += 2) {
                const r3 = s2[t3], n3 = s2[t3 + 1], i3 = t3 + 3, l2 = t3 + 4;
                if ("number" != typeof r3) return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i3);
                if (o2.length && o2[o2.length - 1][0] >= r3) return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i3);
                const u5 = e2.parse(n3, l2, a2);
                if (!u5) return null;
                a2 = a2 || u5.type, o2.push([r3, u5]);
              }
              return "number" === a2.kind || "color" === a2.kind || "array" === a2.kind && "number" === a2.itemType.kind && "number" == typeof a2.N ? new Oi(a2, r2, n2, i2, o2) : e2.error(`Type ${Mr(a2)} is not interpolatable.`);
            }
            evaluate(t2) {
              const e2 = this.labels, r2 = this.outputs;
              if (1 === e2.length) return r2[0].evaluate(t2);
              const n2 = this.input.evaluate(t2);
              if (n2 <= e2[0]) return r2[0].evaluate(t2);
              const i2 = e2.length;
              if (n2 >= e2[i2 - 1]) return r2[i2 - 1].evaluate(t2);
              const s2 = vi(e2, n2), o2 = Oi.interpolationFactor(this.interpolation, n2, e2[s2], e2[s2 + 1]), a2 = r2[s2].evaluate(t2), l2 = r2[s2 + 1].evaluate(t2);
              return "interpolate" === this.operator ? ur[this.type.kind.toLowerCase()](a2, l2, o2) : "interpolate-hcl" === this.operator ? Li.reverse(Li.interpolate(Li.forward(a2), Li.forward(l2), o2)) : Fi.reverse(Fi.interpolate(Fi.forward(a2), Fi.forward(l2), o2));
            }
            eachChild(t2) {
              t2(this.input);
              for (const e2 of this.outputs) t2(e2);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined());
            }
            serialize() {
              let t2;
              t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier", ...this.interpolation.controlPoints];
              const e2 = [this.operator, t2, this.input.serialize()];
              for (let t3 = 0; t3 < this.labels.length; t3++) e2.push(this.labels[t3], this.outputs[t3].serialize());
              return e2;
            }
          }
          function Ui(t2, e2, r2, n2) {
            const i2 = n2 - r2, s2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e2 ? s2 / i2 : (Math.pow(e2, s2) - 1) / (Math.pow(e2, i2) - 1);
          }
          class Ni {
            constructor(t2, e2) {
              this.type = t2, this.args = e2;
            }
            static parse(t2, e2) {
              if (t2.length < 2) return e2.error("Expectected at least one argument.");
              let r2 = null;
              const n2 = e2.expectedType;
              n2 && "value" !== n2.kind && (r2 = n2);
              const i2 = [];
              for (const n3 of t2.slice(1)) {
                const t3 = e2.parse(n3, 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
                if (!t3) return null;
                r2 = r2 || t3.type, i2.push(t3);
              }
              const s2 = n2 && i2.some((t3) => Sr(n2, t3.type));
              return new Ni(s2 ? vr : r2, i2);
            }
            evaluate(t2) {
              let e2, r2 = null, n2 = 0;
              for (const i2 of this.args) {
                if (n2++, r2 = i2.evaluate(t2), r2 && r2 instanceof Vr && !r2.available && (e2 || (e2 = r2), r2 = null, n2 === this.args.length)) return e2;
                if (null !== r2) break;
              }
              return r2;
            }
            eachChild(t2) {
              this.args.forEach(t2);
            }
            outputDefined() {
              return this.args.every((t2) => t2.outputDefined());
            }
            serialize() {
              const t2 = ["coalesce"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class ji {
            constructor(t2, e2) {
              this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
            }
            evaluate(t2) {
              return this.result.evaluate(t2);
            }
            eachChild(t2) {
              for (const e2 of this.bindings) t2(e2[1]);
              t2(this.result);
            }
            static parse(t2, e2) {
              if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found ${t2.length - 1} instead.`);
              const r2 = [];
              for (let n3 = 1; n3 < t2.length - 1; n3 += 2) {
                const i2 = t2[n3];
                if ("string" != typeof i2) return e2.error(`Expected string, but found ${typeof i2} instead.`, n3);
                if (/[^a-zA-Z0-9_]/.test(i2)) return e2.error("Variable names must contain only alphanumeric characters or '_'.", n3);
                const s2 = e2.parse(t2[n3 + 1], n3 + 1);
                if (!s2) return null;
                r2.push([i2, s2]);
              }
              const n2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
              return n2 ? new ji(r2, n2) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
            serialize() {
              const t2 = ["let"];
              for (const [e2, r2] of this.bindings) t2.push(e2, r2.serialize());
              return t2.push(this.result.serialize()), t2;
            }
          }
          class $i {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, dr), n2 = e2.parse(t2[2], 2, Ar(e2.expectedType || vr));
              return r2 && n2 ? new $i(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0) throw new Or(`Array index out of bounds: ${e2} < 0.`);
              if (e2 >= r2.length) throw new Or(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 !== Math.floor(e2)) throw new Or(`Array index must be an integer, but found ${e2} instead. Use at-interpolated to retrieve interpolated result with a fractional index.`);
              return r2[e2];
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at", this.index.serialize(), this.input.serialize()];
            }
          }
          class Gi {
            constructor(t2, e2, r2) {
              this.type = t2, this.index = e2, this.input = r2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, dr), n2 = e2.parse(t2[2], 2, Ar(e2.expectedType || vr));
              return r2 && n2 ? new Gi(n2.type.itemType, r2, n2) : null;
            }
            evaluate(t2) {
              const e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
              if (e2 < 0) throw new Or(`Array index out of bounds: ${e2} < 0.`);
              if (e2 > r2.length - 1) throw new Or(`Array index out of bounds: ${e2} > ${r2.length - 1}.`);
              if (e2 === Math.floor(e2)) return r2[e2];
              const n2 = Math.floor(e2), i2 = Math.ceil(e2), s2 = r2[n2], o2 = r2[i2];
              if ("number" != typeof s2 || "number" != typeof o2) throw new Or(`Cannot interpolate between non-number values at index ${e2}.`);
              const a2 = e2 - n2;
              return s2 * (1 - a2) + o2 * a2;
            }
            eachChild(t2) {
              t2(this.index), t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return ["at-interpolated", this.index.serialize(), this.input.serialize()];
            }
          }
          class qi {
            constructor(t2, e2) {
              this.type = yr, this.needle = t2, this.haystack = e2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error(`Expected 2 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, vr), n2 = e2.parse(t2[2], 2, vr);
              return r2 && n2 ? zr(r2.type, [yr, mr, dr, fr, vr]) ? new qi(r2, n2) : e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(r2.type)} instead`) : null;
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (null == r2) return false;
              if (!kr(e2, ["boolean", "string", "number", "null"])) throw new Or(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(Fr(e2))} instead.`);
              if (!kr(r2, ["string", "array"])) throw new Or(`Expected second argument to be of type array or string, but found ${Mr(Fr(r2))} instead.`);
              return r2.indexOf(e2) >= 0;
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack);
            }
            outputDefined() {
              return true;
            }
            serialize() {
              return ["in", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class Hi {
            constructor(t2, e2, r2) {
              this.type = dr, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, vr), n2 = e2.parse(t2[2], 2, vr);
              if (!r2 || !n2) return null;
              if (!zr(r2.type, [yr, mr, dr, fr, vr])) return e2.error(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, dr);
                return i2 ? new Hi(r2, n2, i2) : null;
              }
              return new Hi(r2, n2);
            }
            evaluate(t2) {
              const e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
              if (!kr(e2, ["boolean", "string", "number", "null"])) throw new Or(`Expected first argument to be of type boolean, string, number or null, but found ${Mr(Fr(e2))} instead.`);
              if (!kr(r2, ["string", "array"])) throw new Or(`Expected second argument to be of type array or string, but found ${Mr(Fr(r2))} instead.`);
              if (this.fromIndex) {
                const n2 = this.fromIndex.evaluate(t2);
                return r2.indexOf(e2, n2);
              }
              return r2.indexOf(e2);
            }
            eachChild(t2) {
              t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.fromIndex && void 0 !== this.fromIndex) {
                const t2 = this.fromIndex.serialize();
                return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
              }
              return ["index-of", this.needle.serialize(), this.haystack.serialize()];
            }
          }
          class Xi {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = s2;
            }
            static parse(t2, e2) {
              if (t2.length < 5) return e2.error(`Expected at least 4 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 1) return e2.error("Expected an even number of arguments.");
              let r2, n2;
              e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
              const i2 = {}, s2 = [];
              for (let o3 = 2; o3 < t2.length - 1; o3 += 2) {
                let a3 = t2[o3];
                const l2 = t2[o3 + 1];
                Array.isArray(a3) || (a3 = [a3]);
                const u5 = e2.concat(o3);
                if (0 === a3.length) return u5.error("Expected at least one branch label.");
                for (const t3 of a3) {
                  if ("number" != typeof t3 && "string" != typeof t3) return u5.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t3 && Math.abs(t3) > Number.MAX_SAFE_INTEGER) return u5.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t3 && Math.floor(t3) !== t3) return u5.error("Numeric branch labels must be integer values.");
                  if (r2) {
                    if (u5.checkSubtype(r2, Fr(t3))) return null;
                  } else r2 = Fr(t3);
                  if (void 0 !== i2[String(t3)]) return u5.error("Branch labels must be unique.");
                  i2[String(t3)] = s2.length;
                }
                const c2 = e2.parse(l2, o3, n2);
                if (!c2) return null;
                n2 = n2 || c2.type, s2.push(c2);
              }
              const o2 = e2.parse(t2[1], 1, vr);
              if (!o2) return null;
              const a2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
              return a2 ? "value" !== o2.type.kind && e2.concat(1).checkSubtype(r2, o2.type) ? null : new Xi(r2, n2, o2, i2, s2, a2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              return (Fr(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
            }
            eachChild(t2) {
              t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t2) => t2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["match", this.input.serialize()], e2 = Object.keys(this.cases).sort(), r2 = [], n2 = {};
              for (const t3 of e2) {
                const e3 = n2[this.cases[t3]];
                void 0 === e3 ? (n2[this.cases[t3]] = r2.length, r2.push([this.cases[t3], [t3]])) : r2[e3][1].push(t3);
              }
              const i2 = (t3) => "number" === this.inputType.kind ? Number(t3) : t3;
              for (const [e3, n3] of r2) t2.push(1 === n3.length ? i2(n3[0]) : n3.map(i2)), t2.push(this.outputs[e3].serialize());
              return t2.push(this.otherwise.serialize()), t2;
            }
          }
          class Zi {
            constructor(t2, e2, r2) {
              this.type = t2, this.branches = e2, this.otherwise = r2;
            }
            static parse(t2, e2) {
              if (t2.length < 4) return e2.error(`Expected at least 3 arguments, but found only ${t2.length - 1}.`);
              if (t2.length % 2 != 0) return e2.error("Expected an odd number of arguments.");
              let r2;
              e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
              const n2 = [];
              for (let i3 = 1; i3 < t2.length - 1; i3 += 2) {
                const s2 = e2.parse(t2[i3], i3, yr);
                if (!s2) return null;
                const o2 = e2.parse(t2[i3 + 1], i3 + 1, r2);
                if (!o2) return null;
                n2.push([s2, o2]), r2 = r2 || o2.type;
              }
              const i2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
              return i2 ? new Zi(r2, n2, i2) : null;
            }
            evaluate(t2) {
              for (const [e2, r2] of this.branches) if (e2.evaluate(t2)) return r2.evaluate(t2);
              return this.otherwise.evaluate(t2);
            }
            eachChild(t2) {
              for (const [e2, r2] of this.branches) t2(e2), t2(r2);
              t2(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t2, e2]) => e2.outputDefined()) && this.otherwise.outputDefined();
            }
            serialize() {
              const t2 = ["case"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          class Wi {
            constructor(t2, e2, r2, n2) {
              this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
            }
            static parse(t2, e2) {
              if (t2.length <= 2 || t2.length >= 5) return e2.error(`Expected 3 or 4 arguments, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1, vr), n2 = e2.parse(t2[2], 2, dr);
              if (!r2 || !n2) return null;
              if (!zr(r2.type, [Ar(vr), mr, vr])) return e2.error(`Expected first argument to be of type array or string, but found ${Mr(r2.type)} instead`);
              if (4 === t2.length) {
                const i2 = e2.parse(t2[3], 3, dr);
                return i2 ? new Wi(r2.type, r2, n2, i2) : null;
              }
              return new Wi(r2.type, r2, n2);
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
              if (!kr(e2, ["string", "array"])) throw new Or(`Expected first argument to be of type array or string, but found ${Mr(Fr(e2))} instead.`);
              if (this.endIndex) {
                const n2 = this.endIndex.evaluate(t2);
                return e2.slice(r2, n2);
              }
              return e2.slice(r2);
            }
            eachChild(t2) {
              t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              if (null != this.endIndex && void 0 !== this.endIndex) {
                const t2 = this.endIndex.serialize();
                return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
              }
              return ["slice", this.input.serialize(), this.beginIndex.serialize()];
            }
          }
          function Yi(t2, e2) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
          }
          function Ki(t2, e2, r2, n2) {
            return 0 === n2.compare(e2, r2);
          }
          function Ji(t2, e2, r2) {
            const n2 = "==" !== t2 && "!=" !== t2;
            return class i2 {
              constructor(t3, e3, r3) {
                this.type = yr, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
              }
              static parse(t3, e3) {
                if (3 !== t3.length && 4 !== t3.length) return e3.error("Expected two or three arguments.");
                const r3 = t3[0];
                let s2 = e3.parse(t3[1], 1, vr);
                if (!s2) return null;
                if (!Yi(r3, s2.type)) return e3.concat(1).error(`"${r3}" comparisons are not supported for type '${Mr(s2.type)}'.`);
                let o2 = e3.parse(t3[2], 2, vr);
                if (!o2) return null;
                if (!Yi(r3, o2.type)) return e3.concat(2).error(`"${r3}" comparisons are not supported for type '${Mr(o2.type)}'.`);
                if (s2.type.kind !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return e3.error(`Cannot compare types '${Mr(s2.type)}' and '${Mr(o2.type)}'.`);
                n2 && ("value" === s2.type.kind && "value" !== o2.type.kind ? s2 = new Nr(o2.type, [s2]) : "value" !== s2.type.kind && "value" === o2.type.kind && (o2 = new Nr(s2.type, [o2])));
                let a2 = null;
                if (4 === t3.length) {
                  if ("string" !== s2.type.kind && "string" !== o2.type.kind && "value" !== s2.type.kind && "value" !== o2.type.kind) return e3.error("Cannot use collator to compare non-string types.");
                  if (a2 = e3.parse(t3[3], 3, br), !a2) return null;
                }
                return new i2(s2, o2, a2);
              }
              evaluate(i3) {
                const s2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  const e3 = Fr(s2), r3 = Fr(o2);
                  if (e3.kind !== r3.kind || "string" !== e3.kind && "number" !== e3.kind) throw new Or(`Expected arguments for "${t2}" to be (string, string) or (number, number), but found (${e3.kind}, ${r3.kind}) instead.`);
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  const t3 = Fr(s2), r3 = Fr(o2);
                  if ("string" !== t3.kind || "string" !== r3.kind) return e2(i3, s2, o2);
                }
                return this.collator ? r2(i3, s2, o2, this.collator.evaluate(i3)) : e2(i3, s2, o2);
              }
              eachChild(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }
              outputDefined() {
                return true;
              }
              serialize() {
                const e3 = [t2];
                return this.eachChild((t3) => {
                  e3.push(t3.serialize());
                }), e3;
              }
            };
          }
          const Qi = Ji("==", function(t2, e2, r2) {
            return e2 === r2;
          }, Ki), ts = Ji("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !Ki(0, e2, r2, n2);
          }), es = Ji("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), rs = Ji(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), ns = Ji("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), is = Ji(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          });
          class ss {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.type = mr, this.number = t2, this.locale = e2, this.currency = r2, this.unit = n2, this.minFractionDigits = i2, this.maxFractionDigits = s2;
            }
            static parse(t2, e2) {
              if (3 !== t2.length) return e2.error("Expected two arguments.");
              const r2 = e2.parse(t2[1], 1, dr);
              if (!r2) return null;
              const n2 = t2[2];
              if ("object" != typeof n2 || Array.isArray(n2)) return e2.error("NumberFormat options argument must be an object.");
              let i2 = null;
              if (n2.locale && (i2 = e2.parseObjectValue(n2.locale, 2, "locale", mr), !i2)) return null;
              let s2 = null;
              if (n2.currency && (s2 = e2.parseObjectValue(n2.currency, 2, "currency", mr), !s2)) return null;
              let o2 = null;
              if (n2.unit && (o2 = e2.parseObjectValue(n2.unit, 2, "unit", mr), !o2)) return null;
              let a2 = null;
              if (n2["min-fraction-digits"] && (a2 = e2.parseObjectValue(n2["min-fraction-digits"], 2, "min-fraction-digits", dr), !a2)) return null;
              let l2 = null;
              return n2["max-fraction-digits"] && (l2 = e2.parseObjectValue(n2["max-fraction-digits"], 2, "max-fraction-digits", dr), !l2) ? null : new ss(r2, i2, s2, o2, a2, l2);
            }
            evaluate(t2) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: (this.currency ? "currency" : this.unit && "unit") || "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, unit: this.unit ? this.unit.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
            }
            eachChild(t2) {
              t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.unit && t2(this.unit), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = {};
              return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.unit && (t2.unit = this.unit.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
            }
          }
          class os {
            constructor(t2) {
              this.type = dr, this.input = t2;
            }
            static parse(t2, e2) {
              if (2 !== t2.length) return e2.error(`Expected 1 argument, but found ${t2.length - 1} instead.`);
              const r2 = e2.parse(t2[1], 1);
              return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error(`Expected argument of type string or array, but found ${Mr(r2.type)} instead.`) : new os(r2) : null;
            }
            evaluate(t2) {
              const e2 = this.input.evaluate(t2);
              if ("string" == typeof e2) return e2.length;
              if (Array.isArray(e2)) return e2.length;
              throw new Or(`Expected value to be of type string or array, but found ${Mr(Fr(e2))} instead.`);
            }
            eachChild(t2) {
              t2(this.input);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              const t2 = ["length"];
              return this.eachChild((e2) => {
                t2.push(e2.serialize());
              }), t2;
            }
          }
          function as(t2) {
            return function() {
              t2 = 1831565813 + (t2 |= 0) | 0;
              let e2 = Math.imul(t2 ^ t2 >>> 15, 1 | t2);
              return e2 = e2 + Math.imul(e2 ^ e2 >>> 7, 61 | e2) ^ e2, ((e2 ^ e2 >>> 14) >>> 0) / 4294967296;
            };
          }
          const ls = { "==": Qi, "!=": ts, ">": rs, "<": es, ">=": is, "<=": ns, array: Nr, at: $i, "at-interpolated": Gi, boolean: Nr, case: Zi, coalesce: Ni, collator: Kr, format: jr, image: $r, in: qi, "index-of": Hi, interpolate: Oi, "interpolate-hcl": Oi, "interpolate-lab": Oi, length: os, let: ji, literal: Rr, match: Xi, number: Nr, "number-format": ss, object: Nr, slice: Wi, step: bi, string: Nr, "to-boolean": Hr, "to-color": Hr, "to-number": Hr, "to-string": Hr, var: mi, within: _n, distance: ai, config: ci };
          function us(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, o2 = Cr(e2, r2, n2, s2);
            if (o2) throw new Or(o2);
            return new ir(e2 / 255 * s2, r2 / 255 * s2, n2 / 255 * s2, s2);
          }
          function cs(t2, [e2, r2, n2, i2]) {
            e2 = e2.evaluate(t2), r2 = r2.evaluate(t2), n2 = n2.evaluate(t2);
            const s2 = i2 ? i2.evaluate(t2) : 1, o2 = function(t3, e3, r3, n3) {
              return "number" == typeof t3 && t3 >= 0 && t3 <= 360 ? "number" == typeof e3 && e3 >= 0 && e3 <= 100 && "number" == typeof r3 && r3 >= 0 && r3 <= 100 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid hsla value [${[t3, e3, r3, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 's', and 'l' must be between 0 and 100.` : `Invalid hsla value [${("number" == typeof n3 ? [t3, e3, r3, n3] : [t3, e3, r3]).join(", ")}]: 'h' must be between 0 and 360.`;
            }(e2, r2, n2, s2);
            if (o2) throw new Or(o2);
            const a2 = `hsla(${e2}, ${r2}%, ${n2}%, ${s2})`, l2 = ir.parse(a2);
            if (!l2) throw new Or(`Failed to parse HSLA color: ${a2}`);
            return l2;
          }
          function hs(t2, e2) {
            return t2 in e2;
          }
          function ps(t2, e2) {
            const r2 = e2[t2];
            return void 0 === r2 ? null : r2;
          }
          function fs(t2) {
            return { type: t2 };
          }
          function ds(t2) {
            return { result: "success", value: t2 };
          }
          function ms(t2) {
            return { result: "error", value: t2 };
          }
          function ys(t2, e2) {
            return !!t2 && !!t2.parameters && t2.parameters.indexOf(e2) > -1;
          }
          function gs(t2) {
            return "data-driven" === t2["property-type"];
          }
          function xs(t2) {
            return ys(t2.expression, "measure-light");
          }
          function vs(t2) {
            return ys(t2.expression, "zoom");
          }
          function bs(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function _s(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
          }
          function ws(t2) {
            return t2;
          }
          function As(t2, e2) {
            const r2 = "color" === e2.type, n2 = t2.stops && "object" == typeof t2.stops[0][0], i2 = n2 || !(n2 || void 0 !== t2.property), s2 = t2.type || (bs(e2) ? "exponential" : "interval");
            if (r2 && ((t2 = cr({}, t2)).stops && (t2.stops = t2.stops.map((t3) => [t3[0], ir.parse(t3[1])])), t2.default = ir.parse(t2.default ? t2.default : e2.default)), t2.colorSpace && "rgb" !== t2.colorSpace && !Ri[t2.colorSpace]) throw new Error(`Unknown color space: ${t2.colorSpace}`);
            let o2, a2, l2;
            if ("exponential" === s2) o2 = zs;
            else if ("interval" === s2) o2 = Ss;
            else if ("categorical" === s2) {
              o2 = Is, a2 = /* @__PURE__ */ Object.create(null);
              for (const e3 of t2.stops) a2[e3[0]] = e3[1];
              l2 = typeof t2.stops[0][0];
            } else {
              if ("identity" !== s2) throw new Error(`Unknown function type "${s2}"`);
              o2 = ks;
            }
            if (n2) {
              const r3 = {}, n3 = [];
              for (let e3 = 0; e3 < t2.stops.length; e3++) {
                const i4 = t2.stops[e3], s4 = i4[0].zoom;
                void 0 === r3[s4] && (r3[s4] = { zoom: s4, type: t2.type, property: t2.property, default: t2.default, stops: [] }, n3.push(s4)), r3[s4].stops.push([i4[0].value, i4[1]]);
              }
              const i3 = [];
              for (const t3 of n3) i3.push([r3[t3].zoom, As(r3[t3], e2)]);
              const s3 = { name: "linear" };
              return { kind: "composite", interpolationType: s3, interpolationFactor: Oi.interpolationFactor.bind(void 0, s3), zoomStops: i3.map((t3) => t3[0]), evaluate: ({ zoom: r4 }, n4) => zs({ stops: i3, base: t2.base }, e2, r4).evaluate(r4, n4) };
            }
            if (i2) {
              const r3 = "exponential" === s2 ? { name: "exponential", base: void 0 !== t2.base ? t2.base : 1 } : null;
              return { kind: "camera", interpolationType: r3, interpolationFactor: Oi.interpolationFactor.bind(void 0, r3), zoomStops: t2.stops.map((t3) => t3[0]), evaluate: ({ zoom: r4 }) => o2(t2, e2, r4, a2, l2) };
            }
            return { kind: "source", evaluate(r3, n3) {
              const i3 = n3 && n3.properties ? n3.properties[t2.property] : void 0;
              return void 0 === i3 ? Ms(t2.default, e2.default) : o2(t2, e2, i3, a2, l2);
            } };
          }
          function Ms(t2, e2, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
          }
          function Is(t2, e2, r2, n2, i2) {
            return Ms(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function Ss(t2, e2, r2) {
            if ("number" !== Gr(r2)) return Ms(t2.default, e2.default);
            const n2 = t2.stops.length;
            if (1 === n2) return t2.stops[0][1];
            if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0]) return t2.stops[n2 - 1][1];
            const i2 = vi(t2.stops.map((t3) => t3[0]), r2);
            return t2.stops[i2][1];
          }
          function zs(t2, e2, r2) {
            const n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== Gr(r2)) return Ms(t2.default, e2.default);
            const i2 = t2.stops.length;
            if (1 === i2) return t2.stops[0][1];
            if (r2 <= t2.stops[0][0]) return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0]) return t2.stops[i2 - 1][1];
            const s2 = vi(t2.stops.map((t3) => t3[0]), r2), o2 = function(t3, e3, r3, n3) {
              const i3 = n3 - r3, s3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e3 ? s3 / i3 : (Math.pow(e3, s3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[s2][0], t2.stops[s2 + 1][0]), a2 = t2.stops[s2][1], l2 = t2.stops[s2 + 1][1];
            let u5 = ur[e2.type] || ws;
            if (t2.colorSpace && "rgb" !== t2.colorSpace) {
              const e3 = Ri[t2.colorSpace];
              u5 = (t3, r3) => e3.reverse(e3.interpolate(e3.forward(t3), e3.forward(r3), o2));
            }
            return "function" == typeof a2.evaluate ? { evaluate(...t3) {
              const e3 = a2.evaluate.apply(void 0, t3), r3 = l2.evaluate.apply(void 0, t3);
              if (void 0 !== e3 && void 0 !== r3) return u5(e3, r3, o2);
            } } : u5(a2, l2, o2);
          }
          function ks(t2, e2, r2) {
            return "color" === e2.type ? r2 = ir.parse(r2) : "formatted" === e2.type ? r2 = Tr.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = Vr.build(r2.toString()) : Gr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Ms(r2, t2.default, e2.default);
          }
          Wr.register(ls, { error: [{ kind: "error" }, [mr], (t2, [e2]) => {
            throw new Or(e2.evaluate(t2));
          }], typeof: [mr, [vr], (t2, [e2]) => Mr(Fr(e2.evaluate(t2)))], "to-rgba": [Ar(dr, 4), [gr], (t2, [e2]) => e2.evaluate(t2).toRenderColor(null).toArray()], "to-hsla": [Ar(dr, 4), [gr], (t2, [e2]) => e2.evaluate(t2).toRenderColor(null).toHslaArray()], rgb: [gr, [dr, dr, dr], us], rgba: [gr, [dr, dr, dr, dr], us], hsl: [gr, [dr, dr, dr], cs], hsla: [gr, [dr, dr, dr, dr], cs], has: { type: yr, overloads: [[[mr], (t2, [e2]) => hs(e2.evaluate(t2), t2.properties())], [[mr, xr], (t2, [e2, r2]) => hs(e2.evaluate(t2), r2.evaluate(t2))]] }, get: { type: vr, overloads: [[[mr], (t2, [e2]) => ps(e2.evaluate(t2), t2.properties())], [[mr, xr], (t2, [e2, r2]) => ps(e2.evaluate(t2), r2.evaluate(t2))]] }, "feature-state": [vr, [mr], (t2, [e2]) => ps(e2.evaluate(t2), t2.featureState || {})], properties: [xr, [], (t2) => t2.properties()], "geometry-type": [mr, [], (t2) => t2.geometryType()], id: [vr, [], (t2) => t2.id()], zoom: [dr, [], (t2) => t2.globals.zoom], pitch: [dr, [], (t2) => t2.globals.pitch || 0], "distance-from-center": [dr, [], (t2) => t2.distanceFromCenter()], "measure-light": [dr, [mr], (t2, [e2]) => t2.measureLight(e2.evaluate(t2))], "heatmap-density": [dr, [], (t2) => t2.globals.heatmapDensity || 0], "line-progress": [dr, [], (t2) => t2.globals.lineProgress || 0], "raster-value": [dr, [], (t2) => t2.globals.rasterValue || 0], "raster-particle-speed": [dr, [], (t2) => t2.globals.rasterParticleSpeed || 0], "sky-radial-progress": [dr, [], (t2) => t2.globals.skyRadialProgress || 0], accumulated: [vr, [], (t2) => void 0 === t2.globals.accumulated ? null : t2.globals.accumulated], "+": [dr, fs(dr), (t2, e2) => {
            let r2 = 0;
            for (const n2 of e2) r2 += n2.evaluate(t2);
            return r2;
          }], "*": [dr, fs(dr), (t2, e2) => {
            let r2 = 1;
            for (const n2 of e2) r2 *= n2.evaluate(t2);
            return r2;
          }], "-": { type: dr, overloads: [[[dr, dr], (t2, [e2, r2]) => e2.evaluate(t2) - r2.evaluate(t2)], [[dr], (t2, [e2]) => -e2.evaluate(t2)]] }, "/": [dr, [dr, dr], (t2, [e2, r2]) => e2.evaluate(t2) / r2.evaluate(t2)], "%": [dr, [dr, dr], (t2, [e2, r2]) => e2.evaluate(t2) % r2.evaluate(t2)], ln2: [dr, [], () => Math.LN2], pi: [dr, [], () => Math.PI], e: [dr, [], () => Math.E], "^": [dr, [dr, dr], (t2, [e2, r2]) => Math.pow(e2.evaluate(t2), r2.evaluate(t2))], sqrt: [dr, [dr], (t2, [e2]) => Math.sqrt(e2.evaluate(t2))], log10: [dr, [dr], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN10], ln: [dr, [dr], (t2, [e2]) => Math.log(e2.evaluate(t2))], log2: [dr, [dr], (t2, [e2]) => Math.log(e2.evaluate(t2)) / Math.LN2], sin: [dr, [dr], (t2, [e2]) => Math.sin(e2.evaluate(t2))], cos: [dr, [dr], (t2, [e2]) => Math.cos(e2.evaluate(t2))], tan: [dr, [dr], (t2, [e2]) => Math.tan(e2.evaluate(t2))], asin: [dr, [dr], (t2, [e2]) => Math.asin(e2.evaluate(t2))], acos: [dr, [dr], (t2, [e2]) => Math.acos(e2.evaluate(t2))], atan: [dr, [dr], (t2, [e2]) => Math.atan(e2.evaluate(t2))], min: [dr, fs(dr), (t2, e2) => Math.min(...e2.map((e3) => e3.evaluate(t2)))], max: [dr, fs(dr), (t2, e2) => Math.max(...e2.map((e3) => e3.evaluate(t2)))], abs: [dr, [dr], (t2, [e2]) => Math.abs(e2.evaluate(t2))], round: [dr, [dr], (t2, [e2]) => {
            const r2 = e2.evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [dr, [dr], (t2, [e2]) => Math.floor(e2.evaluate(t2))], ceil: [dr, [dr], (t2, [e2]) => Math.ceil(e2.evaluate(t2))], "filter-==": [yr, [mr, vr], (t2, [e2, r2]) => t2.properties()[e2.value] === r2.value], "filter-id-==": [yr, [vr], (t2, [e2]) => t2.id() === e2.value], "filter-type-==": [yr, [mr], (t2, [e2]) => t2.geometryType() === e2.value], "filter-<": [yr, [mr, vr], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter-id-<": [yr, [vr], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 < n2;
          }], "filter->": [yr, [mr, vr], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-id->": [yr, [vr], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 > n2;
          }], "filter-<=": [yr, [mr, vr], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter-id-<=": [yr, [vr], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 <= n2;
          }], "filter->=": [yr, [mr, vr], (t2, [e2, r2]) => {
            const n2 = t2.properties()[e2.value], i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-id->=": [yr, [vr], (t2, [e2]) => {
            const r2 = t2.id(), n2 = e2.value;
            return typeof r2 == typeof n2 && r2 >= n2;
          }], "filter-has": [yr, [vr], (t2, [e2]) => e2.value in t2.properties()], "filter-has-id": [yr, [], (t2) => null !== t2.id() && void 0 !== t2.id()], "filter-type-in": [yr, [Ar(mr)], (t2, [e2]) => e2.value.indexOf(t2.geometryType()) >= 0], "filter-id-in": [yr, [Ar(vr)], (t2, [e2]) => e2.value.indexOf(t2.id()) >= 0], "filter-in-small": [yr, [mr, Ar(vr)], (t2, [e2, r2]) => r2.value.indexOf(t2.properties()[e2.value]) >= 0], "filter-in-large": [yr, [mr, Ar(vr)], (t2, [e2, r2]) => function(t3, e3, r3, n2) {
            for (; r3 <= n2; ) {
              const i2 = r3 + n2 >> 1;
              if (e3[i2] === t3) return true;
              e3[i2] > t3 ? n2 = i2 - 1 : r3 = i2 + 1;
            }
            return false;
          }(t2.properties()[e2.value], r2.value, 0, r2.value.length - 1)], all: { type: yr, overloads: [[[yr, yr], (t2, [e2, r2]) => e2.evaluate(t2) && r2.evaluate(t2)], [fs(yr), (t2, e2) => {
            for (const r2 of e2) if (!r2.evaluate(t2)) return false;
            return true;
          }]] }, any: { type: yr, overloads: [[[yr, yr], (t2, [e2, r2]) => e2.evaluate(t2) || r2.evaluate(t2)], [fs(yr), (t2, e2) => {
            for (const r2 of e2) if (r2.evaluate(t2)) return true;
            return false;
          }]] }, "!": [yr, [yr], (t2, [e2]) => !e2.evaluate(t2)], "is-supported-script": [yr, [mr], (t2, [e2]) => {
            const r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2.evaluate(t2));
          }], upcase: [mr, [mr], (t2, [e2]) => e2.evaluate(t2).toUpperCase()], downcase: [mr, [mr], (t2, [e2]) => e2.evaluate(t2).toLowerCase()], concat: [mr, fs(vr), (t2, e2) => e2.map((e3) => Lr(e3.evaluate(t2))).join("")], "resolved-locale": [mr, [br], (t2, [e2]) => e2.evaluate(t2).resolvedLocale()], random: [dr, [dr, dr, vr], (t2, e2) => {
            const [r2, n2, i2] = e2.map((e3) => e3.evaluate(t2));
            if (r2 > n2) return r2;
            if (r2 === n2) return r2;
            let s2;
            if ("string" == typeof i2) s2 = function(t3) {
              let e3 = 0;
              if (0 === t3.length) return e3;
              for (let r3 = 0; r3 < t3.length; r3++) e3 = (e3 << 5) - e3 + t3.charCodeAt(r3), e3 |= 0;
              return e3;
            }(i2);
            else {
              if ("number" != typeof i2) throw new Or(`Invalid seed input: ${i2}`);
              s2 = i2;
            }
            return r2 + as(s2)() * (n2 - r2);
          }] });
          class Es {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this._warningHistory = {}, this._evaluator = new Zr(r2, n2), this._defaultValue = e2 ? function(t3) {
                return "color" === t3.type && (_s(t3.default) || Array.isArray(t3.default)) ? new ir(0, 0, 0, 0) : "color" === t3.type ? ir.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
              }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null, this.configDependencies = fi(t2);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2, o2, a2) {
              return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2, this._evaluator.featureTileCoord = o2 || null, this._evaluator.featureDistanceData = a2 || null, this.expression.evaluate(this._evaluator);
            }
            evaluate(t2, e2, r2, n2, i2, s2, o2, a2) {
              this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2 || null, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = s2 || null, this._evaluator.featureTileCoord = o2 || null, this._evaluator.featureDistanceData = a2 || null;
              try {
                const t3 = this.expression.evaluate(this._evaluator);
                if (null == t3 || "number" == typeof t3 && t3 != t3) return this._defaultValue;
                if (this._enumValues && !(t3 in this._enumValues)) throw new Or(`Expected value to be one of ${Object.keys(this._enumValues).map((t4) => JSON.stringify(t4)).join(", ")}, but found ${JSON.stringify(t3)} instead.`);
                return t3;
              } catch (t3) {
                return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(`Failed to evaluate expression "${JSON.stringify(this.expression.serialize())}". ${t3.message}`)), this._defaultValue;
              }
            }
          }
          function Ps(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in ls;
          }
          function Ts(t2, e2, r2, n2) {
            const i2 = new gi(ls, [], e2 ? function(t3) {
              const e3 = { color: gr, string: mr, number: dr, enum: mr, boolean: yr, formatted: _r, resolvedImage: wr };
              return "array" === t3.type ? Ar(e3[t3.value] || vr, t3.length) : e3[t3.type];
            }(e2) : void 0, void 0, void 0, r2, n2), s2 = i2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
            return s2 ? ds(new Es(s2, e2, r2, n2)) : ms(i2.errors);
          }
          class Bs {
            constructor(t2, e2, r2, n2) {
              this.kind = t2, this._styleExpression = e2, this.isLightConstant = r2, this.isLineProgressConstant = n2, this.isStateDependent = "constant" !== t2 && !pi(e2.expression), this.configDependencies = fi(e2.expression);
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
          }
          class Vs {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !pi(e2.expression), this.isLightConstant = i2, this.isLineProgressConstant = s2, this.configDependencies = fi(e2.expression), this.interpolationType = n2;
            }
            evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, s2);
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return this._styleExpression.evaluate(t2, e2, r2, n2, i2, s2);
            }
            interpolationFactor(t2, e2, r2) {
              return this.interpolationType ? Oi.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
            }
          }
          function Cs(t2, e2, r2, n2) {
            if ("error" === (t2 = Ts(t2, e2, r2, n2)).result) return t2;
            const i2 = t2.value.expression, s2 = hi(i2);
            if (!s2 && !gs(e2)) return ms([new hr("", "data expressions not supported")]);
            const o2 = di(i2, ["zoom", "pitch", "distance-from-center"]);
            if (!o2 && !vs(e2)) return ms([new hr("", "zoom expressions not supported")]);
            const a2 = di(i2, ["measure-light"]);
            if (!a2 && !xs(e2)) return ms([new hr("", "measure-light expression not supported")]);
            const l2 = di(i2, ["line-progress"]);
            if (!l2 && !function(t3) {
              return ys(t3.expression, "line-progress");
            }(e2)) return ms([new hr("", "line-progress expression not supported")]);
            const u5 = e2.expression && e2.expression.relaxZoomRestriction, c2 = Fs(i2);
            return c2 || o2 || u5 ? c2 instanceof hr ? ms([c2]) : c2 instanceof Oi && !bs(e2) ? ms([new hr("", '"interpolate" expressions cannot be used with this property')]) : ds(c2 ? new Vs(s2 && l2 ? "camera" : "composite", t2.value, c2.labels, c2 instanceof Oi ? c2.interpolation : void 0, a2, l2) : new Bs(s2 && l2 ? "constant" : "source", t2.value, a2, l2)) : ms([new hr("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression, or in the properties of atmosphere.')]);
          }
          class Ds {
            constructor(t2, e2) {
              this._parameters = t2, this._specification = e2, cr(this, As(this._parameters, this._specification));
            }
            static deserialize(t2) {
              return new Ds(t2._parameters, t2._specification);
            }
            static serialize(t2) {
              return { _parameters: t2._parameters, _specification: t2._specification };
            }
          }
          function Fs(t2) {
            let e2 = null;
            if (t2 instanceof ji) e2 = Fs(t2.result);
            else if (t2 instanceof Ni) {
              for (const r2 of t2.args) if (e2 = Fs(r2), e2) break;
            } else (t2 instanceof bi || t2 instanceof Oi) && t2.input instanceof Wr && "zoom" === t2.input.name && (e2 = t2);
            return e2 instanceof hr || t2.eachChild((t3) => {
              const r2 = Fs(t3);
              r2 instanceof hr ? e2 = r2 : e2 && r2 && e2 !== r2 && (e2 = new hr("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e2;
          }
          var Ls, Rs, Os = function() {
            if (Rs) return Ls;
            Rs = 1, Ls = e2;
            var t2 = 3;
            function e2(e3, r2, n2) {
              var i2 = this.cells = [];
              if (e3 instanceof ArrayBuffer) {
                this.arrayBuffer = e3;
                var s2 = new Int32Array(this.arrayBuffer);
                e3 = s2[0], this.d = (r2 = s2[1]) + 2 * (n2 = s2[2]);
                for (var o2 = 0; o2 < this.d * this.d; o2++) {
                  var a2 = s2[t2 + o2], l2 = s2[t2 + o2 + 1];
                  i2.push(a2 === l2 ? null : s2.subarray(a2, l2));
                }
                var u5 = s2[t2 + i2.length + 1];
                this.keys = s2.subarray(s2[t2 + i2.length], u5), this.bboxes = s2.subarray(u5), this.insert = this._insertReadonly;
              } else {
                this.d = r2 + 2 * n2;
                for (var c2 = 0; c2 < this.d * this.d; c2++) i2.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = r2, this.extent = e3, this.padding = n2, this.scale = r2 / e3, this.uid = 0;
              var h2 = n2 / r2 * e3;
              this.min = -h2, this.max = e3 + h2;
            }
            return e2.prototype.insert = function(t3, e3, r2, n2, i2) {
              this._forEachCell(e3, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t3), this.bboxes.push(e3), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
            }, e2.prototype._insertReadonly = function() {
              throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
            }, e2.prototype._insertCell = function(t3, e3, r2, n2, i2, s2) {
              this.cells[i2].push(s2);
            }, e2.prototype.query = function(t3, e3, r2, n2, i2) {
              var s2 = this.min, o2 = this.max;
              if (t3 <= s2 && e3 <= s2 && o2 <= r2 && o2 <= n2 && !i2) return Array.prototype.slice.call(this.keys);
              var a2 = [];
              return this._forEachCell(t3, e3, r2, n2, this._queryCell, a2, {}, i2), a2;
            }, e2.prototype._queryCell = function(t3, e3, r2, n2, i2, s2, o2, a2) {
              var l2 = this.cells[i2];
              if (null !== l2) for (var u5 = this.keys, c2 = this.bboxes, h2 = 0; h2 < l2.length; h2++) {
                var p2 = l2[h2];
                if (void 0 === o2[p2]) {
                  var f2 = 4 * p2;
                  (a2 ? a2(c2[f2 + 0], c2[f2 + 1], c2[f2 + 2], c2[f2 + 3]) : t3 <= c2[f2 + 2] && e3 <= c2[f2 + 3] && r2 >= c2[f2 + 0] && n2 >= c2[f2 + 1]) ? (o2[p2] = true, s2.push(u5[p2])) : o2[p2] = false;
                }
              }
            }, e2.prototype._forEachCell = function(t3, e3, r2, n2, i2, s2, o2, a2) {
              for (var l2 = this._convertToCellCoord(t3), u5 = this._convertToCellCoord(e3), c2 = this._convertToCellCoord(r2), h2 = this._convertToCellCoord(n2), p2 = l2; p2 <= c2; p2++) for (var f2 = u5; f2 <= h2; f2++) {
                var d2 = this.d * f2 + p2;
                if ((!a2 || a2(this._convertFromCellCoord(p2), this._convertFromCellCoord(f2), this._convertFromCellCoord(p2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t3, e3, r2, n2, d2, s2, o2, a2)) return;
              }
            }, e2.prototype._convertFromCellCoord = function(t3) {
              return (t3 - this.padding) / this.scale;
            }, e2.prototype._convertToCellCoord = function(t3) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t3 * this.scale) + this.padding));
            }, e2.prototype.toArrayBuffer = function() {
              if (this.arrayBuffer) return this.arrayBuffer;
              for (var e3 = this.cells, r2 = t2 + this.cells.length + 1 + 1, n2 = 0, i2 = 0; i2 < this.cells.length; i2++) n2 += this.cells[i2].length;
              var s2 = new Int32Array(r2 + n2 + this.keys.length + this.bboxes.length);
              s2[0] = this.extent, s2[1] = this.n, s2[2] = this.padding;
              for (var o2 = r2, a2 = 0; a2 < e3.length; a2++) {
                var l2 = e3[a2];
                s2[t2 + a2] = o2, s2.set(l2, o2), o2 += l2.length;
              }
              return s2[t2 + e3.length] = o2, s2.set(this.keys, o2), s2[t2 + e3.length + 1] = o2 += this.keys.length, s2.set(this.bboxes, o2), o2 += this.bboxes.length, s2.buffer;
            }, Ls;
          }(), Us = dt(Os);
          const Ns = {};
          function js(t2, e2, r2 = {}) {
            Object.defineProperty(t2, "_classRegistryKey", { value: e2, writable: false }), Ns[e2] = { klass: t2, omit: r2.omit || [] };
          }
          js(Object, "Object"), Us.serialize = function(t2, e2) {
            const r2 = t2.toArrayBuffer();
            return e2 && e2.add(r2), { buffer: r2 };
          }, Us.deserialize = function(t2) {
            return new Us(t2.buffer);
          }, Object.defineProperty(Us, "name", { value: "Grid" }), js(Us, "Grid"), "undefined" != typeof DOMMatrix && js(DOMMatrix, "DOMMatrix"), js(ir, "Color"), js(Error, "Error"), js(Tr, "Formatted"), js(Pr, "FormattedSection"), js(Be, "AJAXError"), js(Vr, "ResolvedImage"), js(Ds, "StylePropertyFunction"), js(Es, "StyleExpression", { omit: ["_evaluator"] }), js(tr, "ImageId"), js(Br, "ImageVariant"), js(Vs, "ZoomDependentExpression"), js(Bs, "ZoomConstantExpression"), js(Wr, "CompoundExpression", { omit: ["_evaluate"] });
          for (const t2 in ls) Ns[ls[t2]._classRegistryKey] || js(ls[t2], `Expression${t2}`);
          function $s(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function Gs(t2) {
            return self.ImageBitmap && t2 instanceof ImageBitmap;
          }
          function qs(t2, e2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp) return t2;
            if ($s(t2) || Gs(t2)) return e2 && e2.add(t2), t2;
            if (ArrayBuffer.isView(t2)) return e2 && e2.add(t2.buffer), t2;
            if (t2 instanceof ImageData) return e2 && e2.add(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              const r2 = [];
              for (const n2 of t2) r2.push(qs(n2, e2));
              return r2;
            }
            if (t2 instanceof Map) {
              const r2 = { $name: "Map", entries: [] };
              for (const [n2, i2] of t2.entries()) r2.entries.push(qs(n2), qs(i2, e2));
              return r2;
            }
            if (t2 instanceof Set) {
              const e3 = { $name: "Set" };
              let r2 = 0;
              for (const n2 of t2.values()) e3[++r2] = qs(n2);
              return e3;
            }
            if (t2 instanceof DOMMatrix) {
              const e3 = { $name: "DOMMatrix" }, r2 = ["is2D", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "a", "b", "c", "d", "e", "f"];
              for (const n2 of r2) e3[n2] = t2[n2];
              return e3;
            }
            if ("bigint" == typeof t2) return { $name: "BigInt", value: t2.toString() };
            if ("object" == typeof t2) {
              const r2 = t2.constructor, n2 = r2._classRegistryKey;
              if (!n2) throw new Error(`Can't serialize object of unregistered class "${r2.name}".`);
              const i2 = r2.serialize ? r2.serialize(t2, e2) : {};
              if (!r2.serialize) {
                for (const r3 in t2) t2.hasOwnProperty(r3) && (Ns[n2].omit.indexOf(r3) >= 0 || (i2[r3] = qs(t2[r3], e2)));
                t2 instanceof Error && (i2.message = t2.message);
              }
              if (i2.$name) throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n2 && (i2.$name = n2), i2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function Hs(t2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || $s(t2) || Gs(t2) || ArrayBuffer.isView(t2) || t2 instanceof ImageData) return t2;
            if (Array.isArray(t2)) return t2.map(Hs);
            if ("object" == typeof t2) {
              const e2 = t2.$name || "Object";
              if ("Map" === e2) {
                const e3 = t2.entries || [], r3 = /* @__PURE__ */ new Map();
                for (let t3 = 0; t3 < e3.length; t3 += 2) r3.set(Hs(e3[t3]), Hs(e3[t3 + 1]));
                return r3;
              }
              if ("Set" === e2) {
                const e3 = /* @__PURE__ */ new Set();
                for (const r3 of Object.keys(t2)) "$name" !== r3 && e3.add(Hs(t2[r3]));
                return e3;
              }
              if ("DOMMatrix" === e2) {
                let e3;
                return e3 = t2.is2D ? [t2.a, t2.b, t2.c, t2.d, t2.e, t2.f] : [t2.m11, t2.m12, t2.m13, t2.m14, t2.m21, t2.m22, t2.m23, t2.m24, t2.m31, t2.m32, t2.m33, t2.m34, t2.m41, t2.m42, t2.m43, t2.m44], new DOMMatrix(e3);
              }
              if ("BigInt" === e2) return BigInt(t2.value);
              const { klass: r2 } = Ns[e2];
              if (!r2) throw new Error(`Can't deserialize unregistered class "${e2}".`);
              if (r2.deserialize) return r2.deserialize(t2);
              const n2 = Object.create(r2.prototype);
              for (const e3 of Object.keys(t2)) "$name" !== e3 && (n2[e3] = Hs(t2[e3]));
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          const Xs = { "Latin-1 Supplement": (t2) => t2 >= 128 && t2 <= 255, Arabic: (t2) => t2 >= 1536 && t2 <= 1791, "Arabic Supplement": (t2) => t2 >= 1872 && t2 <= 1919, "Arabic Extended-A": (t2) => t2 >= 2208 && t2 <= 2303, "Hangul Jamo": (t2) => t2 >= 4352 && t2 <= 4607, "Unified Canadian Aboriginal Syllabics": (t2) => t2 >= 5120 && t2 <= 5759, Khmer: (t2) => t2 >= 6016 && t2 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t2) => t2 >= 6320 && t2 <= 6399, "General Punctuation": (t2) => t2 >= 8192 && t2 <= 8303, "Letterlike Symbols": (t2) => t2 >= 8448 && t2 <= 8527, "Number Forms": (t2) => t2 >= 8528 && t2 <= 8591, "Miscellaneous Technical": (t2) => t2 >= 8960 && t2 <= 9215, "Control Pictures": (t2) => t2 >= 9216 && t2 <= 9279, "Optical Character Recognition": (t2) => t2 >= 9280 && t2 <= 9311, "Enclosed Alphanumerics": (t2) => t2 >= 9312 && t2 <= 9471, "Geometric Shapes": (t2) => t2 >= 9632 && t2 <= 9727, "Miscellaneous Symbols": (t2) => t2 >= 9728 && t2 <= 9983, "Miscellaneous Symbols and Arrows": (t2) => t2 >= 11008 && t2 <= 11263, "CJK Radicals Supplement": (t2) => t2 >= 11904 && t2 <= 12031, "Kangxi Radicals": (t2) => t2 >= 12032 && t2 <= 12255, "Ideographic Description Characters": (t2) => t2 >= 12272 && t2 <= 12287, "CJK Symbols and Punctuation": (t2) => t2 >= 12288 && t2 <= 12351, Hiragana: (t2) => t2 >= 12352 && t2 <= 12447, Katakana: (t2) => t2 >= 12448 && t2 <= 12543, Bopomofo: (t2) => t2 >= 12544 && t2 <= 12591, "Hangul Compatibility Jamo": (t2) => t2 >= 12592 && t2 <= 12687, Kanbun: (t2) => t2 >= 12688 && t2 <= 12703, "Bopomofo Extended": (t2) => t2 >= 12704 && t2 <= 12735, "CJK Strokes": (t2) => t2 >= 12736 && t2 <= 12783, "Katakana Phonetic Extensions": (t2) => t2 >= 12784 && t2 <= 12799, "Enclosed CJK Letters and Months": (t2) => t2 >= 12800 && t2 <= 13055, "CJK Compatibility": (t2) => t2 >= 13056 && t2 <= 13311, "CJK Unified Ideographs Extension A": (t2) => t2 >= 13312 && t2 <= 19903, "Yijing Hexagram Symbols": (t2) => t2 >= 19904 && t2 <= 19967, "CJK Unified Ideographs": (t2) => t2 >= 19968 && t2 <= 40959, "Yi Syllables": (t2) => t2 >= 40960 && t2 <= 42127, "Yi Radicals": (t2) => t2 >= 42128 && t2 <= 42191, "Hangul Jamo Extended-A": (t2) => t2 >= 43360 && t2 <= 43391, "Hangul Syllables": (t2) => t2 >= 44032 && t2 <= 55215, "Hangul Jamo Extended-B": (t2) => t2 >= 55216 && t2 <= 55295, "Private Use Area": (t2) => t2 >= 57344 && t2 <= 63743, "CJK Compatibility Ideographs": (t2) => t2 >= 63744 && t2 <= 64255, "Arabic Presentation Forms-A": (t2) => t2 >= 64336 && t2 <= 65023, "Vertical Forms": (t2) => t2 >= 65040 && t2 <= 65055, "CJK Compatibility Forms": (t2) => t2 >= 65072 && t2 <= 65103, "Small Form Variants": (t2) => t2 >= 65104 && t2 <= 65135, "Arabic Presentation Forms-B": (t2) => t2 >= 65136 && t2 <= 65279, "Halfwidth and Fullwidth Forms": (t2) => t2 >= 65280 && t2 <= 65519, Osage: (t2) => t2 >= 66736 && t2 <= 66815, "CJK Unified Ideographs Extension B": (t2) => t2 >= 131072 && t2 <= 173791 };
          function Zs(t2) {
            for (const e2 of t2) if (Ks(e2.charCodeAt(0))) return true;
            return false;
          }
          function Ws(t2) {
            for (const e2 of t2) if (!Ys(e2.charCodeAt(0))) return false;
            return true;
          }
          function Ys(t2) {
            return !(Xs.Arabic(t2) || Xs["Arabic Supplement"](t2) || Xs["Arabic Extended-A"](t2) || Xs["Arabic Presentation Forms-A"](t2) || Xs["Arabic Presentation Forms-B"](t2));
          }
          function Ks(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Xs["Bopomofo Extended"](t2) || Xs.Bopomofo(t2) || Xs["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Xs["CJK Compatibility Ideographs"](t2) || Xs["CJK Compatibility"](t2) || Xs["CJK Radicals Supplement"](t2) || Xs["CJK Strokes"](t2) || !(!Xs["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Xs["CJK Unified Ideographs Extension A"](t2) || Xs["CJK Unified Ideographs"](t2) || Xs["Enclosed CJK Letters and Months"](t2) || Xs["Hangul Compatibility Jamo"](t2) || Xs["Hangul Jamo Extended-A"](t2) || Xs["Hangul Jamo Extended-B"](t2) || Xs["Hangul Jamo"](t2) || Xs["Hangul Syllables"](t2) || Xs.Hiragana(t2) || Xs["Ideographic Description Characters"](t2) || Xs.Kanbun(t2) || Xs["Kangxi Radicals"](t2) || Xs["Katakana Phonetic Extensions"](t2) || Xs.Katakana(t2) && 12540 !== t2 || !(!Xs["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Xs["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Xs["Unified Canadian Aboriginal Syllabics"](t2) || Xs["Unified Canadian Aboriginal Syllabics Extended"](t2) || Xs["Vertical Forms"](t2) || Xs["Yijing Hexagram Symbols"](t2) || Xs["Yi Syllables"](t2) || Xs["Yi Radicals"](t2))));
          }
          function Js(t2) {
            return !(Ks(t2) || function(t3) {
              return !!(Xs["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Xs["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Xs["Letterlike Symbols"](t3) || Xs["Number Forms"](t3) || Xs["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Xs["Control Pictures"](t3) && 9251 !== t3 || Xs["Optical Character Recognition"](t3) || Xs["Enclosed Alphanumerics"](t3) || Xs["Geometric Shapes"](t3) || Xs["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Xs["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Xs["CJK Symbols and Punctuation"](t3) || Xs.Katakana(t3) || Xs["Private Use Area"](t3) || Xs["CJK Compatibility Forms"](t3) || Xs["Small Form Variants"](t3) || Xs["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          function Qs(t2) {
            return Xs.Arabic(t2) || Xs["Arabic Supplement"](t2) || Xs["Arabic Extended-A"](t2) || Xs["Arabic Presentation Forms-A"](t2) || Xs["Arabic Presentation Forms-B"](t2);
          }
          function to(t2) {
            return t2 >= 1424 && t2 <= 2303 || Xs["Arabic Presentation Forms-A"](t2) || Xs["Arabic Presentation Forms-B"](t2);
          }
          function eo(t2, e2) {
            return !(!e2 && to(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Xs.Khmer(t2));
          }
          function ro(t2) {
            for (const e2 of t2) if (to(e2.charCodeAt(0))) return true;
            return false;
          }
          const no = "deferred", io = "loading", so = "loaded";
          let oo = null, ao = "unavailable", lo = null;
          const uo = function(t2) {
            t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (ao = "error"), oo && oo(t2);
          };
          function co() {
            ho.fire(new We("pluginStateChange", { pluginStatus: ao, pluginURL: lo }));
          }
          const ho = new Qe(), po = function() {
            return ao;
          }, fo = function() {
            if (ao !== no || !lo) throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            ao = io, co(), lo && De({ url: lo }, (t2) => {
              t2 ? uo(t2) : (ao = so, co());
            });
          }, mo = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ao === so || null != mo.applyArabicShaping, isLoading: () => ao === io, setState(t2) {
            ao = t2.pluginStatus, lo = t2.pluginURL;
          }, isParsed: () => null != mo.applyArabicShaping && null != mo.processBidirectionalText && null != mo.processStyledBidirectionalText, getPluginURL: () => lo };
          class yo {
            constructor(t2, e2) {
              this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.transition = e2.transition, this.pitch = e2.pitch, this.brightness = e2.brightness) : (this.now = 0, this.fadeDuration = 0, this.transition = {}, this.pitch = 0, this.brightness = 0);
            }
            isSupportedScript(t2) {
              return function(t3, e2) {
                for (const r2 of t3) if (!eo(r2.charCodeAt(0), e2)) return false;
                return true;
              }(t2, mo.isLoaded());
            }
          }
          class go {
            constructor(t2, e2, r2, n2) {
              this.property = t2, this.value = e2, this.expression = function(t3, e3, r3, n3) {
                if (_s(t3)) return new Ds(t3, e3);
                if (Ps(t3) || Array.isArray(t3) && t3.length > 0) {
                  const i2 = Cs(t3, e3, r3, n3);
                  if ("error" === i2.result) throw new Error(i2.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
                  return i2.value;
                }
                {
                  let r4 = t3;
                  return "string" == typeof t3 && "color" === e3.type && (r4 = ir.parse(t3)), { kind: "constant", configDependencies: /* @__PURE__ */ new Set(), evaluate: () => r4 };
                }
              }(void 0 === e2 ? t2.specification.default : e2, t2.specification, r2, n2);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t2, e2, r2) {
              return this.property.possiblyEvaluate(this, t2, e2, r2);
            }
          }
          class xo {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = new go(t2, void 0, e2, r2);
            }
            transitioned(t2, e2) {
              return new bo(this.property, this.value, e2, Ct({}, t2.transition, this.transition), t2.now);
            }
            untransitioned() {
              return new bo(this.property, this.value, null, {}, 0);
            }
          }
          class vo {
            constructor(t2, e2, r2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues), this._scope = e2, this._options = r2, this.configDependencies = /* @__PURE__ */ new Set();
            }
            getValue(t2) {
              return Nt(this._values[t2].value.value);
            }
            setValue(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new xo(this._values[t2].property, this._scope, this._options)), this._values[t2].value = new go(this._values[t2].property, null === e2 ? void 0 : Nt(e2), this._scope, this._options), this._values[t2].value.expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].value.expression.configDependencies]));
            }
            setTransitionOrValue(t2, e2) {
              e2 && (this._options = e2);
              const r2 = this._properties.properties;
              if (t2) for (const e3 in t2) {
                const n2 = t2[e3];
                if (e3.endsWith("-transition")) {
                  const t3 = e3.slice(0, -11);
                  r2[t3] && this.setTransition(t3, n2);
                } else r2.hasOwnProperty(e3) && this.setValue(e3, n2);
              }
            }
            getTransition(t2) {
              return Nt(this._values[t2].transition);
            }
            setTransition(t2, e2) {
              this._values.hasOwnProperty(t2) || (this._values[t2] = new xo(this._values[t2].property)), this._values[t2].transition = Nt(e2) || void 0;
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
                const n2 = this.getTransition(e2);
                void 0 !== n2 && (t2[`${e2}-transition`] = n2);
              }
              return t2;
            }
            transitioned(t2, e2) {
              const r2 = new _o(this._properties);
              for (const n2 of Object.keys(this._values)) r2._values[n2] = this._values[n2].transitioned(t2, e2._values[n2]);
              return r2;
            }
            untransitioned() {
              const t2 = new _o(this._properties);
              for (const e2 of Object.keys(this._values)) t2._values[e2] = this._values[e2].untransitioned();
              return t2;
            }
          }
          class bo {
            constructor(t2, e2, r2, n2, i2) {
              const s2 = n2.delay || 0, o2 = n2.duration || 0;
              i2 = i2 || 0, this.property = t2, this.value = e2, this.begin = i2 + s2, this.end = this.begin + o2, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), s2 = this.prior;
              if (s2) {
                if (n2 > this.end) return this.prior = null, i2;
                if (this.value.isDataDriven()) return this.prior = null, i2;
                if (n2 < this.begin) return s2.possiblyEvaluate(t2, e2, r2);
                {
                  const o2 = (n2 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(s2.possiblyEvaluate(t2, e2, r2), i2, zt(o2));
                }
              }
              return i2;
            }
          }
          class _o {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Mo(this._properties);
              for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
            hasTransition() {
              for (const t2 of Object.keys(this._values)) if (this._values[t2].prior) return true;
              return false;
            }
          }
          class wo {
            constructor(t2, e2, r2) {
              this._properties = t2, this._values = Object.create(t2.defaultPropertyValues), this._scope = e2, this._options = r2, this.configDependencies = /* @__PURE__ */ new Set();
            }
            getValue(t2) {
              return Nt(this._values[t2].value);
            }
            setValue(t2, e2) {
              this._values[t2] = new go(this._values[t2].property, null === e2 ? void 0 : Nt(e2), this._scope, this._options), this._values[t2].expression.configDependencies && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._values[t2].expression.configDependencies]));
            }
            serialize() {
              const t2 = {};
              for (const e2 of Object.keys(this._values)) {
                const r2 = this.getValue(e2);
                void 0 !== r2 && (t2[e2] = r2);
              }
              return t2;
            }
            possiblyEvaluate(t2, e2, r2) {
              const n2 = new Mo(this._properties);
              for (const i2 of Object.keys(this._values)) n2._values[i2] = this._values[i2].possiblyEvaluate(t2, e2, r2);
              return n2;
            }
          }
          class Ao {
            constructor(t2, e2, r2) {
              this.property = t2, this.value = e2, this.parameters = r2;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t2) {
              return "constant" === this.value.kind ? this.value.value : t2;
            }
            evaluate(t2, e2, r2, n2) {
              return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
            }
          }
          class Mo {
            constructor(t2) {
              this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
            }
            get(t2) {
              return this._values[t2];
            }
          }
          class Io {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return t2.expression.evaluate(e2);
            }
            interpolate(t2, e2, r2) {
              const n2 = ur[this.specification.type];
              return n2 ? n2(t2, e2, r2) : t2;
            }
          }
          class So {
            constructor(t2, e2) {
              this.specification = t2, this.overrides = e2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return new Ao(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
            }
            interpolate(t2, e2, r2) {
              if ("constant" !== t2.value.kind || "constant" !== e2.value.kind) return t2;
              if (void 0 === t2.value.value || void 0 === e2.value.value) return new Ao(this, { kind: "constant", value: void 0 }, t2.parameters);
              const n2 = ur[this.specification.type];
              return n2 ? new Ao(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
            }
            evaluate(t2, e2, r2, n2, i2, s2) {
              return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, s2);
            }
          }
          class zo {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2, r2, n2) {
              return !!t2.expression.evaluate(e2, null, {}, r2, n2);
            }
            interpolate() {
              return false;
            }
          }
          class ko {
            constructor(t2) {
              this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              const e2 = new yo(0, {});
              for (const r2 in t2) {
                const n2 = t2[r2];
                n2.specification.overridable && this.overridableProperties.push(r2);
                const i2 = this.defaultPropertyValues[r2] = new go(n2, void 0), s2 = this.defaultTransitionablePropertyValues[r2] = new xo(n2);
                this.defaultTransitioningPropertyValues[r2] = s2.untransitioned(), this.defaultPossiblyEvaluatedValues[r2] = i2.possiblyEvaluate(e2);
              }
            }
          }
          js(So, "DataDrivenProperty"), js(Io, "DataConstantProperty"), js(zo, "ColorRampProperty");
          var Eo = JSON.parse('{"$version":8,"$root":{"version":{"type":"enum","values":[8]},"fragment":{"type":"boolean"},"name":{"type":"string"},"metadata":{"type":"*"},"center":{"type":"array","value":"number"},"zoom":{"type":"number"},"bearing":{"type":"number","default":0,"period":360},"pitch":{"type":"number","default":0},"light":{"type":"light"},"lights":{"type":"array","value":"light-3d"},"terrain":{"type":"terrain","optional":true},"fog":{"type":"fog"},"snow":{"type":"snow"},"rain":{"type":"rain"},"camera":{"type":"camera"},"color-theme":{"type":"colorTheme"},"indoor":{"type":"indoor"},"imports":{"type":"array","value":"import"},"iconsets":{"type":"iconsets"},"schema":{"type":"schema"},"sources":{"type":"sources"},"sprite":{"type":"string"},"glyphs":{"type":"string","default":"mapbox://fonts/mapbox/{fontstack}/{range}.pbf"},"transition":{"type":"transition"},"projection":{"type":"projection"},"layers":{"type":"array","value":"layer"},"models":{"type":"models"},"featuresets":{"type":"featuresets"}},"featuresets":{"*":{"type":"featureset"}},"featureset":{"metadata":{"type":"*"},"selectors":{"type":"array","value":"selector"}},"selector":{"layer":{"type":"string"},"properties":{"type":"selectorProperty"},"featureNamespace":{"type":"string"},"_uniqueFeatureID":{"type":"boolean"}},"selectorProperty":{"*":{"type":"*"}},"model":{"type":"string"},"import":{"id":{"type":"string"},"url":{"type":"string"},"config":{"type":"config"},"data":{"type":"$root"},"color-theme":{"type":"colorTheme","optional":true}},"config":{"*":{"type":"*"}},"schema":{"*":{"type":"option"}},"option":{"default":{"type":"*","expression":{}},"type":{"type":"enum","values":{"string":1,"number":1,"boolean":1,"color":1}},"array":{"type":"boolean"},"minValue":{"type":"number"},"maxValue":{"type":"number"},"stepValue":{"type":"number"},"values":{"type":"array","value":"*"},"metadata":{"type":"*"}},"models":{"*":{"type":"model"}},"light-3d":{"id":{"type":"string"},"properties":{"type":"properties"},"type":{"type":"enum","values":{"ambient":{},"directional":{},"flat":{}}}},"properties":["properties_light_directional","properties_light_ambient","properties_light_flat"],"properties_light_directional":{"direction":{"type":"array","default":[210,30],"minimum":[0,0],"maximum":[360,90],"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"cast-shadows":{"type":"boolean","default":false},"shadow-quality":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"parameters":["zoom"]}},"shadow-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_ambient":{"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"properties_light_flat":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"iconsets":{"*":{"type":"iconset"}},"iconset":["iconset_sprite","iconset_source"],"iconset_sprite":{"type":{"type":"enum","values":{"sprite":1}},"url":{"type":"string"}},"iconset_source":{"type":{"type":"enum","values":{"source":1}},"source":{"type":"string"}},"sources":{"*":{"type":"source"}},"source":["source_vector","source_raster","source_raster_dem","source_raster_array","source_geojson","source_video","source_image","source_model"],"source_vector":{"type":{"type":"enum","values":{"vector":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"attribution":{"type":"string"},"promoteId":{"type":"promoteId"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster":{"type":{"type":"enum","values":{"raster":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"scheme":{"type":"enum","values":{"xyz":1,"tms":1},"default":"xyz"},"attribution":{"type":"string"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_dem":{"type":{"type":"enum","values":{"raster-dem":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"encoding":{"type":"enum","values":{"terrarium":1,"mapbox":1},"default":"mapbox"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_raster_array":{"type":{"type":"enum","values":{"raster-array":1}},"url":{"type":"string"},"tiles":{"type":"array","value":"string"},"bounds":{"type":"array","value":"number","length":4,"default":[-180,-85.051129,180,85.051129]},"extra_bounds":{"type":"array","value":{"type":"array","value":"number","length":4}},"minzoom":{"type":"number","default":0},"maxzoom":{"type":"number","default":22},"tileSize":{"type":"number","default":512},"attribution":{"type":"string"},"rasterLayers":{"type":"*"},"volatile":{"type":"boolean","default":false},"*":{"type":"*"}},"source_geojson":{"type":{"type":"enum","values":{"geojson":1}},"data":{"type":"*"},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"attribution":{"type":"string"},"buffer":{"type":"number","default":128,"maximum":512,"minimum":0},"filter":{"type":"*"},"tolerance":{"type":"number","default":0.375},"cluster":{"type":"boolean","default":false},"clusterRadius":{"type":"number","default":50,"minimum":0},"clusterMaxZoom":{"type":"number"},"clusterMinPoints":{"type":"number"},"clusterProperties":{"type":"*"},"lineMetrics":{"type":"boolean","default":false},"generateId":{"type":"boolean","default":false},"promoteId":{"type":"promoteId"},"dynamic":{"type":"boolean","default":false}},"source_video":{"type":{"type":"enum","values":{"video":1}},"urls":{"type":"array","value":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_image":{"type":{"type":"enum","values":{"image":1}},"url":{"type":"string"},"coordinates":{"type":"array","length":4,"value":{"type":"array","length":2,"value":"number"}}},"source_model":{"type":{"type":"enum","values":{"model":1,"batched-model":1}},"maxzoom":{"type":"number","default":18},"minzoom":{"type":"number","default":0},"tiles":{"type":"array","value":"string"}},"layer":{"id":{"type":"string"},"type":{"type":"enum","values":{"fill":{},"line":{},"symbol":{},"circle":{},"heatmap":{},"fill-extrusion":{},"building":{},"raster":{},"raster-particle":{},"hillshade":{},"model":{},"background":{},"sky":{},"slot":{},"clip":{}}},"metadata":{"type":"*"},"source":{"type":"string"},"source-layer":{"type":"string"},"slot":{"type":"string"},"minzoom":{"type":"number","minimum":0,"maximum":24},"maxzoom":{"type":"number","minimum":0,"maximum":24},"filter":{"type":"filter"},"layout":{"type":"layout"},"paint":{"type":"paint"}},"layout":["layout_clip","layout_fill","layout_line","layout_circle","layout_heatmap","layout_fill-extrusion","layout_building","layout_symbol","layout_raster","layout_raster-particle","layout_hillshade","layout_background","layout_sky","layout_model"],"layout_background":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_sky":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_model":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"model-id":{"type":"string","default":"","property-type":"data-driven","expression":{"parameters":["zoom","feature"]}}},"layout_clip":{"clip-layer-types":{"type":"array","value":"enum","values":{"model":1,"symbol":1},"default":[],"expression":{}},"clip-layer-scope":{"type":"array","value":"string","default":[],"expression":{}}},"layout_fill":{"fill-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-base":1,"hd-road-markup":1},"default":"none","expression":{}},"fill-construct-bridge-guard-rail":{"type":"boolean","default":"true","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"}},"layout_circle":{"circle-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"circle-elevation-reference":{"type":"enum","values":{"none":1,"hd-road-markup":1},"default":"none","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_heatmap":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_fill-extrusion":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"fill-extrusion-edge-radius":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}}},"layout_building":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"building-roof-shape":{"type":"enum","values":{"flat":1,"hipped":1,"gabled":1,"parapet":1,"mansard":1,"skillion":1,"pyramidal":1},"default":"flat","expression":{"parameters":["feature"]},"property-type":"data-driven"},"building-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"},"building-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{},"property-type":"data-driven"}},"layout_line":{"line-cap":{"type":"enum","values":{"butt":1,"round":1,"square":1},"default":"butt","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-join":{"type":"enum","values":{"bevel":1,"round":1,"miter":1,"none":1},"default":"miter","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-miter-limit":{"type":"number","default":2,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-round-limit":{"type":"number","default":1.05,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-z-offset":{"type":"number","default":0,"expression":{"parameters":["zoom","feature","line-progress"]},"property-type":"data-driven"},"line-elevation-reference":{"type":"enum","values":{"none":1,"sea":1,"ground":1,"hd-road-markup":1},"default":"none","expression":{}},"line-cross-slope":{"type":"number","expression":{}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}},"line-width-unit":{"type":"enum","values":{"pixels":1,"meters":1},"default":"pixels","expression":{"parameters":["zoom"]}}},"layout_symbol":{"symbol-placement":{"type":"enum","values":{"point":1,"line":1,"line-center":1},"default":"point","expression":{"parameters":["zoom"]}},"symbol-spacing":{"type":"number","default":250,"minimum":1,"expression":{"interpolated":true,"parameters":["zoom"]}},"symbol-avoid-edges":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-sort-key":{"type":"number","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"symbol-z-order":{"type":"enum","values":{"auto":1,"viewport-y":1,"source":1},"default":"auto","expression":{"parameters":["zoom"]}},"symbol-z-elevate":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"symbol-elevation-reference":{"type":"enum","values":{"sea":1,"ground":1,"hd-road-markup":1},"default":"ground","expression":{"parameters":["zoom"]}},"icon-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"icon-size":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"icon-text-fit":{"type":"enum","values":{"none":1,"width":1,"height":1,"both":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-text-fit-padding":{"type":"array","value":"number","length":4,"default":[0,0,0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-image":{"type":"resolvedImage","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-keep-upright":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"icon-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"icon-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-rotation-alignment":{"type":"enum","values":{"map":1,"viewport":1,"auto":1},"default":"auto","expression":{"parameters":["zoom"]}},"text-field":{"type":"formatted","default":"","tokens":true,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-font":{"type":"array","value":"string","default":["Open Sans Regular","Arial Unicode MS Regular"],"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size":{"type":"number","default":16,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-size-scale-range":{"type":"array","value":"number","length":2,"default":[0.8,2],"minimum":0.1,"maximum":10,"expression":{}},"text-max-width":{"type":"number","default":10,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-line-height":{"type":"number","default":1.2,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-letter-spacing":{"type":"number","default":0,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-justify":{"type":"enum","values":{"auto":1,"left":1,"center":1,"right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-radial-offset":{"type":"number","default":0,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["zoom","feature"]}},"text-variable-anchor":{"type":"array","value":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"expression":{"parameters":["zoom"]}},"text-anchor":{"type":"enum","values":{"center":1,"left":1,"right":1,"top":1,"bottom":1,"top-left":1,"top-right":1,"bottom-left":1,"bottom-right":1},"default":"center","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-max-angle":{"type":"number","default":45,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-writing-mode":{"type":"array","value":"enum","values":{"horizontal":1,"vertical":1},"expression":{"parameters":["zoom"]}},"text-rotate":{"type":"number","default":0,"period":360,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-padding":{"type":"number","default":2,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-keep-upright":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"text-transform":{"type":"enum","values":{"none":1,"uppercase":1,"lowercase":1},"default":"none","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-offset":{"type":"array","value":"number","length":2,"default":[0,0],"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"text-allow-overlap":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-ignore-placement":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"text-optional":{"type":"boolean","default":false,"expression":{"parameters":["zoom"]}},"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_raster-particle":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"layout_hillshade":{"visibility":{"type":"enum","values":{"visible":1,"none":1},"default":"visible","expression":{}}},"filter":{"type":"array","value":"*"},"filter_symbol":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature","pitch","distance-from-center"]}},"filter_fill":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_hillshade":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_raster-particle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_clip":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_model":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_line":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_circle":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_fill-extrusion":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_building":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_heatmap":{"type":"boolean","default":false,"property-type":"data-driven","expression":{"parameters":["zoom","feature"]}},"filter_operator":{"type":"enum","values":{"==":1,"!=":1,">":1,">=":1,"<":1,"<=":1,"in":1,"!in":1,"all":1,"any":1,"none":1,"has":1,"!has":1}},"geometry_type":{"type":"enum","values":{"Point":1,"LineString":1,"Polygon":1}},"function":{"expression":{"type":"expression"},"stops":{"type":"array","value":"function_stop"},"base":{"type":"number","default":1,"minimum":0},"property":{"type":"string","default":"$zoom"},"type":{"type":"enum","values":{"identity":1,"exponential":1,"interval":1,"categorical":1},"default":"exponential"},"colorSpace":{"type":"enum","values":{"rgb":1,"lab":1,"hcl":1},"default":"rgb"},"default":{"type":"*"}},"function_stop":{"type":"array","minimum":0,"maximum":24,"value":["number","color"],"length":2},"expression":{"type":"array","value":"*","minimum":1},"fog":{"range":{"type":"array","default":[0.5,10],"minimum":-20,"maximum":20,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"high-color":{"type":"color","default":"#245cdf","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"space-color":{"type":"color","default":["interpolate",["linear"],["zoom"],4,"#010b19",7,"#367ab9"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"horizon-blend":{"type":"number","default":["interpolate",["linear"],["zoom"],4,0.2,7,0.1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"star-intensity":{"type":"number","default":["interpolate",["linear"],["zoom"],5,0.35,6,0],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vertical-range":{"type":"array","default":[0,0],"minimum":0,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}}},"snow":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.85],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.3],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","default":0.4,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,50],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"flake-size":{"type":"number","default":0.71,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"rain":{"density":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,0.5],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#03113d",0.3,"#a8adbc"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"opacity":{"type":"number","default":["interpolate",["linear"],["measure-light","brightness"],0,0.88,1,0.7],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette":{"type":"number","default":["interpolate",["linear"],["zoom"],11,0,13,1],"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"vignette-color":{"type":"color","default":["interpolate",["linear"],["measure-light","brightness"],0,"#001736",0.3,"#464646"],"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"center-thinning":{"type":"number","default":0.57,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true},"direction":{"type":"array","default":[0,80],"minimum":0,"maximum":360,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"droplet-size":{"type":"array","default":[2.6,18.2],"minimum":0,"maximum":50,"length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true}},"distortion-strength":{"type":"number","default":0.7,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"],"relaxZoomRestriction":true},"transition":true}},"camera":{"camera-projection":{"type":"enum","values":{"perspective":1,"orthographic":1},"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]},"default":"perspective"}},"colorTheme":{"data":{"type":"string","expression":{}}},"indoor":{"floorplanFeaturesetId":{"type":"string","expression":{}},"buildingFeaturesetId":{"type":"string","expression":{}}},"light":{"anchor":{"type":"enum","default":"viewport","values":{"map":1,"viewport":1},"expression":{"parameters":["zoom"]}},"position":{"type":"array","default":[1.15,210,30],"length":3,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"color":{"type":"color","default":"#ffffff","expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"intensity":{"type":"number","default":0.5,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"projection":{"name":{"type":"enum","values":{"albers":1,"equalEarth":1,"equirectangular":1,"lambertConformalConic":1,"mercator":1,"naturalEarth":1,"winkelTripel":1,"globe":1},"default":"mercator"},"center":{"type":"array","length":2,"value":"number","minimum":[-180,-90],"maximum":[180,90]},"parallels":{"type":"array","length":2,"value":"number","minimum":[-90,-90],"maximum":[90,90]}},"terrain":{"source":{"type":"string"},"exaggeration":{"type":"number","default":1,"minimum":0,"maximum":1000,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint":["paint_fill","paint_line","paint_circle","paint_heatmap","paint_fill-extrusion","paint_building","paint_symbol","paint_raster","paint_raster-particle","paint_hillshade","paint_background","paint_sky","paint_model"],"paint_fill":{"fill-antialias":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-outline-color":{"type":"color","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"fill-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-bridge-guard-rail-color":{"type":"color","default":"rgba(241, 236, 225, 255)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"},"fill-tunnel-structure-color":{"type":"color","default":"rgba(241, 236, 225, 255)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature"]},"property-type":"data-driven"}},"paint_fill-extrusion":{"fill-extrusion-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"fill-extrusion-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"fill-extrusion-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"fill-extrusion-height":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-base":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"fill-extrusion-height-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"flat"},"fill-extrusion-base-alignment":{"type":"enum","values":{"terrain":1,"flat":1},"default":"terrain"},"fill-extrusion-vertical-gradient":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-ambient-occlusion-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-wall-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"fill-extrusion-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-flood-light-color":{"type":"color","default":"#ffffff","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"fill-extrusion-flood-light-wall-radius":{"property-type":"data-driven","type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-radius":{"property-type":"data-driven","type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state"]}},"fill-extrusion-flood-light-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"fill-extrusion-rounded-roof":{"type":"boolean","default":true,"expression":{"parameters":["zoom"]}},"fill-extrusion-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"fill-extrusion-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"fill-extrusion-line-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"fill-extrusion-cast-shadows":{"type":"boolean","default":true}},"paint_building":{"building-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-ambient-occlusion-wall-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-intensity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-radius":{"type":"number","default":3,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"building-ambient-occlusion-ground-attenuation":{"type":"number","default":0.69,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-vertical-scale":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"building-cast-shadows":{"type":"boolean","default":true},"building-color":{"type":"color","default":"rgba(193, 154, 127, 1)","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"property-type":"data-driven"},"building-emissive-strength":{"type":"number","default":0,"minimum":0,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"property-type":"data-driven"}},"paint_line":{"line-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"line-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"line-width":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light","line-progress"]},"property-type":"data-driven"},"line-gap-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-offset":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"line-dasharray":{"type":"array","value":"number","minimum":0,"expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom","feature"]},"property-type":"data-driven"},"line-pattern-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"line-gradient":{"type":"color","expression":{"interpolated":true,"parameters":["line-progress"]}},"line-trim-offset":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1]},"line-trim-fade-range":{"type":"array","value":"number","length":2,"default":[0,0],"minimum":[0,0],"maximum":[1,1],"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-trim-color":{"type":"color","default":"transparent","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"line-border-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-border-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state"]},"property-type":"data-driven"},"line-occlusion-opacity":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true}},"paint_circle":{"circle-radius":{"type":"number","default":5,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-blur":{"type":"number","default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"circle-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-scale":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"circle-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"circle-stroke-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-stroke-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"circle-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_heatmap":{"heatmap-radius":{"type":"number","default":30,"minimum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-weight":{"type":"number","default":1,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"heatmap-intensity":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"heatmap-color":{"type":"color","default":["interpolate",["linear"],["heatmap-density"],0,"rgba(0, 0, 255, 0)",0.1,"royalblue",0.3,"cyan",0.5,"lime",0.7,"yellow",1,"red"],"expression":{"interpolated":true,"parameters":["heatmap-density"]}},"heatmap-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_symbol":{"icon-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"text-emissive-strength":{"type":"number","default":1,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light","feature-state"]},"property-type":"data-driven"},"icon-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"icon-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"icon-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-image-cross-fade":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]},"transition":true},"text-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-occlusion-opacity":{"type":"number","minimum":0,"maximum":1,"default":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-color":{"type":"color","default":"#000000","transition":true,"overridable":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-color":{"type":"color","default":"rgba(0, 0, 0, 0)","transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-width":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-halo-blur":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature","feature-state","measure-light"]},"property-type":"data-driven"},"text-translate":{"type":"array","value":"number","length":2,"default":[0,0],"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"text-translate-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":["zoom"]}},"icon-color-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"expression":{}},"icon-color-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"icon-color-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{}},"symbol-z-offset":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","feature"]},"property-type":"data-driven"}},"paint_raster":{"raster-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-value"]}},"raster-color-mix":{"type":"array","default":[0.2126,0.7152,0.0722,0],"length":4,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-color-range":{"type":"array","length":2,"value":"number","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-hue-rotate":{"type":"number","default":0,"period":360,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-min":{"type":"number","default":0,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-brightness-max":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-saturation":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-contrast":{"type":"number","default":0,"minimum":-1,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-resampling":{"type":"enum","values":{"linear":1,"nearest":1},"default":"linear","expression":{"parameters":["zoom"]}},"raster-fade-duration":{"type":"number","default":300,"minimum":0,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"raster-array-band":{"type":"string"},"raster-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_raster-particle":{"raster-particle-array-band":{"type":"string"},"raster-particle-count":{"type":"number","default":512,"minimum":1},"raster-particle-color":{"type":"color","expression":{"interpolated":true,"parameters":["raster-particle-speed"]}},"raster-particle-max-speed":{"type":"number","default":1,"minimum":1},"raster-particle-speed-factor":{"type":"number","default":0.2,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-fade-opacity-factor":{"type":"number","default":0.98,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"raster-particle-reset-rate-factor":{"type":"number","default":0.8,"minimum":0,"maximum":1},"raster-particle-elevation":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_hillshade":{"hillshade-illumination-direction":{"type":"number","default":335,"minimum":0,"maximum":359,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-illumination-anchor":{"type":"enum","values":{"map":1,"viewport":1},"default":"viewport","expression":{"parameters":["zoom"]}},"hillshade-exaggeration":{"type":"number","default":0.5,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"hillshade-shadow-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-highlight-color":{"type":"color","default":"#FFFFFF","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-accent-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}},"hillshade-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_background":{"background-pitch-alignment":{"type":"enum","values":{"map":1,"viewport":1},"default":"map","expression":{"parameters":[]}},"background-color":{"type":"color","default":"#000000","transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-pattern":{"type":"resolvedImage","expression":{"parameters":["zoom"]}},"background-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}},"background-emissive-strength":{"type":"number","default":0,"minimum":0,"transition":true,"expression":{"interpolated":true,"parameters":["zoom","measure-light"]}}},"paint_sky":{"sky-type":{"type":"enum","values":{"gradient":1,"atmosphere":1},"default":"atmosphere","expression":{"parameters":["zoom"]}},"sky-atmosphere-sun":{"type":"array","value":"number","length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-atmosphere-sun-intensity":{"type":"number","default":10,"minimum":0,"maximum":100},"sky-gradient-center":{"type":"array","value":"number","default":[0,0],"length":2,"minimum":[0,0],"maximum":[360,180],"expression":{"parameters":["zoom"]}},"sky-gradient-radius":{"type":"number","default":90,"minimum":0,"maximum":180,"expression":{"parameters":["zoom"]}},"sky-gradient":{"type":"color","default":["interpolate",["linear"],["sky-radial-progress"],0.8,"#87ceeb",1,"white"],"expression":{"interpolated":true,"parameters":["sky-radial-progress"]}},"sky-atmosphere-halo-color":{"type":"color","default":"white"},"sky-atmosphere-color":{"type":"color","default":"white"},"sky-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["zoom"]}}},"paint_model":{"model-opacity":{"type":"number","default":1,"minimum":0,"maximum":1,"transition":true,"expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"property-type":"data-driven"},"model-rotation":{"type":"array","value":"number","length":3,"default":[0,0,0],"period":360,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-scale":{"type":"array","value":"number","length":3,"default":[1,1,1],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-translation":{"type":"array","value":"number","length":3,"default":[0,0,0],"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","zoom"]},"transition":true},"model-color":{"type":"color","default":"#ffffff","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light","zoom"]},"transition":true},"model-color-mix-intensity":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-type":{"type":"enum","values":{"common-3d":1,"location-indicator":1},"default":"common-3d"},"model-cast-shadows":{"type":"boolean","default":true},"model-receive-shadows":{"type":"boolean","default":true},"model-ambient-occlusion-intensity":{"type":"number","default":1,"minimum":0,"maximum":1,"expression":{"interpolated":true,"parameters":["zoom"]},"transition":true},"model-emissive-strength":{"type":"number","property-type":"data-driven","default":0,"minimum":0,"maximum":5,"expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-roughness":{"type":"number","default":1,"minimum":0,"maximum":1,"property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state"]},"transition":true},"model-height-based-emissive-strength-multiplier":{"type":"array","default":[1,1,1,1,0],"length":5,"value":"number","property-type":"data-driven","expression":{"interpolated":true,"parameters":["feature","feature-state","measure-light"]},"transition":true},"model-cutoff-fade-range":{"type":"number","default":0,"minimum":0,"maximum":1,"expression":{}},"model-front-cutoff":{"type":"array","value":"number","expression":{"interpolated":true,"parameters":["zoom"]},"length":3,"default":[0,0,1],"minimum":[0,0,0],"maximum":[1,1,1]}},"transition":{"duration":{"type":"number","default":300,"minimum":0},"delay":{"type":"number","default":0,"minimum":0}},"promoteId":{"*":{"type":"*"}}}');
          function Po(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function To(t2) {
            if (Array.isArray(t2)) return t2.map(To);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              const e2 = {};
              for (const r2 in t2) e2[r2] = To(t2[r2]);
              return e2;
            }
            return Po(t2);
          }
          function Bo(t2) {
            if (true === t2 || false === t2) return true;
            if (!Array.isArray(t2) || 0 === t2.length) return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (const e2 of t2.slice(1)) if (!Bo(e2) && "boolean" != typeof e2) return false;
                return true;
              default:
                return true;
            }
          }
          function Vo(t2, e2 = "", r2 = null, n2 = "fill") {
            if (null == t2) return { filter: () => true, needGeometry: false, needFeature: false };
            Bo(t2) || (t2 = Uo(t2));
            const i2 = t2;
            let s2 = true;
            try {
              s2 = function(t3) {
                if (!Fo(t3)) return t3;
                let e3 = To(t3);
                return Do(e3), e3 = Co(e3), e3;
              }(i2);
            } catch (t3) {
              console.warn(`Failed to extract static filter. Filter will continue working, but at higher memory usage and slower framerate.
This is most likely a bug, please report this via https://github.com/mapbox/mapbox-gl-js/issues/new?assignees=&labels=&template=Bug_report.md
and paste the contents of this message in the report.
Thank you!
Filter Expression:
${JSON.stringify(i2, null, 2)}
        `);
            }
            let o2 = null, a2 = null;
            if ("background" !== n2 && "sky" !== n2 && "slot" !== n2) {
              a2 = Eo[`filter_${n2}`];
              const t3 = Ts(s2, a2, e2, r2);
              if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              o2 = (e3, r3, n3) => t3.value.evaluate(e3, r3, {}, n3);
            }
            let l2 = null, u5 = null;
            if (s2 !== i2) {
              const t3 = Ts(i2, a2, e2, r2);
              if ("error" === t3.result) throw new Error(t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", "));
              l2 = (e3, r3, n3, i3, s3) => t3.value.evaluate(e3, r3, {}, n3, void 0, void 0, i3, s3), u5 = !hi(t3.value.expression);
            }
            return { filter: o2, dynamicFilter: l2 || void 0, needGeometry: Oo(s2), needFeature: !!u5 };
          }
          function Co(t2) {
            if (!Array.isArray(t2)) return t2;
            const e2 = function(t3) {
              if (Lo.has(t3[0])) {
                for (let e3 = 1; e3 < t3.length; e3++) if (Fo(t3[e3])) return true;
              }
              return t3;
            }(t2);
            return true === e2 ? e2 : e2.map((t3) => Co(t3));
          }
          function Do(t2) {
            let e2 = false;
            const r2 = [];
            if ("case" === t2[0]) {
              for (let n2 = 1; n2 < t2.length - 1; n2 += 2) e2 = e2 || Fo(t2[n2]), r2.push(t2[n2 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("match" === t2[0]) {
              e2 = e2 || Fo(t2[1]);
              for (let e3 = 2; e3 < t2.length - 1; e3 += 2) r2.push(t2[e3 + 1]);
              r2.push(t2[t2.length - 1]);
            } else if ("step" === t2[0]) {
              e2 = e2 || Fo(t2[1]);
              for (let e3 = 1; e3 < t2.length - 1; e3 += 2) r2.push(t2[e3 + 1]);
            }
            e2 && (t2.length = 0, t2.push("any", ...r2));
            for (let e3 = 1; e3 < t2.length; e3++) Do(t2[e3]);
          }
          function Fo(t2) {
            if (!Array.isArray(t2)) return false;
            if ("pitch" === (e2 = t2[0]) || "distance-from-center" === e2) return true;
            var e2;
            for (let e3 = 1; e3 < t2.length; e3++) if (Fo(t2[e3])) return true;
            return false;
          }
          const Lo = /* @__PURE__ */ new Set(["in", "==", "!=", ">", ">=", "<", "<=", "to-boolean"]);
          function Ro(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function Oo(t2) {
            if (!Array.isArray(t2)) return false;
            if ("within" === t2[0] || "distance" === t2[0]) return true;
            for (let e2 = 1; e2 < t2.length; e2++) if (Oo(t2[e2])) return true;
            return false;
          }
          function Uo(t2) {
            if (!t2) return true;
            const e2 = t2[0];
            return t2.length <= 1 ? "any" !== e2 : "==" === e2 ? No(t2[1], t2[2], "==") : "!=" === e2 ? Go(No(t2[1], t2[2], "==")) : "<" === e2 || ">" === e2 || "<=" === e2 || ">=" === e2 ? No(t2[1], t2[2], e2) : "any" === e2 ? (r2 = t2.slice(1), ["any"].concat(r2.map(Uo))) : "all" === e2 ? ["all"].concat(t2.slice(1).map(Uo)) : "none" === e2 ? ["all"].concat(t2.slice(1).map(Uo).map(Go)) : "in" === e2 ? jo(t2[1], t2.slice(2)) : "!in" === e2 ? Go(jo(t2[1], t2.slice(2))) : "has" === e2 ? $o(t2[1]) : "!has" !== e2 || Go($o(t2[1]));
            var r2;
          }
          function No(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return [`filter-type-${r2}`, e2];
              case "$id":
                return [`filter-id-${r2}`, e2];
              default:
                return [`filter-${r2}`, t2, e2];
            }
          }
          function jo(t2, e2) {
            if (0 === e2.length) return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some((t3) => typeof t3 != typeof e2[0]) ? ["filter-in-large", t2, ["literal", e2.sort(Ro)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function $o(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function Go(t2) {
            return ["!", t2];
          }
          const qo = "";
          function Ho(t2, e2) {
            return e2 ? `${t2}${qo}${e2}` : t2;
          }
          const Xo = "-transition", Zo = /* @__PURE__ */ new Set(["fill", "line", "background", "hillshade", "raster"]);
          class Wo extends Qe {
            constructor(t2, e2, r2, n2, i2) {
              if (super(), this.id = t2.id, this.fqid = Ho(this.id, r2), this.type = t2.type, this.scope = r2, this.lut = n2, this.options = i2, this._featureFilter = { filter: () => true, needGeometry: false, needFeature: false }, this._filterCompiled = false, this.configDependencies = /* @__PURE__ */ new Set(), "custom" !== t2.type) {
                if (this.metadata = t2.metadata, this.minzoom = t2.minzoom, this.maxzoom = t2.maxzoom, t2.type && "background" !== t2.type && "sky" !== t2.type && "slot" !== t2.type) {
                  this.source = t2.source, this.sourceLayer = t2["source-layer"], this.filter = t2.filter;
                  const e3 = Ts(this.filter, Eo[`filter_${t2.type}`]);
                  "error" !== e3.result && (this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...e3.value.configDependencies]));
                }
                if (t2.slot && (this.slot = t2.slot), e2.layout && (this._unevaluatedLayout = new wo(e2.layout, this.scope, i2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._unevaluatedLayout.configDependencies])), e2.paint) {
                  this._transitionablePaint = new vo(e2.paint, this.scope, i2);
                  for (const e3 in t2.paint) this.setPaintProperty(e3, t2.paint[e3]);
                  for (const e3 in t2.layout) this.setLayoutProperty(e3, t2.layout[e3]);
                  this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...this._transitionablePaint.configDependencies]), this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new Mo(e2.paint);
                }
              }
            }
            onAdd(t2) {
            }
            onRemove(t2) {
            }
            isDraped(t2) {
              return !this.is3D(true) && Zo.has(this.type);
            }
            getLayoutProperty(t2) {
              return "visibility" === t2 ? this.visibility : this._unevaluatedLayout.getValue(t2);
            }
            setLayoutProperty(t2, e2) {
              if ("custom" === this.type && "visibility" === t2) return void (this.visibility = e2);
              const r2 = this._unevaluatedLayout;
              r2._properties.properties[t2] && (r2.setValue(t2, e2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r2.configDependencies]), "visibility" === t2 && this.possiblyEvaluateVisibility());
            }
            possiblyEvaluateVisibility() {
              this._unevaluatedLayout._values.visibility && (this.visibility = this._unevaluatedLayout._values.visibility.possiblyEvaluate({ zoom: 0 }));
            }
            getPaintProperty(t2) {
              return t2.endsWith(Xo) ? this._transitionablePaint.getTransition(t2.slice(0, -11)) : this._transitionablePaint.getValue(t2);
            }
            setPaintProperty(t2, e2) {
              const r2 = this._transitionablePaint, n2 = r2._properties.properties;
              if (t2.endsWith(Xo)) {
                const i3 = t2.slice(0, -11);
                return n2[i3] && r2.setTransition(i3, e2 || void 0), false;
              }
              if (!n2[t2]) return false;
              const i2 = r2._values[t2], s2 = i2.value.isDataDriven(), o2 = i2.value;
              r2.setValue(t2, e2), this.configDependencies = /* @__PURE__ */ new Set([...this.configDependencies, ...r2.configDependencies]), this._handleSpecialPaintPropertyUpdate(t2);
              const a2 = r2._values[t2].value, l2 = a2.isDataDriven(), u5 = t2.endsWith("pattern") || "line-dasharray" === t2;
              return l2 || s2 || u5 || this._handleOverridablePaintPropertyUpdate(t2, o2, a2);
            }
            _handleSpecialPaintPropertyUpdate(t2) {
            }
            getProgramIds() {
              return null;
            }
            getDefaultProgramParams(t2, e2, r2) {
              return null;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return false;
            }
            isHidden(t2) {
              return !!(this.minzoom && t2 < this.minzoom) || !!(this.maxzoom && t2 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t2) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t2, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t2, e2) {
              this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t2, void 0, e2)), this.paint = this._transitioningPaint.possiblyEvaluate(t2, void 0, e2);
            }
            serialize() {
              return Ut({ id: this.id, type: this.type, slot: this.slot, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() }, (t2, e2) => !(void 0 === t2 || "layout" === e2 && !Object.keys(t2).length || "paint" === e2 && !Object.keys(t2).length));
            }
            is3D(t2) {
              return false;
            }
            hasElevation() {
              return false;
            }
            isSky() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            hasShadowPass() {
              return false;
            }
            canCastShadows() {
              return false;
            }
            hasLightBeamPass() {
              return false;
            }
            cutoffRange() {
              return 0;
            }
            tileCoverLift() {
              return 0;
            }
            resize() {
            }
            isStateDependent() {
              for (const t2 in this.paint._values) {
                const e2 = this.paint.get(t2);
                if (e2 instanceof Ao && gs(e2.property.specification) && ("source" === e2.value.kind || "composite" === e2.value.kind) && e2.value.isStateDependent) return true;
              }
              return false;
            }
            compileFilter(t2) {
              this._filterCompiled || (this._featureFilter = Vo(this.filter, this.scope, t2), this._filterCompiled = true);
            }
            invalidateCompiledFilter() {
              this._filterCompiled = false;
            }
            dynamicFilter() {
              return this._featureFilter.dynamicFilter;
            }
            dynamicFilterNeedsFeature() {
              return this._featureFilter.needFeature;
            }
            getLayerRenderingStats() {
              return this._stats;
            }
            resetLayerRenderingStats(t2) {
              this._stats && ("shadow" === t2.renderPass ? this._stats.numRenderedVerticesInShadowPass = 0 : this._stats.numRenderedVerticesInTransparentPass = 0);
            }
            queryRadius(t2) {
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            }
          }
          const Yo = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class Ko {
            constructor(t2, e2) {
              this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class Jo {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t2, e2) {
              return t2._trim(), e2 && (t2.isTransferred = true, e2.add(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
            }
            static deserialize(t2) {
              const e2 = Object.create(this.prototype);
              return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t2) {
              this.reserve(t2), this.length = t2;
            }
            reserve(t2) {
              if (t2 > this.capacity) {
                this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e2 = this.uint8;
                this._refreshViews(), e2 && this.uint8.set(e2);
              }
            }
            _refreshViews() {
              throw new Error("StructArray#_refreshViews() must be implemented by each concrete StructArray layout");
            }
            emplace(...t2) {
              throw new Error("StructArray#emplace() must be implemented by each concrete StructArray layout");
            }
            emplaceBack(...t2) {
              throw new Error("StructArray#emplaceBack() must be implemented by each concrete StructArray layout");
            }
            destroy() {
              this.int8 = this.uint8 = this.int16 = this.uint16 = this.int32 = this.uint32 = this.float32 = null, this.arrayBuffer = null;
            }
          }
          function Qo(t2, e2 = 1) {
            let r2 = 0, n2 = 0;
            return { members: t2.map((t3) => {
              const i2 = Yo[t3.type].BYTES_PER_ELEMENT, s2 = r2 = ta(r2, Math.max(e2, i2)), o2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * o2, { name: t3.name, type: t3.type, components: o2, offset: s2 };
            }), size: ta(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function ta(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          class ea2 extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.int16[n2 + 0] = e2, this.int16[n2 + 1] = r2, t2;
            }
          }
          ea2.prototype.bytesPerElement = 4, js(ea2, "StructArrayLayout2i4");
          class ra extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          ra.prototype.bytesPerElement = 6, js(ra, "StructArrayLayout3i6");
          class na extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.int16[s2 + 0] = e2, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, t2;
            }
          }
          na.prototype.bytesPerElement = 8, js(na, "StructArrayLayout4i8");
          class ia extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.float32[1 * t2 + 0] = e2, t2;
            }
          }
          ia.prototype.bytesPerElement = 4, js(ia, "StructArrayLayout1f4");
          class sa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 4 * t2, s2 = 2 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.float32[s2 + 1] = n2, t2;
            }
          }
          sa.prototype.bytesPerElement = 8, js(sa, "StructArrayLayout2i1f8");
          class oa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 4 * t2;
              return this.int16[i2 + 0] = e2, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t2;
            }
          }
          oa.prototype.bytesPerElement = 8, js(oa, "StructArrayLayout3i8");
          class aa2 extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const o2 = 5 * t2;
              return this.int16[o2 + 0] = e2, this.int16[o2 + 1] = r2, this.int16[o2 + 2] = n2, this.int16[o2 + 3] = i2, this.int16[o2 + 4] = s2, t2;
            }
          }
          aa2.prototype.bytesPerElement = 10, js(aa2, "StructArrayLayout5i10");
          class la extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2, o2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = 6 * t2, u5 = 12 * t2, c2 = 3 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.uint8[u5 + 4] = n2, this.uint8[u5 + 5] = i2, this.uint8[u5 + 6] = s2, this.uint8[u5 + 7] = o2, this.float32[c2 + 2] = a2, t2;
            }
          }
          la.prototype.bytesPerElement = 12, js(la, "StructArrayLayout2i4ub1f12");
          class ua extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.float32[i2 + 0] = e2, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t2;
            }
          }
          ua.prototype.bytesPerElement = 12, js(ua, "StructArrayLayout3f12");
          class ca3 extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const o2 = 6 * t2, a2 = 3 * t2;
              return this.uint16[o2 + 0] = e2, this.uint16[o2 + 1] = r2, this.uint16[o2 + 2] = n2, this.uint16[o2 + 3] = i2, this.float32[a2 + 2] = s2, t2;
            }
          }
          ca3.prototype.bytesPerElement = 12, js(ca3, "StructArrayLayout4ui1f12");
          class ha extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.uint16[s2 + 0] = e2, this.uint16[s2 + 1] = r2, this.uint16[s2 + 2] = n2, this.uint16[s2 + 3] = i2, t2;
            }
          }
          ha.prototype.bytesPerElement = 8, js(ha, "StructArrayLayout4ui8");
          class pa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = 6 * t2;
              return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, this.int16[a2 + 4] = s2, this.int16[a2 + 5] = o2, t2;
            }
          }
          pa.prototype.bytesPerElement = 12, js(pa, "StructArrayLayout6i12");
          class fa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2) {
              const p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2) {
              const f2 = 12 * t2;
              return this.int16[f2 + 0] = e2, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = s2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = a2, this.uint16[f2 + 7] = l2, this.int16[f2 + 8] = u5, this.int16[f2 + 9] = c2, this.int16[f2 + 10] = h2, this.int16[f2 + 11] = p2, t2;
            }
          }
          fa.prototype.bytesPerElement = 24, js(fa, "StructArrayLayout4i4ui4i24");
          class da2 extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = 10 * t2, l2 = 5 * t2;
              return this.int16[a2 + 0] = e2, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = o2, t2;
            }
          }
          da2.prototype.bytesPerElement = 20, js(da2, "StructArrayLayout3i3f20");
          class ma extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 4 * t2;
              return this.float32[s2 + 0] = e2, this.float32[s2 + 1] = r2, this.float32[s2 + 2] = n2, this.float32[s2 + 3] = i2, t2;
            }
          }
          ma.prototype.bytesPerElement = 16, js(ma, "StructArrayLayout4f16");
          class ya extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint32[1 * t2 + 0] = e2, t2;
            }
          }
          ya.prototype.bytesPerElement = 4, js(ya, "StructArrayLayout1ul4");
          class ga extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.uint16[n2 + 0] = e2, this.uint16[n2 + 1] = r2, t2;
            }
          }
          ga.prototype.bytesPerElement = 4, js(ga, "StructArrayLayout2ui4");
          class xa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2) {
              const f2 = this.length;
              return this.resize(f2 + 1), this.emplace(f2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2) {
              const d2 = 20 * t2, m2 = 10 * t2;
              return this.int16[d2 + 0] = e2, this.int16[d2 + 1] = r2, this.int16[d2 + 2] = n2, this.int16[d2 + 3] = i2, this.int16[d2 + 4] = s2, this.float32[m2 + 3] = o2, this.float32[m2 + 4] = a2, this.float32[m2 + 5] = l2, this.float32[m2 + 6] = u5, this.int16[d2 + 14] = c2, this.uint32[m2 + 8] = h2, this.uint16[d2 + 18] = p2, this.uint16[d2 + 19] = f2, t2;
            }
          }
          xa.prototype.bytesPerElement = 40, js(xa, "StructArrayLayout5i4f1i1ul2ui40");
          class va extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2, o2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = 8 * t2;
              return this.int16[l2 + 0] = e2, this.int16[l2 + 1] = r2, this.int16[l2 + 2] = n2, this.int16[l2 + 4] = i2, this.int16[l2 + 5] = s2, this.int16[l2 + 6] = o2, this.int16[l2 + 7] = a2, t2;
            }
          }
          va.prototype.bytesPerElement = 16, js(va, "StructArrayLayout3i2i2i16");
          class ba extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const o2 = 4 * t2, a2 = 8 * t2;
              return this.float32[o2 + 0] = e2, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.int16[a2 + 6] = i2, this.int16[a2 + 7] = s2, t2;
            }
          }
          ba.prototype.bytesPerElement = 16, js(ba, "StructArrayLayout2f1f2i16");
          class _a extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2) {
              const o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t2, e2, r2, n2, i2, s2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = 20 * t2, l2 = 5 * t2;
              return this.uint8[a2 + 0] = e2, this.uint8[a2 + 1] = r2, this.float32[l2 + 1] = n2, this.float32[l2 + 2] = i2, this.float32[l2 + 3] = s2, this.float32[l2 + 4] = o2, t2;
            }
          }
          _a.prototype.bytesPerElement = 20, js(_a, "StructArrayLayout2ub4f20");
          class wa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2) {
              const n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t2, e2, r2);
            }
            emplace(t2, e2, r2, n2) {
              const i2 = 3 * t2;
              return this.uint16[i2 + 0] = e2, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t2;
            }
          }
          wa.prototype.bytesPerElement = 6, js(wa, "StructArrayLayout3ui6");
          class Aa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2) {
              const _2 = this.length;
              return this.resize(_2 + 1), this.emplace(_2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2, _2) {
              const w2 = 30 * t2, A2 = 15 * t2, M2 = 60 * t2;
              return this.int16[w2 + 0] = e2, this.int16[w2 + 1] = r2, this.int16[w2 + 2] = n2, this.float32[A2 + 2] = i2, this.float32[A2 + 3] = s2, this.uint16[w2 + 8] = o2, this.uint16[w2 + 9] = a2, this.uint32[A2 + 5] = l2, this.uint32[A2 + 6] = u5, this.uint32[A2 + 7] = c2, this.uint16[w2 + 16] = h2, this.uint16[w2 + 17] = p2, this.uint16[w2 + 18] = f2, this.float32[A2 + 10] = d2, this.float32[A2 + 11] = m2, this.uint8[M2 + 48] = y2, this.uint8[M2 + 49] = g2, this.uint8[M2 + 50] = x2, this.uint32[A2 + 13] = v3, this.int16[w2 + 28] = b2, this.uint8[M2 + 58] = _2, t2;
            }
          }
          Aa.prototype.bytesPerElement = 60, js(Aa, "StructArrayLayout3i2f2ui3ul3ui2f3ub1ul1i1ub60");
          class Ma extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2, _2, w2, A2, M2, I2, S2, z2, k2, E2, P2, T2, B3) {
              const V2 = this.length;
              return this.resize(V2 + 1), this.emplace(V2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2, _2, w2, A2, M2, I2, S2, z2, k2, E2, P2, T2, B3);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3, b2, _2, w2, A2, M2, I2, S2, z2, k2, E2, P2, T2, B3, V2) {
              const C3 = 20 * t2, D3 = 40 * t2, F2 = 80 * t2;
              return this.float32[C3 + 0] = e2, this.float32[C3 + 1] = r2, this.int16[D3 + 4] = n2, this.int16[D3 + 5] = i2, this.int16[D3 + 6] = s2, this.int16[D3 + 7] = o2, this.int16[D3 + 8] = a2, this.int16[D3 + 9] = l2, this.int16[D3 + 10] = u5, this.int16[D3 + 11] = c2, this.int16[D3 + 12] = h2, this.uint16[D3 + 13] = p2, this.uint16[D3 + 14] = f2, this.uint16[D3 + 15] = d2, this.uint16[D3 + 16] = m2, this.uint16[D3 + 17] = y2, this.uint16[D3 + 18] = g2, this.uint16[D3 + 19] = x2, this.uint16[D3 + 20] = v3, this.uint16[D3 + 21] = b2, this.uint16[D3 + 22] = _2, this.uint16[D3 + 23] = w2, this.uint16[D3 + 24] = A2, this.uint16[D3 + 25] = M2, this.uint16[D3 + 26] = I2, this.uint16[D3 + 27] = S2, this.uint32[C3 + 14] = z2, this.float32[C3 + 15] = k2, this.float32[C3 + 16] = E2, this.float32[C3 + 17] = P2, this.float32[C3 + 18] = T2, this.uint8[F2 + 76] = B3, this.uint16[D3 + 39] = V2, t2;
            }
          }
          Ma.prototype.bytesPerElement = 80, js(Ma, "StructArrayLayout2f9i15ui1ul4f1ub1ui80");
          class Ia extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2) {
              const s2 = this.length;
              return this.resize(s2 + 1), this.emplace(s2, t2, e2, r2, n2, i2);
            }
            emplace(t2, e2, r2, n2, i2, s2) {
              const o2 = 5 * t2;
              return this.float32[o2 + 0] = e2, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.float32[o2 + 3] = i2, this.float32[o2 + 4] = s2, t2;
            }
          }
          Ia.prototype.bytesPerElement = 20, js(Ia, "StructArrayLayout5f20");
          class Sa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2, o2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = 7 * t2;
              return this.float32[l2 + 0] = e2, this.float32[l2 + 1] = r2, this.float32[l2 + 2] = n2, this.float32[l2 + 3] = i2, this.float32[l2 + 4] = s2, this.float32[l2 + 5] = o2, this.float32[l2 + 6] = a2, t2;
            }
          }
          Sa.prototype.bytesPerElement = 28, js(Sa, "StructArrayLayout7f28");
          class za extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2) {
              const h2 = this.length;
              return this.resize(h2 + 1), this.emplace(h2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2) {
              const p2 = 11 * t2;
              return this.float32[p2 + 0] = e2, this.float32[p2 + 1] = r2, this.float32[p2 + 2] = n2, this.float32[p2 + 3] = i2, this.float32[p2 + 4] = s2, this.float32[p2 + 5] = o2, this.float32[p2 + 6] = a2, this.float32[p2 + 7] = l2, this.float32[p2 + 8] = u5, this.float32[p2 + 9] = c2, this.float32[p2 + 10] = h2, t2;
            }
          }
          za.prototype.bytesPerElement = 44, js(za, "StructArrayLayout11f44");
          class ka extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
              const u5 = this.length;
              return this.resize(u5 + 1), this.emplace(u5, t2, e2, r2, n2, i2, s2, o2, a2, l2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) {
              const c2 = 9 * t2;
              return this.float32[c2 + 0] = e2, this.float32[c2 + 1] = r2, this.float32[c2 + 2] = n2, this.float32[c2 + 3] = i2, this.float32[c2 + 4] = s2, this.float32[c2 + 5] = o2, this.float32[c2 + 6] = a2, this.float32[c2 + 7] = l2, this.float32[c2 + 8] = u5, t2;
            }
          }
          ka.prototype.bytesPerElement = 36, js(ka, "StructArrayLayout9f36");
          class Ea extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2) {
              const r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t2, e2);
            }
            emplace(t2, e2, r2) {
              const n2 = 2 * t2;
              return this.float32[n2 + 0] = e2, this.float32[n2 + 1] = r2, t2;
            }
          }
          Ea.prototype.bytesPerElement = 8, js(Ea, "StructArrayLayout2f8");
          class Pa extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2) {
              const i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t2, e2, r2, n2);
            }
            emplace(t2, e2, r2, n2, i2) {
              const s2 = 6 * t2;
              return this.uint32[3 * t2 + 0] = e2, this.uint16[s2 + 2] = r2, this.uint16[s2 + 3] = n2, this.uint16[s2 + 4] = i2, t2;
            }
          }
          Pa.prototype.bytesPerElement = 12, js(Pa, "StructArrayLayout1ul3ui12");
          class Ta extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint16[1 * t2 + 0] = e2, t2;
            }
          }
          Ta.prototype.bytesPerElement = 2, js(Ta, "StructArrayLayout1ui2");
          class Ba extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2) {
              const y2 = this.length;
              return this.resize(y2 + 1), this.emplace(y2, t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2) {
              const g2 = 16 * t2;
              return this.float32[g2 + 0] = e2, this.float32[g2 + 1] = r2, this.float32[g2 + 2] = n2, this.float32[g2 + 3] = i2, this.float32[g2 + 4] = s2, this.float32[g2 + 5] = o2, this.float32[g2 + 6] = a2, this.float32[g2 + 7] = l2, this.float32[g2 + 8] = u5, this.float32[g2 + 9] = c2, this.float32[g2 + 10] = h2, this.float32[g2 + 11] = p2, this.float32[g2 + 12] = f2, this.float32[g2 + 13] = d2, this.float32[g2 + 14] = m2, this.float32[g2 + 15] = y2, t2;
            }
          }
          Ba.prototype.bytesPerElement = 64, js(Ba, "StructArrayLayout16f64");
          class Va extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t2, e2, r2, n2, i2, s2, o2);
            }
            emplace(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = 10 * t2, u5 = 5 * t2;
              return this.uint16[l2 + 0] = e2, this.uint16[l2 + 1] = r2, this.uint16[l2 + 2] = n2, this.uint16[l2 + 3] = i2, this.float32[u5 + 2] = s2, this.float32[u5 + 3] = o2, this.float32[u5 + 4] = a2, t2;
            }
          }
          Va.prototype.bytesPerElement = 20, js(Va, "StructArrayLayout4ui3f20");
          class Ca extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.int16[1 * t2 + 0] = e2, t2;
            }
          }
          Ca.prototype.bytesPerElement = 2, js(Ca, "StructArrayLayout1i2");
          class Da extends Jo {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer);
            }
            emplaceBack(t2) {
              const e2 = this.length;
              return this.resize(e2 + 1), this.emplace(e2, t2);
            }
            emplace(t2, e2) {
              return this.uint8[1 * t2 + 0] = e2, t2;
            }
          }
          Da.prototype.bytesPerElement = 1, js(Da, "StructArrayLayout1ub1");
          class Fa extends Ko {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get tileAnchorY() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get x1() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get y1() {
              return this._structArray.float32[this._pos4 + 4];
            }
            get x2() {
              return this._structArray.float32[this._pos4 + 5];
            }
            get y2() {
              return this._structArray.float32[this._pos4 + 6];
            }
            get padding() {
              return this._structArray.int16[this._pos2 + 14];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 8];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
          }
          Fa.prototype.size = 40;
          class La extends xa {
            get(t2) {
              return new Fa(this, t2);
            }
          }
          js(La, "CollisionBoxArray");
          class Ra extends Ko {
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 2];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 3];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 5];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 6];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 7];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 10];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 11];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 48];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 49];
            }
            set placedOrientation(t2) {
              this._structArray.uint8[this._pos1 + 49] = t2;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 50];
            }
            set hidden(t2) {
              this._structArray.uint8[this._pos1 + 50] = t2;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 13];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 13] = t2;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 28];
            }
            get flipState() {
              return this._structArray.uint8[this._pos1 + 58];
            }
            set flipState(t2) {
              this._structArray.uint8[this._pos1 + 58] = t2;
            }
          }
          Ra.prototype.size = 60;
          class Oa extends Aa {
            get(t2) {
              return new Ra(this, t2);
            }
          }
          js(Oa, "PlacedSymbolArray");
          class Ua extends Ko {
            get tileAnchorX() {
              return this._structArray.float32[this._pos4 + 0];
            }
            get tileAnchorY() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get projectedAnchorX() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get projectedAnchorY() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get projectedAnchorZ() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 8];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 9];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 10];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 11];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 12];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 23];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 24];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 25];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 26];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 27];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 14];
            }
            set crossTileID(t2) {
              this._structArray.uint32[this._pos4 + 14] = t2;
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 15];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 16];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 17];
            }
            get zOffset() {
              return this._structArray.float32[this._pos4 + 18];
            }
            set zOffset(t2) {
              this._structArray.float32[this._pos4 + 18] = t2;
            }
            get hasIconTextFit() {
              return this._structArray.uint8[this._pos1 + 76];
            }
            get elevationFeatureIndex() {
              return this._structArray.uint16[this._pos2 + 39];
            }
          }
          Ua.prototype.size = 80;
          class Na extends Ma {
            get(t2) {
              return new Ua(this, t2);
            }
          }
          js(Na, "SymbolInstanceArray");
          class ja extends ia {
            getoffsetX(t2) {
              return this.float32[1 * t2 + 0];
            }
          }
          js(ja, "GlyphOffsetArray");
          class $a extends ea2 {
            getx(t2) {
              return this.int16[2 * t2 + 0];
            }
            gety(t2) {
              return this.int16[2 * t2 + 1];
            }
          }
          js($a, "SymbolLineVertexArray");
          class Ga extends Ko {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get layoutVertexArrayOffset() {
              return this._structArray.uint16[this._pos2 + 4];
            }
          }
          Ga.prototype.size = 12;
          class qa extends Pa {
            get(t2) {
              return new Ga(this, t2);
            }
          }
          js(qa, "FeatureIndexArray");
          class Ha extends ga {
            geta_centroid_pos0(t2) {
              return this.uint16[2 * t2 + 0];
            }
            geta_centroid_pos1(t2) {
              return this.uint16[2 * t2 + 1];
            }
          }
          js(Ha, "FillExtrusionCentroidArray");
          class Xa extends Ko {
            get a_join_normal_inside0() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get a_join_normal_inside1() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get a_join_normal_inside2() {
              return this._structArray.int16[this._pos2 + 2];
            }
          }
          Xa.prototype.size = 6;
          class Za extends ra {
            get(t2) {
              return new Xa(this, t2);
            }
          }
          js(Za, "FillExtrusionWallArray");
          const Wa = Qo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Ya = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]);
          class Ka {
            constructor(t2 = []) {
              this.segments = t2;
            }
            _prepareSegment(t2, e2, r2, n2) {
              let i2 = this.segments[this.segments.length - 1];
              return t2 > Ka.MAX_VERTEX_ARRAY_LENGTH && $t(`Max vertices per segment is ${Ka.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t2}`), (!i2 || i2.vertexLength + t2 > Ka.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2, primitiveOffset: r2, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
            }
            prepareSegment(t2, e2, r2, n2) {
              return this._prepareSegment(t2, e2.length, r2.length, n2);
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t2 of this.segments) for (const e2 in t2.vaos) t2.vaos[e2].destroy();
            }
            static simpleSegment(t2, e2, r2, n2) {
              return new Ka([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
            }
          }
          function Ja(t2, e2) {
            return 256 * (t2 = Pt(Math.floor(t2), 0, 255)) + Pt(Math.floor(e2), 0, 255);
          }
          Ka.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, js(Ka, "SegmentVector");
          const Qa = Qo([{ name: "a_pattern", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), tl = Qo([{ name: "a_pattern_b", components: 4, type: "Uint16" }, { name: "a_pixel_ratio", components: 1, type: "Float32" }]), el = Qo([{ name: "a_dash", components: 4, type: "Uint16" }]);
          class rl {
            constructor() {
              this.ids = [], this.uniqueIds = [], this.positions = [], this.indexed = false;
            }
            add(t2, e2, r2, n2) {
              this.ids.push(nl(t2)), this.positions.push(e2, r2, n2);
            }
            eachPosition(t2, e2) {
              const r2 = nl(t2);
              let n2 = 0, i2 = this.ids.length - 1;
              for (; n2 < i2; ) {
                const t3 = n2 + i2 >> 1;
                this.ids[t3] >= r2 ? i2 = t3 : n2 = t3 + 1;
              }
              for (; this.ids[n2] === r2; ) e2(this.positions[3 * n2], this.positions[3 * n2 + 1], this.positions[3 * n2 + 2]), n2++;
            }
            static serialize(t2, e2) {
              const r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
              return il(r2, n2, 0, r2.length - 1), e2 && (e2.add(r2.buffer), e2.add(n2.buffer)), { ids: r2, positions: n2 };
            }
            static deserialize(t2) {
              const e2 = new rl();
              let r2;
              e2.ids = t2.ids, e2.positions = t2.positions;
              for (const t3 of e2.ids) t3 !== r2 && e2.uniqueIds.push(t3), r2 = t3;
              return e2.indexed = true, e2;
            }
          }
          function nl(t2) {
            const e2 = +t2;
            return !isNaN(e2) && Number.MIN_SAFE_INTEGER <= e2 && e2 <= Number.MAX_SAFE_INTEGER ? e2 : Ze(String(t2));
          }
          function il(t2, e2, r2, n2) {
            for (; r2 < n2; ) {
              const i2 = t2[r2 + n2 >> 1];
              let s2 = r2 - 1, o2 = n2 + 1;
              for (; ; ) {
                do {
                  s2++;
                } while (t2[s2] < i2);
                do {
                  o2--;
                } while (t2[o2] > i2);
                if (s2 >= o2) break;
                sl(t2, s2, o2), sl(e2, 3 * s2, 3 * o2), sl(e2, 3 * s2 + 1, 3 * o2 + 1), sl(e2, 3 * s2 + 2, 3 * o2 + 2);
              }
              o2 - r2 < n2 - o2 ? (il(t2, e2, r2, o2), r2 = o2 + 1) : (il(t2, e2, o2 + 1, n2), n2 = o2);
            }
          }
          function sl(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          js(rl, "FeaturePositionMap");
          class ol {
            constructor(t2) {
              this.gl = t2.gl, this.initialized = false;
            }
            fetchUniformLocation(t2, e2) {
              return this.location || this.initialized || (this.location = this.gl.getUniformLocation(t2, e2), this.initialized = true), !!this.location;
            }
            set(t2, e2, r2) {
              throw new Error("Uniform#set() must be implemented by each concrete Uniform");
            }
          }
          class al extends ol {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1i(this.location, r2));
            }
          }
          class ll extends ol {
            constructor(t2) {
              super(t2), this.current = 0;
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && this.current !== r2 && (this.current = r2, this.gl.uniform1f(this.location, r2));
            }
          }
          class ul extends ol {
            constructor(t2) {
              super(t2), this.current = [0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] || (this.current = r2, this.gl.uniform2f(this.location, r2[0], r2[1])));
            }
          }
          class cl extends ol {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] || (this.current = r2, this.gl.uniform3f(this.location, r2[0], r2[1], r2[2])));
            }
          }
          class hl extends ol {
            constructor(t2) {
              super(t2), this.current = [0, 0, 0, 0];
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2[0] === this.current[0] && r2[1] === this.current[1] && r2[2] === this.current[2] && r2[3] === this.current[3] || (this.current = r2, this.gl.uniform4f(this.location, r2[0], r2[1], r2[2], r2[3])));
            }
          }
          class pl extends ol {
            constructor(t2) {
              super(t2), this.current = ir.transparent.toRenderColor(null);
            }
            set(t2, e2, r2) {
              this.fetchUniformLocation(t2, e2) && (r2.r === this.current.r && r2.g === this.current.g && r2.b === this.current.b && r2.a === this.current.a || (this.current = r2, this.gl.uniform4f(this.location, r2.r, r2.g, r2.b, r2.a)));
            }
          }
          const fl = new Float32Array(16);
          class dl extends ol {
            constructor(t2) {
              super(t2), this.current = fl;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                if (r2[12] !== this.current[12] || r2[0] !== this.current[0]) return this.current = r2, void this.gl.uniformMatrix4fv(this.location, false, r2);
                for (let t3 = 1; t3 < 16; t3++) if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix4fv(this.location, false, r2);
                  break;
                }
              }
            }
          }
          const ml = new Float32Array(9), yl = new Float32Array(4);
          class gl extends ol {
            constructor(t2) {
              super(t2), this.current = yl;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 4; t3++) if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix2fv(this.location, false, r2);
                  break;
                }
              }
            }
          }
          function xl(t2) {
            return [Ja(255 * t2.r, 255 * t2.g), Ja(255 * t2.b, 255 * t2.a)];
          }
          class vl {
            constructor(t2, e2, r2, n2) {
              this.value = t2, this.uniformNames = e2.map((t3) => `u_${t3}`), this.type = r2, this.context = n2;
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = n2.constantOr(this.value);
              e2.set(t2, i2, s2 instanceof ir ? s2.toRenderColor(this.lutExpression && "none" === this.lutExpression.value ? null : this.context.lut) : s2);
            }
            getBinding(t2, e2) {
              return "color" === this.type ? new pl(t2) : new ll(t2);
            }
          }
          class bl {
            constructor(t2, e2) {
              this.uniformNames = e2.map((t3) => `u_${t3}`), this.pattern = null, this.patternTransition = null, this.pixelRatio = 1;
            }
            setConstantPatternPositions(t2, e2) {
              this.pixelRatio = t2.pixelRatio || 1, this.pattern = t2.tl.concat(t2.br), this.patternTransition = e2 ? e2.tl.concat(e2.br) : this.pattern;
            }
            setUniform(t2, e2, r2, n2, i2) {
              let s2 = null;
              "u_pattern" !== i2 && "u_dash" !== i2 || (s2 = this.pattern), "u_pattern_b" === i2 && (s2 = this.patternTransition), "u_pixel_ratio" === i2 && (s2 = this.pixelRatio), s2 && e2.set(t2, i2, s2);
            }
            getBinding(t2, e2) {
              return "u_pattern" === e2 || "u_pattern_b" === e2 || "u_dash" === e2 ? new hl(t2) : new ll(t2);
            }
          }
          class _l {
            constructor(t2, e2, r2, n2) {
              this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.paintVertexArray.length, l2 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate(new yo(0, { brightness: s2 }), e2, {}, i2, n2, o2) : "constant" === this.expression.kind && this.expression.value, u5 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: s2 }), e2, {}, i2, n2, o2) : this.lutExpression.value);
              this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, l2, u5 ? null : this.context.lut);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = "composite" === this.expression.kind || "source" === this.expression.kind ? this.expression.evaluate({ zoom: 0, brightness: o2 }, r2, n2, void 0, i2) : "constant" === this.expression.kind && this.expression.value, l2 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: o2 }), r2, n2, void 0, i2) : this.lutExpression.value);
              this._setPaintValue(t2, e2, a2, l2 ? null : this.context.lut);
            }
            _setPaintValue(t2, e2, r2, n2) {
              if ("color" === this.type) {
                const i2 = xl(r2.toRenderColor(n2));
                for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, i2[0], i2[1]);
              } else {
                for (let n3 = t2; n3 < e2; n3++) this.paintVertexArray.emplace(n3, r2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.lutExpression && "constant" !== this.lutExpression.kind && (this.lutExpression.isStateDependent || !this.lutExpression.isLightConstant) || "constant" !== this.expression.kind && (this.expression.isStateDependent || !this.expression.isLightConstant)));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class wl {
            constructor(t2, e2, r2, n2, i2, s2) {
              this.expression = t2, this.uniformNames = e2.map((t3) => `u_${t3}_t`), this.type = r2, this.useIntegerZoom = n2, this.context = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map((t3) => ({ name: `a_${t3}`, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 })), this.paintVertexArray = new s2();
            }
            populatePaintArray(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.expression.evaluate(new yo(this.context.zoom, { brightness: s2 }), e2, {}, i2, n2, o2), l2 = this.expression.evaluate(new yo(this.context.zoom + 1, { brightness: s2 }), e2, {}, i2, n2, o2), u5 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: s2 }), e2, {}, i2, n2, o2) : this.lutExpression.value), c2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValue(c2, t2, a2, l2, u5 ? null : this.context.lut);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = this.expression.evaluate({ zoom: this.context.zoom, brightness: o2 }, r2, n2, void 0, i2), l2 = this.expression.evaluate({ zoom: this.context.zoom + 1, brightness: o2 }, r2, n2, void 0, i2), u5 = !!this.lutExpression && "none" === ("composite" === this.lutExpression.kind || "source" === this.lutExpression.kind ? this.lutExpression.evaluate(new yo(0, { brightness: o2 }), r2, n2, void 0, i2) : this.lutExpression.value);
              this._setPaintValue(t2, e2, a2, l2, u5 ? null : this.context.lut);
            }
            _setPaintValue(t2, e2, r2, n2, i2) {
              if ("color" === this.type) {
                const n3 = xl(r2.toRenderColor(i2)), s2 = xl(r2.toRenderColor(i2));
                for (let r3 = t2; r3 < e2; r3++) this.paintVertexArray.emplace(r3, n3[0], n3[1], s2[0], s2[1]);
              } else {
                for (let i3 = t2; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r2, n2);
                this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
              }
            }
            upload(t2) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent || !this.expression.isLightConstant));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t2, e2, r2, n2, i2) {
              const s2 = this.useIntegerZoom ? Math.floor(r2.zoom) : r2.zoom, o2 = Pt(this.expression.interpolationFactor(s2, this.context.zoom, this.context.zoom + 1), 0, 1);
              e2.set(t2, i2, o2);
            }
            getBinding(t2, e2) {
              return new ll(t2);
            }
          }
          class Al {
            constructor(t2, e2, r2, n2, i2) {
              this.expression = t2, this.layerId = i2, this.paintVertexAttributes = ("array" === r2 ? el : Qa).members;
              for (let t3 = 0; t3 < e2.length; ++t3) ;
              this.paintVertexArray = new n2(), this.paintTransitionVertexArray = new ca3();
            }
            populatePaintArray(t2, e2, r2, n2) {
              const i2 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t2), this._setPaintValues(i2, t2, e2.patterns && e2.patterns[this.layerId], r2);
            }
            updatePaintArray(t2, e2, r2, n2, i2, s2, o2) {
              this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], s2);
            }
            _setPaintValues(t2, e2, r2, n2) {
              if (!n2 || !r2) return;
              const i2 = n2[r2[0]], s2 = n2[r2[1]];
              if (i2) {
                if (i2) {
                  const { tl: r3, br: n3, pixelRatio: s3 } = i2;
                  for (let i3 = t2; i3 < e2; i3++) this.paintVertexArray.emplace(i3, r3[0], r3[1], n3[0], n3[1], s3);
                }
                if (s2) {
                  this.paintTransitionVertexArray.resize(this.paintVertexArray.length);
                  const { tl: r3, br: n3, pixelRatio: i3 } = s2;
                  for (let s3 = t2; s3 < e2; s3++) this.paintTransitionVertexArray.emplace(s3, r3[0], r3[1], n3[0], n3[1], i3);
                }
              }
            }
            upload(t2) {
              const e2 = this.expression.isStateDependent || !this.expression.isLightConstant;
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, e2)), this.paintTransitionVertexArray && this.paintTransitionVertexArray.length && (this.paintTransitionVertexBuffer = t2.createVertexBuffer(this.paintTransitionVertexArray, tl.members, e2));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy(), this.paintTransitionVertexBuffer && this.paintTransitionVertexBuffer.destroy();
            }
          }
          class Ml {
            constructor(t2, e2, r2 = () => true) {
              this.binders = {}, this._buffers = [], this.context = e2;
              const n2 = [];
              for (const i2 in t2.paint._values) {
                const s2 = t2.paint.get(i2);
                if (i2.endsWith("-use-theme")) continue;
                if (!r2(i2)) continue;
                if (!(s2 instanceof Ao && gs(s2.property.specification))) continue;
                const o2 = zl(i2, t2.type), a2 = s2.value, l2 = s2.property.specification.type, u5 = !!s2.property.useIntegerZoom, c2 = "line-dasharray" === i2 || i2.endsWith("pattern"), h2 = t2.paint.get(`${i2}-use-theme`), p2 = "line-dasharray" === i2 && "constant" !== t2.layout.get("line-cap").value.kind || h2 && "constant" !== h2.value.kind;
                if ("constant" !== a2.kind || p2) if ("source" === a2.kind || p2 || c2) {
                  const e3 = Pl(i2, l2, "source");
                  this.binders[i2] = c2 ? new Al(a2, o2, l2, e3, t2.id) : new _l(a2, o2, l2, e3), n2.push(`/a_${i2}`);
                } else {
                  const t3 = Pl(i2, l2, "composite");
                  this.binders[i2] = new wl(a2, o2, l2, u5, e2, t3), n2.push(`/z_${i2}`);
                }
                else this.binders[i2] = c2 ? new bl(a2.value, o2) : new vl(a2.value, o2, l2, e2), n2.push(`/u_${i2}`);
                h2 && (this.binders[i2].lutExpression = h2.value);
              }
              this.cacheKey = n2.sort().join("");
            }
            getMaxValue(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof _l || e2 instanceof wl ? e2.maxValue : 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2, o2) {
              for (const a2 in this.binders) {
                const l2 = this.binders[a2];
                l2.context = this.context, (l2 instanceof _l || l2 instanceof wl || l2 instanceof Al) && l2.populatePaintArray(t2, e2, r2, n2, i2, s2, o2);
              }
            }
            setConstantPatternPositions(t2, e2) {
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                n2 instanceof bl && n2.setConstantPatternPositions(t2, e2);
              }
            }
            getPatternTransitionVertexBuffer(t2) {
              const e2 = this.binders[t2];
              return e2 instanceof Al ? e2.paintTransitionVertexBuffer : null;
            }
            updatePaintArrays(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
              let u5 = false;
              const c2 = Object.keys(t2), h2 = 0 !== c2.length && !a2, p2 = h2 ? c2 : e2.uniqueIds;
              this.context.lut = i2.lut;
              for (const a3 in this.binders) {
                const c3 = this.binders[a3];
                if (c3.context = this.context, (c3 instanceof _l || c3 instanceof wl || c3 instanceof Al) && c3.expression && c3.expression.kind && "constant" !== c3.expression.kind && (true === c3.expression.isStateDependent || false === c3.expression.isLightConstant)) {
                  const f2 = i2.paint.get(a3);
                  c3.expression = f2.value;
                  for (const r3 of p2) {
                    const i3 = t2[r3.toString()];
                    e2.eachPosition(r3, (t3, e3, r4) => {
                      const a4 = n2.feature(t3);
                      c3.updatePaintArray(e3, r4, a4, i3, s2, o2, l2);
                    });
                  }
                  if (!h2) for (const e3 of r2.uniqueIds) {
                    const i3 = t2[e3.toString()];
                    r2.eachPosition(e3, (t3, e4, r3) => {
                      const a4 = n2.feature(t3);
                      c3.updatePaintArray(e4, r3, a4, i3, s2, o2, l2);
                    });
                  }
                  u5 = true;
                }
              }
              return u5;
            }
            defines() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof vl || r2 instanceof bl) && t2.push(...r2.uniformNames.map((t3) => `#define HAS_UNIFORM_${t3}`));
              }
              return t2;
            }
            getBinderAttributes() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof _l || r2 instanceof wl || r2 instanceof Al) for (let e3 = 0; e3 < r2.paintVertexAttributes.length; e3++) t2.push(r2.paintVertexAttributes[e3].name);
                if (r2 instanceof Al) for (let e3 = 0; e3 < tl.members.length; e3++) t2.push(tl.members[e3].name);
              }
              return t2;
            }
            getBinderUniforms() {
              const t2 = [];
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                if (r2 instanceof vl || r2 instanceof bl || r2 instanceof wl) for (const e3 of r2.uniformNames) t2.push(e3);
              }
              return t2;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t2) {
              const e2 = [];
              for (const r2 in this.binders) {
                const n2 = this.binders[r2];
                if (n2 instanceof vl || n2 instanceof bl || n2 instanceof wl) for (const i2 of n2.uniformNames) e2.push({ name: i2, property: r2, binding: n2.getBinding(t2, i2) });
              }
              return e2;
            }
            setUniforms(t2, e2, r2, n2, i2) {
              for (const { name: e3, property: s2, binding: o2 } of r2) this.binders[s2].setUniform(t2, o2, i2, n2.get(s2), e3);
            }
            updatePaintBuffers() {
              this._buffers = [];
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof _l || e2 instanceof wl || e2 instanceof Al) && e2.paintVertexBuffer && this._buffers.push(e2.paintVertexBuffer), e2 instanceof Al && e2.paintTransitionVertexBuffer && this._buffers.push(e2.paintTransitionVertexBuffer);
              }
            }
            upload(t2) {
              for (const e2 in this.binders) {
                const r2 = this.binders[e2];
                (r2 instanceof _l || r2 instanceof wl || r2 instanceof Al) && r2.upload(t2);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t2 in this.binders) {
                const e2 = this.binders[t2];
                (e2 instanceof _l || e2 instanceof wl || e2 instanceof Al) && e2.destroy();
              }
            }
          }
          class Il {
            constructor(t2, e2, r2 = () => true) {
              this.programConfigurations = {};
              for (const n2 of t2) this.programConfigurations[n2.id] = new Ml(n2, e2, r2);
              this.needsUpload = false, this._featureMap = new rl(), this._featureMapWithoutIds = new rl(), this._bufferOffset = 0, this._idlessCounter = 0;
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2, o2, a2) {
              for (const r3 in this.programConfigurations) this.programConfigurations[r3].populatePaintArrays(t2, e2, n2, i2, s2, o2, a2);
              void 0 !== e2.id ? this._featureMap.add(e2.id, r2, this._bufferOffset, t2) : (this._featureMapWithoutIds.add(this._idlessCounter, r2, this._bufferOffset, t2), this._idlessCounter += 1), this._bufferOffset = t2, this.needsUpload = true;
            }
            updatePaintArrays(t2, e2, r2, n2, i2, s2, o2) {
              for (const a2 of r2) this.needsUpload = this.programConfigurations[a2.id].updatePaintArrays(t2, this._featureMap, this._featureMapWithoutIds, e2, a2, n2, i2, s2, o2 || 0) || this.needsUpload;
            }
            get(t2) {
              return this.programConfigurations[t2];
            }
            upload(t2) {
              if (this.needsUpload) {
                for (const e2 in this.programConfigurations) this.programConfigurations[e2].upload(t2);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t2 in this.programConfigurations) this.programConfigurations[t2].destroy();
            }
          }
          const Sl = { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-occlusion-opacity": ["occlusion_opacity"], "icon-occlusion-opacity": ["occlusion_opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-emissive-strength": ["emissive_strength"], "icon-emissive-strength": ["emissive_strength"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "symbol-z-offset": ["z_offset"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-pattern": ["pattern", "pixel_ratio", "pattern_b"], "fill-extrusion-pattern": ["pattern", "pixel_ratio", "pattern_b"], "line-dasharray": ["dash"] };
          function zl(t2, e2) {
            return Sl[t2] || [t2.replace(`${e2}-`, "").replace(/-/g, "_")];
          }
          const kl = { "line-pattern": { source: ca3, composite: ca3 }, "fill-pattern": { source: ca3, composite: ca3 }, "fill-extrusion-pattern": { source: ca3, composite: ca3 }, "line-dasharray": { source: ha, composite: ha } }, El = { color: { source: Ea, composite: ma }, number: { source: ia, composite: Ea } };
          function Pl(t2, e2, r2) {
            const n2 = kl[t2];
            return n2 && n2[r2] || El[e2][r2];
          }
          js(vl, "ConstantBinder"), js(bl, "PatternConstantBinder"), js(_l, "SourceExpressionBinder"), js(Al, "PatternCompositeBinder"), js(wl, "CompositeExpressionBinder"), js(Ml, "ProgramConfiguration", { omit: ["_buffers"] }), js(Il, "ProgramConfigurationSet");
          const Tl = Tn / Math.PI / 2, Bl = 5, Vl = 6, Cl = 16383, Dl = 64, Fl = [Dl, 32, 16], Ll = -Tl, Rl = Tl;
          function Ol(t2, e2, r2, n2 = Tl) {
            return r2 = Mt(r2), [t2 * Math.sin(r2) * n2, -e2 * n2, t2 * Math.cos(r2) * n2];
          }
          function Ul(t2, e2, r2) {
            return Ol(Math.cos(Mt(t2)), Math.sin(Mt(t2)), e2, r2);
          }
          const Nl = 63710088e-1, jl = 2 * Math.PI * Nl;
          class $l {
            constructor(t2, e2) {
              if (isNaN(t2) || isNaN(e2)) throw new Error(`Invalid LngLat object: (${t2}, ${e2})`);
              if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90) throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new $l(Bt(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t2) {
              const e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
              return Nl * Math.acos(Math.min(i2, 1));
            }
            toBounds(t2 = 0) {
              const e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
              return new Gl({ lng: this.lng - r2, lat: this.lat - e2 }, { lng: this.lng + r2, lat: this.lat + e2 });
            }
            toEcef(t2) {
              return Ul(this.lat, this.lng, Tl + t2 * Tl / Nl);
            }
            static convert(t2) {
              if (t2 instanceof $l) return t2;
              if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length)) return new $l(Number(t2[0]), Number(t2[1]));
              if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2) return new $l(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          class Gl {
            constructor(t2, e2) {
              if (t2) if (e2) this.setSouthWest(t2).setNorthEast(e2);
              else if (4 === t2.length) {
                const e3 = t2;
                this.setSouthWest([e3[0], e3[1]]).setNorthEast([e3[2], e3[3]]);
              } else {
                const e3 = t2;
                this.setSouthWest(e3[0]).setNorthEast(e3[1]);
              }
            }
            setNorthEast(t2) {
              return this._ne = t2 instanceof $l ? new $l(t2.lng, t2.lat) : $l.convert(t2), this;
            }
            setSouthWest(t2) {
              return this._sw = t2 instanceof $l ? new $l(t2.lng, t2.lat) : $l.convert(t2), this;
            }
            extend(t2) {
              const e2 = this._sw, r2 = this._ne;
              let n2, i2;
              if (t2 instanceof $l) n2 = t2, i2 = t2;
              else {
                if (!(t2 instanceof Gl)) return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Gl.convert(t2)) : this.extend($l.convert(t2)) : "object" == typeof t2 && null !== t2 && t2.hasOwnProperty("lat") && (t2.hasOwnProperty("lon") || t2.hasOwnProperty("lng")) ? this.extend($l.convert(t2)) : this;
                if (n2 = t2._sw, i2 = t2._ne, !n2 || !i2) return this;
              }
              return e2 || r2 ? (e2.lng = Math.min(n2.lng, e2.lng), e2.lat = Math.min(n2.lat, e2.lat), r2.lng = Math.max(i2.lng, r2.lng), r2.lat = Math.max(i2.lat, r2.lat)) : (this._sw = new $l(n2.lng, n2.lat), this._ne = new $l(i2.lng, i2.lat)), this;
            }
            getCenter() {
              return new $l((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new $l(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new $l(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(t2) {
              const { lng: e2, lat: r2 } = $l.convert(t2);
              let n2 = this._sw.lng <= e2 && e2 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (n2 = this._sw.lng >= e2 && e2 >= this._ne.lng), this._sw.lat <= r2 && r2 <= this._ne.lat && n2;
            }
            static convert(t2) {
              if (t2) return t2 instanceof Gl ? t2 : new Gl(t2);
            }
          }
          const ql = 0, Hl = 25.5;
          function Xl(t2) {
            return jl * Math.cos(t2 * Math.PI / 180);
          }
          function Zl(t2) {
            return (180 + t2) / 360;
          }
          function Wl(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function Yl(t2, e2) {
            return t2 / Xl(e2);
          }
          function Kl(t2) {
            return 360 * t2 - 180;
          }
          function Jl(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          function Ql(t2, e2) {
            return t2 * Xl(Jl(e2));
          }
          const tu = 85.051129;
          function eu(t2) {
            return Math.cos(Mt(Pt(t2, -tu, tu)));
          }
          function ru(t2, e2) {
            const r2 = Pt(e2, ql, Hl), n2 = Math.pow(2, r2);
            return eu(t2) * jl / (512 * n2);
          }
          function nu(t2) {
            return 1 / Math.cos(t2 * Math.PI / 180);
          }
          function iu(t2, e2 = 0) {
            const r2 = Math.exp(Math.PI * (1 - (t2.y + e2 / Tn) / (1 << t2.z) * 2));
            return 80150034 * r2 / (r2 * r2 + 1) / Tn / (1 << t2.z);
          }
          class su {
            constructor(t2, e2, r2 = 0) {
              this.x = +t2, this.y = +e2, this.z = +r2;
            }
            static fromLngLat(t2, e2 = 0) {
              const r2 = $l.convert(t2);
              return new su(Zl(r2.lng), Wl(r2.lat), Yl(e2, r2.lat));
            }
            toLngLat() {
              return new $l(Kl(this.x), Jl(this.y));
            }
            toAltitude() {
              return Ql(this.z, this.y);
            }
            meterInMercatorCoordinateUnits() {
              return 1 / jl * nu(Jl(this.y));
            }
          }
          function ou(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            const u5 = (e2 + n2) / 2, c2 = (r2 + i2) / 2, h2 = new bt(u5, c2);
            a2(h2), function(t3, e3, r3, n3, i3, s3) {
              const o3 = r3 - i3, a3 = n3 - s3;
              return Math.abs((n3 - e3) * o3 - (r3 - t3) * a3) / Math.hypot(o3, a3);
            }(h2.x, h2.y, s2.x, s2.y, o2.x, o2.y) >= l2 ? (ou(t2, e2, r2, u5, c2, s2, h2, a2, l2), ou(t2, u5, c2, n2, i2, h2, o2, a2, l2)) : t2.push(o2);
          }
          function au(t2, e2, r2) {
            let n2 = t2[0], i2 = n2.x, s2 = n2.y;
            e2(n2);
            const o2 = [n2];
            for (let a2 = 1; a2 < t2.length; a2++) {
              const l2 = t2[a2], { x: u5, y: c2 } = l2;
              e2(l2), ou(o2, i2, s2, u5, c2, n2, l2, e2, r2), i2 = u5, s2 = c2, n2 = l2;
            }
            return o2;
          }
          function lu(t2, e2, r2, n2) {
            if (n2(e2, r2)) {
              const i2 = e2.add(r2)._mult(0.5);
              lu(t2, e2, i2, n2), lu(t2, i2, r2, n2);
            } else t2.push(r2);
          }
          function uu(t2, e2) {
            let r2 = t2[0];
            const n2 = [r2];
            for (let i2 = 1; i2 < t2.length; i2++) {
              const s2 = t2[i2];
              lu(n2, r2, s2, e2), r2 = s2;
            }
            return n2;
          }
          const cu = Math.pow(2, 14) - 1, hu = -cu - 1;
          function pu(t2, e2) {
            const r2 = Math.round(t2.x * e2), n2 = Math.round(t2.y * e2);
            return t2.x = Pt(r2, hu, cu), t2.y = Pt(n2, hu, cu), (r2 < t2.x || r2 > t2.x + 1 || n2 < t2.y || n2 > t2.y + 1) && $t("Geometry exceeds allowed extent, reduce your vector tile buffer size"), t2;
          }
          function fu(t2, e2, r2) {
            const n2 = t2.loadGeometry(), i2 = t2.extent, s2 = Tn / i2;
            if (e2 && r2 && r2.projection.isReprojectedInTileSpace) {
              const s3 = 1 << e2.z, { scale: o2, x: a2, y: l2, projection: u5 } = r2, c2 = (t3) => {
                const r3 = Kl((e2.x + t3.x / i2) / s3), n3 = Jl((e2.y + t3.y / i2) / s3), c3 = u5.project(r3, n3);
                t3.x = (c3.x * o2 - a2) * i2, t3.y = (c3.y * o2 - l2) * i2;
              };
              for (let e3 = 0; e3 < n2.length; e3++) if (1 !== t2.type) n2[e3] = au(n2[e3], c2, 1);
              else {
                const t3 = [];
                for (const r3 of n2[e3]) r3.x < 0 || r3.x >= i2 || r3.y < 0 || r3.y >= i2 || (c2(r3), t3.push(r3));
                n2[e3] = t3;
              }
            }
            for (const t3 of n2) for (const e3 of t3) pu(e3, s2);
            return n2;
          }
          function du(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? fu(t2) : [] };
          }
          function mu(t2, e2, r2, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          function yu(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class gu {
            constructor(t2) {
              this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.projection = t2.projection, this.layoutVertexArray = new ea2(), this.indexArray = new wa(), this.segments = new Ka(), this.programConfigurations = new Il(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id);
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = [];
              let o2 = null;
              "circle" === i2.type && (o2 = i2.layout.get("circle-sort-key"));
              for (const { feature: e3, id: i3, index: a3, sourceLayerIndex: l2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u5 = du(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u5, r2)) continue;
                const c2 = o2 ? o2.evaluate(u5, {}, r2) : void 0, h2 = { id: i3, properties: e3.properties, type: e3.type, sourceLayerIndex: l2, index: a3, geometry: t3 ? u5.geometry : fu(e3, r2, n2), patterns: {}, sortKey: c2 };
                s2.push(h2);
              }
              o2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              let a2 = null;
              "globe" === n2.projection.name && (this.globeExtVertexArray = new pa(), a2 = n2.projection);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: o3 } = n3, l2 = t2[s3].feature;
                this.addFeature(n3, i3, s3, e2.availableImages, r2, a2, e2.brightness), e2.featureIndex.insert(l2, i3, s3, o3, this.index);
              }
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Wa.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.globeExtVertexArray && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, Ya.members))), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2, o2) {
              for (const r3 of e2) for (const e3 of r3) {
                const r4 = e3.x, n3 = e3.y;
                if (r4 < 0 || r4 >= Tn || n3 < 0 || n3 >= Tn) continue;
                if (s2) {
                  const t3 = s2.projectTilePoint(r4, n3, i2), e4 = s2.upVector(i2, r4, n3), o4 = this.globeExtVertexArray;
                  yu(o4, t3, e4), yu(o4, t3, e4), yu(o4, t3, e4), yu(o4, t3, e4);
                }
                const o3 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), a2 = o3.vertexLength;
                mu(this.layoutVertexArray, r4, n3, -1, -1), mu(this.layoutVertexArray, r4, n3, 1, -1), mu(this.layoutVertexArray, r4, n3, 1, 1), mu(this.layoutVertexArray, r4, n3, -1, 1), this.indexArray.emplaceBack(a2, a2 + 1, a2 + 2), this.indexArray.emplaceBack(a2, a2 + 2, a2 + 3), o3.vertexLength += 4, o3.primitiveLength += 2;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2, i2, o2);
            }
          }
          function xu(t2, e2) {
            for (let r2 = 0; r2 < t2.length; r2++) if (Eu(e2, t2[r2])) return true;
            for (let r2 = 0; r2 < e2.length; r2++) if (Eu(t2, e2[r2])) return true;
            return !!wu(t2, e2);
          }
          function vu(t2, e2, r2) {
            return !!Eu(t2, e2) || !!Su(e2, t2, r2);
          }
          function bu(t2, e2) {
            if (1 === t2.length) return ku(e2, t2[0]);
            for (let r2 = 0; r2 < e2.length; r2++) {
              const n2 = e2[r2];
              for (let e3 = 0; e3 < n2.length; e3++) if (Eu(t2, n2[e3])) return true;
            }
            for (let r2 = 0; r2 < t2.length; r2++) if (ku(e2, t2[r2])) return true;
            for (let r2 = 0; r2 < e2.length; r2++) if (wu(t2, e2[r2])) return true;
            return false;
          }
          function _u(t2, e2, r2) {
            if (t2.length > 1) {
              if (wu(t2, e2)) return true;
              for (let n2 = 0; n2 < e2.length; n2++) if (Su(e2[n2], t2, r2)) return true;
            }
            for (let n2 = 0; n2 < t2.length; n2++) if (Su(t2[n2], e2, r2)) return true;
            return false;
          }
          function wu(t2, e2) {
            if (0 === t2.length || 0 === e2.length) return false;
            for (let r2 = 0; r2 < t2.length - 1; r2++) {
              const n2 = t2[r2], i2 = t2[r2 + 1];
              for (let t3 = 0; t3 < e2.length - 1; t3++) if (Au(n2, i2, e2[t3], e2[t3 + 1])) return true;
            }
            return false;
          }
          function Au(t2, e2, r2, n2) {
            return Gt(t2, r2, n2) !== Gt(e2, r2, n2) && Gt(t2, e2, r2) !== Gt(t2, e2, n2);
          }
          function Mu(t2, e2, r2) {
            return (t2.x - r2.x) * (e2.y - r2.y) - (t2.y - r2.y) * (e2.x - r2.x);
          }
          function Iu(t2, e2, r2, n2) {
            const i2 = Mu(t2, e2, n2), s2 = Mu(t2, e2, r2);
            if (Math.sign(i2) === Math.sign(s2)) return;
            const o2 = Mu(r2, n2, t2), a2 = o2 + s2 - i2;
            return Math.sign(o2) !== Math.sign(a2) ? [o2 / (o2 - a2), s2 / (s2 - i2)] : void 0;
          }
          function Su(t2, e2, r2) {
            const n2 = r2 * r2;
            if (1 === e2.length) return t2.distSqr(e2[0]) < n2;
            for (let r3 = 1; r3 < e2.length; r3++) if (zu(t2, e2[r3 - 1], e2[r3]) < n2) return true;
            return false;
          }
          function zu(t2, e2, r2) {
            const n2 = e2.distSqr(r2);
            if (0 === n2) return t2.distSqr(e2);
            const i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function ku(t2, e2) {
            let r2, n2, i2, s2 = false;
            for (let o2 = 0; o2 < t2.length; o2++) {
              r2 = t2[o2];
              for (let t3 = 0, o3 = r2.length - 1; t3 < r2.length; o3 = t3++) n2 = r2[t3], i2 = r2[o3], n2.y > e2.y != i2.y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (s2 = !s2);
            }
            return s2;
          }
          function Eu(t2, e2) {
            let r2 = false;
            for (let n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              const s2 = t2[n2], o2 = t2[i2];
              s2.y > e2.y != o2.y > e2.y && e2.x < (o2.x - s2.x) * (e2.y - s2.y) / (o2.y - s2.y) + s2.x && (r2 = !r2);
            }
            return r2;
          }
          function Pu(t2, e2, r2, n2, i2) {
            for (const s3 of t2) if (e2 <= s3.x && r2 <= s3.y && n2 >= s3.x && i2 >= s3.y) return true;
            const s2 = [new bt(e2, r2), new bt(e2, i2), new bt(n2, i2), new bt(n2, r2)];
            if (t2.length > 2) {
              for (const e3 of s2) if (Eu(t2, e3)) return true;
            }
            for (let e3 = 0; e3 < t2.length - 1; e3++) if (Tu(t2[e3], t2[e3 + 1], s2)) return true;
            return false;
          }
          function Tu(t2, e2, r2) {
            const n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y) return false;
            const s2 = Gt(t2, e2, r2[0]);
            return s2 !== Gt(t2, e2, r2[1]) || s2 !== Gt(t2, e2, r2[2]) || s2 !== Gt(t2, e2, r2[3]);
          }
          function Bu(t2, e2, r2, n2, i2, s2) {
            let o2 = e2.y - t2.y, a2 = t2.x - e2.x;
            if (s2 = s2 || 0) {
              const t3 = o2 * o2 + a2 * a2;
              if (0 === t3) return true;
              const e3 = Math.sqrt(t3);
              o2 /= e3, a2 /= e3;
            }
            return !((r2.x - t2.x) * o2 + (r2.y - t2.y) * a2 - s2 < 0 || (n2.x - t2.x) * o2 + (n2.y - t2.y) * a2 - s2 < 0 || (i2.x - t2.x) * o2 + (i2.y - t2.y) * a2 - s2 < 0);
          }
          function Vu(t2, e2, r2, n2, i2, s2, o2) {
            return !(Bu(t2, e2, n2, i2, s2, o2) || Bu(e2, r2, n2, i2, s2, o2) || Bu(r2, t2, n2, i2, s2, o2) || Bu(n2, i2, t2, e2, r2, o2) || Bu(i2, s2, t2, e2, r2, o2) || Bu(s2, n2, t2, e2, r2, o2));
          }
          function Cu(t2, e2, r2) {
            const n2 = e2.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function Du(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function Fu(t2, e2, r2, n2, i2) {
            if (!e2[0] && !e2[1]) return t2;
            const s2 = bt.convert(e2)._mult(i2);
            "viewport" === r2 && s2._rotate(-n2);
            const o2 = [];
            for (let e3 = 0; e3 < t2.length; e3++) o2.push(t2[e3].sub(s2));
            return o2;
          }
          function Lu(t2, e2, r2, n2) {
            const i2 = bt.convert(t2)._mult(n2);
            return "viewport" === e2 && i2._rotate(-r2), i2;
          }
          let Ru, Ou;
          function Uu(t2, e2, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          js(gu, "CircleBucket", { omit: ["layers"] });
          class Nu {
            constructor(t2, e2, r2) {
              this.z = t2, this.x = e2, this.y = r2, this.key = Gu(0, t2, t2, e2, r2);
            }
            equals(t2) {
              return this.z === t2.z && this.x === t2.x && this.y === t2.y;
            }
            url(t2, e2) {
              const r2 = function(t3, e3, r3) {
                var n3 = Uu(256 * t3, 256 * (e3 = Math.pow(2, r3) - e3 - 1), r3), i2 = Uu(256 * (t3 + 1), 256 * (e3 + 1), r3);
                return n3[0] + "," + n3[1] + "," + i2[0] + "," + i2[1];
              }(this.x, this.y, this.z), n2 = function(t3, e3, r3) {
                let n3, i2 = "";
                for (let s2 = t3; s2 > 0; s2--) n3 = 1 << s2 - 1, i2 += (e3 & n3 ? 1 : 0) + (r3 & n3 ? 2 : 0);
                return i2;
              }(this.z, this.x, this.y);
              return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", n2).replace("{bbox-epsg-3857}", r2);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class ju {
            constructor(t2, e2) {
              this.wrap = t2, this.canonical = e2, this.key = Gu(t2, e2.z, e2.z, e2.x, e2.y);
            }
          }
          class $u {
            constructor(t2, e2, r2, n2, i2) {
              this.overscaledZ = t2, this.wrap = e2, this.canonical = new Nu(r2, +n2, +i2), this.key = 0 === e2 && t2 === r2 ? this.canonical.key : Gu(e2, t2, r2, n2, i2);
            }
            equals(t2) {
              return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
            }
            scaledTo(t2) {
              const e2 = this.canonical.z - t2;
              return t2 > this.canonical.z ? new $u(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new $u(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
            }
            calculateScaledKey(t2, e2 = true) {
              if (this.overscaledZ === t2 && e2) return this.key;
              if (t2 > this.canonical.z) return Gu(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y);
              {
                const r2 = this.canonical.z - t2;
                return Gu(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
              }
            }
            isChildOf(t2) {
              if (t2.wrap !== this.wrap) return false;
              const e2 = this.canonical.z - t2.canonical.z;
              return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.z < this.canonical.z && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
            }
            children(t2) {
              if (this.overscaledZ >= t2) return [new $u(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
              return [new $u(e2, this.wrap, e2, r2, n2), new $u(e2, this.wrap, e2, r2 + 1, n2), new $u(e2, this.wrap, e2, r2, n2 + 1), new $u(e2, this.wrap, e2, r2 + 1, n2 + 1)];
            }
            isLessThan(t2) {
              return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
            }
            wrapped() {
              return new $u(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t2) {
              return new $u(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new ju(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
          }
          function Gu(t2, e2, r2, n2, i2) {
            const s2 = 1 << Math.min(r2, 22);
            let o2 = s2 * (i2 % s2) + n2 % s2;
            return t2 && r2 < 22 && (o2 += s2 * s2 * ((t2 < 0 ? -2 * t2 - 1 : 2 * t2) % (1 << 2 * (22 - r2)))), 16 * (32 * o2 + r2) + (e2 - r2);
          }
          const qu = [(t2) => {
            let e2 = t2.canonical.x - 1, r2 = t2.wrap;
            return e2 < 0 && (e2 = (1 << t2.canonical.z) - 1, r2--), new $u(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
          }, (t2) => {
            let e2 = t2.canonical.x + 1, r2 = t2.wrap;
            return e2 === 1 << t2.canonical.z && (e2 = 0, r2++), new $u(t2.overscaledZ, r2, t2.canonical.z, e2, t2.canonical.y);
          }, (t2) => new $u(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, (0 === t2.canonical.y ? 1 << t2.canonical.z : t2.canonical.y) - 1), (t2) => new $u(t2.overscaledZ, t2.wrap, t2.canonical.z, t2.canonical.x, t2.canonical.y === (1 << t2.canonical.z) - 1 ? 0 : t2.canonical.y + 1)];
          js(Nu, "CanonicalTileID"), js($u, "OverscaledTileID", { omit: ["projMatrix", "expandedProjMatrix"] });
          const Hu = Qo([{ type: "Float32", name: "a_globe_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]), { members: Xu } = Hu, Zu = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }]);
          var Wu = Qo([{ name: "a_pos", type: "Int16", components: 2 }]);
          class Yu {
            constructor(t2, e2) {
              this.pos = t2, this.dir = e2;
            }
            intersectsPlane(t2, e2, r2) {
              const n2 = ft(e2, this.dir);
              if (Math.abs(n2) < 1e-6) return false;
              const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1]) / n2;
              return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, true;
            }
          }
          class Ku {
            constructor(t2, e2) {
              this.pos = t2, this.dir = e2;
            }
            intersectsPlane(t2, e2, r2) {
              const n2 = D2(e2, this.dir);
              if (Math.abs(n2) < 1e-6) return false;
              const i2 = ((t2[0] - this.pos[0]) * e2[0] + (t2[1] - this.pos[1]) * e2[1] + (t2[2] - this.pos[2]) * e2[2]) / n2;
              return r2[0] = this.pos[0] + this.dir[0] * i2, r2[1] = this.pos[1] + this.dir[1] * i2, r2[2] = this.pos[2] + this.dir[2] * i2, true;
            }
            closestPointOnSphere(t2, r2, n2) {
              if (function(t3, r3) {
                var n3 = t3[0], i3 = t3[1], s3 = t3[2], o3 = r3[0], a3 = r3[1], l3 = r3[2];
                return Math.abs(n3 - o3) <= e * Math.max(1, Math.abs(n3), Math.abs(o3)) && Math.abs(i3 - a3) <= e * Math.max(1, Math.abs(i3), Math.abs(a3)) && Math.abs(s3 - l3) <= e * Math.max(1, Math.abs(s3), Math.abs(l3));
              }(this.pos, t2) || 0 === r2) return n2[0] = n2[1] = n2[2] = 0, false;
              const [i2, s2, o2] = this.dir, a2 = this.pos[0] - t2[0], l2 = this.pos[1] - t2[1], u5 = this.pos[2] - t2[2], c2 = i2 * i2 + s2 * s2 + o2 * o2, h2 = 2 * (a2 * i2 + l2 * s2 + u5 * o2), p2 = h2 * h2 - 4 * c2 * (a2 * a2 + l2 * l2 + u5 * u5 - r2 * r2);
              if (p2 < 0) {
                const t3 = Math.max(-h2 / 2, 0), e2 = a2 + i2 * t3, c3 = l2 + s2 * t3, p3 = u5 + o2 * t3, f2 = Math.hypot(e2, c3, p3);
                return n2[0] = e2 * r2 / f2, n2[1] = c3 * r2 / f2, n2[2] = p3 * r2 / f2, false;
              }
              {
                const t3 = (-h2 - Math.sqrt(p2)) / (2 * c2);
                if (t3 < 0) {
                  const t4 = Math.hypot(a2, l2, u5);
                  return n2[0] = a2 * r2 / t4, n2[1] = l2 * r2 / t4, n2[2] = u5 * r2 / t4, false;
                }
                return n2[0] = a2 + i2 * t3, n2[1] = l2 + s2 * t3, n2[2] = u5 + o2 * t3, true;
              }
            }
          }
          class Ju {
            constructor(t2, e2, r2, n2, i2) {
              this.TL = t2, this.TR = e2, this.BR = r2, this.BL = n2, this.horizon = i2;
            }
            static fromInvProjectionMatrix(t2, e2, r2) {
              const n2 = [-1, 1, 1], i2 = [1, 1, 1], s2 = [1, -1, 1], o2 = [-1, -1, 1], a2 = R(n2, n2, t2), l2 = R(i2, i2, t2), u5 = R(s2, s2, t2), c2 = R(o2, o2, t2);
              return new Ju(a2, l2, u5, c2, e2 / r2);
            }
          }
          function Qu(t2, e2, r2) {
            let n2 = 1 / 0, i2 = -1 / 0;
            const s2 = [];
            for (const o2 of t2) {
              j(s2, o2, e2);
              const t3 = D2(s2, r2);
              n2 = Math.min(n2, t3), i2 = Math.max(i2, t3);
            }
            return [n2, i2];
          }
          function tc(t2, e2) {
            let r2 = true;
            for (let n2 = 0; n2 < t2.planes.length; n2++) {
              const i2 = t2.planes[n2];
              let s2 = 0;
              for (let t3 = 0; t3 < e2.length; t3++) s2 += D2(i2, e2[t3]) + i2[3] >= 0;
              if (0 === s2) return 0;
              s2 !== e2.length && (r2 = false);
            }
            return r2 ? 2 : 1;
          }
          function ec(t2, e2) {
            for (const r2 of t2.projections) {
              const n2 = Qu(e2, t2.points[0], r2.axis);
              if (r2.projection[1] < n2[0] || r2.projection[0] > n2[1]) return 0;
            }
            return 1;
          }
          function rc(t2, e2) {
            let r2 = 0;
            const n2 = [0, 0, 0, 0];
            for (let o2 = 0; o2 < t2.length; o2++) n2[0] = t2[o2][0], n2[1] = t2[o2][1], n2[2] = t2[o2][2], n2[3] = 1, (i2 = n2)[0] * (s2 = e2)[0] + i2[1] * s2[1] + i2[2] * s2[2] + i2[3] * s2[3] >= 0 && r2++;
            var i2, s2;
            return r2;
          }
          class nc {
            constructor(t2, e2) {
              this.points = t2 || new Array(8).fill([0, 0, 0]), this.planes = e2 || new Array(6).fill([0, 0, 0, 0]), this.bounds = ic.fromPoints(this.points), this.projections = [], this.frustumEdges = [j([], this.points[2], this.points[3]), j([], this.points[0], this.points[3]), j([], this.points[4], this.points[0]), j([], this.points[5], this.points[1]), j([], this.points[6], this.points[2]), j([], this.points[7], this.points[3])];
              for (const t3 of this.frustumEdges) {
                const e3 = [0, -t3[2], t3[1]], r2 = [t3[2], 0, -t3[0]];
                this.projections.push({ axis: e3, projection: Qu(this.points, this.points[0], e3) }), this.projections.push({ axis: r2, projection: Qu(this.points, this.points[0], r2) });
              }
            }
            static fromInvProjectionMatrix(t2, e2, r2, n2) {
              const i2 = Math.pow(2, r2), s2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((r3) => {
                const s3 = Z([], r3, t2), o3 = 1 / s3[3] / e2 * i2;
                return (a3 = s3)[0] = (l2 = s3)[0] * (u5 = [o3, o3, n2 ? 1 / s3[3] : o3, o3])[0], a3[1] = l2[1] * u5[1], a3[2] = l2[2] * u5[2], a3[3] = l2[3] * u5[3], a3;
                var a3, l2, u5;
              }), o2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t3) => {
                const e3 = C([], F([], j([], s2[t3[0]], s2[t3[1]]), j([], s2[t3[2]], s2[t3[1]]))), r3 = -D2(e3, s2[t3[1]]);
                return e3.concat(r3);
              }), a2 = [];
              for (let t3 = 0; t3 < s2.length; t3++) a2.push([s2[t3][0], s2[t3][1], s2[t3][2]]);
              return new nc(a2, o2);
            }
            intersectsPrecise(t2, e2, r2) {
              for (let r3 = 0; r3 < e2.length; r3++) if (!rc(t2, e2[r3])) return 0;
              for (let e3 = 0; e3 < this.planes.length; e3++) if (!rc(t2, this.planes[e3])) return 0;
              for (const e3 of r2) for (const r3 of this.frustumEdges) {
                const n2 = F([], e3, r3), i2 = w(n2);
                if (0 === i2) continue;
                E(n2, n2, 1 / i2);
                const s2 = Qu(this.points, this.points[0], n2), o2 = Qu(t2, this.points[0], n2);
                if (s2[0] > o2[1] || o2[0] > s2[1]) return 0;
              }
              return 1;
            }
            containsPoint(t2) {
              for (const e2 of this.planes) {
                const r2 = e2[3];
                if (D2([e2[0], e2[1], e2[2]], t2) + r2 < 0) return false;
              }
              return true;
            }
          }
          class ic {
            static fromPoints(t2) {
              const e2 = [1 / 0, 1 / 0, 1 / 0], r2 = [-1 / 0, -1 / 0, -1 / 0];
              for (const n2 of t2) z(e2, e2, n2), k(r2, r2, n2);
              return new ic(e2, r2);
            }
            static fromTileIdAndHeight(t2, e2, r2) {
              const n2 = 1 << t2.canonical.z, i2 = t2.canonical.x, s2 = t2.canonical.y;
              return new ic([i2 / n2, s2 / n2, e2], [(i2 + 1) / n2, (s2 + 1) / n2, r2]);
            }
            static applyTransform(t2, e2) {
              const r2 = t2.getCorners();
              for (let t3 = 0; t3 < r2.length; ++t3) R(r2[t3], r2[t3], e2);
              return ic.fromPoints(r2);
            }
            static applyTransformFast(t2, e2) {
              const r2 = [e2[12], e2[13], e2[14]], n2 = [...r2];
              for (let i2 = 0; i2 < 3; i2++) for (let s2 = 0; s2 < 3; s2++) {
                const o2 = e2[4 * s2 + i2], a2 = o2 * t2.min[s2], l2 = o2 * t2.max[s2];
                r2[i2] += Math.min(a2, l2), n2[i2] += Math.max(a2, l2);
              }
              return new ic(r2, n2);
            }
            static projectAabbCorners(t2, e2) {
              const r2 = t2.getCorners();
              for (let t3 = 0; t3 < r2.length; ++t3) R(r2[t3], r2[t3], e2);
              return r2;
            }
            constructor(t2, e2) {
              this.min = t2, this.max = e2, this.center = E([], M([], this.min, this.max), 0.5);
            }
            quadrant(t2) {
              const e2 = [t2 % 2 == 0, t2 < 2], r2 = _(this.min), n2 = _(this.max);
              for (let t3 = 0; t3 < e2.length; t3++) r2[t3] = e2[t3] ? this.min[t3] : this.center[t3], n2[t3] = e2[t3] ? this.center[t3] : this.max[t3];
              return n2[2] = this.max[2], new ic(r2, n2);
            }
            distanceX(t2) {
              return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
            }
            distanceY(t2) {
              return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
            }
            distanceZ(t2) {
              return Math.max(Math.min(this.max[2], t2[2]), this.min[2]) - t2[2];
            }
            getCorners() {
              const t2 = this.min, e2 = this.max;
              return [[t2[0], t2[1], t2[2]], [e2[0], t2[1], t2[2]], [e2[0], e2[1], t2[2]], [t2[0], e2[1], t2[2]], [t2[0], t2[1], e2[2]], [e2[0], t2[1], e2[2]], [e2[0], e2[1], e2[2]], [t2[0], e2[1], e2[2]]];
            }
            intersects(t2) {
              return this.intersectsAabb(t2.bounds) ? tc(t2, this.getCorners()) : 0;
            }
            intersectsFlat(t2) {
              return this.intersectsAabb(t2.bounds) ? tc(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
            }
            intersectsPrecise(t2, e2) {
              return e2 || this.intersects(t2) ? ec(t2, this.getCorners()) : 0;
            }
            intersectsPreciseFlat(t2, e2) {
              return e2 || this.intersectsFlat(t2) ? ec(t2, [[this.min[0], this.min[1], 0], [this.max[0], this.min[1], 0], [this.max[0], this.max[1], 0], [this.min[0], this.max[1], 0]]) : 0;
            }
            intersectsAabb(t2) {
              for (let e2 = 0; e2 < 3; ++e2) if (this.min[e2] > t2.max[e2] || t2.min[e2] > this.max[e2]) return false;
              return true;
            }
            intersectsAabbXY(t2) {
              return !(this.min[0] > t2.max[0] || t2.min[0] > this.max[0] || this.min[1] > t2.max[1] || t2.min[1] > this.max[1]);
            }
            encapsulate(t2) {
              for (let e2 = 0; e2 < 3; e2++) this.min[e2] = Math.min(this.min[e2], t2.min[e2]), this.max[e2] = Math.max(this.max[e2], t2.max[e2]);
            }
            encapsulatePoint(t2) {
              for (let e2 = 0; e2 < 3; e2++) this.min[e2] = Math.min(this.min[e2], t2[e2]), this.max[e2] = Math.max(this.max[e2], t2[e2]);
            }
            closestPoint(t2) {
              return [Math.max(Math.min(this.max[0], t2[0]), this.min[0]), Math.max(Math.min(this.max[1], t2[1]), this.min[1]), Math.max(Math.min(this.max[2], t2[2]), this.min[2])];
            }
          }
          function sc(t2) {
            return t2 * Tl / Nl;
          }
          js(ic, "Aabb");
          const oc = [new ic([Ll, Ll, Ll], [Rl, Rl, Rl]), new ic([Ll, Ll, Ll], [0, 0, Rl]), new ic([0, Ll, Ll], [Rl, 0, Rl]), new ic([Ll, 0, Ll], [0, Rl, Rl]), new ic([0, 0, Ll], [Rl, Rl, Rl])];
          function ac2(t2, e2, r2, n2 = true) {
            const i2 = E([], t2._camera.position, t2.worldSize), s2 = [e2, r2, 1, 1];
            Z(s2, s2, t2.pixelMatrixInverse), H(s2, s2, 1 / s2[3]);
            const o2 = C([], j([], s2, i2)), a2 = t2.globeMatrix, l2 = [a2[12], a2[13], a2[14]], u5 = j([], l2, i2), c2 = w(u5), h2 = C([], u5), p2 = t2.worldSize / (2 * Math.PI), f2 = D2(h2, o2), d2 = Math.asin(p2 / c2);
            if (d2 < Math.acos(f2)) {
              if (!n2) return null;
              const t3 = [], e3 = [];
              E(t3, o2, c2 / f2), C(e3, j(e3, t3, u5)), C(o2, M(o2, u5, E(o2, e3, Math.tan(d2) * c2)));
            }
            const m2 = [];
            new Ku(i2, o2).closestPointOnSphere(l2, p2, m2);
            const y2 = C([], Yt(a2, 0)), g2 = C([], Yt(a2, 1)), x2 = C([], Yt(a2, 2)), v3 = D2(y2, m2), b2 = D2(g2, m2), _2 = D2(x2, m2), A2 = It(Math.asin(-b2 / p2));
            let I2 = It(Math.atan2(v3, _2));
            I2 = t2.center.lng + function(t3, e3) {
              const r3 = (e3 - t3 + 180) % 360 - 180;
              return r3 < -180 ? r3 + 360 : r3;
            }(t2.center.lng, I2);
            const S2 = Zl(I2), z2 = Pt(Wl(A2), 0, 1);
            return new su(S2, z2);
          }
          class lc {
            constructor(t2, e2, r2) {
              this.a = j([], t2, r2), this.b = j([], e2, r2), this.center = r2;
              const n2 = C([], this.a), i2 = C([], this.b);
              this.angle = Math.acos(D2(n2, i2));
            }
          }
          function uc(t2, e2) {
            if (0 === t2.angle) return null;
            let r2;
            return r2 = 0 === t2.a[e2] ? 1 / t2.angle * 0.5 * Math.PI : 1 / t2.angle * Math.atan(t2.b[e2] / t2.a[e2] / Math.sin(t2.angle) - 1 / Math.tan(t2.angle)), r2 < 0 || r2 > 1 ? null : function(t3, e3, r3, n2) {
              const i2 = Math.sin(r3);
              return t3 * (Math.sin((1 - n2) * r3) / i2) + e3 * (Math.sin(n2 * r3) / i2);
            }(t2.a[e2], t2.b[e2], t2.angle, Pt(r2, 0, 1)) + t2.center[e2];
          }
          function cc2(t2) {
            if (t2.z <= 1) return oc[t2.z + 2 * t2.y + t2.x];
            const e2 = mc(dc(t2));
            return ic.fromPoints(e2);
          }
          function hc(t2, e2, r2) {
            return E(t2, t2, 1 - r2), P(t2, t2, e2, r2);
          }
          function pc(t2, e2, r2) {
            for (const n2 of t2) R(n2, n2, e2), E(n2, n2, r2);
          }
          function fc(t2, e2, r2, n2) {
            const i2 = e2 / t2.worldSize, s2 = t2.globeMatrix;
            if (r2.z <= 1) {
              const t3 = cc2(r2).getCorners();
              return pc(t3, s2, i2), ic.fromPoints(t3);
            }
            const o2 = dc(r2, n2), a2 = mc(o2, Tl + sc(t2._tileCoverLift));
            pc(a2, s2, i2);
            const l2 = Number.MAX_VALUE, u5 = [-l2, -l2, -l2], c2 = [l2, l2, l2];
            if (o2.contains(t2.center)) {
              for (const t3 of a2) z(c2, c2, t3), k(u5, u5, t3);
              u5[2] = 0;
              const e3 = t2.point, r3 = [e3.x * i2, e3.y * i2, 0];
              return z(c2, c2, r3), k(u5, u5, r3), new ic(c2, u5);
            }
            if (t2._tileCoverLift > 0) {
              for (const t3 of a2) z(c2, c2, t3), k(u5, u5, t3);
              return new ic(c2, u5);
            }
            const h2 = [s2[12] * i2, s2[13] * i2, s2[14] * i2], p2 = o2.getCenter(), f2 = Pt(t2.center.lat, -tu, tu), d2 = Pt(p2.lat, -tu, tu), m2 = Zl(t2.center.lng), y2 = Wl(f2);
            let g2 = m2 - Zl(p2.lng);
            const x2 = y2 - Wl(d2);
            g2 > 0.5 ? g2 -= 1 : g2 < -0.5 && (g2 += 1);
            let v3 = 0;
            Math.abs(g2) > Math.abs(x2) ? v3 = g2 >= 0 ? 1 : 3 : (v3 = x2 >= 0 ? 0 : 2, P(h2, h2, [s2[4] * i2, s2[5] * i2, s2[6] * i2], -Math.sin(Mt(x2 >= 0 ? o2.getSouth() : o2.getNorth())) * Tl));
            const b2 = a2[v3], _2 = a2[(v3 + 1) % 4], w2 = new lc(b2, _2, h2), A2 = [uc(w2, 0) || b2[0], uc(w2, 1) || b2[1], uc(w2, 2) || b2[2]], I2 = Mc(t2.zoom);
            if (I2 > 0) {
              const n3 = function({ x: t3, y: e3, z: r3 }, n4, i4, s3, o3) {
                const a3 = 1 / (1 << r3);
                let l3 = t3 * a3, u6 = l3 + a3, c3 = e3 * a3, h3 = c3 + a3, p3 = 0;
                const f3 = (l3 + u6) / 2 - s3;
                return f3 > 0.5 ? p3 = -1 : f3 < -0.5 && (p3 = 1), l3 = ((l3 + p3) * n4 - (s3 *= n4)) * i4 + s3, u6 = ((u6 + p3) * n4 - s3) * i4 + s3, c3 = (c3 * n4 - (o3 *= n4)) * i4 + o3, h3 = (h3 * n4 - o3) * i4 + o3, [[l3, h3, 0], [u6, h3, 0], [u6, c3, 0], [l3, c3, 0]];
              }(r2, e2, t2._pixelsPerMercatorPixel, m2, y2);
              for (let t3 = 0; t3 < a2.length; t3++) hc(a2[t3], n3[t3], I2);
              const i3 = M([], n3[v3], n3[(v3 + 1) % 4]);
              E(i3, i3, 0.5), hc(A2, i3, I2);
            }
            for (const t3 of a2) z(c2, c2, t3), k(u5, u5, t3);
            return c2[2] = Math.min(b2[2], _2[2]), z(c2, c2, A2), k(u5, u5, A2), new ic(c2, u5);
          }
          function dc({ x: t2, y: e2, z: r2 }, n2 = false) {
            const i2 = 1 / (1 << r2), s2 = new $l(Kl(t2 * i2), e2 === (1 << r2) - 1 && n2 ? -90 : Jl((e2 + 1) * i2)), o2 = new $l(Kl((t2 + 1) * i2), 0 === e2 && n2 ? 90 : Jl(e2 * i2));
            return new Gl(s2, o2);
          }
          function mc(t2, e2 = Tl) {
            const r2 = Mt(t2.getNorth()), n2 = Mt(t2.getSouth()), i2 = Math.cos(r2), s2 = Math.cos(n2), o2 = Math.sin(r2), a2 = Math.sin(n2), l2 = t2.getWest(), u5 = t2.getEast();
            return [Ol(s2, a2, l2, e2), Ol(s2, a2, u5, e2), Ol(i2, o2, u5, e2), Ol(i2, o2, l2, e2)];
          }
          function yc(t2, e2, r2, n2) {
            const i2 = 1 << r2.z, s2 = (t2 / Tn + r2.x) / i2;
            return Ul(Jl((e2 / Tn + r2.y) / i2), Kl(s2), n2);
          }
          function gc({ min: t2, max: e2 }) {
            return Cl / Math.max(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
          }
          const xc = new Float64Array(16);
          function vc(t2) {
            const e2 = gc(t2), r2 = y(xc, [e2, e2, e2]);
            return h(r2, r2, V([], t2.min));
          }
          function bc4(t2) {
            const e2 = (n2 = t2.min, (r2 = xc)[0] = 1, r2[1] = 0, r2[2] = 0, r2[3] = 0, r2[4] = 0, r2[5] = 1, r2[6] = 0, r2[7] = 0, r2[8] = 0, r2[9] = 0, r2[10] = 1, r2[11] = 0, r2[12] = n2[0], r2[13] = n2[1], r2[14] = n2[2], r2[15] = 1, r2);
            var r2, n2;
            const i2 = 1 / gc(t2);
            return p(e2, e2, [i2, i2, i2]);
          }
          function _c(t2) {
            const e2 = Tn / (2 * Math.PI);
            return t2 / (2 * Math.PI) / e2;
          }
          function wc(t2, e2) {
            return Tn / (512 * Math.pow(2, t2)) * gc(cc2(e2));
          }
          function Ac(t2, e2, r2, n2, i2) {
            const s2 = _c(r2), o2 = [t2, e2, -r2 / (2 * Math.PI)], a2 = l(new Float64Array(16));
            return h(a2, a2, o2), p(a2, a2, [s2, s2, s2]), f(a2, a2, Mt(-i2)), d(a2, a2, Mt(-n2)), a2;
          }
          function Mc(t2) {
            return Tt(Bl, Vl, t2);
          }
          function Ic(t2, e2) {
            const r2 = Ul(e2.lat, e2.lng), n2 = function(t3) {
              const e3 = Ul(t3._center.lat, t3._center.lng);
              let r3 = F([], A(0, 1, 0), e3);
              const n3 = g([], -t3.angle, e3);
              r3 = R(r3, r3, n3), g(n3, -t3._pitch, r3);
              const i3 = C([], e3);
              return E(i3, i3, sc(t3.cameraToCenterDistance / t3.pixelsPerMeter)), R(i3, i3, n3), M([], e3, i3);
            }(t2);
            return o2 = (i2 = I([], n2, r2))[0], a2 = i2[1], l2 = i2[2], u5 = (s2 = r2)[0], c2 = s2[1], h2 = s2[2], f2 = (p2 = Math.sqrt(o2 * o2 + a2 * a2 + l2 * l2) * Math.sqrt(u5 * u5 + c2 * c2 + h2 * h2)) && D2(i2, s2) / p2, Math.acos(Math.min(Math.max(f2, -1), 1));
            var i2, s2, o2, a2, l2, u5, c2, h2, p2, f2;
          }
          function Sc(t2, e2) {
            return Ic(t2, e2) > Math.PI / 2 * 1.01;
          }
          const zc = Mt(85), kc = Math.cos(zc), Ec = Math.sin(zc), Pc = a(), Tc = (t2) => {
            const e2 = [];
            return "map" === t2.paint.get("circle-pitch-alignment") && e2.push("PITCH_WITH_MAP"), "map" === t2.paint.get("circle-pitch-scale") && e2.push("SCALE_WITH_MAP"), e2;
          };
          function Bc(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            if (s2 && t2.queryGeometry.isAboveHorizon) return false;
            s2 && (l2 *= t2.pixelToTileUnitsFactor);
            const u5 = t2.tileID.canonical, c2 = r2.projection.upVectorScale(u5, r2.center.lat, r2.worldSize).metersToTile;
            for (const h2 of e2) for (const e3 of h2) {
              const h3 = e3.add(a2), p2 = i2 && r2.elevation ? r2.elevation.exaggeration() * i2.getElevationAt(h3.x, h3.y, true) : 0, f2 = r2.projection.projectTilePoint(h3.x, h3.y, u5);
              if (p2 > 0) {
                const t3 = r2.projection.upVector(u5, h3.x, h3.y);
                f2.x += t3[0] * c2 * p2, f2.y += t3[1] * c2 * p2, f2.z += t3[2] * c2 * p2;
              }
              const d2 = s2 ? h3 : Vc(f2.x, f2.y, f2.z, n2), m2 = s2 ? t2.tilespaceRays.map((t3) => Fc(t3, p2)) : t2.queryGeometry.screenGeometry, y2 = Z([], [f2.x, f2.y, f2.z, 1], n2);
              if (!o2 && s2 ? l2 *= y2[3] / r2.cameraToCenterDistance : o2 && !s2 && (l2 *= r2.cameraToCenterDistance / y2[3]), s2) {
                const t3 = Jl((e3.y / Tn + u5.y) / (1 << u5.z));
                l2 /= r2.projection.pixelsPerMeter(t3, 1) / Yl(1, t3);
              }
              if (vu(m2, d2, l2)) return true;
            }
            return false;
          }
          function Vc(t2, e2, r2, n2) {
            const i2 = Z([], [t2, e2, r2, 1], n2);
            return new bt(i2[0] / i2[3], i2[1] / i2[3]);
          }
          const Cc = A(0, 0, 0), Dc = A(0, 0, 1);
          function Fc(t2, e2) {
            const r2 = b();
            return Cc[2] = e2, t2.intersectsPlane(Cc, Dc, r2), new bt(r2[0], r2[1]);
          }
          class Lc extends gu {
          }
          let Rc, Oc, Uc, Nc;
          function jc(t2, { width: e2, height: r2 }, n2, i2) {
            if (i2) {
              if (i2 instanceof Uint8ClampedArray) i2 = new Uint8Array(i2.buffer);
              else if (i2.length !== e2 * r2 * n2) throw new RangeError("mismatched image size");
            } else i2 = new Uint8Array(e2 * r2 * n2);
            return t2.width = e2, t2.height = r2, t2.data = i2, t2;
          }
          function $c(t2, e2, r2) {
            const { width: n2, height: i2 } = e2;
            n2 === t2.width && i2 === t2.height || (Gc(t2, e2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2, null), t2.width = n2, t2.height = i2, t2.data = e2.data);
          }
          function Gc(t2, e2, r2, n2, i2, s2, o2, a2) {
            if (0 === i2.width || 0 === i2.height) return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height) throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height) throw new RangeError("out of range destination coordinates for image copy");
            const l2 = t2.data, u5 = e2.data, c2 = 4 === s2 && a2;
            for (let a3 = 0; a3 < i2.height; a3++) {
              const h2 = ((r2.y + a3) * t2.width + r2.x) * s2, p2 = ((n2.y + a3) * e2.width + n2.x) * s2;
              if (c2) for (let t3 = 0; t3 < i2.width; t3++) {
                const e3 = h2 + t3 * s2 + 3, r3 = p2 + t3 * s2;
                u5[r3 + 0] = 255, u5[r3 + 1] = 255, u5[r3 + 2] = 255, u5[r3 + 3] = l2[e3];
              }
              else if (o2) for (let t3 = 0; t3 < i2.width; t3++) {
                const e3 = h2 + t3 * s2, r3 = p2 + t3 * s2, n3 = l2[e3 + 3], i3 = new ir(l2[e3 + 0] / 255 * n3, l2[e3 + 1] / 255 * n3, l2[e3 + 2] / 255 * n3, n3).toRenderColor(o2).toArray();
                u5[r3 + 0] = i3[0], u5[r3 + 1] = i3[1], u5[r3 + 2] = i3[2], u5[r3 + 3] = i3[3];
              }
              else for (let t3 = 0; t3 < i2.width * s2; t3++) u5[p2 + t3] = l2[h2 + t3];
            }
            return e2;
          }
          js(Lc, "HeatmapBucket", { omit: ["layers"] });
          class qc {
            constructor(t2, e2) {
              jc(this, t2, 1, e2);
            }
            resize(t2) {
              $c(this, new qc(t2), 1);
            }
            clone() {
              return new qc({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2) {
              Gc(t2, e2, r2, n2, i2, 1, null);
            }
          }
          class Hc {
            constructor(t2, e2) {
              jc(this, t2, 4, e2);
            }
            resize(t2) {
              $c(this, new Hc(t2), 4);
            }
            replace(t2, e2) {
              e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
            }
            clone() {
              return new Hc({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t2, e2, r2, n2, i2, s2, o2) {
              Gc(t2, e2, r2, n2, i2, 4, s2, o2);
            }
          }
          class Xc {
            constructor(t2, e2) {
              this.width = t2.width, this.height = t2.height, this.data = e2 instanceof Uint8Array ? new Float32Array(e2.buffer) : e2;
            }
          }
          function Zc(t2) {
            const e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new Hc({ width: r2, height: n2 }), s2 = (r3, n3, s3) => {
              e2[t2.evaluationKey] = s3;
              const o2 = t2.expression.evaluate(e2);
              o2 && (i2.data[r3 + n3 + 0] = Math.floor(255 * o2.r / o2.a), i2.data[r3 + n3 + 1] = Math.floor(255 * o2.g / o2.a), i2.data[r3 + n3 + 2] = Math.floor(255 * o2.b / o2.a), i2.data[r3 + n3 + 3] = Math.floor(255 * o2.a));
            };
            if (t2.clips) for (let e3 = 0, i3 = 0; e3 < n2; ++e3, i3 += 4 * r2) for (let n3 = 0, o2 = 0; n3 < r2; n3++, o2 += 4) {
              const a2 = n3 / (r2 - 1), { start: l2, end: u5 } = t2.clips[e3];
              s2(i3, o2, l2 * (1 - a2) + u5 * a2);
            }
            else for (let t3 = 0, e3 = 0; t3 < r2; t3++, e3 += 4) s2(0, e3, t3 / (r2 - 1));
            return i2;
          }
          js(qc, "AlphaImage"), js(Hc, "RGBAImage");
          const Wc = Qo([{ name: "a_pos", components: 2, type: "Int16" }], 4), Yc = Qo([{ name: "a_road_z_offset", components: 1, type: "Float32" }], 4), Kc = Qo([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_height", components: 1, type: "Float32" }], 4), Jc = Qo([{ name: "a_pos_normal_3", components: 3, type: "Int16" }], 4);
          function Qc(t2, e2, r2 = 2) {
            const n2 = e2 && e2.length, i2 = n2 ? e2[0] * r2 : t2.length;
            let s2 = th(t2, 0, i2, r2, true);
            const o2 = [];
            if (!s2 || s2.next === s2.prev) return o2;
            let a2, l2, u5;
            if (n2 && (s2 = function(t3, e3, r3, n3) {
              const i3 = [];
              for (let r4 = 0, s3 = e3.length; r4 < s3; r4++) {
                const o3 = th(t3, e3[r4] * n3, r4 < s3 - 1 ? e3[r4 + 1] * n3 : t3.length, n3, false);
                o3 === o3.next && (o3.steiner = true), i3.push(hh(o3));
              }
              i3.sort(ah);
              for (let t4 = 0; t4 < i3.length; t4++) r3 = lh(i3[t4], r3);
              return r3;
            }(t2, e2, s2, r2)), t2.length > 80 * r2) {
              a2 = 1 / 0, l2 = 1 / 0;
              let e3 = -1 / 0, n3 = -1 / 0;
              for (let s3 = r2; s3 < i2; s3 += r2) {
                const r3 = t2[s3], i3 = t2[s3 + 1];
                r3 < a2 && (a2 = r3), i3 < l2 && (l2 = i3), r3 > e3 && (e3 = r3), i3 > n3 && (n3 = i3);
              }
              u5 = Math.max(e3 - a2, n3 - l2), u5 = 0 !== u5 ? 32767 / u5 : 0;
            }
            return rh(s2, o2, r2, a2, l2, u5, 0), o2;
          }
          function th(t2, e2, r2, n2, i2) {
            let s2;
            if (i2 === function(t3, e3, r3, n3) {
              let i3 = 0;
              for (let s3 = e3, o2 = r3 - n3; s3 < r3; s3 += n3) i3 += (t3[o2] - t3[s3]) * (t3[s3 + 1] + t3[o2 + 1]), o2 = s3;
              return i3;
            }(t2, e2, r2, n2) > 0) for (let i3 = e2; i3 < r2; i3 += n2) s2 = wh(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            else for (let i3 = r2 - n2; i3 >= e2; i3 -= n2) s2 = wh(i3 / n2 | 0, t2[i3], t2[i3 + 1], s2);
            return s2 && yh(s2, s2.next) && (Ah(s2), s2 = s2.next), s2;
          }
          function eh(t2, e2) {
            if (!t2) return t2;
            e2 || (e2 = t2);
            let r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !yh(n2, n2.next) && 0 !== mh(n2.prev, n2, n2.next)) n2 = n2.next;
              else {
                if (Ah(n2), n2 = e2 = n2.prev, n2 === n2.next) break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function rh(t2, e2, r2, n2, i2, s2, o2) {
            if (!t2) return;
            !o2 && s2 && function(t3, e3, r3, n3) {
              let i3 = t3;
              do {
                0 === i3.z && (i3.z = ch(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
              } while (i3 !== t3);
              i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                let e4, r4 = 1;
                do {
                  let n4, i4 = t4;
                  t4 = null;
                  let s3 = null;
                  for (e4 = 0; i4; ) {
                    e4++;
                    let o3 = i4, a3 = 0;
                    for (let t5 = 0; t5 < r4 && (a3++, o3 = o3.nextZ, o3); t5++) ;
                    let l2 = r4;
                    for (; a3 > 0 || l2 > 0 && o3; ) 0 !== a3 && (0 === l2 || !o3 || i4.z <= o3.z) ? (n4 = i4, i4 = i4.nextZ, a3--) : (n4 = o3, o3 = o3.nextZ, l2--), s3 ? s3.nextZ = n4 : t4 = n4, n4.prevZ = s3, s3 = n4;
                    i4 = o3;
                  }
                  s3.nextZ = null, r4 *= 2;
                } while (e4 > 1);
              }(i3);
            }(t2, n2, i2, s2);
            let a2 = t2;
            for (; t2.prev !== t2.next; ) {
              const l2 = t2.prev, u5 = t2.next;
              if (s2 ? ih(t2, n2, i2, s2) : nh(t2)) e2.push(l2.i, t2.i, u5.i), Ah(t2), t2 = u5.next, a2 = u5.next;
              else if ((t2 = u5) === a2) {
                o2 ? 1 === o2 ? rh(t2 = sh(eh(t2), e2), e2, r2, n2, i2, s2, 2) : 2 === o2 && oh(t2, e2, r2, n2, i2, s2) : rh(eh(t2), e2, r2, n2, i2, s2, 1);
                break;
              }
            }
          }
          function nh(t2) {
            const e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (mh(e2, r2, n2) >= 0) return false;
            const i2 = e2.x, s2 = r2.x, o2 = n2.x, a2 = e2.y, l2 = r2.y, u5 = n2.y, c2 = Math.min(i2, s2, o2), h2 = Math.min(a2, l2, u5), p2 = Math.max(i2, s2, o2), f2 = Math.max(a2, l2, u5);
            let d2 = n2.next;
            for (; d2 !== e2; ) {
              if (d2.x >= c2 && d2.x <= p2 && d2.y >= h2 && d2.y <= f2 && fh(i2, a2, s2, l2, o2, u5, d2.x, d2.y) && mh(d2.prev, d2, d2.next) >= 0) return false;
              d2 = d2.next;
            }
            return true;
          }
          function ih(t2, e2, r2, n2) {
            const i2 = t2.prev, s2 = t2, o2 = t2.next;
            if (mh(i2, s2, o2) >= 0) return false;
            const a2 = i2.x, l2 = s2.x, u5 = o2.x, c2 = i2.y, h2 = s2.y, p2 = o2.y, f2 = Math.min(a2, l2, u5), d2 = Math.min(c2, h2, p2), m2 = Math.max(a2, l2, u5), y2 = Math.max(c2, h2, p2), g2 = ch(f2, d2, e2, r2, n2), x2 = ch(m2, y2, e2, r2, n2);
            let v3 = t2.prevZ, b2 = t2.nextZ;
            for (; v3 && v3.z >= g2 && b2 && b2.z <= x2; ) {
              if (v3.x >= f2 && v3.x <= m2 && v3.y >= d2 && v3.y <= y2 && v3 !== i2 && v3 !== o2 && fh(a2, c2, l2, h2, u5, p2, v3.x, v3.y) && mh(v3.prev, v3, v3.next) >= 0) return false;
              if (v3 = v3.prevZ, b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== o2 && fh(a2, c2, l2, h2, u5, p2, b2.x, b2.y) && mh(b2.prev, b2, b2.next) >= 0) return false;
              b2 = b2.nextZ;
            }
            for (; v3 && v3.z >= g2; ) {
              if (v3.x >= f2 && v3.x <= m2 && v3.y >= d2 && v3.y <= y2 && v3 !== i2 && v3 !== o2 && fh(a2, c2, l2, h2, u5, p2, v3.x, v3.y) && mh(v3.prev, v3, v3.next) >= 0) return false;
              v3 = v3.prevZ;
            }
            for (; b2 && b2.z <= x2; ) {
              if (b2.x >= f2 && b2.x <= m2 && b2.y >= d2 && b2.y <= y2 && b2 !== i2 && b2 !== o2 && fh(a2, c2, l2, h2, u5, p2, b2.x, b2.y) && mh(b2.prev, b2, b2.next) >= 0) return false;
              b2 = b2.nextZ;
            }
            return true;
          }
          function sh(t2, e2) {
            let r2 = t2;
            do {
              const n2 = r2.prev, i2 = r2.next.next;
              !yh(n2, i2) && gh(n2, r2, r2.next, i2) && bh(n2, i2) && bh(i2, n2) && (e2.push(n2.i, r2.i, i2.i), Ah(r2), Ah(r2.next), r2 = t2 = i2), r2 = r2.next;
            } while (r2 !== t2);
            return eh(r2);
          }
          function oh(t2, e2, r2, n2, i2, s2) {
            let o2 = t2;
            do {
              let t3 = o2.next.next;
              for (; t3 !== o2.prev; ) {
                if (o2.i !== t3.i && dh(o2, t3)) {
                  let a2 = _h(o2, t3);
                  return o2 = eh(o2, o2.next), a2 = eh(a2, a2.next), rh(o2, e2, r2, n2, i2, s2, 0), void rh(a2, e2, r2, n2, i2, s2, 0);
                }
                t3 = t3.next;
              }
              o2 = o2.next;
            } while (o2 !== t2);
          }
          function ah(t2, e2) {
            let r2 = t2.x - e2.x;
            return 0 === r2 && (r2 = t2.y - e2.y, 0 === r2) && (r2 = (t2.next.y - t2.y) / (t2.next.x - t2.x) - (e2.next.y - e2.y) / (e2.next.x - e2.x)), r2;
          }
          function lh(t2, e2) {
            const r2 = function(t3, e3) {
              let r3 = e3;
              const n3 = t3.x, i2 = t3.y;
              let s2, o2 = -1 / 0;
              if (yh(t3, r3)) return r3;
              do {
                if (yh(t3, r3.next)) return r3.next;
                if (i2 <= r3.y && i2 >= r3.next.y && r3.next.y !== r3.y) {
                  const t4 = r3.x + (i2 - r3.y) * (r3.next.x - r3.x) / (r3.next.y - r3.y);
                  if (t4 <= n3 && t4 > o2 && (o2 = t4, s2 = r3.x < r3.next.x ? r3 : r3.next, t4 === n3)) return s2;
                }
                r3 = r3.next;
              } while (r3 !== e3);
              if (!s2) return null;
              const a2 = s2, l2 = s2.x, u5 = s2.y;
              let c2 = 1 / 0;
              r3 = s2;
              do {
                if (n3 >= r3.x && r3.x >= l2 && n3 !== r3.x && ph(i2 < u5 ? n3 : o2, i2, l2, u5, i2 < u5 ? o2 : n3, i2, r3.x, r3.y)) {
                  const e4 = Math.abs(i2 - r3.y) / (n3 - r3.x);
                  bh(r3, t3) && (e4 < c2 || e4 === c2 && (r3.x > s2.x || r3.x === s2.x && uh(s2, r3))) && (s2 = r3, c2 = e4);
                }
                r3 = r3.next;
              } while (r3 !== a2);
              return s2;
            }(t2, e2);
            if (!r2) return e2;
            const n2 = _h(r2, t2);
            return eh(n2, n2.next), eh(r2, r2.next);
          }
          function uh(t2, e2) {
            return mh(t2.prev, t2, e2.prev) < 0 && mh(e2.next, t2, t2.next) < 0;
          }
          function ch(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = (t2 - r2) * i2 | 0) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = (e2 - n2) * i2 | 0) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function hh(t2) {
            let e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function ph(t2, e2, r2, n2, i2, s2, o2, a2) {
            return (i2 - o2) * (e2 - a2) >= (t2 - o2) * (s2 - a2) && (t2 - o2) * (n2 - a2) >= (r2 - o2) * (e2 - a2) && (r2 - o2) * (s2 - a2) >= (i2 - o2) * (n2 - a2);
          }
          function fh(t2, e2, r2, n2, i2, s2, o2, a2) {
            return !(t2 === o2 && e2 === a2) && ph(t2, e2, r2, n2, i2, s2, o2, a2);
          }
          function dh(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              let r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && gh(r2, r2.next, t3, e3)) return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (bh(t2, e2) && bh(e2, t2) && function(t3, e3) {
              let r2 = t3, n2 = false;
              const i2 = (t3.x + e3.x) / 2, s2 = (t3.y + e3.y) / 2;
              do {
                r2.y > s2 != r2.next.y > s2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (s2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (mh(t2.prev, t2, e2.prev) || mh(t2, e2.prev, e2)) || yh(t2, e2) && mh(t2.prev, t2, t2.next) > 0 && mh(e2.prev, e2, e2.next) > 0);
          }
          function mh(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function yh(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function gh(t2, e2, r2, n2) {
            const i2 = vh(mh(t2, e2, r2)), s2 = vh(mh(t2, e2, n2)), o2 = vh(mh(r2, n2, t2)), a2 = vh(mh(r2, n2, e2));
            return i2 !== s2 && o2 !== a2 || !(0 !== i2 || !xh(t2, r2, e2)) || !(0 !== s2 || !xh(t2, n2, e2)) || !(0 !== o2 || !xh(r2, t2, n2)) || !(0 !== a2 || !xh(r2, e2, n2));
          }
          function xh(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function vh(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function bh(t2, e2) {
            return mh(t2.prev, t2, t2.next) < 0 ? mh(t2, e2, t2.next) >= 0 && mh(t2, t2.prev, e2) >= 0 : mh(t2, e2, t2.prev) < 0 || mh(t2, t2.next, e2) < 0;
          }
          function _h(t2, e2) {
            const r2 = Mh(t2.i, t2.x, t2.y), n2 = Mh(e2.i, e2.x, e2.y), i2 = t2.next, s2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, s2.next = n2, n2.prev = s2, n2;
          }
          function wh(t2, e2, r2, n2) {
            const i2 = Mh(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function Ah(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function Mh(t2, e2, r2) {
            return { i: t2, x: e2, y: r2, prev: null, next: null, z: 0, prevZ: null, nextZ: null, steiner: false };
          }
          function Ih(t2, e2) {
            const r2 = t2.length;
            if (r2 <= 1) return [t2];
            const n2 = [];
            let i2, s2;
            for (let e3 = 0; e3 < r2; e3++) {
              const r3 = qt(t2[e3]);
              0 !== r3 && (t2[e3].area = Math.abs(r3), void 0 === s2 && (s2 = r3 < 0), s2 === r3 < 0 ? (i2 && n2.push(i2), i2 = [t2[e3]]) : i2.push(t2[e3]));
            }
            if (i2 && n2.push(i2), e2 > 1) for (let t3 = 0; t3 < n2.length; t3++) n2[t3].length <= e2 || (Jr(n2[t3], e2, 1, n2[t3].length - 1, Sh), n2[t3] = n2[t3].slice(0, e2));
            return n2;
          }
          function Sh(t2, e2) {
            return e2.area - t2.area;
          }
          function zh(t2, e2, r2 = 1) {
            if (!t2) return null;
            const n2 = "string" == typeof t2 ? Vr.from(t2).getPrimary() : t2.getPrimary(), i2 = "string" == typeof t2 ? null : t2.getSecondary();
            for (const t3 of [n2, i2]) {
              if (!t3) continue;
              const n3 = t3.id.toString();
              e2.has(n3) || e2.set(n3, []), t3.scaleSelf(r2), e2.get(n3).push(t3);
            }
            return { primary: n2.toString(), secondary: i2 ? i2.toString() : null };
          }
          function kh(t2, e2, r2, n2) {
            const i2 = n2.patternDependencies;
            let s2 = false;
            for (const n3 of e2) {
              const e3 = n3.paint.get(`${t2}-pattern`);
              e3.isConstant() || (s2 = true), zh(e3.constantOr(null), i2, r2) && (s2 = true);
            }
            return s2;
          }
          function Eh(t2, e2, r2, n2, i2, s2) {
            const o2 = s2.patternDependencies;
            for (const a2 of e2) {
              const e3 = a2.paint.get(`${t2}-pattern`).value;
              if ("constant" !== e3.kind) {
                let t3 = e3.evaluate({ zoom: n2 }, r2, {}, s2.availableImages);
                t3 = t3 && t3.name ? t3.name : t3;
                const l2 = zh(t3, o2, i2);
                if (!l2) continue;
                const { primary: u5, secondary: c2 } = l2;
                u5 && (r2.patterns[a2.id] = [u5, c2].filter(Boolean));
              }
            }
            return r2;
          }
          var Ph, Th, Bh, Vh, Ch, Dh, Fh, Lh = {};
          function Rh() {
            if (Th) return Ph;
            Th = 1;
            var t2 = vt();
            function e2(t3, e3, n3, i2, s2) {
              this.properties = {}, this.extent = n3, this.type = 0, this._pbf = t3, this._geometry = -1, this._keys = i2, this._values = s2, t3.readFields(r2, this, e3);
            }
            function r2(t3, e3, r3) {
              1 == t3 ? e3.id = r3.readVarint() : 2 == t3 ? function(t4, e4) {
                for (var r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n3 = e4._keys[t4.readVarint()], i2 = e4._values[t4.readVarint()];
                  e4.properties[n3] = i2;
                }
              }(r3, e3) : 3 == t3 ? e3.type = r3.readVarint() : 4 == t3 && (e3._geometry = r3.pos);
            }
            function n2(t3) {
              for (var e3, r3, n3 = 0, i2 = 0, s2 = t3.length, o2 = s2 - 1; i2 < s2; o2 = i2++) n3 += ((r3 = t3[o2]).x - (e3 = t3[i2]).x) * (e3.y + r3.y);
              return n3;
            }
            return Ph = e2, e2.types = ["Unknown", "Point", "LineString", "Polygon"], e2.prototype.loadGeometry = function() {
              var e3 = this._pbf;
              e3.pos = this._geometry;
              for (var r3, n3 = e3.readVarint() + e3.pos, i2 = 1, s2 = 0, o2 = 0, a2 = 0, l2 = []; e3.pos < n3; ) {
                if (s2 <= 0) {
                  var u5 = e3.readVarint();
                  i2 = 7 & u5, s2 = u5 >> 3;
                }
                if (s2--, 1 === i2 || 2 === i2) o2 += e3.readSVarint(), a2 += e3.readSVarint(), 1 === i2 && (r3 && l2.push(r3), r3 = []), r3.push(new t2(o2, a2));
                else {
                  if (7 !== i2) throw new Error("unknown command " + i2);
                  r3 && r3.push(r3[0].clone());
                }
              }
              return r3 && l2.push(r3), l2;
            }, e2.prototype.bbox = function() {
              var t3 = this._pbf;
              t3.pos = this._geometry;
              for (var e3 = t3.readVarint() + t3.pos, r3 = 1, n3 = 0, i2 = 0, s2 = 0, o2 = 1 / 0, a2 = -1 / 0, l2 = 1 / 0, u5 = -1 / 0; t3.pos < e3; ) {
                if (n3 <= 0) {
                  var c2 = t3.readVarint();
                  r3 = 7 & c2, n3 = c2 >> 3;
                }
                if (n3--, 1 === r3 || 2 === r3) (i2 += t3.readSVarint()) < o2 && (o2 = i2), i2 > a2 && (a2 = i2), (s2 += t3.readSVarint()) < l2 && (l2 = s2), s2 > u5 && (u5 = s2);
                else if (7 !== r3) throw new Error("unknown command " + r3);
              }
              return [o2, l2, a2, u5];
            }, e2.prototype.toGeoJSON = function(t3, r3, i2) {
              var s2, o2, a2 = this.extent * Math.pow(2, i2), l2 = this.extent * t3, u5 = this.extent * r3, c2 = this.loadGeometry(), h2 = e2.types[this.type];
              function p2(t4) {
                for (var e3 = 0; e3 < t4.length; e3++) {
                  var r4 = t4[e3];
                  t4[e3] = [360 * (r4.x + l2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r4.y + u5) / a2) * Math.PI / 180)) - 90];
                }
              }
              switch (this.type) {
                case 1:
                  var f2 = [];
                  for (s2 = 0; s2 < c2.length; s2++) f2[s2] = c2[s2][0];
                  p2(c2 = f2);
                  break;
                case 2:
                  for (s2 = 0; s2 < c2.length; s2++) p2(c2[s2]);
                  break;
                case 3:
                  for (c2 = function(t4) {
                    var e3 = t4.length;
                    if (e3 <= 1) return [t4];
                    for (var r4, i3, s3 = [], o3 = 0; o3 < e3; o3++) {
                      var a3 = n2(t4[o3]);
                      0 !== a3 && (void 0 === i3 && (i3 = a3 < 0), i3 === a3 < 0 ? (r4 && s3.push(r4), r4 = [t4[o3]]) : r4.push(t4[o3]));
                    }
                    return r4 && s3.push(r4), s3;
                  }(c2), s2 = 0; s2 < c2.length; s2++) for (o2 = 0; o2 < c2[s2].length; o2++) p2(c2[s2][o2]);
              }
              1 === c2.length ? c2 = c2[0] : h2 = "Multi" + h2;
              var d2 = { type: "Feature", geometry: { type: h2, coordinates: c2 }, properties: this.properties };
              return "id" in this && (d2.id = this.id), d2;
            }, Ph;
          }
          function Oh() {
            if (Vh) return Bh;
            Vh = 1;
            var t2 = Rh();
            function e2(t3, e3) {
              this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t3, this._keys = [], this._values = [], this._features = [], t3.readFields(r2, this, e3), this.length = this._features.length;
            }
            function r2(t3, e3, r3) {
              15 === t3 ? e3.version = r3.readVarint() : 1 === t3 ? e3.name = r3.readString() : 5 === t3 ? e3.extent = r3.readVarint() : 2 === t3 ? e3._features.push(r3.pos) : 3 === t3 ? e3._keys.push(r3.readString()) : 4 === t3 && e3._values.push(function(t4) {
                for (var e4 = null, r4 = t4.readVarint() + t4.pos; t4.pos < r4; ) {
                  var n2 = t4.readVarint() >> 3;
                  e4 = 1 === n2 ? t4.readString() : 2 === n2 ? t4.readFloat() : 3 === n2 ? t4.readDouble() : 4 === n2 ? t4.readVarint64() : 5 === n2 ? t4.readVarint() : 6 === n2 ? t4.readSVarint() : 7 === n2 ? t4.readBoolean() : null;
                }
                return e4;
              }(r3));
            }
            return Bh = e2, e2.prototype.feature = function(e3) {
              if (e3 < 0 || e3 >= this._features.length) throw new Error("feature index out of bounds");
              this._pbf.pos = this._features[e3];
              var r3 = this._pbf.readVarint() + this._pbf.pos;
              return new t2(this._pbf, r3, this.extent, this._keys, this._values);
            }, Bh;
          }
          function Uh() {
            return Fh || (Fh = 1, Lh.VectorTile = function() {
              if (Dh) return Ch;
              Dh = 1;
              var t2 = Oh();
              function e2(e3, r2, n2) {
                if (3 === e3) {
                  var i2 = new t2(n2, n2.readVarint() + n2.pos);
                  i2.length && (r2[i2.name] = i2);
                }
              }
              return Ch = function(t3, r2) {
                this.layers = t3.readFields(e2, {}, r2);
              }, Ch;
            }(), Lh.VectorTileFeature = Rh(), Lh.VectorTileLayer = Oh()), Lh;
          }
          var Nh = Uh();
          const jh = "3d_elevation_id", $h = "level";
          class Gh {
            constructor() {
              this._valid = false;
            }
            reset(t2) {
              return this.feature = t2, this._valid = true, this._geometry = t2.loadGeometry(), 0 !== this._geometry.length && 0 !== this._geometry[0].length || (this._valid = false), this;
            }
            geometry(t2, e2) {
              return this._valid && t2(e2(this._geometry)), this;
            }
            require(t2, e2, r2) {
              return this.get(t2, true, e2, r2);
            }
            optional(t2, e2, r2) {
              return this.get(t2, false, e2, r2);
            }
            success() {
              return this._valid;
            }
            get(t2, e2, r2, n2) {
              const i2 = this.feature.properties.hasOwnProperty(t2) ? +this.feature.properties[t2] : void 0;
              return this._valid && void 0 !== i2 && !Number.isNaN(i2) ? r2(n2 ? n2(i2) : i2) : e2 && (this._valid = false), this;
            }
          }
          class qh {
            constructor(t2, e2) {
              this.featureFunc = t2, this.vertexFunc = e2;
            }
            parseFeature(t2, e2, r2) {
              return this.featureFunc(t2, e2, r2);
            }
            parseVertex(t2, e2, r2) {
              return this.vertexFunc(t2, e2, r2);
            }
          }
          const Hh = new qh((t2, e2, r2) => t2.reset(e2).require(jh, (t3) => {
            r2.id = t3;
          }).optional("fixed_height_relative", (t3) => {
            r2.constantHeight = t3;
          }, Zh.decodeRelativeHeight).geometry((t3) => {
            r2.bounds = t3;
          }, un).success(), (t2, e2, r2) => t2.reset(e2).require(jh, (t3) => {
            r2.id = t3;
          }).require("elevation_idx", (t3) => {
            r2.idx = t3;
          }).require("extent", (t3) => {
            r2.extent = t3;
          }).require("height_relative", (t3) => {
            r2.height = t3;
          }, Zh.decodeRelativeHeight).geometry((t3) => {
            r2.position = t3;
          }, Zh.getPoint).success()), Xh = new qh((t2, e2, r2) => t2.reset(e2).require(jh, (t3) => {
            r2.id = t3;
          }).optional("fixed_height", (t3) => {
            r2.constantHeight = t3;
          }, Zh.decodeMetricHeight).geometry((t3) => {
            r2.bounds = t3;
          }, un).success(), (t2, e2, r2) => t2.reset(e2).require(jh, (t3) => {
            r2.id = t3;
          }).require("elevation_idx", (t3) => {
            r2.idx = t3;
          }).require("extent", (t3) => {
            r2.extent = t3;
          }).require("height", (t3) => {
            r2.height = t3;
          }, Zh.decodeMetricHeight).geometry((t3) => {
            r2.position = t3;
          }, Zh.getPoint).success());
          class Zh {
            static getPoint(t2) {
              return at(t2[0][0].x, t2[0][0].y);
            }
            static decodeRelativeHeight(t2) {
              return 1e-4 * t2 * 5;
            }
            static decodeMetricHeight(t2) {
              return 1e-4 * t2;
            }
            static parse(t2) {
              const e2 = [], r2 = [], n2 = t2.length, i2 = new Gh();
              for (let o2 = 0; o2 < n2; o2++) {
                const n3 = t2.feature(o2), a2 = n3.properties.hasOwnProperty("version") ? String(n3.properties.version) : void 0, l2 = (s2 = a2) ? "1.0.1" === s2 ? Xh : void 0 : Hh;
                if (void 0 === l2) {
                  $t(`Unknown elevation feature version number ${a2 || "(unknown)"}`);
                  continue;
                }
                const u5 = n3.properties.hasOwnProperty("type") ? n3.properties.type : void 0;
                if (u5) {
                  if ("Point" === Nh.VectorTileFeature.types[n3.type] && "curve_point" === u5) {
                    const t3 = {};
                    l2.parseVertex(i2, n3, t3) && e2.push(t3);
                  } else if ("Polygon" === Nh.VectorTileFeature.types[n3.type] && "curve_meta" === u5) {
                    const t3 = {};
                    l2.parseFeature(i2, n3, t3) && r2.push(t3);
                  }
                }
              }
              var s2;
              return { vertices: e2, features: r2 };
            }
          }
          class Wh {
            constructor(t2, e2) {
              this.feature = t2, this.metersToTile = e2, this.index = 0;
            }
            get() {
              const t2 = this.feature.vertices[this.index], e2 = this.feature.vertexProps[this.index].dir, r2 = e2[1], n2 = -e2[0], i2 = (t2.extent + 1) * this.metersToTile;
              return [new bt(Math.trunc(t2.position[0] + r2 * i2), Math.trunc(t2.position[1] + n2 * i2)), new bt(Math.trunc(t2.position[0] - r2 * i2), Math.trunc(t2.position[1] - n2 * i2))];
            }
            next() {
              this.index++;
            }
            valid() {
              return this.index < this.feature.vertices.length;
            }
          }
          class Yh {
            constructor(t2, e2, r2, n2, i2, s2) {
              if (this.vertices = new Array(), this.vertexProps = new Array(), this.edges = new Array(), this.edgeProps = new Array(), this.id = t2, this.heightRange = { min: r2, max: r2 }, this.safeArea = e2, this.constantHeight = r2, null == this.constantHeight && (null != this.constantHeight || 0 !== n2.length)) {
                this.vertices = n2, this.edges = i2, this.edges = this.edges.filter((t3) => {
                  return t3.a < this.vertices.length && t3.b < this.vertices.length && !((e3 = this.vertices[t3.a].position)[0] === (r3 = this.vertices[t3.b].position)[0] && e3[1] === r3[1]);
                  var e3, r3;
                }), this.heightRange = { min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY };
                for (const t3 of this.vertices) this.vertexProps.push({ dir: at(0, 0) }), this.heightRange.min = Math.min(this.heightRange.min, t3.height), this.heightRange.max = Math.max(this.heightRange.max, t3.height);
                for (const t3 of this.edges) {
                  const e3 = this.vertices[t3.a].position, r3 = this.vertices[t3.b].position, n3 = ut(ot(), r3, e3), i3 = ht(n3), s3 = ct(ot(), n3, 1 / i3);
                  this.edgeProps.push({ vec: n3, dir: s3, len: i3 });
                  const o2 = this.vertexProps[t3.a].dir, a2 = this.vertexProps[t3.b].dir;
                  lt(o2, o2, s3), lt(a2, a2, s3);
                }
                for (const t3 of this.vertexProps) 0 === t3.dir[0] && 0 === t3.dir[1] || pt(t3.dir, t3.dir);
                this.tessellate(s2);
              }
            }
            pointElevation(t2) {
              if (null != this.constantHeight) return this.constantHeight;
              const e2 = this.getClosestEdge(t2);
              if (null == e2) return 0;
              const [r2, n2] = e2;
              return ((t3, e3, r3) => (1 - r3) * t3 + r3 * e3)(this.vertices[this.edges[r2].a].height, this.vertices[this.edges[r2].b].height, n2);
            }
            getSafeArea() {
              return this.safeArea;
            }
            isTunnel() {
              return this.heightRange.max <= -5;
            }
            getClosestEdge(t2) {
              if (0 === this.edges.length) return;
              let e2 = 0, r2 = Number.POSITIVE_INFINITY, n2 = 0;
              const i2 = at(t2.x, t2.y);
              for (let t3 = 0; t3 < this.edges.length; t3++) {
                const s2 = this.edges[t3], o2 = this.edgeProps[t3].dir, a2 = new Yu(i2, this.edgeProps[t3].dir), l2 = this.vertices[s2.a].position, u5 = this.vertices[s2.b].position, c2 = ot(), h2 = ot(), p2 = a2.intersectsPlane(l2, this.vertexProps[s2.a].dir, c2), f2 = a2.intersectsPlane(u5, this.vertexProps[s2.b].dir, h2);
                if (!p2 || !f2) continue;
                const d2 = ut(ot(), h2, c2), m2 = ut(ot(), i2, c2), y2 = ft(d2, d2), g2 = y2 > 0 ? ft(m2, d2) / y2 : 0, x2 = Pt(g2, 0, 1), v3 = Math.abs((g2 - x2) * this.edgeProps[t3].len), b2 = ut(ot(), i2, l2), _2 = v3 + Math.abs(ft(b2, at(o2[1], -o2[0])));
                _2 < r2 && (e2 = t3, r2 = _2, n2 = x2);
              }
              return [e2, n2];
            }
            tessellate(t2) {
              for (let e2 = this.edges.length - 1; e2 >= 0; --e2) {
                const r2 = this.edges[e2].a, n2 = this.edges[e2].b, { position: i2, height: s2, extent: o2 } = this.vertices[r2], { position: a2, height: l2, extent: u5 } = this.vertices[n2], c2 = this.vertexProps[r2].dir, h2 = this.vertexProps[n2].dir, p2 = A(i2[0] / t2, i2[1] / t2, s2), f2 = A(a2[0] / t2, a2[1] / t2, l2), d2 = A(c2[1], -c2[0], 0);
                E(d2, d2, o2);
                const m2 = A(h2[1], -h2[0], 0);
                if (E(m2, m2, u5), this.distSqLines(A(p2[0] + 0.5 * d2[0], p2[1] + 0.5 * d2[1], p2[2] + 0.5 * d2[2]), A(f2[0] - 0.5 * m2[0], f2[1] - 0.5 * m2[1], f2[2] - 0.5 * m2[2]), A(p2[0] - 0.5 * d2[0], p2[1] - 0.5 * d2[1], p2[2] - 0.5 * d2[2]), A(f2[0] + 0.5 * m2[0], f2[1] + 0.5 * m2[1], f2[2] + 0.5 * m2[2])) <= 0.0025000000000000005) continue;
                const y2 = this.vertices.length, g2 = lt(ot(), i2, a2);
                this.vertices.push({ position: ct(g2, g2, 0.5), height: 0.5 * (s2 + l2), extent: 0.5 * (o2 + u5) });
                const x2 = lt(ot(), c2, h2);
                this.vertexProps.push({ dir: pt(x2, x2) }), this.edges.splice(e2, 1), this.edgeProps.splice(e2, 1), this.edges.push({ a: r2, b: y2 }), this.edges.push({ a: y2, b: n2 });
                const v3 = ut(ot(), this.vertices[y2].position, i2), b2 = ht(v3), _2 = { vec: v3, dir: ct(ot(), v3, 1 / b2), len: b2 };
                this.edgeProps.push(_2), this.edgeProps.push(_2);
              }
            }
            distSqLines(t2, e2, r2, n2) {
              const i2 = I(b(), e2, t2), s2 = I(b(), n2, r2), o2 = I(b(), t2, r2), a2 = D2(i2, i2), l2 = D2(i2, s2), u5 = D2(i2, o2), c2 = D2(s2, s2), h2 = D2(s2, o2), p2 = a2 * c2 - l2 * l2;
              if (0 === p2) {
                const e3 = D2(o2, s2) / D2(s2, s2);
                return T(L(b(), r2, n2, e3), t2);
              }
              const f2 = (l2 * h2 - u5 * c2) / p2, d2 = (a2 * h2 - l2 * u5) / p2;
              return T(L(b(), t2, e2, f2), L(b(), r2, n2, d2));
            }
          }
          class Kh {
            static parseFrom(t2, e2) {
              const r2 = Zh.parse(t2);
              if (!r2) return [];
              let { vertices: n2, features: i2 } = r2;
              const s2 = 1 / iu(e2);
              i2.sort((t3, e3) => t3.id - e3.id), n2.sort((t3, e3) => t3.id - e3.id || t3.idx - e3.idx), n2 = n2.filter((t3, e3, r3) => e3 === r3.findIndex((e4) => e4.id === t3.id && e4.idx === t3.idx));
              const o2 = new Array();
              let a2 = 0;
              const l2 = n2.length;
              for (const t3 of i2) {
                if (t3.constantHeight) {
                  o2.push(new Yh(t3.id, t3.bounds, t3.constantHeight));
                  continue;
                }
                for (; a2 !== l2 && n2[a2].id < t3.id; ) a2++;
                if (a2 === l2 || n2[a2].id !== t3.id) continue;
                const e3 = new Array(), r3 = new Array(), i3 = a2;
                for (; a2 !== l2 && n2[a2].id === t3.id; ) {
                  const t4 = n2[a2];
                  if (e3.push({ position: t4.position, height: t4.height, extent: t4.extent }), a2 !== i3 && n2[a2 - 1].idx === t4.idx - 1) {
                    const t5 = a2 - i3;
                    r3.push({ a: t5 - 1, b: t5 });
                  }
                  a2++;
                }
                o2.push(new Yh(t3.id, t3.bounds, void 0, e3, r3, s2));
              }
              return o2;
            }
            static getElevationFeature(t2, e2) {
              if (!e2) return;
              const r2 = +t2.properties[jh];
              return Number.isNaN(r2) ? void 0 : e2.find((t3) => t3.id === r2);
            }
          }
          class Jh {
            constructor(t2, e2) {
              this.zScale = 1, this.xOffset = 0, this.yOffset = 0, t2.equals(e2) || (this.zScale = Math.pow(2, e2.z - t2.z), this.xOffset = (t2.x * this.zScale - e2.x) * Tn, this.yOffset = (t2.y * this.zScale - e2.y) * Tn);
            }
            constantElevation(t2, e2) {
              if (null != t2.constantHeight) return this.computeBiasedHeight(t2.constantHeight, e2);
            }
            pointElevation(t2, e2, r2) {
              const n2 = this.constantElevation(e2, r2);
              return null != n2 ? n2 : (t2.x = t2.x * this.zScale + this.xOffset, t2.y = t2.y * this.zScale + this.yOffset, this.computeBiasedHeight(e2.pointElevation(t2), r2));
            }
            computeBiasedHeight(t2, e2) {
              return e2 <= 0 ? t2 : t2 + e2 * Tt(0, e2, t2 >= 0 ? t2 : Math.abs(0.5 * t2));
            }
          }
          js(Yh, "ElevationFeature");
          class Qh {
            constructor() {
              this.polygons = /* @__PURE__ */ new Map();
            }
            add(t2, ...e2) {
              this.polygons.has(t2) ? this.polygons.get(t2).push(...e2) : this.polygons.set(t2, e2);
            }
            merge(t2) {
              for (const [e2, r2] of t2.polygons) this.add(e2, ...r2);
            }
          }
          class tp {
            constructor() {
              this.portals = [];
            }
            static evaluate(t2) {
              if (0 === t2.length) return new tp();
              let e2 = [];
              for (const r3 of t2) e2.push(...r3.portals);
              if (0 === e2.length) return new tp();
              const r2 = (t3, e3) => t3 <= 0 && e3 <= 0 || t3 >= Tn && e3 >= Tn;
              for (const t3 of e2) {
                const e3 = t3.va, n3 = t3.vb;
                (r2(e3.x, n3.x) || r2(e3.y, n3.y)) && (t3.type = "border");
              }
              const n2 = e2.filter((t3) => "unevaluated" !== t3.type), i2 = e2.filter((t3) => "unevaluated" === t3.type);
              if (0 === i2.length) return new tp();
              i2.sort((t3, e3) => t3.hash === e3.hash ? t3.isTunnel === e3.isTunnel ? 0 : t3.isTunnel ? -1 : 1 : t3.hash < e3.hash ? 1 : -1), e2 = n2.concat(i2);
              let s2 = n2.length, o2 = s2, a2 = s2;
              do {
                if (o2++, o2 === e2.length || e2[s2].hash !== e2[o2].hash) {
                  if (o2 - s2 == 2) {
                    a2 < s2 && (e2[a2] = e2[s2], e2[s2] = null);
                    const t3 = e2[a2], r3 = e2[o2 - 1];
                    t3.type = t3.isTunnel !== r3.isTunnel ? "tunnel" : "polygon", t3.connection = { a: t3.connection.a, b: r3.connection.a }, a2++;
                  }
                  s2 = o2;
                }
              } while (s2 !== e2.length);
              return e2.splice(a2), e2.sort((t3, e3) => t3.hash < e3.hash ? 1 : -1), { portals: e2 };
            }
          }
          js(tp, "ElevationPortalGraph"), js(Qh, "ElevationPolygons");
          class ep {
            constructor(t2, e2, r2) {
              this.outPositions = t2, this.outNormals = e2, this.outIndices = r2, this.vertexLookup = /* @__PURE__ */ new Map(), this.buffer = new ArrayBuffer(4), this.view = new DataView(this.buffer);
            }
            addVertex(t2, e2, r2) {
              let n2 = t2[2];
              null != r2 && (n2 *= r2);
              const i2 = this.getVec3Bits(t2) << 96n | this.getVec3Bits(e2), s2 = this.vertexLookup.get(i2);
              if (null != s2) return s2;
              const o2 = this.outPositions.length;
              this.vertexLookup.set(i2, o2);
              const a2 = Math.trunc(16384 * e2[0]), l2 = Math.trunc(16384 * e2[1]), u5 = Math.trunc(16384 * e2[2]);
              return this.outPositions.emplaceBack(t2[0], t2[1], n2), this.outNormals.emplaceBack(a2, l2, u5), o2;
            }
            addVertices(t2, e2, ...r2) {
              const n2 = [];
              for (const i2 of r2) {
                const r3 = this.addVertex(i2, t2, e2);
                n2.push(r3);
              }
              return n2;
            }
            addTriangles(t2, e2, r2) {
              if (e2 && r2) {
                const n2 = 1 === r2.length, i2 = A(0, 0, 0);
                for (let s2 = 0; s2 < t2.length; s2 += 3) {
                  const o2 = e2[t2[s2 + 0]], a2 = e2[t2[s2 + 1]], l2 = e2[t2[s2 + 2]], u5 = n2 ? r2[0] : r2[t2[s2 + 1]], c2 = n2 ? r2[0] : r2[t2[s2 + 2]], h2 = this.addVertex(A(o2.x, o2.y, n2 ? r2[0] : r2[t2[s2 + 0]]), i2), p2 = this.addVertex(A(a2.x, a2.y, u5), i2), f2 = this.addVertex(A(l2.x, l2.y, c2), i2);
                  this.outIndices.emplaceBack(h2, p2, f2);
                }
              } else for (let e3 = 0; e3 < t2.length; e3 += 3) this.outIndices.emplaceBack(t2[e3 + 0], t2[e3 + 1], t2[e3 + 2]);
            }
            addQuad(t2, e2) {
              const r2 = this.addVertices(e2, void 0, ...t2.map((t3) => A(t3.coord.x, t3.coord.y, t3.height))), [n2, i2, s2, o2] = r2;
              this.addTriangles([n2, i2, s2, s2, o2, n2]);
            }
            getBits(t2) {
              return this.view.setFloat32(0, t2), BigInt(this.view.getUint32(0));
            }
            getVec3Bits(t2) {
              return this.getBits(t2[0]) << 64n | this.getBits(t2[1]) << 32n | this.getBits(t2[2]);
            }
          }
          class rp {
            constructor(t2) {
              this.unevaluatedPortals = new tp(), this.portalPolygons = new Qh(), this.vertexHashLookup = /* @__PURE__ */ new Map(), this.unevalVertices = [], this.unevalHeights = [], this.unevalTriangles = [], this.unevalTunnelTriangles = [], this.unevalEdges = [], this.vertexPositions = new sa(), this.vertexNormals = new oa(), this.indexArray = new wa(), this.tileToMeters = iu(t2);
            }
            addVertices(t2, e2) {
              const r2 = this.unevalVertices.length;
              for (let r3 = 0; r3 < t2.length; r3++) this.unevalVertices.push(t2[r3]), this.unevalHeights.push(e2[r3]);
              return r2;
            }
            addTriangles(t2, e2, r2) {
              const n2 = r2 ? this.unevalTunnelTriangles : this.unevalTriangles;
              for (const r3 of t2) n2.push(r3 + e2);
            }
            addRenderableRing(t2, e2, r2, n2, i2) {
              const s2 = [new bt(i2.min.x, i2.min.y), new bt(i2.max.x, i2.min.y), new bt(i2.max.x, i2.max.y), new bt(i2.min.x, i2.max.y)];
              for (let o2 = 0; o2 < r2 - 1; o2++) {
                const r3 = e2 + o2, a2 = r3 + 1, l2 = this.unevalVertices[r3], u5 = this.unevalVertices[a2];
                if (!(l2.x >= i2.min.x && l2.x <= i2.max.x && l2.y >= i2.min.y && l2.y <= i2.max.y || u5.x >= i2.min.x && u5.x <= i2.max.x && u5.y >= i2.min.y && u5.y <= i2.max.y || Tu(l2, u5, s2))) continue;
                if (this.isOnBorder(l2.x, u5.x) || this.isOnBorder(l2.y, u5.y)) continue;
                const c2 = rp.computeEdgeHash(this.unevalVertices[r3], this.unevalVertices[a2]);
                let h2, p2 = this.vertexHashLookup.get(rp.computePosHash(l2));
                null != p2 ? h2 = p2.next : (p2 = this.vertexHashLookup.get(rp.computePosHash(u5)), h2 = null != p2 ? p2.prev : c2), this.unevalEdges.push({ polygonIdx: t2, a: r3, b: a2, hash: c2, portalHash: h2, isTunnel: n2, type: "unevaluated" });
              }
            }
            addPortalCandidates(t2, e2, r2, n2, i2) {
              if (0 === e2.length) return;
              this.portalPolygons.add(t2, { geometry: e2, zLevel: i2 });
              const s2 = e2[0];
              this.vertexHashLookup.clear();
              let o2 = rp.computeEdgeHash(s2[s2.length - 2], s2[s2.length - 1]);
              for (let e3 = 0; e3 < s2.length - 1; e3++) {
                const i3 = s2[e3 + 0], a2 = s2[e3 + 1], l2 = at(a2.x - i3.x, a2.y - i3.y), u5 = ht(l2);
                if (0 === u5) continue;
                let c2 = "unevaluated";
                const h2 = n2.pointElevation(i3), p2 = n2.pointElevation(a2);
                Math.abs(h2) < 0.01 && Math.abs(p2) < 0.01 ? c2 = "entrance" : (this.isOnBorder(i3.x, a2.x) || this.isOnBorder(i3.y, a2.y)) && (c2 = "border");
                const f2 = rp.computeEdgeHash(i3, a2);
                this.unevaluatedPortals.portals.push({ connection: { a: t2, b: void 0 }, va: i3, vb: a2, vab: l2, length: u5, hash: f2, isTunnel: r2, type: c2 });
                const d2 = rp.computePosHash(i3);
                this.vertexHashLookup.set(d2, { prev: o2, next: f2 }), o2 = f2;
              }
            }
            construct(t2) {
              if (0 === this.unevalVertices.length) return;
              const e2 = () => ({ vertexOffset: 0, primitiveOffset: this.indexArray.length }), r2 = (t3) => {
                t3.primitiveLength = this.indexArray.length - t3.primitiveOffset;
              }, n2 = new ep(this.vertexPositions, this.vertexNormals, this.indexArray);
              this.prepareEdges(t2.portals, this.unevalEdges);
              const i2 = e2(), s2 = e2(), o2 = e2(), a2 = (t3, e3) => {
                t3.sort((t4, r4) => t4.type === e3 && r4.type !== e3 ? -1 : t4.type !== e3 && r4.type === e3 ? 1 : 0);
                const r3 = t3.findIndex((t4) => t4.type !== e3);
                return r3 >= 0 ? r3 : t3.length;
              };
              let l2 = 0;
              this.unevalEdges.length > 0 && (l2 = a2(this.unevalEdges, "none"), this.constructBridgeStructures(n2, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l2 }, this.tileToMeters));
              const u5 = e2();
              if (this.unevalEdges.length > 0) {
                const t3 = this.unevalEdges.splice(l2), e3 = a2(t3, "tunnel") + l2;
                this.unevalEdges.push(...t3), this.constructTunnelStructures(n2, this.unevalVertices, this.unevalHeights, this.unevalEdges, { min: 0, max: l2 }, { min: l2, max: e3 });
              }
              r2(o2), n2.addTriangles(this.unevalTriangles, this.unevalVertices, this.unevalHeights), r2(u5), n2.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, this.unevalHeights), r2(s2), n2.addTriangles(this.unevalTunnelTriangles, this.unevalVertices, [-0.1]), r2(i2), this.maskSegments = Ka.simpleSegment(0, u5.primitiveOffset, 0, u5.primitiveLength), this.depthSegments = Ka.simpleSegment(0, s2.primitiveOffset, 0, s2.primitiveLength), this.renderableSegments = Ka.simpleSegment(0, o2.primitiveOffset, 0, o2.primitiveLength), this.shadowCasterSegments = Ka.simpleSegment(0, i2.primitiveOffset, 0, i2.primitiveLength);
            }
            upload(t2) {
              this.vertexBuffer || 0 === this.vertexPositions.length || 0 === this.vertexNormals.length || 0 === this.indexArray.length || (this.vertexBuffer = t2.createVertexBuffer(this.vertexPositions, Kc.members), this.vertexBufferNormal = t2.createVertexBuffer(this.vertexNormals, Jc.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray));
            }
            destroy() {
              this.vertexBuffer && (this.vertexBuffer.destroy(), this.vertexBufferNormal.destroy(), this.indexBuffer.destroy()), this.maskSegments && (this.maskSegments.destroy(), this.depthSegments.destroy(), this.renderableSegments.destroy(), this.shadowCasterSegments.destroy());
            }
            computeVertexConnections(t2, e2, r2, n2, i2) {
              const s2 = /* @__PURE__ */ new Map();
              for (let o2 = n2; o2 < i2; o2++) {
                const n3 = r2[o2], i3 = n3.a, a2 = n3.b, l2 = rp.computePosHash(t2[i3]), u5 = rp.computePosHash(t2[a2]);
                s2.has(l2) || s2.set(l2, {}), s2.has(u5) || s2.set(u5, {});
                const c2 = s2.get(l2), h2 = s2.get(u5);
                e2[i3] <= 0 && e2[a2] <= 0 || (c2.to = a2, h2.from = i3);
              }
              return s2;
            }
            constructBridgeStructures(t2, e2, r2, n2, i2, s2) {
              const o2 = this.computeVertexConnections(e2, r2, n2, i2.min, i2.max), a2 = 1 / s2, l2 = 0.5 * a2, u5 = (t3) => A(e2[t3].x, e2[t3].y, r2[t3] * a2), c2 = (t3) => {
                const r3 = o2.get(rp.computePosHash(e2[t3])), n3 = r3.from, i3 = r3.to;
                if (!n3 || !i3) return;
                const s3 = u5(n3), a3 = u5(t3), l3 = u5(i3), c3 = A(0, 0, 0);
                if (!N(s3, a3)) {
                  const t4 = j(b(), a3, s3);
                  M(c3, c3, C(t4, t4));
                }
                if (!N(l3, a3)) {
                  const t4 = j(b(), l3, a3);
                  M(c3, c3, C(t4, t4));
                }
                const h2 = G(c3);
                return h2 > 0 ? E(c3, c3, 1 / h2) : void 0;
              };
              for (let o3 = i2.min; o3 < i2.max; o3++) {
                const i3 = n2[o3], u6 = this.prepareEdgePoints(e2, r2, i3, (t3, e3) => t3 > e3);
                if (null == u6) continue;
                const h2 = u6[0], p2 = u6[1], f2 = A(h2.coord.x, h2.coord.y, a2 * h2.height), d2 = A(p2.coord.x, p2.coord.y, a2 * p2.height);
                if (N(f2, d2)) continue;
                const m2 = j(b(), d2, f2);
                C(m2, m2);
                const y2 = (t3) => C(t3, t3), g2 = c2(i3.a) || m2, x2 = c2(i3.b) || m2, v3 = y2(A(g2[1], -g2[0], 0)), _2 = y2(A(x2[1], -x2[0], 0)), w2 = y2(F(b(), v3, g2)), I2 = y2(F(b(), _2, x2)), S2 = b(), z2 = [M(b(), f2, E(S2, j(S2, v3, w2), l2)), M(b(), f2, E(S2, M(S2, v3, w2), l2)), M(b(), f2, E(S2, w2, l2)), f2], k2 = [M(b(), d2, E(S2, j(S2, _2, I2), l2)), M(b(), d2, E(S2, M(S2, _2, I2), l2)), M(b(), d2, E(S2, I2, l2)), d2], [P2, T2] = t2.addVertices(v3, s2, z2[0], z2[1]), [B3, D3] = t2.addVertices(_2, s2, k2[0], k2[1]);
                t2.addTriangles([P2, T2, B3, T2, D3, B3]);
                const [L2, R2] = t2.addVertices(w2, s2, z2[1], z2[2]), [O2, U2] = t2.addVertices(I2, s2, k2[1], k2[2]);
                t2.addTriangles([L2, R2, O2, R2, U2, O2]);
                const [$2, G2] = t2.addVertices(V(v3, v3), s2, z2[2], z2[3]), [q2, H2] = t2.addVertices(V(_2, _2), s2, k2[2], k2[3]);
                t2.addTriangles([$2, G2, q2, G2, H2, q2]);
              }
            }
            constructTunnelStructures(t2, e2, r2, n2, i2, s2) {
              const o2 = (t3) => C(t3, t3);
              for (let s3 = i2.min; s3 < i2.max; s3++) {
                const i3 = this.prepareEdgePoints(e2, r2, n2[s3], (t3, e3) => t3 < e3);
                if (null == i3) continue;
                const [a2, l2] = i3, u5 = o2(A(l2.coord.y - a2.coord.y, -(l2.coord.x - a2.coord.x), 0));
                t2.addQuad([a2, l2, { coord: l2.coord, height: n2[s3].isTunnel ? -0.1 : 0 }, { coord: a2.coord, height: n2[s3].isTunnel ? -0.1 : 0 }], u5);
              }
              for (let i3 = s2.min; i3 < s2.max; i3++) {
                const s3 = n2[i3], a2 = e2[s3.a], l2 = e2[s3.b], u5 = o2(A(l2.y - a2.y, -(l2.x - a2.x), 0));
                t2.addQuad([{ coord: l2, height: 0 }, { coord: a2, height: 0 }, { coord: a2, height: r2[s3.a] + 4 }, { coord: l2, height: r2[s3.b] + 4 }], u5), t2.addQuad([{ coord: a2, height: 0 }, { coord: l2, height: 0 }, { coord: l2, height: r2[s3.b] + 4 }, { coord: a2, height: r2[s3.a] + 4 }], u5);
              }
            }
            prepareEdgePoints(t2, e2, r2, n2) {
              let i2 = e2[r2.a], s2 = e2[r2.b];
              const o2 = n2(i2, 0), a2 = n2(s2, 0);
              if (o2 && a2) return [{ coord: t2[r2.a], height: i2 }, { coord: t2[r2.b], height: s2 }];
              if (!o2 && !a2) return;
              const l2 = t2[r2.a].clone(), u5 = t2[r2.b].clone();
              if (o2) {
                if (!a2) {
                  const t3 = s2 / (s2 - i2);
                  u5.x = or(u5.x, l2.x, t3), u5.y = or(u5.y, l2.y, t3), s2 = or(s2, i2, t3);
                }
              } else {
                const t3 = i2 / (i2 - s2);
                l2.x = or(l2.x, u5.x, t3), l2.y = or(l2.y, u5.y, t3), i2 = or(i2, s2, t3);
              }
              return [{ coord: l2, height: i2 }, { coord: u5, height: s2 }];
            }
            prepareEdges(t2, e2) {
              if (0 === e2.length) return;
              e2.sort((t3, e3) => t3.hash === e3.hash ? e3.polygonIdx - t3.polygonIdx : e3.hash > t3.hash ? 1 : -1);
              let r2 = 0, n2 = 0, i2 = 0, s2 = e2[r2].polygonIdx;
              do {
                n2++, (n2 === e2.length || e2[r2].hash !== e2[n2].hash) && ((1 == n2 - r2 || e2[n2 - 1].polygonIdx !== s2) && (i2 < r2 && (e2[i2] = e2[r2], e2[r2] = null), e2[i2].type = "none", i2++), r2 = n2, r2 !== e2.length && (s2 = e2[r2].polygonIdx));
              } while (r2 !== e2.length);
              if (e2.splice(i2), 0 !== e2.length && 0 !== t2.length) {
                e2.sort((t3, e3) => t3.portalHash < e3.portalHash ? 1 : -1);
                let r3 = 0, n3 = 0;
                for (; r3 !== e2.length && n3 !== t2.length; ) {
                  const i3 = e2[r3], s3 = t2[n3];
                  i3.portalHash > s3.hash ? r3++ : s3.hash > i3.portalHash ? n3++ : (i3.type = s3.type, r3++);
                }
              }
            }
            isOnBorder(t2, e2) {
              return t2 <= 0 && e2 <= 0 || t2 >= Tn && e2 >= Tn;
            }
            static computeEdgeHash(t2, e2) {
              return (t2.y === e2.y && t2.x > e2.x || t2.y > e2.y) && ([t2, e2] = [e2, t2]), BigInt(rp.computePosHash(t2)) << 32n | BigInt(rp.computePosHash(e2));
            }
            static computePosHash(t2) {
              return ((65535 & t2.x) << 16 | 65535 & t2.y) >>> 0;
            }
          }
          var np, ip = { exports: {} }, sp = (np || (np = 1, function(t2, e2) {
            !function(t3) {
              function e3(t4, e4) {
                return t4 > e4 ? 1 : t4 < e4 ? -1 : 0;
              }
              var r2 = function(t4, r3) {
                void 0 === t4 && (t4 = e3), void 0 === r3 && (r3 = false), this._compare = t4, this._root = null, this._size = 0, this._noDuplicates = !!r3;
              }, n2 = { size: { configurable: true } };
              function i2(t4, e4, r3, n3, s3) {
                var o3 = s3 - n3;
                if (o3 > 0) {
                  var a3 = n3 + Math.floor(o3 / 2), l3 = { key: e4[a3], data: r3[a3], parent: t4 };
                  return l3.left = i2(l3, e4, r3, n3, a3), l3.right = i2(l3, e4, r3, a3 + 1, s3), l3;
                }
                return null;
              }
              function s2(t4, e4, r3, n3, i3) {
                if (!(r3 >= n3)) {
                  for (var o3 = t4[r3 + n3 >> 1], a3 = r3 - 1, l3 = n3 + 1; ; ) {
                    do {
                      a3++;
                    } while (i3(t4[a3], o3) < 0);
                    do {
                      l3--;
                    } while (i3(t4[l3], o3) > 0);
                    if (a3 >= l3) break;
                    var u6 = t4[a3];
                    t4[a3] = t4[l3], t4[l3] = u6, u6 = e4[a3], e4[a3] = e4[l3], e4[l3] = u6;
                  }
                  s2(t4, e4, r3, l3, i3), s2(t4, e4, l3 + 1, n3, i3);
                }
              }
              r2.prototype.rotateLeft = function(t4) {
                var e4 = t4.right;
                e4 && (t4.right = e4.left, e4.left && (e4.left.parent = t4), e4.parent = t4.parent), t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.left = t4), t4.parent = e4;
              }, r2.prototype.rotateRight = function(t4) {
                var e4 = t4.left;
                e4 && (t4.left = e4.right, e4.right && (e4.right.parent = t4), e4.parent = t4.parent), t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.right = t4), t4.parent = e4;
              }, r2.prototype._splay = function(t4) {
                for (; t4.parent; ) {
                  var e4 = t4.parent;
                  e4.parent ? e4.left === t4 && e4.parent.left === e4 ? (this.rotateRight(e4.parent), this.rotateRight(e4)) : e4.right === t4 && e4.parent.right === e4 ? (this.rotateLeft(e4.parent), this.rotateLeft(e4)) : e4.left === t4 && e4.parent.right === e4 ? (this.rotateRight(e4), this.rotateLeft(e4)) : (this.rotateLeft(e4), this.rotateRight(e4)) : e4.left === t4 ? this.rotateRight(e4) : this.rotateLeft(e4);
                }
              }, r2.prototype.splay = function(t4) {
                for (var e4, r3, n3, i3, s3; t4.parent; ) (r3 = (e4 = t4.parent).parent) && r3.parent ? ((n3 = r3.parent).left === r3 ? n3.left = t4 : n3.right = t4, t4.parent = n3) : (t4.parent = null, this._root = t4), i3 = t4.left, s3 = t4.right, t4 === e4.left ? (r3 && (r3.left === e4 ? (e4.right ? (r3.left = e4.right, r3.left.parent = r3) : r3.left = null, e4.right = r3, r3.parent = e4) : (i3 ? (r3.right = i3, i3.parent = r3) : r3.right = null, t4.left = r3, r3.parent = t4)), s3 ? (e4.left = s3, s3.parent = e4) : e4.left = null, t4.right = e4, e4.parent = t4) : (r3 && (r3.right === e4 ? (e4.left ? (r3.right = e4.left, r3.right.parent = r3) : r3.right = null, e4.left = r3, r3.parent = e4) : (s3 ? (r3.left = s3, s3.parent = r3) : r3.left = null, t4.right = r3, r3.parent = t4)), i3 ? (e4.right = i3, i3.parent = e4) : e4.right = null, t4.left = e4, e4.parent = t4);
              }, r2.prototype.replace = function(t4, e4) {
                t4.parent ? t4 === t4.parent.left ? t4.parent.left = e4 : t4.parent.right = e4 : this._root = e4, e4 && (e4.parent = t4.parent);
              }, r2.prototype.minNode = function(t4) {
                if (void 0 === t4 && (t4 = this._root), t4) for (; t4.left; ) t4 = t4.left;
                return t4;
              }, r2.prototype.maxNode = function(t4) {
                if (void 0 === t4 && (t4 = this._root), t4) for (; t4.right; ) t4 = t4.right;
                return t4;
              }, r2.prototype.insert = function(t4, e4) {
                var r3 = this._root, n3 = null, i3 = this._compare;
                if (this._noDuplicates) for (; r3; ) {
                  if (n3 = r3, 0 === i3(r3.key, t4)) return;
                  r3 = i3(r3.key, t4) < 0 ? r3.right : r3.left;
                }
                else for (; r3; ) n3 = r3, r3 = i3(r3.key, t4) < 0 ? r3.right : r3.left;
                return r3 = { key: t4, data: e4, left: null, right: null, parent: n3 }, n3 ? i3(n3.key, r3.key) < 0 ? n3.right = r3 : n3.left = r3 : this._root = r3, this.splay(r3), this._size++, r3;
              }, r2.prototype.find = function(t4) {
                for (var e4 = this._root, r3 = this._compare; e4; ) {
                  var n3 = r3(e4.key, t4);
                  if (n3 < 0) e4 = e4.right;
                  else {
                    if (!(n3 > 0)) return e4;
                    e4 = e4.left;
                  }
                }
                return null;
              }, r2.prototype.contains = function(t4) {
                for (var e4 = this._root, r3 = this._compare; e4; ) {
                  var n3 = r3(t4, e4.key);
                  if (0 === n3) return true;
                  e4 = n3 < 0 ? e4.left : e4.right;
                }
                return false;
              }, r2.prototype.remove = function(t4) {
                var e4 = this.find(t4);
                if (!e4) return false;
                if (this.splay(e4), e4.left) if (e4.right) {
                  var r3 = this.minNode(e4.right);
                  r3.parent !== e4 && (this.replace(r3, r3.right), r3.right = e4.right, r3.right.parent = r3), this.replace(e4, r3), r3.left = e4.left, r3.left.parent = r3;
                } else this.replace(e4, e4.left);
                else this.replace(e4, e4.right);
                return this._size--, true;
              }, r2.prototype.removeNode = function(t4) {
                if (!t4) return false;
                if (this.splay(t4), t4.left) if (t4.right) {
                  var e4 = this.minNode(t4.right);
                  e4.parent !== t4 && (this.replace(e4, e4.right), e4.right = t4.right, e4.right.parent = e4), this.replace(t4, e4), e4.left = t4.left, e4.left.parent = e4;
                } else this.replace(t4, t4.left);
                else this.replace(t4, t4.right);
                return this._size--, true;
              }, r2.prototype.erase = function(t4) {
                var e4 = this.find(t4);
                if (e4) {
                  this.splay(e4);
                  var r3 = e4.left, n3 = e4.right, i3 = null;
                  r3 && (r3.parent = null, i3 = this.maxNode(r3), this.splay(i3), this._root = i3), n3 && (r3 ? i3.right = n3 : this._root = n3, n3.parent = i3), this._size--;
                }
              }, r2.prototype.pop = function() {
                var t4 = this._root, e4 = null;
                if (t4) {
                  for (; t4.left; ) t4 = t4.left;
                  e4 = { key: t4.key, data: t4.data }, this.remove(t4.key);
                }
                return e4;
              }, r2.prototype.next = function(t4) {
                var e4 = t4;
                if (e4) if (e4.right) for (e4 = e4.right; e4 && e4.left; ) e4 = e4.left;
                else for (e4 = t4.parent; e4 && e4.right === t4; ) t4 = e4, e4 = e4.parent;
                return e4;
              }, r2.prototype.prev = function(t4) {
                var e4 = t4;
                if (e4) if (e4.left) for (e4 = e4.left; e4 && e4.right; ) e4 = e4.right;
                else for (e4 = t4.parent; e4 && e4.left === t4; ) t4 = e4, e4 = e4.parent;
                return e4;
              }, r2.prototype.forEach = function(t4) {
                for (var e4 = this._root, r3 = [], n3 = false, i3 = 0; !n3; ) e4 ? (r3.push(e4), e4 = e4.left) : r3.length > 0 ? (t4(e4 = r3.pop(), i3++), e4 = e4.right) : n3 = true;
                return this;
              }, r2.prototype.range = function(t4, e4, r3, n3) {
                for (var i3 = [], s3 = this._compare, o3 = this._root; 0 !== i3.length || o3; ) if (o3) i3.push(o3), o3 = o3.left;
                else {
                  if (s3((o3 = i3.pop()).key, e4) > 0) break;
                  if (s3(o3.key, t4) >= 0 && r3.call(n3, o3)) return this;
                  o3 = o3.right;
                }
                return this;
              }, r2.prototype.keys = function() {
                for (var t4 = this._root, e4 = [], r3 = [], n3 = false; !n3; ) t4 ? (e4.push(t4), t4 = t4.left) : e4.length > 0 ? (t4 = e4.pop(), r3.push(t4.key), t4 = t4.right) : n3 = true;
                return r3;
              }, r2.prototype.values = function() {
                for (var t4 = this._root, e4 = [], r3 = [], n3 = false; !n3; ) t4 ? (e4.push(t4), t4 = t4.left) : e4.length > 0 ? (t4 = e4.pop(), r3.push(t4.data), t4 = t4.right) : n3 = true;
                return r3;
              }, r2.prototype.at = function(t4) {
                for (var e4 = this._root, r3 = [], n3 = false, i3 = 0; !n3; ) if (e4) r3.push(e4), e4 = e4.left;
                else if (r3.length > 0) {
                  if (e4 = r3.pop(), i3 === t4) return e4;
                  i3++, e4 = e4.right;
                } else n3 = true;
                return null;
              }, r2.prototype.load = function(t4, e4, r3) {
                if (void 0 === t4 && (t4 = []), void 0 === e4 && (e4 = []), void 0 === r3 && (r3 = false), 0 !== this._size) throw new Error("bulk-load: tree is not empty");
                var n3 = t4.length;
                return r3 && s2(t4, e4, 0, n3 - 1, this._compare), this._root = i2(null, t4, e4, 0, n3), this._size = n3, this;
              }, r2.prototype.min = function() {
                var t4 = this.minNode(this._root);
                return t4 ? t4.key : null;
              }, r2.prototype.max = function() {
                var t4 = this.maxNode(this._root);
                return t4 ? t4.key : null;
              }, r2.prototype.isEmpty = function() {
                return null === this._root;
              }, n2.size.get = function() {
                return this._size;
              }, r2.createTree = function(t4, e4, n3, i3, s3) {
                return new r2(n3, s3).load(t4, e4, i3);
              }, Object.defineProperties(r2.prototype, n2);
              var o2 = 0, a2 = 1, l2 = 2, u5 = 3, c2 = 0, h2 = 1, p2 = 2, f2 = 3;
              function d2(t4, e4, r3) {
                null === e4 ? (t4.inOut = false, t4.otherInOut = true) : (t4.isSubject === e4.isSubject ? (t4.inOut = !e4.inOut, t4.otherInOut = e4.otherInOut) : (t4.inOut = !e4.otherInOut, t4.otherInOut = e4.isVertical() ? !e4.inOut : e4.inOut), e4 && (t4.prevInResult = !m2(e4, r3) || e4.isVertical() ? e4.prevInResult : e4));
                var n3 = m2(t4, r3);
                t4.resultTransition = n3 ? function(t5, e5) {
                  var r4, n4 = !t5.inOut, i3 = !t5.otherInOut;
                  switch (e5) {
                    case c2:
                      r4 = n4 && i3;
                      break;
                    case h2:
                      r4 = n4 || i3;
                      break;
                    case f2:
                      r4 = n4 ^ i3;
                      break;
                    case p2:
                      r4 = t5.isSubject ? n4 && !i3 : i3 && !n4;
                  }
                  return r4 ? 1 : -1;
                }(t4, r3) : 0;
              }
              function m2(t4, e4) {
                switch (t4.type) {
                  case o2:
                    switch (e4) {
                      case c2:
                        return !t4.otherInOut;
                      case h2:
                        return t4.otherInOut;
                      case p2:
                        return t4.isSubject && t4.otherInOut || !t4.isSubject && !t4.otherInOut;
                      case f2:
                        return true;
                    }
                    break;
                  case l2:
                    return e4 === c2 || e4 === h2;
                  case u5:
                    return e4 === p2;
                  case a2:
                    return false;
                }
                return false;
              }
              var y2 = function(t4, e4, r3, n3, i3) {
                this.left = e4, this.point = t4, this.otherEvent = r3, this.isSubject = n3, this.type = i3 || o2, this.inOut = false, this.otherInOut = false, this.prevInResult = null, this.resultTransition = 0, this.otherPos = -1, this.outputContourId = -1, this.isExteriorRing = true;
              }, g2 = { inResult: { configurable: true } };
              function x2(t4, e4) {
                return t4[0] === e4[0] && t4[1] === e4[1];
              }
              y2.prototype.isBelow = function(t4) {
                var e4 = this.point, r3 = this.otherEvent.point;
                return this.left ? (e4[0] - t4[0]) * (r3[1] - t4[1]) - (r3[0] - t4[0]) * (e4[1] - t4[1]) > 0 : (r3[0] - t4[0]) * (e4[1] - t4[1]) - (e4[0] - t4[0]) * (r3[1] - t4[1]) > 0;
              }, y2.prototype.isAbove = function(t4) {
                return !this.isBelow(t4);
              }, y2.prototype.isVertical = function() {
                return this.point[0] === this.otherEvent.point[0];
              }, g2.inResult.get = function() {
                return 0 !== this.resultTransition;
              }, y2.prototype.clone = function() {
                var t4 = new y2(this.point, this.left, this.otherEvent, this.isSubject, this.type);
                return t4.contourId = this.contourId, t4.resultTransition = this.resultTransition, t4.prevInResult = this.prevInResult, t4.isExteriorRing = this.isExteriorRing, t4.inOut = this.inOut, t4.otherInOut = this.otherInOut, t4;
              }, Object.defineProperties(y2.prototype, g2);
              var v3 = 11102230246251565e-32, b2 = 134217729, _2 = (3 + 8 * v3) * v3;
              function w2(t4, e4, r3, n3, i3) {
                var s3, o3, a3, l3, u6 = e4[0], c3 = n3[0], h3 = 0, p3 = 0;
                c3 > u6 == c3 > -u6 ? (s3 = u6, u6 = e4[++h3]) : (s3 = c3, c3 = n3[++p3]);
                var f3 = 0;
                if (h3 < t4 && p3 < r3) for (c3 > u6 == c3 > -u6 ? (a3 = s3 - ((o3 = u6 + s3) - u6), u6 = e4[++h3]) : (a3 = s3 - ((o3 = c3 + s3) - c3), c3 = n3[++p3]), s3 = o3, 0 !== a3 && (i3[f3++] = a3); h3 < t4 && p3 < r3; ) c3 > u6 == c3 > -u6 ? (a3 = s3 - ((o3 = s3 + u6) - (l3 = o3 - s3)) + (u6 - l3), u6 = e4[++h3]) : (a3 = s3 - ((o3 = s3 + c3) - (l3 = o3 - s3)) + (c3 - l3), c3 = n3[++p3]), s3 = o3, 0 !== a3 && (i3[f3++] = a3);
                for (; h3 < t4; ) a3 = s3 - ((o3 = s3 + u6) - (l3 = o3 - s3)) + (u6 - l3), u6 = e4[++h3], s3 = o3, 0 !== a3 && (i3[f3++] = a3);
                for (; p3 < r3; ) a3 = s3 - ((o3 = s3 + c3) - (l3 = o3 - s3)) + (c3 - l3), c3 = n3[++p3], s3 = o3, 0 !== a3 && (i3[f3++] = a3);
                return 0 === s3 && 0 !== f3 || (i3[f3++] = s3), f3;
              }
              function A2(t4) {
                return new Float64Array(t4);
              }
              var M2 = 33306690738754716e-32, I2 = 22204460492503146e-32, S2 = 11093356479670487e-47, z2 = A2(4), k2 = A2(8), E2 = A2(12), P2 = A2(16), T2 = A2(4);
              function B3(t4, e4, r3) {
                var n3 = function(t5, e5, r4, n4, i3, s3) {
                  var o3 = (e5 - s3) * (r4 - i3), a3 = (t5 - i3) * (n4 - s3), l3 = o3 - a3;
                  if (0 === o3 || 0 === a3 || o3 > 0 != a3 > 0) return l3;
                  var u6 = Math.abs(o3 + a3);
                  return Math.abs(l3) >= M2 * u6 ? l3 : -function(t6, e6, r5, n5, i4, s4, o4) {
                    var a4, l4, u7, c3, h3, p3, f3, d3, m3, y3, g3, x3, v4, A3, M3, B4, V3, C4, D4 = t6 - i4, F3 = r5 - i4, L3 = e6 - s4, R3 = n5 - s4;
                    z2[0] = (M3 = (d3 = D4 - (f3 = (p3 = b2 * D4) - (p3 - D4))) * (y3 = R3 - (m3 = (p3 = b2 * R3) - (p3 - R3))) - ((A3 = D4 * R3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = L3 - (f3 = (p3 = b2 * L3) - (p3 - L3))) * (y3 = F3 - (m3 = (p3 = b2 * F3) - (p3 - F3))) - ((B4 = L3 * F3) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), z2[1] = (v4 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v4 - B4) + (h3 = v4 - g3)) + (h3 - B4), z2[2] = x3 - ((C4 = x3 + g3) - (h3 = C4 - x3)) + (g3 - h3), z2[3] = C4;
                    var O3 = function(t7, e7) {
                      for (var r6 = e7[0], n6 = 1; n6 < 4; n6++) r6 += e7[n6];
                      return r6;
                    }(0, z2), U3 = I2 * o4;
                    if (O3 >= U3 || -O3 >= U3) return O3;
                    if (a4 = t6 - (D4 + (h3 = t6 - D4)) + (h3 - i4), u7 = r5 - (F3 + (h3 = r5 - F3)) + (h3 - i4), l4 = e6 - (L3 + (h3 = e6 - L3)) + (h3 - s4), c3 = n5 - (R3 + (h3 = n5 - R3)) + (h3 - s4), 0 === a4 && 0 === l4 && 0 === u7 && 0 === c3) return O3;
                    if (U3 = S2 * o4 + _2 * Math.abs(O3), (O3 += D4 * c3 + R3 * a4 - (L3 * u7 + F3 * l4)) >= U3 || -O3 >= U3) return O3;
                    T2[0] = (M3 = (d3 = a4 - (f3 = (p3 = b2 * a4) - (p3 - a4))) * (y3 = R3 - (m3 = (p3 = b2 * R3) - (p3 - R3))) - ((A3 = a4 * R3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = l4 - (f3 = (p3 = b2 * l4) - (p3 - l4))) * (y3 = F3 - (m3 = (p3 = b2 * F3) - (p3 - F3))) - ((B4 = l4 * F3) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v4 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v4 - B4) + (h3 = v4 - g3)) + (h3 - B4), T2[2] = x3 - ((C4 = x3 + g3) - (h3 = C4 - x3)) + (g3 - h3), T2[3] = C4;
                    var N3 = w2(4, z2, 4, T2, k2);
                    T2[0] = (M3 = (d3 = D4 - (f3 = (p3 = b2 * D4) - (p3 - D4))) * (y3 = c3 - (m3 = (p3 = b2 * c3) - (p3 - c3))) - ((A3 = D4 * c3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = L3 - (f3 = (p3 = b2 * L3) - (p3 - L3))) * (y3 = u7 - (m3 = (p3 = b2 * u7) - (p3 - u7))) - ((B4 = L3 * u7) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v4 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v4 - B4) + (h3 = v4 - g3)) + (h3 - B4), T2[2] = x3 - ((C4 = x3 + g3) - (h3 = C4 - x3)) + (g3 - h3), T2[3] = C4;
                    var j3 = w2(N3, k2, 4, T2, E2);
                    T2[0] = (M3 = (d3 = a4 - (f3 = (p3 = b2 * a4) - (p3 - a4))) * (y3 = c3 - (m3 = (p3 = b2 * c3) - (p3 - c3))) - ((A3 = a4 * c3) - f3 * m3 - d3 * m3 - f3 * y3)) - ((g3 = M3 - (V3 = (d3 = l4 - (f3 = (p3 = b2 * l4) - (p3 - l4))) * (y3 = u7 - (m3 = (p3 = b2 * u7) - (p3 - u7))) - ((B4 = l4 * u7) - f3 * m3 - d3 * m3 - f3 * y3))) + (h3 = M3 - g3)) + (h3 - V3), T2[1] = (v4 = A3 - ((x3 = A3 + g3) - (h3 = x3 - A3)) + (g3 - h3)) - ((g3 = v4 - B4) + (h3 = v4 - g3)) + (h3 - B4), T2[2] = x3 - ((C4 = x3 + g3) - (h3 = C4 - x3)) + (g3 - h3), T2[3] = C4;
                    var $3 = w2(j3, E2, 4, T2, P2);
                    return P2[$3 - 1];
                  }(t5, e5, r4, n4, i3, s3, u6);
                }(t4[0], t4[1], e4[0], e4[1], r3[0], r3[1]);
                return n3 > 0 ? -1 : n3 < 0 ? 1 : 0;
              }
              function V2(t4, e4) {
                var r3 = t4.point, n3 = e4.point;
                return r3[0] > n3[0] ? 1 : r3[0] < n3[0] ? -1 : r3[1] !== n3[1] ? r3[1] > n3[1] ? 1 : -1 : function(t5, e5, r4, n4) {
                  return t5.left !== e5.left ? t5.left ? 1 : -1 : 0 !== B3(r4, t5.otherEvent.point, e5.otherEvent.point) ? t5.isBelow(e5.otherEvent.point) ? -1 : 1 : !t5.isSubject && e5.isSubject ? 1 : -1;
                }(t4, e4, r3);
              }
              function C3(t4, e4, r3) {
                var n3 = new y2(e4, false, t4, t4.isSubject), i3 = new y2(e4, true, t4.otherEvent, t4.isSubject);
                return x2(t4.point, t4.otherEvent.point) && console.warn("what is that, a collapsed segment?", t4), n3.contourId = i3.contourId = t4.contourId, V2(i3, t4.otherEvent) > 0 && (t4.otherEvent.left = true, i3.left = false), t4.otherEvent.otherEvent = i3, t4.otherEvent = n3, r3.push(i3), r3.push(n3), r3;
              }
              function D3(t4, e4) {
                return t4[0] * e4[1] - t4[1] * e4[0];
              }
              function F2(t4, e4) {
                return t4[0] * e4[0] + t4[1] * e4[1];
              }
              function L2(t4, e4, r3) {
                var n3 = function(t5, e5, r4, n4, i4) {
                  var s4 = [e5[0] - t5[0], e5[1] - t5[1]], o4 = [n4[0] - r4[0], n4[1] - r4[1]];
                  function a3(t6, e6, r5) {
                    return [t6[0] + e6 * r5[0], t6[1] + e6 * r5[1]];
                  }
                  var l3 = [r4[0] - t5[0], r4[1] - t5[1]], u6 = D3(s4, o4), c4 = u6 * u6, h3 = F2(s4, s4);
                  if (c4 > 0) {
                    var p3 = D3(l3, o4) / u6;
                    if (p3 < 0 || p3 > 1) return null;
                    var f3 = D3(l3, s4) / u6;
                    return f3 < 0 || f3 > 1 ? null : 0 === p3 || 1 === p3 ? [a3(t5, p3, s4)] : 0 === f3 || 1 === f3 ? [a3(r4, f3, o4)] : [a3(t5, p3, s4)];
                  }
                  if ((c4 = (u6 = D3(l3, s4)) * u6) > 0) return null;
                  var d3 = F2(s4, l3) / h3, m3 = d3 + F2(s4, o4) / h3, y3 = Math.min(d3, m3), g3 = Math.max(d3, m3);
                  return y3 <= 1 && g3 >= 0 ? 1 === y3 ? [a3(t5, y3 > 0 ? y3 : 0, s4)] : 0 === g3 ? [a3(t5, g3 < 1 ? g3 : 1, s4)] : [a3(t5, y3 > 0 ? y3 : 0, s4), a3(t5, g3 < 1 ? g3 : 1, s4)] : null;
                }(t4.point, t4.otherEvent.point, e4.point, e4.otherEvent.point), i3 = n3 ? n3.length : 0;
                if (0 === i3) return 0;
                if (1 === i3 && (x2(t4.point, e4.point) || x2(t4.otherEvent.point, e4.otherEvent.point))) return 0;
                if (2 === i3 && t4.isSubject === e4.isSubject) return 0;
                if (1 === i3) return x2(t4.point, n3[0]) || x2(t4.otherEvent.point, n3[0]) || C3(t4, n3[0], r3), x2(e4.point, n3[0]) || x2(e4.otherEvent.point, n3[0]) || C3(e4, n3[0], r3), 1;
                var s3 = [], o3 = false, c3 = false;
                return x2(t4.point, e4.point) ? o3 = true : 1 === V2(t4, e4) ? s3.push(e4, t4) : s3.push(t4, e4), x2(t4.otherEvent.point, e4.otherEvent.point) ? c3 = true : 1 === V2(t4.otherEvent, e4.otherEvent) ? s3.push(e4.otherEvent, t4.otherEvent) : s3.push(t4.otherEvent, e4.otherEvent), o3 && c3 || o3 ? (e4.type = a2, t4.type = e4.inOut === t4.inOut ? l2 : u5, o3 && !c3 && C3(s3[1].otherEvent, s3[0].point, r3), 2) : c3 ? (C3(s3[0], s3[1].point, r3), 3) : s3[0] !== s3[3].otherEvent ? (C3(s3[0], s3[1].point, r3), C3(s3[1], s3[2].point, r3), 3) : (C3(s3[0], s3[1].point, r3), C3(s3[3].otherEvent, s3[2].point, r3), 3);
              }
              function R2(t4, e4) {
                if (t4 === e4) return 0;
                if (0 !== B3(t4.point, t4.otherEvent.point, e4.point) || 0 !== B3(t4.point, t4.otherEvent.point, e4.otherEvent.point)) return x2(t4.point, e4.point) ? t4.isBelow(e4.otherEvent.point) ? -1 : 1 : t4.point[0] === e4.point[0] ? t4.point[1] < e4.point[1] ? -1 : 1 : 1 === V2(t4, e4) ? e4.isAbove(t4.point) ? -1 : 1 : t4.isBelow(e4.point) ? -1 : 1;
                if (t4.isSubject !== e4.isSubject) return t4.isSubject ? -1 : 1;
                var r3 = t4.point, n3 = e4.point;
                return r3[0] === n3[0] && r3[1] === n3[1] ? (r3 = t4.otherEvent.point)[0] === (n3 = e4.otherEvent.point)[0] && r3[1] === n3[1] ? 0 : t4.contourId > e4.contourId ? 1 : -1 : 1 === V2(t4, e4) ? 1 : -1;
              }
              var O2 = function() {
                this.points = [], this.holeIds = [], this.holeOf = null, this.depth = null;
              };
              function U2(t4, e4, r3, n3) {
                var i3, s3 = t4 + 1, o3 = e4[t4].point, a3 = e4.length;
                for (s3 < a3 && (i3 = e4[s3].point); s3 < a3 && i3[0] === o3[0] && i3[1] === o3[1]; ) {
                  if (!r3[s3]) return s3;
                  ++s3 < a3 && (i3 = e4[s3].point);
                }
                for (s3 = t4 - 1; r3[s3] && s3 > n3; ) s3--;
                return s3;
              }
              O2.prototype.isExterior = function() {
                return null == this.holeOf;
              };
              var N2 = $2, j2 = $2;
              function $2(t4, e4) {
                if (!(this instanceof $2)) return new $2(t4, e4);
                if (this.data = t4 || [], this.length = this.data.length, this.compare = e4 || G2, this.length > 0) for (var r3 = (this.length >> 1) - 1; r3 >= 0; r3--) this._down(r3);
              }
              function G2(t4, e4) {
                return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
              }
              $2.prototype = { push: function(t4) {
                this.data.push(t4), this.length++, this._up(this.length - 1);
              }, pop: function() {
                if (0 !== this.length) {
                  var t4 = this.data[0];
                  return this.length--, this.length > 0 && (this.data[0] = this.data[this.length], this._down(0)), this.data.pop(), t4;
                }
              }, peek: function() {
                return this.data[0];
              }, _up: function(t4) {
                for (var e4 = this.data, r3 = this.compare, n3 = e4[t4]; t4 > 0; ) {
                  var i3 = t4 - 1 >> 1, s3 = e4[i3];
                  if (r3(n3, s3) >= 0) break;
                  e4[t4] = s3, t4 = i3;
                }
                e4[t4] = n3;
              }, _down: function(t4) {
                for (var e4 = this.data, r3 = this.compare, n3 = this.length >> 1, i3 = e4[t4]; t4 < n3; ) {
                  var s3 = 1 + (t4 << 1), o3 = s3 + 1, a3 = e4[s3];
                  if (o3 < this.length && r3(e4[o3], a3) < 0 && (s3 = o3, a3 = e4[o3]), r3(a3, i3) >= 0) break;
                  e4[t4] = a3, t4 = s3;
                }
                e4[t4] = i3;
              } }, N2.default = j2;
              var q2 = Math.max, H2 = Math.min, X2 = 0;
              function Z2(t4, e4, r3, n3, i3, s3) {
                var o3, a3, l3, u6, c3, h3;
                for (o3 = 0, a3 = t4.length - 1; o3 < a3; o3++) if (u6 = t4[o3 + 1], c3 = new y2(l3 = t4[o3], false, void 0, e4), h3 = new y2(u6, false, c3, e4), c3.otherEvent = h3, l3[0] !== u6[0] || l3[1] !== u6[1]) {
                  c3.contourId = h3.contourId = r3, s3 || (c3.isExteriorRing = false, h3.isExteriorRing = false), V2(c3, h3) > 0 ? h3.left = true : c3.left = true;
                  var p3 = l3[0], f3 = l3[1];
                  i3[0] = H2(i3[0], p3), i3[1] = H2(i3[1], f3), i3[2] = q2(i3[2], p3), i3[3] = q2(i3[3], f3), n3.push(c3), n3.push(h3);
                }
              }
              var W2 = [];
              function Y2(t4, e4, n3) {
                "number" == typeof t4[0][0][0] && (t4 = [t4]), "number" == typeof e4[0][0][0] && (e4 = [e4]);
                var i3 = function(t5, e5, r3) {
                  var n4 = null;
                  return t5.length * e5.length == 0 && (r3 === c2 ? n4 = W2 : r3 === p2 ? n4 = t5 : r3 !== h2 && r3 !== f2 || (n4 = 0 === t5.length ? e5 : t5)), n4;
                }(t4, e4, n3);
                if (i3) return i3 === W2 ? null : i3;
                var s3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], o3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a3 = function(t5, e5, r3, n4, i4) {
                  var s4, o4, a4, l4, u7, c3, h3 = new N2(null, V2);
                  for (a4 = 0, l4 = t5.length; a4 < l4; a4++) for (u7 = 0, c3 = (s4 = t5[a4]).length; u7 < c3; u7++) (o4 = 0 === u7) && X2++, Z2(s4[u7], true, X2, h3, r3, o4);
                  for (a4 = 0, l4 = e5.length; a4 < l4; a4++) for (u7 = 0, c3 = (s4 = e5[a4]).length; u7 < c3; u7++) o4 = 0 === u7, i4 === p2 && (o4 = false), o4 && X2++, Z2(s4[u7], false, X2, h3, n4, o4);
                  return h3;
                }(t4, e4, s3, o3, n3);
                if (i3 = function(t5, e5, r3, n4, i4) {
                  var s4 = null;
                  return (r3[0] > n4[2] || n4[0] > r3[2] || r3[1] > n4[3] || n4[1] > r3[3]) && (i4 === c2 ? s4 = W2 : i4 === p2 ? s4 = t5 : i4 !== h2 && i4 !== f2 || (s4 = t5.concat(e5))), s4;
                }(t4, e4, s3, o3, n3)) return i3 === W2 ? null : i3;
                for (var l3 = function(t5) {
                  var e5, r3, n4 = function(t6) {
                    var e6, r4, n5, i5, s5 = [];
                    for (r4 = 0, n5 = t6.length; r4 < n5; r4++) ((e6 = t6[r4]).left && e6.inResult || !e6.left && e6.otherEvent.inResult) && s5.push(e6);
                    for (var o5 = false; !o5; ) for (o5 = true, r4 = 0, n5 = s5.length; r4 < n5; r4++) r4 + 1 < n5 && 1 === V2(s5[r4], s5[r4 + 1]) && (i5 = s5[r4], s5[r4] = s5[r4 + 1], s5[r4 + 1] = i5, o5 = false);
                    for (r4 = 0, n5 = s5.length; r4 < n5; r4++) (e6 = s5[r4]).otherPos = r4;
                    for (r4 = 0, n5 = s5.length; r4 < n5; r4++) (e6 = s5[r4]).left || (i5 = e6.otherPos, e6.otherPos = e6.otherEvent.otherPos, e6.otherEvent.otherPos = i5);
                    return s5;
                  }(t5), i4 = {}, s4 = [], o4 = function() {
                    if (!i4[e5]) {
                      var t6 = s4.length, r4 = function(t7, e6, r5) {
                        var n5 = new O2();
                        if (null != t7.prevInResult) {
                          var i5 = t7.prevInResult, s5 = i5.outputContourId;
                          if (i5.resultTransition > 0) {
                            var o6 = e6[s5];
                            if (null != o6.holeOf) {
                              var a5 = o6.holeOf;
                              e6[a5].holeIds.push(r5), n5.holeOf = a5, n5.depth = e6[s5].depth;
                            } else e6[s5].holeIds.push(r5), n5.holeOf = s5, n5.depth = e6[s5].depth + 1;
                          } else n5.holeOf = null, n5.depth = e6[s5].depth;
                        } else n5.holeOf = null, n5.depth = 0;
                        return n5;
                      }(n4[e5], s4, t6), o5 = function(e6) {
                        i4[e6] = true, e6 < n4.length && n4[e6] && (n4[e6].outputContourId = t6);
                      }, a4 = e5, l4 = e5;
                      for (r4.points.push(n4[e5].point); o5(a4), o5(a4 = n4[a4].otherPos), r4.points.push(n4[a4].point), !((a4 = U2(a4, n4, i4, l4)) == l4 || a4 >= n4.length) && n4[a4]; ) ;
                      s4.push(r4);
                    }
                  };
                  for (e5 = 0, r3 = n4.length; e5 < r3; e5++) o4();
                  return s4;
                }(function(t5, e5, n4, i4, s4, o4) {
                  for (var a4, l4, u7, h3 = new r2(R2), f3 = [], m4 = Math.min(i4[2], s4[2]); 0 !== t5.length; ) {
                    var y4 = t5.pop();
                    if (f3.push(y4), o4 === c2 && y4.point[0] > m4 || o4 === p2 && y4.point[0] > i4[2]) break;
                    if (y4.left) {
                      l4 = a4 = h3.insert(y4), a4 = a4 !== (u7 = h3.minNode()) ? h3.prev(a4) : null, l4 = h3.next(l4);
                      var g4 = a4 ? a4.key : null;
                      if (d2(y4, g4, o4), l4 && 2 === L2(y4, l4.key, t5) && (d2(y4, g4, o4), d2(l4.key, y4, o4)), a4 && 2 === L2(a4.key, y4, t5)) {
                        var x4 = a4;
                        d2(g4, (x4 = x4 !== u7 ? h3.prev(x4) : null) ? x4.key : null, o4), d2(y4, g4, o4);
                      }
                    } else l4 = a4 = h3.find(y4 = y4.otherEvent), a4 && l4 && (a4 = a4 !== u7 ? h3.prev(a4) : null, l4 = h3.next(l4), h3.remove(y4), l4 && a4 && L2(a4.key, l4.key, t5));
                  }
                  return f3;
                }(a3, 0, 0, s3, o3, n3)), u6 = [], m3 = 0; m3 < l3.length; m3++) {
                  var y3 = l3[m3];
                  if (y3.isExterior()) {
                    for (var g3 = [y3.points], x3 = 0; x3 < y3.holeIds.length; x3++) g3.push(l3[y3.holeIds[x3]].points);
                    u6.push(g3);
                  }
                }
                return u6;
              }
              var K2 = { UNION: h2, DIFFERENCE: p2, INTERSECTION: c2, XOR: f2 };
              t3.diff = function(t4, e4) {
                return Y2(t4, e4, p2);
              }, t3.intersection = function(t4, e4) {
                return Y2(t4, e4, c2);
              }, t3.operations = K2, t3.union = function(t4, e4) {
                return Y2(t4, e4, h2);
              }, t3.xor = function(t4, e4) {
                return Y2(t4, e4, f2);
              }, Object.defineProperty(t3, "__esModule", { value: true });
            }(e2);
          }(0, ip.exports)), ip.exports);
          function op(t2, e2, r2, n2) {
            const i2 = [], s2 = 0 === n2 ? (t3, e3, r3, n3, i3, s3) => {
              t3.push(new bt(s3, r3 + (s3 - e3) / (n3 - e3) * (i3 - r3)));
            } : (t3, e3, r3, n3, i3, s3) => {
              t3.push(new bt(e3 + (s3 - r3) / (i3 - r3) * (n3 - e3), s3));
            };
            for (const o2 of t2) {
              const t3 = [];
              for (const i3 of o2) {
                if (i3.length <= 2) continue;
                const o3 = [];
                for (let t4 = 0; t4 < i3.length - 1; t4++) {
                  const a3 = i3[t4].x, l3 = i3[t4].y, u5 = i3[t4 + 1].x, c2 = i3[t4 + 1].y, h2 = 0 === n2 ? a3 : l3, p2 = 0 === n2 ? u5 : c2;
                  h2 < e2 ? p2 > e2 && s2(o3, a3, l3, u5, c2, e2) : h2 > r2 ? p2 < r2 && s2(o3, a3, l3, u5, c2, r2) : o3.push(i3[t4]), p2 < e2 && h2 >= e2 && s2(o3, a3, l3, u5, c2, e2), p2 > r2 && h2 <= r2 && s2(o3, a3, l3, u5, c2, r2);
                }
                let a2 = i3[i3.length - 1];
                const l2 = 0 === n2 ? a2.x : a2.y;
                l2 >= e2 && l2 <= r2 && o3.push(a2), o3.length && (a2 = o3[o3.length - 1], o3[0].x === a2.x && o3[0].y === a2.y || o3.push(o3[0]), t3.push(o3));
              }
              t3.length && i2.push(t3);
            }
            return i2;
          }
          function ap(t2, e2) {
            const r2 = up(t2), n2 = up([e2]), i2 = sp.intersection(r2, n2);
            return null == i2 ? [] : cp(i2);
          }
          function lp(t2, e2) {
            const r2 = 65536;
            let n2 = up(t2, r2);
            for (; e2.valid(); e2.next()) {
              const [t3, i2] = e2.get(), s2 = t3.x * r2, o2 = t3.y * r2, a2 = i2.x * r2, l2 = i2.y * r2, u5 = a2 - s2, c2 = l2 - o2, h2 = Math.hypot(u5, c2), p2 = Math.trunc(c2 / h2 * 3), f2 = -Math.trunc(u5 / h2 * 3);
              n2 = sp.diff(n2, [[[s2, o2], [a2, l2], [a2 + p2, l2 + f2], [s2 + p2, o2 + f2], [s2, o2]]]);
            }
            return cp(n2, 1 / r2);
          }
          function up(t2, e2 = 1) {
            return [t2.map((t3) => t3.map((t4) => [t4.x * e2, t4.y * e2]))];
          }
          function cp(t2, e2 = 1) {
            return t2.map((t3) => t3.map((t4, r2) => {
              const n2 = t4.map((t5) => new bt(t5[0] * e2, t5[1] * e2).round());
              return r2 > 0 && n2.reverse(), n2;
            }));
          }
          class hp {
            constructor(t2, e2) {
              this.layoutVertexArray = new ea2(), this.indexArray = new wa(), this.lineIndexArray = new ga(), this.triangleSegments = new Ka(), this.lineSegments = new Ka(), this.programConfigurations = new Il(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.uploaded = false, e2 && (this.elevatedLayoutVertexArray = new ia());
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            needsUpload() {
              return this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Wc.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.lineIndexBuffer = t2.createIndexBuffer(this.lineIndexArray), this.elevatedLayoutVertexArray && this.elevatedLayoutVertexArray.length > 0 && (this.elevatedLayoutVertexBuffer = t2.createVertexBuffer(this.elevatedLayoutVertexArray, Yc.members))), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.elevatedLayoutVertexBuffer && this.elevatedLayoutVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.lineIndexBuffer.destroy(), this.programConfigurations.destroy(), this.triangleSegments.destroy(), this.lineSegments.destroy());
            }
            populatePaintArrays(t2, e2, r2, n2, i2, s2) {
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, e2, r2, n2, i2, s2);
            }
          }
          class pp {
            constructor(t2) {
              this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.bufferData = new hp(t2, false), this.elevationBufferData = new hp(t2, true), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.projection = t2.projection, this.elevationMode = this.layers[0].layout.get("fill-elevation-reference");
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = kh("fill", this.layers, this.pixelRatio, e2);
              const i2 = this.layers[0].layout.get("fill-sort-key"), s2 = [];
              for (const { feature: o2, id: a2, index: l2, sourceLayerIndex: u5 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, c2 = du(o2, t3);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), c2, r2)) continue;
                const h2 = i2 ? i2.evaluate(c2, {}, r2, e2.availableImages) : void 0, p2 = { id: a2, properties: o2.properties, type: o2.type, sourceLayerIndex: u5, index: l2, geometry: t3 ? c2.geometry : fu(o2, r2, n2), patterns: {}, sortKey: h2 };
                s2.push(p2);
              }
              i2 && s2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              for (const n3 of s2) {
                const { geometry: i3, index: s3, sourceLayerIndex: o2 } = n3;
                if (this.hasPattern) {
                  const t3 = Eh("fill", this.layers, n3, this.zoom, this.pixelRatio, e2);
                  this.patternFeatures.push(t3);
                } else this.addFeature(n3, i3, s3, r2, {}, e2.availableImages, e2.brightness, e2.elevationFeatures);
                e2.featureIndex.insert(t2[s3].feature, i3, s3, o2, this.index);
              }
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.bufferData.update(t2, e2, r2, n2, i2, s2, o2), this.elevationBufferData.update(t2, e2, r2, n2, i2, s2, o2);
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const i3 of this.patternFeatures) this.addFeature(i3, i3.geometry, i3.index, e2, r2, n2, s2, t2.elevationFeatures);
            }
            isEmpty() {
              return this.bufferData.isEmpty() && this.elevationBufferData.isEmpty();
            }
            uploadPending() {
              return !this.uploaded || this.bufferData.needsUpload() || this.elevationBufferData.needsUpload();
            }
            upload(t2) {
              this.bufferData.upload(t2), this.elevationBufferData.upload(t2), this.elevatedStructures && this.elevatedStructures.upload(t2);
            }
            destroy() {
              this.bufferData.destroy(), this.elevationBufferData.destroy(), this.elevatedStructures && this.elevatedStructures.destroy();
            }
            addFeature(t2, e2, r2, n2, i2, s2 = [], o2, a2) {
              const l2 = Ih(e2, 500);
              "none" !== this.elevationMode ? this.addElevatedRoadFeature(t2, l2, n2, r2, a2) : this.addGeometry(l2, this.bufferData), this.bufferData.populatePaintArrays(t2, r2, i2, s2, n2, o2), this.elevationBufferData.populatePaintArrays(t2, r2, i2, s2, n2, o2);
            }
            getUnevaluatedPortalGraph() {
              return this.elevatedStructures ? this.elevatedStructures.unevaluatedPortals : void 0;
            }
            getElevationPolygons() {
              return this.elevatedStructures ? this.elevatedStructures.portalPolygons : void 0;
            }
            setEvaluatedPortalGraph(t2) {
              this.elevatedStructures && this.elevatedStructures.construct(t2);
            }
            addElevatedRoadFeature(t2, e2, r2, n2, i2) {
              const s2 = new Array(), o2 = Kh.getElevationFeature(t2, i2);
              if (o2) {
                {
                  const t3 = this.clipPolygonsToTile(e2, 1);
                  t3.length > 0 && s2.push({ polygons: t3, elevationFeature: o2, elevationTileID: r2 });
                }
                for (const e3 of s2) if (e3.elevationFeature) {
                  if ("hd-road-base" === this.elevationMode) {
                    this.elevatedStructures || (this.elevatedStructures = new rp(e3.elevationTileID));
                    const r3 = e3.elevationFeature.isTunnel();
                    let n3 = 0;
                    t2.properties.hasOwnProperty($h) && (n3 = +t2.properties[$h]);
                    for (const t3 of e3.polygons) this.elevatedStructures.addPortalCandidates(e3.elevationFeature.id, t3, r3, e3.elevationFeature, n3);
                  }
                  null == e3.elevationFeature.constantHeight && (e3.polygons = this.prepareElevatedPolygons(e3.polygons, e3.elevationFeature, e3.elevationTileID));
                  const i3 = new Jh(r2, e3.elevationTileID);
                  this.addElevatedGeometry(e3.polygons, i3, e3.elevationFeature, "hd-road-base" === this.elevationMode ? 0 : 0.05, n2);
                }
              } else this.addGeometry(e2, this.bufferData);
            }
            addElevatedGeometry(t2, e2, r2, n2, i2) {
              const s2 = { elevation: r2, elevationSampler: e2, bias: n2, index: i2 }, [o2, a2] = this.addGeometry(t2, this.elevationBufferData, s2);
              null == this.elevationBufferData.heightRange ? this.elevationBufferData.heightRange = { min: o2, max: a2 } : (this.elevationBufferData.heightRange.min = Math.min(this.elevationBufferData.heightRange.min, o2), this.elevationBufferData.heightRange.max = Math.max(this.elevationBufferData.heightRange.max, a2));
            }
            addGeometry(t2, e2, r2) {
              let n2 = Number.POSITIVE_INFINITY, i2 = Number.NEGATIVE_INFINITY, s2 = null;
              r2 && (s2 = r2.elevationSampler.constantElevation(r2.elevation, r2.bias), null != s2 && (n2 = s2, i2 = s2));
              const o2 = (t3, o3, a2) => {
                if (null != r2) if (o3.push(t3), null != s2) e2.elevatedLayoutVertexArray.emplaceBack(s2), a2.push(s2);
                else {
                  const s3 = r2.elevationSampler.pointElevation(t3, r2.elevation, r2.bias);
                  e2.elevatedLayoutVertexArray.emplaceBack(s3), a2.push(s3), n2 = Math.min(n2, s3), i2 = Math.max(i2, s3);
                }
              };
              for (const n3 of t2) {
                let t3 = 0;
                for (const e3 of n3) t3 += e3.length;
                const i3 = e2.triangleSegments.prepareSegment(t3, e2.layoutVertexArray, e2.indexArray), s3 = i3.vertexLength, a2 = [], l2 = [], u5 = [], c2 = [], h2 = [], p2 = e2.layoutVertexArray.length;
                for (const t4 of n3) {
                  if (0 === t4.length) continue;
                  t4 !== n3[0] && l2.push(a2.length / 2);
                  const i4 = e2.lineSegments.prepareSegment(t4.length, e2.layoutVertexArray, e2.lineIndexArray), s4 = i4.vertexLength;
                  r2 && h2.push(e2.layoutVertexArray.length - p2), o2(t4[0], u5, c2), e2.layoutVertexArray.emplaceBack(t4[0].x, t4[0].y), e2.lineIndexArray.emplaceBack(s4 + t4.length - 1, s4), a2.push(t4[0].x), a2.push(t4[0].y);
                  for (let r3 = 1; r3 < t4.length; r3++) o2(t4[r3], u5, c2), e2.layoutVertexArray.emplaceBack(t4[r3].x, t4[r3].y), e2.lineIndexArray.emplaceBack(s4 + r3 - 1, s4 + r3), a2.push(t4[r3].x), a2.push(t4[r3].y);
                  i4.vertexLength += t4.length, i4.primitiveLength += t4.length;
                }
                const f2 = Qc(a2, l2);
                for (let t4 = 0; t4 < f2.length; t4 += 3) e2.indexArray.emplaceBack(s3 + f2[t4], s3 + f2[t4 + 1], s3 + f2[t4 + 2]);
                if (f2.length > 0 && r2 && "hd-road-base" === this.elevationMode) {
                  const t4 = r2.elevation.isTunnel(), e3 = r2.elevation.safeArea, n4 = this.elevatedStructures.addVertices(u5, c2);
                  this.elevatedStructures.addTriangles(f2, n4, t4);
                  const i4 = h2.length;
                  if (i4 > 0) {
                    for (let s4 = 0; s4 < i4 - 1; s4++) this.elevatedStructures.addRenderableRing(r2.index, h2[s4] + n4, h2[s4 + 1] - h2[s4], t4, e3);
                    this.elevatedStructures.addRenderableRing(r2.index, h2[i4 - 1] + n4, u5.length - h2[i4 - 1], t4, e3);
                  }
                }
                i3.vertexLength += t3, i3.primitiveLength += f2.length / 3;
              }
              return [n2, i2];
            }
            prepareElevatedPolygons(t2, e2, r2) {
              const n2 = 1 / iu(r2), i2 = [];
              for (const r3 of t2) {
                const t3 = lp(r3, new Wh(e2, n2));
                i2.push(...t3);
              }
              return i2;
            }
            clipPolygonsToTile(t2, e2) {
              const r2 = -e2, n2 = -e2, i2 = Tn + e2, s2 = Tn + e2;
              let o2 = 0;
              const a2 = [], l2 = [];
              for (; o2 < t2.length; o2++) {
                const e3 = t2[o2], u6 = un(e3);
                (u6.min.x >= r2 && u6.max.x <= i2 && u6.min.y >= n2 && u6.max.y <= s2 ? a2 : l2).push(e3);
              }
              if (a2.length === t2.length) return t2;
              const u5 = [new bt(r2, n2), new bt(i2, n2), new bt(i2, s2), new bt(r2, s2), new bt(r2, n2)], c2 = a2;
              for (const t3 of l2) c2.push(...ap(t3, u5));
              return c2;
            }
          }
          let fp, dp, mp, yp;
          js(pp, "FillBucket", { omit: ["layers", "patternFeatures"] }), js(hp, "FillBufferData"), js(rp, "ElevatedStructures");
          class gp {
            constructor(t2, e2, r2, n2) {
              if (this.triangleCount = e2.length / 3, this.min = new bt(0, 0), this.max = new bt(0, 0), this.xScale = 0, this.yScale = 0, this.cellsX = 0, this.cellsY = 0, this.cells = [], this.payload = [], 0 === this.triangleCount || 0 === t2.length) return;
              const [i2, s2] = [t2[0].clone(), t2[0].clone()];
              for (let e3 = 1; e3 < t2.length; ++e3) {
                const r3 = t2[e3];
                i2.x = Math.min(i2.x, r3.x), i2.y = Math.min(i2.y, r3.y), s2.x = Math.max(s2.x, r3.x), s2.y = Math.max(s2.y, r3.y);
              }
              if (n2) {
                const t3 = Math.ceil(Math.max(s2.x - i2.x, s2.y - i2.y) / n2);
                r2 = Math.max(r2, t3);
              }
              if (0 === r2) return;
              this.min = i2, this.max = s2;
              const o2 = this.max.sub(this.min);
              o2.x = Math.max(o2.x, 1), o2.y = Math.max(o2.y, 1);
              const a2 = Math.max(o2.x, o2.y) / r2;
              this.cellsX = Math.max(1, Math.ceil(o2.x / a2)), this.cellsY = Math.max(1, Math.ceil(o2.y / a2)), this.xScale = 1 / a2, this.yScale = 1 / a2;
              const l2 = [];
              for (let r3 = 0; r3 < this.triangleCount; r3++) {
                const n3 = t2[e2[3 * r3 + 0]].sub(this.min), i3 = t2[e2[3 * r3 + 1]].sub(this.min), s3 = t2[e2[3 * r3 + 2]].sub(this.min), o3 = xp(Math.floor(Math.min(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), u6 = xp(Math.floor(Math.max(n3.x, i3.x, s3.x)), this.xScale, this.cellsX), c2 = xp(Math.floor(Math.min(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), h2 = xp(Math.floor(Math.max(n3.y, i3.y, s3.y)), this.yScale, this.cellsY), p2 = new bt(0, 0), f2 = new bt(0, 0), d2 = new bt(0, 0), m2 = new bt(0, 0);
                for (let t3 = c2; t3 <= h2; ++t3) {
                  p2.y = f2.y = t3 * a2, d2.y = m2.y = (t3 + 1) * a2;
                  for (let e3 = o3; e3 <= u6; ++e3) p2.x = d2.x = e3 * a2, f2.x = m2.x = (e3 + 1) * a2, (Vu(n3, i3, s3, p2, f2, m2) || Vu(n3, i3, s3, p2, m2, d2)) && l2.push({ cellIdx: t3 * this.cellsX + e3, triIdx: r3 });
                }
              }
              if (0 === l2.length) return;
              l2.sort((t3, e3) => t3.cellIdx - e3.cellIdx || t3.triIdx - e3.triIdx);
              let u5 = 0;
              for (; u5 < l2.length; ) {
                const t3 = l2[u5].cellIdx, e3 = { start: this.payload.length, len: 0 };
                for (; u5 < l2.length && l2[u5].cellIdx === t3; ) ++e3.len, this.payload.push(l2[u5++].triIdx);
                this.cells[t3] = e3;
              }
            }
            _lazyInitLookup() {
              this.lookup || (this.lookup = new Uint8Array(Math.ceil(this.triangleCount / 8))), this.lookup.fill(0);
            }
            queryPoint(t2, e2) {
              if (0 === this.triangleCount || 0 === this.cells.length) return;
              if (t2.x > this.max.x || this.min.x > t2.x || t2.y > this.max.y || this.min.y > t2.y) return;
              const r2 = xp(t2.x - this.min.x, this.xScale, this.cellsX), n2 = xp(t2.y - this.min.y, this.yScale, this.cellsY), i2 = this.cells[n2 * this.cellsX + r2];
              if (i2) {
                this._lazyInitLookup();
                for (let t3 = 0; t3 < i2.len; t3++) {
                  const r3 = this.payload[i2.start + t3], n3 = Math.floor(r3 / 8), s2 = 1 << r3 % 8;
                  if (!(this.lookup[n3] & s2) && (this.lookup[n3] |= s2, e2.push(r3), e2.length === this.triangleCount)) return;
                }
              }
            }
            query(t2, e2, r2) {
              if (0 === this.triangleCount || 0 === this.cells.length) return;
              if (t2.x > this.max.x || this.min.x > e2.x) return;
              if (t2.y > this.max.y || this.min.y > e2.y) return;
              this._lazyInitLookup();
              const n2 = xp(t2.x - this.min.x, this.xScale, this.cellsX), i2 = xp(e2.x - this.min.x, this.xScale, this.cellsX), s2 = xp(t2.y - this.min.y, this.yScale, this.cellsY), o2 = xp(e2.y - this.min.y, this.yScale, this.cellsY);
              for (let t3 = s2; t3 <= o2; t3++) for (let e3 = n2; e3 <= i2; e3++) {
                const n3 = this.cells[t3 * this.cellsX + e3];
                if (n3) for (let t4 = 0; t4 < n3.len; t4++) {
                  const e4 = this.payload[n3.start + t4], i3 = Math.floor(e4 / 8), s3 = 1 << e4 % 8;
                  if (!(this.lookup[i3] & s3) && (this.lookup[i3] |= s3, r2.push(e4), r2.length === this.triangleCount)) return;
                }
              }
            }
          }
          function xp(t2, e2, r2) {
            return Math.max(0, Math.min(r2 - 1, Math.floor(t2 * e2)));
          }
          js(gp, "TriangleGridIndex");
          class vp {
            constructor(t2) {
              this.zoom = t2.zoom, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.footprints = [];
            }
            updateFootprints(t2, e2) {
              for (const r2 of this.footprints) e2.push({ footprint: r2, id: t2 });
            }
            populate(t2, e2, r2, n2) {
              const i2 = [];
              for (const { feature: e3, id: s2, index: o2, sourceLayerIndex: a2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = du(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), l2, r2)) continue;
                const u5 = { id: s2, properties: e3.properties, type: e3.type, sourceLayerIndex: a2, index: o2, geometry: t3 ? l2.geometry : fu(e3, r2, n2), patterns: {} };
                i2.push(u5);
              }
              for (const n3 of i2) {
                const { geometry: i3, index: s2, sourceLayerIndex: o2 } = n3;
                this.addFeature(n3, i3, s2, r2, {}, e2.availableImages, e2.brightness), e2.featureIndex.insert(t2[s2].feature, i3, s2, o2, this.index);
              }
            }
            isEmpty() {
              return 0 === this.footprints.length;
            }
            uploadPending() {
              return false;
            }
            upload(t2) {
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
            }
            destroy() {
            }
            addFeature(t2, e2, r2, n2, i2, s2 = [], o2) {
              for (const t3 of Ih(e2, 2)) {
                const e3 = [], r3 = [], n3 = [], i3 = new bt(1 / 0, 1 / 0), s3 = new bt(-1 / 0, -1 / 0);
                for (const o4 of t3) if (0 !== o4.length) {
                  o4 !== t3[0] && n3.push(r3.length / 2);
                  for (let t4 = 0; t4 < o4.length; t4++) r3.push(o4[t4].x), r3.push(o4[t4].y), e3.push(o4[t4]), i3.x = Math.min(i3.x, o4[t4].x), i3.y = Math.min(i3.y, o4[t4].y), s3.x = Math.max(s3.x, o4[t4].x), s3.y = Math.max(s3.y, o4[t4].y);
                }
                const o3 = Qc(r3, n3), a2 = new gp(e3, o3, 8, 256);
                this.footprints.push({ vertices: e3, indices: o3, grid: a2, min: i3, max: s3 });
              }
            }
          }
          js(vp, "ClipBucket", { omit: ["layers"] });
          const bp = Qo([{ name: "a_pos_normal_ed", components: 4, type: "Int16" }]), _p = Qo([{ name: "a_pos_end", components: 4, type: "Int16" }, { name: "a_angular_offset_factor", components: 1, type: "Int16" }]), wp = Qo([{ name: "a_centroid_pos", components: 2, type: "Uint16" }]), Ap = Qo([{ name: "a_join_normal_inside", components: 3, type: "Int16" }]), Mp = Qo([{ name: "a_hidden_by_landmark", components: 1, type: "Uint8" }]), Ip = Qo([{ name: "a_pos_3", components: 3, type: "Int16" }, { name: "a_pos_normal_3", components: 3, type: "Int16" }]), { members: Sp } = bp, zp = Number.MAX_SAFE_INTEGER;
          function kp(t2, e2, r2, n2) {
            return t2.order < e2 || t2.order === zp || !(t2.clipMask & r2) || function(t3, e3) {
              return 0 !== e3.length && void 0 === e3.find((e4) => e4 === t3);
            }(n2, t2.clipScope);
          }
          function Ep(t2, e2) {
            return t2.x - e2.x || t2.y - e2.y;
          }
          function Pp(t2, e2) {
            return 0 === Ep(t2.min, e2.min) && 0 === Ep(t2.max, e2.max);
          }
          function Tp(t2, e2) {
            return !(t2.min.x > e2.max.x || t2.max.x < e2.min.x || t2.min.y > e2.max.y || t2.max.y < e2.min.y);
          }
          function Bp(t2, e2) {
            if (t2.length !== e2.length) return false;
            for (let r2 = 0; r2 < t2.length; r2++) if (t2[r2].sourceId !== e2[r2].sourceId || !Pp(t2[r2], e2[r2]) || t2[r2].order !== e2[r2].order || t2[r2].clipMask !== e2[r2].clipMask || !_t(t2[r2].clipScope, e2[r2].clipScope)) return false;
            return true;
          }
          function Vp(t2, e2, r2) {
            const n2 = 1 / Tn, i2 = 1 / (1 << r2.canonical.z), s2 = (e2.x * n2 + r2.canonical.x) * i2 + r2.wrap, o2 = (e2.y * n2 + r2.canonical.y) * i2;
            return { min: new bt((t2.x * n2 + r2.canonical.x) * i2 + r2.wrap, (t2.y * n2 + r2.canonical.y) * i2), max: new bt(s2, o2) };
          }
          function Cp(t2, e2, r2) {
            const n2 = 1 << r2.canonical.z, i2 = ((e2.x - r2.wrap) * n2 - r2.canonical.x) * Tn, s2 = (e2.y * n2 - r2.canonical.y) * Tn;
            return { min: new bt(((t2.x - r2.wrap) * n2 - r2.canonical.x) * Tn, (t2.y * n2 - r2.canonical.y) * Tn), max: new bt(i2, s2) };
          }
          function Dp(t2, e2, r2, n2, i2, s2, o2) {
            const a2 = t2.indices, l2 = t2.vertices, u5 = [];
            for (let c2 = n2; c2 < n2 + i2; c2 += 3) {
              const n3 = e2[r2[c2 + 0] + s2], i3 = e2[r2[c2 + 1] + s2], h2 = e2[r2[c2 + 2] + s2], p2 = Math.min(n3.x, i3.x, h2.x), f2 = Math.max(n3.x, i3.x, h2.x), d2 = Math.min(n3.y, i3.y, h2.y), m2 = Math.max(n3.y, i3.y, h2.y);
              u5.length = 0, t2.grid.query(new bt(p2, d2), new bt(f2, m2), u5);
              for (let t3 = 0; t3 < u5.length; t3++) {
                const e3 = u5[t3];
                if (Vu(l2[a2[3 * e3 + 0]], l2[a2[3 * e3 + 1]], l2[a2[3 * e3 + 2]], n3, i3, h2, o2)) return true;
              }
            }
            return false;
          }
          function Fp(t2, e2, r2, n2) {
            if (!t2 || !r2) return false;
            let i2 = t2.vertices;
            if (!e2.canonical.equals(n2.canonical) || e2.wrap !== n2.wrap) {
              if (r2.vertices.length < t2.vertices.length) return Fp(r2, n2, t2, e2);
              const s2 = e2.canonical, o2 = n2.canonical, a2 = Math.pow(2, o2.z - s2.z);
              i2 = t2.vertices.map((t3) => new bt((t3.x + s2.x * Tn) * a2 - o2.x * Tn, (t3.y + s2.y * Tn) * a2 - o2.y * Tn));
            }
            return Dp(r2, i2, t2.indices, 0, t2.indices.length, 0, 0);
          }
          function Lp(t2, e2, r2, n2) {
            const i2 = Math.pow(2, n2.z - r2.z);
            return new bt((t2 + r2.x * Tn) * i2 - n2.x * Tn, (e2 + r2.y * Tn) * i2 - n2.y * Tn);
          }
          function Rp(t2, e2) {
            const r2 = [];
            e2.grid.queryPoint(t2, r2);
            const n2 = e2.indices, i2 = e2.vertices;
            for (let e3 = 0; e3 < r2.length; e3++) {
              const s2 = r2[e3];
              if (Eu([i2[n2[3 * s2 + 0]], i2[n2[3 * s2 + 1]], i2[n2[3 * s2 + 2]]], t2)) return true;
            }
            return false;
          }
          const Op = [new bt(0, 0), new bt(Tn, 0), new bt(Tn, Tn), new bt(0, Tn)];
          function Up(t2, e2) {
            const r2 = [];
            let n2 = [];
            if (!e2 || t2.length < 2) return [t2];
            if (2 === t2.length) return Tu(t2[0], t2[1], Op) ? [t2] : [];
            for (let e3 = 0; e3 < t2.length + 2; e3++) {
              const i2 = t2[e3 % t2.length], s2 = t2[(e3 + 1) % t2.length], o2 = Tu(0 === e3 ? t2[t2.length - 1] : t2[(e3 - 1) % t2.length], i2, Op), a2 = Tu(i2, s2, Op), l2 = o2 || a2;
              l2 && n2.push(i2), l2 && a2 || n2.length > 0 && (n2.length > 1 && r2.push(n2), n2 = []);
            }
            return n2.length > 1 && r2.push(n2), r2;
          }
          const Np = Nh.VectorTileFeature.types, jp = ["fill-extrusion-base", "fill-extrusion-height", "fill-extrusion-color", "fill-extrusion-pattern", "fill-extrusion-flood-light-wall-radius", "fill-extrusion-line-width", "fill-extrusion-emissive-strength"], $p = ["fill-extrusion-flood-light-ground-radius"], Gp = Math.pow(2, 13), qp = Math.pow(2, 15) - 1, Hp = new bt(0, 1), Xp = 2147483648;
          function Zp(t2, e2, r2, n2, i2, s2, o2, a2) {
            t2.emplaceBack((e2 << 1) + o2, (r2 << 1) + s2, (Math.floor(n2 * Gp) << 1) + i2, Math.round(a2));
          }
          function Wp(t2, e2, r2) {
            t2.emplaceBack(e2.x * Tn, e2.y * Tn, r2 ? 1 : 0);
          }
          function Yp(t2, e2, r2, n2, i2, s2) {
            t2.emplaceBack(e2.x, e2.y, (r2.x << 1) + n2, (r2.y << 1) + i2, s2);
          }
          function Kp(t2, e2, r2) {
            const n2 = 16384;
            t2.emplaceBack(e2.x, e2.y, e2.z, r2[0] * n2, r2[1] * n2, r2[2] * n2);
          }
          class Jp {
            constructor() {
              this.vertexOffset = 0, this.vertexCount = 0, this.indexOffset = 0, this.indexCount = 0;
            }
          }
          class Qp {
            constructor() {
              this.centroidXY = new bt(0, 0), this.vertexArrayOffset = 0, this.vertexCount = 0, this.groundVertexArrayOffset = 0, this.groundVertexCount = 0, this.flags = 0, this.footprintSegIdx = -1, this.footprintSegLen = 0, this.polygonSegIdx = -1, this.polygonSegLen = 0, this.min = new bt(Number.MAX_VALUE, Number.MAX_VALUE), this.max = new bt(-Number.MAX_VALUE, -Number.MAX_VALUE), this.height = 0;
            }
            span() {
              return new bt(this.max.x - this.min.x, this.max.y - this.min.y);
            }
          }
          class tf {
            constructor() {
              this.acc = new bt(0, 0), this.accCount = 0, this.centroidDataIndex = 0;
            }
            startRing(t2, e2) {
              t2.min.x === Number.MAX_VALUE && (t2.min.x = t2.max.x = e2.x, t2.min.y = t2.max.y = e2.y);
            }
            appendEdge(t2, e2, r2) {
              this.accCount++, this.acc._add(e2);
              let n2 = !!this.borders;
              e2.x < t2.min.x ? (t2.min.x = e2.x, n2 = true) : e2.x > t2.max.x && (t2.max.x = e2.x, n2 = true), e2.y < t2.min.y ? (t2.min.y = e2.y, n2 = true) : e2.y > t2.max.y && (t2.max.y = e2.y, n2 = true), ((0 === e2.x || e2.x === Tn) && e2.x === r2.x) != ((0 === e2.y || e2.y === Tn) && e2.y === r2.y) && this.processBorderOverlap(e2, r2), n2 && this.checkBorderIntersection(e2, r2);
            }
            checkBorderIntersection(t2, e2) {
              e2.x < 0 != t2.x < 0 && this.addBorderIntersection(0, or(e2.y, t2.y, (0 - e2.x) / (t2.x - e2.x))), e2.x > Tn != t2.x > Tn && this.addBorderIntersection(1, or(e2.y, t2.y, (Tn - e2.x) / (t2.x - e2.x))), e2.y < 0 != t2.y < 0 && this.addBorderIntersection(2, or(e2.x, t2.x, (0 - e2.y) / (t2.y - e2.y))), e2.y > Tn != t2.y > Tn && this.addBorderIntersection(3, or(e2.x, t2.x, (Tn - e2.y) / (t2.y - e2.y)));
            }
            addBorderIntersection(t2, e2) {
              this.borders || (this.borders = [[Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE], [Number.MAX_VALUE, -Number.MAX_VALUE]]);
              const r2 = this.borders[t2];
              e2 < r2[0] && (r2[0] = e2), e2 > r2[1] && (r2[1] = e2);
            }
            processBorderOverlap(t2, e2) {
              if (t2.x === e2.x) {
                if (t2.y === e2.y) return;
                const r2 = 0 === t2.x ? 0 : 1;
                this.addBorderIntersection(r2, e2.y), this.addBorderIntersection(r2, t2.y);
              } else {
                const r2 = 0 === t2.y ? 2 : 3;
                this.addBorderIntersection(r2, e2.x), this.addBorderIntersection(r2, t2.x);
              }
            }
            centroid() {
              return 0 === this.accCount ? new bt(0, 0) : new bt(Math.floor(Math.max(0, this.acc.x) / this.accCount), Math.floor(Math.max(0, this.acc.y) / this.accCount));
            }
            intersectsCount() {
              return this.borders ? this.borders.reduce((t2, e2) => t2 + +(e2[0] !== Number.MAX_VALUE), 0) : 0;
            }
          }
          function ef(t2, e2) {
            const r2 = t2.add(e2)._unit(), n2 = Pt(t2.x * r2.x + t2.y * r2.y, -1, 1);
            var i2, s2, o2;
            return i2 = Math.acos(n2), Math.min(4, Math.max(-4, Math.tan(i2))) / 4 * qp * ((s2 = t2).x * (o2 = e2).y - s2.y * o2.x < 0 ? -1 : 1);
          }
          const rf = [(t2) => t2.x < 0, (t2) => t2.x > Tn, (t2) => t2.y < 0, (t2) => t2.y > Tn];
          function nf(t2, e2, r2, n2) {
            const i2 = [4];
            if (0 === n2) return i2;
            r2._mult(n2);
            const s2 = t2.sub(r2), o2 = e2.sub(r2), a2 = [t2, e2, s2, o2];
            for (let t3 = 0; t3 < 4; t3++) for (const e3 of a2) if (rf[t3](e3)) {
              i2.push(t3);
              break;
            }
            return i2;
          }
          class sf {
            constructor(t2) {
              this.vertexArray = new aa2(), this.indexArray = new wa(), this.programConfigurations = new Il(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => $p.includes(t3)), this._segments = new Ka(), this.hiddenByLandmarkVertexArray = new Da(), this._segmentToGroundQuads = {}, this._segmentToGroundQuads[0] = [], this._segmentToRegionTriCounts = {}, this._segmentToRegionTriCounts[0] = [0, 0, 0, 0, 0], this.regionSegments = {}, this.regionSegments[4] = new Ka();
            }
            getDefaultSegment() {
              return this.regionSegments[4];
            }
            hasData() {
              return 0 !== this.vertexArray.length;
            }
            addData(t2, e2, r2, n2 = false) {
              const i2 = t2.length;
              if (i2 > 2) {
                let s2 = Math.max(0, this._segments.get().length - 1);
                const o2 = this._segments._prepareSegment(4 * i2, this.vertexArray.length, 2 * this._segmentToGroundQuads[s2].length);
                let a2;
                s2 !== this._segments.get().length - 1 && (s2++, this._segmentToGroundQuads[s2] = [], this._segmentToRegionTriCounts[s2] = [0, 0, 0, 0, 0]);
                {
                  const e3 = t2[0], r3 = t2[1];
                  a2 = ef(e3.sub(t2[i2 - 1])._perp()._unit(), r3.sub(e3)._perp()._unit());
                }
                for (let l2 = 0; l2 < i2; l2++) {
                  const u5 = l2 === i2 - 1 ? 0 : l2 + 1, c2 = t2[l2], h2 = t2[u5], p2 = t2[u5 === i2 - 1 ? 0 : u5 + 1], f2 = h2.sub(c2)._perp()._unit(), d2 = ef(f2, p2.sub(h2)._perp()._unit()), m2 = a2, y2 = d2;
                  if (cf(c2, h2, e2) || n2 && hf(c2, e2) && hf(h2, e2)) {
                    a2 = d2;
                    continue;
                  }
                  const g2 = o2.vertexLength;
                  Yp(this.vertexArray, c2, h2, 1, 1, m2), Yp(this.vertexArray, c2, h2, 1, 0, m2), Yp(this.vertexArray, c2, h2, 0, 1, y2), Yp(this.vertexArray, c2, h2, 0, 0, y2), o2.vertexLength += 4;
                  const x2 = nf(c2, h2, f2, r2);
                  for (const t3 of x2) this._segmentToGroundQuads[s2].push({ id: g2, region: t3 }), this._segmentToRegionTriCounts[s2][t3] += 2, o2.primitiveLength += 2;
                  a2 = d2;
                }
              }
            }
            prepareBorderSegments() {
              if (!this.hasData()) return;
              const t2 = this._segments.get(), e2 = t2.length;
              for (let t3 = 0; t3 < e2; t3++) this._segmentToGroundQuads[t3].sort((t4, e3) => t4.region - e3.region);
              for (let r2 = 0; r2 < e2; r2++) {
                const e3 = this._segmentToGroundQuads[r2], n2 = t2[r2], i2 = this._segmentToRegionTriCounts[r2];
                i2.reduce((t3, e4) => t3 + e4, 0);
                let s2 = 0;
                for (let t3 = 0; t3 <= 4; t3++) {
                  const e4 = i2[t3];
                  if (0 !== e4) {
                    let r3 = this.regionSegments[t3];
                    r3 || (r3 = this.regionSegments[t3] = new Ka());
                    const i3 = { vertexOffset: n2.vertexOffset, primitiveOffset: n2.primitiveOffset + s2, vertexLength: n2.vertexLength, primitiveLength: e4 };
                    r3.get().push(i3);
                  }
                  s2 += e4;
                }
                for (let t3 = 0; t3 < e3.length; t3++) {
                  const r3 = e3[t3].id;
                  this.indexArray.emplaceBack(r3, r3 + 1, r3 + 3), this.indexArray.emplaceBack(r3, r3 + 3, r3 + 2);
                }
              }
              this._segmentToGroundQuads = null, this._segmentToRegionTriCounts = null, this._segments.destroy(), this._segments = null;
            }
            addPaintPropertiesData(t2, e2, r2, n2, i2, s2) {
              this.hasData() && this.programConfigurations.populatePaintArrays(this.vertexArray.length, t2, e2, r2, n2, i2, s2);
            }
            upload(t2) {
              this.hasData() && (this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, _p.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray));
            }
            uploadPaintProperties(t2) {
              this.hasData() && this.programConfigurations.upload(t2);
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.hasData() && this.programConfigurations.updatePaintArrays(t2, e2, r2, n2, i2, s2, o2);
            }
            updateHiddenByLandmark(t2) {
              if (!this.hasData()) return;
              const e2 = t2.groundVertexCount + t2.groundVertexArrayOffset;
              if (0 === t2.groundVertexCount) return;
              const r2 = t2.flags & Xp ? 1 : 0;
              for (let n2 = t2.groundVertexArrayOffset; n2 < e2; ++n2) this.hiddenByLandmarkVertexArray.emplace(n2, r2);
              this._needsHiddenByLandmarkUpdate = true;
            }
            uploadHiddenByLandmark(t2) {
              this.hasData() && this._needsHiddenByLandmarkUpdate && (!this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexArray.length > 0 ? this.hiddenByLandmarkVertexBuffer = t2.createVertexBuffer(this.hiddenByLandmarkVertexArray, Mp.members, true) : this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.updateData(this.hiddenByLandmarkVertexArray), this._needsHiddenByLandmarkUpdate = false);
            }
            destroy() {
              if (this.vertexBuffer) {
                this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.hiddenByLandmarkVertexBuffer && this.hiddenByLandmarkVertexBuffer.destroy(), this._segments && this._segments.destroy(), this.programConfigurations.destroy();
                for (let t2 = 0; t2 <= 4; t2++) {
                  const e2 = this.regionSegments[t2];
                  e2 && e2.destroy();
                }
              }
            }
          }
          class of {
            constructor(t2) {
              this.zoom = t2.zoom, this.canonical = t2.canonical, this.overscaling = t2.overscaling, this.layers = t2.layers, this.pixelRatio = t2.pixelRatio, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.hasPattern = false, this.edgeRadius = 0, this.projection = t2.projection, this.activeReplacements = [], this.replacementUpdateTime = 0, this.centroidData = [], this.footprintIndices = new wa(), this.footprintVertices = new ea2(), this.footprintSegments = [], this.layoutVertexArray = new na(), this.centroidVertexArray = new Ha(), this.wallVertexArray = new Za(), this.indexArray = new wa(), this.programConfigurations = new Il(t2.layers, { zoom: t2.zoom, lut: t2.lut }, (t3) => jp.includes(t3)), this.segments = new Ka(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.groundEffect = new sf(t2), this.maxHeight = 0, this.partLookup = {}, this.triangleSubSegments = [], this.polygonSegments = [];
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.features = [], this.hasPattern = kh("fill-extrusion", this.layers, this.pixelRatio, e2), this.featuresOnBorder = [], this.borderFeatureIndices = [[], [], [], []], this.borderDoneWithNeighborZ = [-1, -1, -1, -1], this.selfDEMTileTimestamp = Number.MAX_VALUE, this.borderDEMTileTimestamp = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], this.tileToMeter = iu(r2), this.edgeRadius = this.layers[0].layout.get("fill-extrusion-edge-radius") / this.tileToMeter, this.wallMode = 0 !== this.layers[0].paint.get("fill-extrusion-line-width").constantOr(1);
              for (const { feature: i2, id: s2, index: o2, sourceLayerIndex: a2 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, l2 = du(i2, t3);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), l2, r2)) continue;
                const u5 = { id: s2, sourceLayerIndex: a2, index: o2, geometry: t3 ? l2.geometry : fu(i2, r2, n2), properties: i2.properties, type: i2.type, patterns: {} }, c2 = this.layoutVertexArray.length, h2 = "Polygon" === Np[u5.type];
                if (this.hasPattern) this.features.push(Eh("fill-extrusion", this.layers, u5, this.zoom, this.pixelRatio, e2));
                else if (this.wallMode) for (const t4 of u5.geometry) for (const i3 of Up(t4, h2)) this.addFeature(u5, [i3], o2, r2, {}, e2.availableImages, n2, e2.brightness);
                else this.addFeature(u5, u5.geometry, o2, r2, {}, e2.availableImages, n2, e2.brightness);
                e2.featureIndex.insert(i2, u5.geometry, o2, a2, this.index, c2);
              }
              this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles(), this.groundEffect.prepareBorderSegments(), this.polygonSegments.length = 0;
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const t3 of this.features) {
                const o2 = "Polygon" === Np[t3.type], { geometry: a2 } = t3;
                if (this.wallMode) for (const l2 of a2) for (const a3 of Up(l2, o2)) this.addFeature(t3, [a3], t3.index, e2, r2, n2, i2, s2);
                else this.addFeature(t3, a2, t3.index, e2, r2, n2, i2, s2);
              }
              this.sortBorders(), "mercator" === this.projection.name && this.splitToSubtiles();
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2), this.groundEffect.update(t2, e2, i2, r2, n2, s2, o2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload || this.groundEffect.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Sp), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.wallVertexBuffer = t2.createVertexBuffer(this.wallVertexArray, Ap.members), this.layoutVertexExtArray && (this.layoutVertexExtBuffer = t2.createVertexBuffer(this.layoutVertexExtArray, Ip.members, true)), this.groundEffect.upload(t2)), this.groundEffect.uploadPaintProperties(t2), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            uploadCentroid(t2) {
              this.groundEffect.uploadHiddenByLandmark(t2), this.needsCentroidUpdate && (!this.centroidVertexBuffer && this.centroidVertexArray.length > 0 ? this.centroidVertexBuffer = t2.createVertexBuffer(this.centroidVertexArray, wp.members, true) : this.centroidVertexBuffer && this.centroidVertexBuffer.updateData(this.centroidVertexArray), this.needsCentroidUpdate = false);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.centroidVertexBuffer && this.centroidVertexBuffer.destroy(), this.layoutVertexExtBuffer && this.layoutVertexExtBuffer.destroy(), this.groundEffect.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = this.layers[0].paint.get("fill-extrusion-flood-light-ground-radius").evaluate(t2, {}) / this.tileToMeter, u5 = [new bt(0, 0), new bt(Tn, Tn)], c2 = o2.projection, h2 = "globe" === c2.name, p2 = this.wallMode || "Polygon" === Np[t2.type], f2 = new tf();
              f2.centroidDataIndex = this.centroidData.length;
              const d2 = new Qp(), m2 = this.layers[0].paint.get("fill-extrusion-base").evaluate(t2, {}, n2) <= 0, y2 = this.layers[0].paint.get("fill-extrusion-height").evaluate(t2, {}, n2);
              let g2;
              if (d2.height = y2, d2.vertexArrayOffset = this.layoutVertexArray.length, d2.groundVertexArrayOffset = this.groundEffect.vertexArray.length, h2 && !this.layoutVertexExtArray && (this.layoutVertexExtArray = new pa()), this.wallMode) {
                if (h2) return void $t("Non zero fill-extrusion-line-width is not yet supported on globe.");
                if (1 !== e2.length) return;
                g2 = function(t3) {
                  const e3 = t3[0].x === t3[t3.length - 1].x && t3[0].y === t3[t3.length - 1].y, r3 = function(t4) {
                    let e4 = 0;
                    const r4 = t4.length;
                    for (let n4 = 0; n4 < r4; n4++) e4 += (t4[(n4 + 1) % r4].x - t4[n4].x) * (t4[(n4 + 1) % r4].y + t4[n4].y);
                    return e4 >= 0;
                  }(t3);
                  r3 || (t3 = t3.reverse());
                  const n3 = { geometry: [], joinNormals: [], indices: [] }, i3 = [], s3 = [], o3 = [];
                  let a3 = t3.length;
                  for (; a3 >= 2 && t3[a3 - 1].equals(t3[a3 - 2]); ) a3--;
                  if (a3 < (e3 ? 3 : 2)) return n3;
                  let l3, u6, c3, h3, p3, f3 = 0;
                  for (; f3 < a3 - 1 && t3[f3].equals(t3[f3 + 1]); ) f3++;
                  e3 && (l3 = t3[a3 - 2], p3 = t3[f3].sub(l3)._unit()._perp());
                  for (let r4 = f3; r4 < a3; r4++) {
                    if (c3 = r4 === a3 - 1 ? e3 ? t3[f3 + 1] : void 0 : t3[r4 + 1], c3 && t3[r4].equals(c3)) continue;
                    p3 && (h3 = p3), l3 && (u6 = l3), l3 = t3[r4], p3 = c3 ? c3.sub(l3)._unit()._perp() : h3, h3 = h3 || p3;
                    let n4 = h3.add(p3);
                    0 === n4.x && 0 === n4.y || n4._unit();
                    const d4 = n4.x * p3.x + n4.y * p3.y, m3 = 0 !== d4 ? 1 / d4 : 1 / 0, y3 = h3.x * p3.y - h3.y * p3.x > 0;
                    let g3 = "miter";
                    const x3 = 2;
                    "miter" === g3 && m3 > x3 && (g3 = "bevel"), "bevel" === g3 && (m3 > 100 && (g3 = "flipbevel"), m3 < x3 && (g3 = "miter"));
                    const v4 = (t4, e4, r5, n5) => {
                      const a4 = new bt(t4.x, t4.y), l4 = new bt(t4.x, t4.y);
                      a4.x += e4.x * n5, a4.y += e4.y * n5, l4.x -= e4.x * Math.max(r5, 1), l4.y -= e4.y * Math.max(r5, 1), o3.push(e4), i3.push(a4), s3.push(l4);
                    };
                    if ("miter" === g3) n4._mult(m3), v4(l3, n4, 0, 0);
                    else if ("flipbevel" === g3) n4 = p3.mult(-1), v4(l3, n4, 0, 0), v4(l3, n4.mult(-1), 0, 0);
                    else {
                      const t4 = -Math.sqrt(m3 * m3 - 1), e4 = y3 ? t4 : 0, r5 = y3 ? 0 : t4;
                      u6 && v4(l3, h3, e4, r5), c3 && v4(l3, p3, e4, r5);
                    }
                  }
                  n3.geometry = [...i3, ...s3.reverse(), i3[0]], n3.joinNormals = [...o3, ...o3.reverse(), o3[o3.length - 1]];
                  const d3 = n3.geometry.length - 1;
                  for (let t4 = 0; t4 < d3 / 2; t4++) if (t4 + 1 < d3 / 2) {
                    let e4 = t4, r4 = t4 + 1, i4 = d3 - 1 - t4, s4 = d3 - 2 - t4;
                    e4 = 0 === e4 ? d3 - 1 : e4 - 1, r4 = 0 === r4 ? d3 - 1 : r4 - 1, i4 = 0 === i4 ? d3 - 1 : i4 - 1, s4 = 0 === s4 ? d3 - 1 : s4 - 1, n3.indices.push(i4), n3.indices.push(r4), n3.indices.push(e4), n3.indices.push(i4), n3.indices.push(s4), n3.indices.push(r4);
                  }
                  return n3;
                }(e2[0]), e2 = [g2.geometry];
              }
              const x2 = (t3, e3) => t3 < (e3.length - 1) / 2 || t3 === e3.length - 1, v3 = this.wallMode ? [e2] : Ih(e2, 500);
              for (let t3 = v3.length - 1; t3 >= 0; t3--) {
                const e3 = v3[t3];
                (0 === e3.length || (b2 = e3[0]).every((t4) => t4.x <= 0) || b2.every((t4) => t4.x >= Tn) || b2.every((t4) => t4.y <= 0) || b2.every((t4) => t4.y >= Tn)) && v3.splice(t3, 1);
              }
              var b2;
              let _2;
              if (h2) _2 = mf(v3, u5, n2);
              else {
                _2 = [];
                for (const t3 of v3) _2.push({ polygon: t3, bounds: u5 });
              }
              const w2 = p2 ? this.edgeRadius : 0, A2 = w2 > 0 && this.zoom < 17, M2 = (t3, e3) => {
                if (0 === t3.length) return false;
                const r3 = t3[t3.length - 1];
                return e3.x === r3.x && e3.y === r3.y;
              };
              for (const { polygon: t3, bounds: e3 } of _2) {
                let r3 = 0, i3 = 0;
                for (const e4 of t3) p2 && !e4[0].equals(e4[e4.length - 1]) && e4.push(e4[0]), i3 += p2 ? e4.length - 1 : e4.length;
                const s3 = this.segments.prepareSegment((p2 ? 5 : 4) * i3, this.layoutVertexArray, this.indexArray);
                d2.footprintSegIdx < 0 && (d2.footprintSegIdx = this.footprintSegments.length), d2.polygonSegIdx < 0 && (d2.polygonSegIdx = this.polygonSegments.length);
                const o3 = { triangleArrayOffset: this.indexArray.length, triangleCount: 0, triangleSegIdx: this.segments.segments.length - 1 }, a3 = new Jp();
                if (a3.vertexOffset = this.footprintVertices.length, a3.indexOffset = 3 * this.footprintIndices.length, a3.ringIndices = [], p2) {
                  const i4 = [], o4 = [];
                  r3 = s3.vertexLength;
                  for (let r4 = 0; r4 < t3.length; r4++) {
                    const u7 = t3[r4];
                    u7.length && 0 !== r4 && o4.push(i4.length / 2);
                    const p3 = [];
                    let f3, d3;
                    f3 = u7[1].sub(u7[0])._perp()._unit(), a3.ringIndices.push(u7.length - 1);
                    for (let t4 = 1; t4 < u7.length; t4++) {
                      const e4 = u7[t4], r5 = u7[t4 === u7.length - 1 ? 1 : t4 + 1], o5 = e4.clone();
                      if (w2) {
                        d3 = r5.sub(e4)._perp()._unit();
                        const t5 = f3.add(d3)._unit(), n3 = w2 * Math.min(4, 1 / (f3.x * t5.x + f3.y * t5.y));
                        o5.x += n3 * t5.x, o5.y += n3 * t5.y, o5.x = Math.round(o5.x), o5.y = Math.round(o5.y), f3 = d3;
                      }
                      if (!m2 || 0 !== w2 && !A2 || M2(p3, o5) || p3.push(o5), Zp(this.layoutVertexArray, o5.x, o5.y, 0, 0, 1, 1, 0), this.wallMode) {
                        const e5 = x2(t4, u7);
                        Wp(this.wallVertexArray, g2.joinNormals[t4], !e5);
                      }
                      s3.vertexLength++, this.footprintVertices.emplaceBack(e4.x, e4.y), i4.push(e4.x, e4.y), h2 && Kp(this.layoutVertexExtArray, c2.projectTilePoint(o5.x, o5.y, n2), c2.upVector(n2, o5.x, o5.y));
                    }
                    m2 && (0 === w2 || A2) && (0 !== p3.length && M2(p3, p3[0]) && p3.pop(), this.groundEffect.addData(p3, e3, l2));
                  }
                  const u6 = this.wallMode ? g2.indices : Qc(i4, o4);
                  for (let t4 = 0; t4 < u6.length; t4 += 3) this.footprintIndices.emplaceBack(a3.vertexOffset + u6[t4 + 0], a3.vertexOffset + u6[t4 + 1], a3.vertexOffset + u6[t4 + 2]), this.indexArray.emplaceBack(r3 + u6[t4], r3 + u6[t4 + 2], r3 + u6[t4 + 1]), s3.primitiveLength++;
                  a3.indexCount += u6.length, a3.vertexCount += this.footprintVertices.length - a3.vertexOffset;
                }
                for (let i4 = 0; i4 < t3.length; i4++) {
                  const o4 = t3[i4];
                  f2.startRing(d2, o4[0]);
                  let a4 = o4.length > 4 && pf(o4[o4.length - 2], o4[0], o4[1]), u6 = w2 ? lf(o4[o4.length - 2], o4[0], o4[1], w2) : 0;
                  const y3 = [];
                  let v4, b3, _3;
                  b3 = o4[1].sub(o4[0])._perp()._unit();
                  let A3 = true;
                  for (let t4 = 1, i5 = 0; t4 < o4.length; t4++) {
                    let l3 = o4[t4 - 1], p3 = o4[t4];
                    const I2 = o4[t4 === o4.length - 1 ? 1 : t4 + 1];
                    if (f2.appendEdge(d2, p3, l3), cf(p3, l3, e3)) {
                      w2 && (b3 = I2.sub(p3)._perp()._unit(), A3 = !A3);
                      continue;
                    }
                    const S2 = p3.sub(l3)._perp(), z2 = S2.x / (Math.abs(S2.x) + Math.abs(S2.y)), k2 = S2.y > 0 ? 1 : 0, E2 = l3.dist(p3);
                    if (i5 + E2 > 32768 && (i5 = 0), w2) {
                      _3 = I2.sub(p3)._perp()._unit();
                      let t5 = uf(l3, p3, I2, af(b3, _3), w2);
                      isNaN(t5) && (t5 = 0);
                      const e4 = p3.sub(l3)._unit();
                      l3 = l3.add(e4.mult(u6))._round(), p3 = p3.add(e4.mult(-t5))._round(), u6 = t5, b3 = _3, m2 && this.zoom >= 17 && (M2(y3, l3) || y3.push(l3), M2(y3, p3) || y3.push(p3));
                    }
                    const P2 = s3.vertexLength, T2 = o4.length > 4 && pf(l3, p3, I2);
                    let B3 = ff(i5, a4, A3);
                    if (Zp(this.layoutVertexArray, l3.x, l3.y, z2, k2, 0, 0, B3), Zp(this.layoutVertexArray, l3.x, l3.y, z2, k2, 0, 1, B3), this.wallMode) {
                      const e4 = x2(t4 - 1, o4), r4 = g2.joinNormals[t4 - 1];
                      Wp(this.wallVertexArray, r4, e4), Wp(this.wallVertexArray, r4, e4);
                    }
                    if (i5 += E2, B3 = ff(i5, T2, !A3), a4 = T2, Zp(this.layoutVertexArray, p3.x, p3.y, z2, k2, 0, 0, B3), Zp(this.layoutVertexArray, p3.x, p3.y, z2, k2, 0, 1, B3), this.wallMode) {
                      const e4 = x2(t4, o4), r4 = g2.joinNormals[t4];
                      Wp(this.wallVertexArray, r4, e4), Wp(this.wallVertexArray, r4, e4);
                    }
                    if (s3.vertexLength += 4, this.indexArray.emplaceBack(P2 + 0, P2 + 1, P2 + 2), this.indexArray.emplaceBack(P2 + 1, P2 + 3, P2 + 2), s3.primitiveLength += 2, w2) {
                      const n3 = r3 + (1 === t4 ? o4.length - 2 : t4 - 2), i6 = 1 === t4 ? r3 : n3 + 1;
                      if (this.indexArray.emplaceBack(P2 + 1, n3, P2 + 3), this.indexArray.emplaceBack(n3, i6, P2 + 3), s3.primitiveLength += 2, void 0 === v4 && (v4 = P2), !cf(I2, o4[t4], e3)) {
                        const e4 = t4 === o4.length - 1 ? v4 : s3.vertexLength;
                        this.indexArray.emplaceBack(P2 + 2, P2 + 3, e4), this.indexArray.emplaceBack(P2 + 3, e4 + 1, e4), this.indexArray.emplaceBack(P2 + 3, i6, e4 + 1), s3.primitiveLength += 3;
                      }
                      A3 = !A3;
                    }
                    if (h2) {
                      const t5 = this.layoutVertexExtArray, e4 = c2.projectTilePoint(l3.x, l3.y, n2), r4 = c2.projectTilePoint(p3.x, p3.y, n2), i6 = c2.upVector(n2, l3.x, l3.y), s4 = c2.upVector(n2, p3.x, p3.y);
                      Kp(t5, e4, i6), Kp(t5, e4, i6), Kp(t5, r4, s4), Kp(t5, r4, s4);
                    }
                  }
                  p2 && (r3 += o4.length - 1), m2 && w2 && this.zoom >= 17 && (0 !== y3.length && M2(y3, y3[0]) && y3.pop(), this.groundEffect.addData(y3, e3, l2, w2 > 0));
                }
                this.footprintSegments.push(a3), o3.triangleCount = this.indexArray.length - o3.triangleArrayOffset, this.polygonSegments.push(o3), ++d2.footprintSegLen, ++d2.polygonSegLen;
              }
              if (d2.vertexCount = this.layoutVertexArray.length - d2.vertexArrayOffset, d2.groundVertexCount = this.groundEffect.vertexArray.length - d2.groundVertexArrayOffset, 0 !== d2.vertexCount) {
                if (d2.centroidXY = f2.borders ? Hp : this.encodeCentroid(f2, d2), this.centroidData.push(d2), f2.borders) {
                  this.featuresOnBorder.push(f2);
                  const t3 = this.featuresOnBorder.length - 1;
                  for (let e3 = 0; e3 < f2.borders.length; e3++) f2.borders[e3][0] !== Number.MAX_VALUE && this.borderFeatureIndices[e3].push(t3);
                }
                this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, a2), this.groundEffect.addPaintPropertiesData(t2, r2, i2, s2, n2, a2), this.maxHeight = Math.max(this.maxHeight, y2);
              }
            }
            sortBorders() {
              for (let t2 = 0; t2 < this.borderFeatureIndices.length; t2++) this.borderFeatureIndices[t2].sort((e2, r2) => this.featuresOnBorder[e2].borders[t2][0] - this.featuresOnBorder[r2].borders[t2][0]);
            }
            splitToSubtiles() {
              const t2 = [];
              for (let e3 = 0; e3 < this.centroidData.length; e3++) {
                const r3 = this.centroidData[e3], n3 = +(r3.min.y + r3.max.y > Tn), i3 = 2 * n3 + (+(r3.min.x + r3.max.x > Tn) ^ n3);
                for (let n4 = 0; n4 < r3.polygonSegLen; n4++) {
                  const s3 = r3.polygonSegIdx + n4;
                  t2.push({ centroidIdx: e3, subtile: i3, polygonSegmentIdx: s3, triangleSegmentIdx: this.polygonSegments[s3].triangleSegIdx });
                }
              }
              const e2 = new wa();
              t2.sort((t3, e3) => t3.triangleSegmentIdx === e3.triangleSegmentIdx ? t3.subtile - e3.subtile : t3.triangleSegmentIdx - e3.triangleSegmentIdx);
              let r2 = 0, n2 = 0, i2 = 0;
              for (const e3 of t2) {
                if (e3.triangleSegmentIdx !== r2) break;
                i2++;
              }
              const s2 = t2.length;
              for (; n2 !== t2.length; ) {
                r2 = t2[n2].triangleSegmentIdx;
                let o2 = 0, a2 = n2, l2 = n2;
                for (let e3 = a2; e3 < i2 && t2[e3].subtile === o2; e3++) l2++;
                for (; a2 !== i2; ) {
                  const n3 = t2[a2];
                  o2 = n3.subtile;
                  const s3 = this.centroidData[n3.centroidIdx].min.clone(), u5 = this.centroidData[n3.centroidIdx].max.clone(), c2 = { vertexOffset: this.segments.segments[r2].vertexOffset, primitiveOffset: e2.length, vertexLength: this.segments.segments[r2].vertexLength, primitiveLength: 0, sortKey: void 0, vaos: {} };
                  for (let r3 = a2; r3 < l2; r3++) {
                    const n4 = t2[r3], i3 = this.polygonSegments[n4.polygonSegmentIdx], o3 = this.centroidData[n4.centroidIdx].min, a3 = this.centroidData[n4.centroidIdx].max, l3 = this.indexArray.uint16;
                    for (let t3 = i3.triangleArrayOffset; t3 < i3.triangleArrayOffset + i3.triangleCount; t3++) e2.emplaceBack(l3[3 * t3], l3[3 * t3 + 1], l3[3 * t3 + 2]);
                    c2.primitiveLength += i3.triangleCount, s3.x = Math.min(s3.x, o3.x), s3.y = Math.min(s3.y, o3.y), u5.x = Math.max(u5.x, a3.x), u5.y = Math.max(u5.y, a3.y);
                  }
                  c2.primitiveLength > 0 && this.triangleSubSegments.push({ segment: c2, min: s3, max: u5 }), a2 = l2;
                  for (let e3 = a2; e3 < i2 && t2[e3].subtile === t2[a2].subtile; e3++) l2++;
                }
                n2 = i2;
                for (let e3 = n2; e3 < s2 && t2[e3].triangleSegmentIdx === t2[n2].triangleSegmentIdx; e3++) i2++;
              }
              e2._trim(), this.indexArray = e2;
            }
            getVisibleSegments(t2, e2, r2) {
              const n2 = new Ka();
              if (this.wallMode) {
                for (const t3 of this.triangleSubSegments) n2.segments.push(t3.segment);
                return n2;
              }
              let i2 = 0, s2 = 0;
              const o2 = 1 << t2.canonical.z;
              if (e2) {
                const r3 = e2.getMinMaxForTile(t2);
                r3 && (i2 = r3.min, s2 = r3.max);
              }
              s2 += this.maxHeight;
              const a2 = t2.toUnwrapped();
              let l2;
              const u5 = [a2.canonical.x / o2 + a2.wrap, a2.canonical.y / o2], c2 = [(a2.canonical.x + 1) / o2 + a2.wrap, (a2.canonical.y + 1) / o2], h2 = (t3, e3, r3) => [t3[0] * (1 - r3[0]) + e3[0] * r3[0], t3[1] * (1 - r3[1]) + e3[1] * r3[1]], p2 = [], f2 = [];
              for (const t3 of this.triangleSubSegments) {
                p2[0] = t3.min.x / Tn, p2[1] = t3.min.y / Tn, f2[0] = t3.max.x / Tn, f2[1] = t3.max.y / Tn;
                const e3 = h2(u5, c2, p2), o3 = h2(u5, c2, f2);
                if (0 === new ic([e3[0], e3[1], i2], [o3[0], o3[1], s2]).intersectsPrecise(r2)) {
                  l2 && (n2.segments.push(l2), l2 = void 0);
                  continue;
                }
                const a3 = t3.segment;
                l2 && l2.vertexOffset !== a3.vertexOffset && (n2.segments.push(l2), l2 = void 0), l2 ? (l2.vertexLength += a3.vertexLength, l2.primitiveLength += a3.primitiveLength) : l2 = { vertexOffset: a3.vertexOffset, primitiveLength: a3.primitiveLength, vertexLength: a3.vertexLength, primitiveOffset: a3.primitiveOffset, sortKey: void 0, vaos: {} };
              }
              return l2 && n2.segments.push(l2), n2;
            }
            encodeCentroid(t2, e2) {
              const r2 = t2.centroid(), n2 = e2.span(), i2 = Math.min(7, Math.round(n2.x * this.tileToMeter / 10)), s2 = Math.min(7, Math.round(n2.y * this.tileToMeter / 10));
              return new bt(Pt(r2.x, 1, Tn - 1) << 3 | i2, Pt(r2.y, 1, Tn - 1) << 3 | s2);
            }
            encodeBorderCentroid(t2) {
              if (!t2.borders) return new bt(0, 0);
              const e2 = t2.borders, r2 = Number.MAX_VALUE;
              if (e2[0][0] !== r2 || e2[1][0] !== r2) {
                const t3 = e2[0][0] !== r2 ? 0 : 1;
                return new bt(6 | (e2[0][0] !== r2 ? 0 : 65528), (e2[t3][0] + e2[t3][1]) / 2 << 3 | 6);
              }
              {
                const t3 = e2[2][0] !== r2 ? 2 : 3;
                return new bt((e2[t3][0] + e2[t3][1]) / 2 << 3 | 6, 6 | (e2[2][0] !== r2 ? 0 : 65528));
              }
            }
            showCentroid(t2) {
              const e2 = this.centroidData[t2.centroidDataIndex];
              e2.flags &= Xp, e2.centroidXY.x = 0, e2.centroidXY.y = 0, this.writeCentroidToBuffer(e2);
            }
            writeCentroidToBuffer(t2) {
              this.groundEffect.updateHiddenByLandmark(t2);
              const e2 = t2.vertexArrayOffset, r2 = t2.vertexCount + t2.vertexArrayOffset, n2 = t2.flags & Xp ? Hp : t2.centroidXY, i2 = this.centroidVertexArray.geta_centroid_pos0(e2);
              if (this.centroidVertexArray.geta_centroid_pos1(e2) !== n2.y || i2 !== n2.x) {
                for (let t3 = e2; t3 < r2; ++t3) this.centroidVertexArray.emplace(t3, n2.x, n2.y);
                this.needsCentroidUpdate = true;
              }
            }
            createCentroidsBuffer() {
              this.centroidVertexArray.resize(this.layoutVertexArray.length), this.groundEffect.hiddenByLandmarkVertexArray.resize(this.groundEffect.vertexArray.length);
              for (const t2 of this.centroidData) this.writeCentroidToBuffer(t2);
            }
            updateReplacement(t2, e2, r2) {
              if (e2.updateTime === this.replacementUpdateTime) return;
              this.replacementUpdateTime = e2.updateTime;
              const n2 = e2.getReplacementRegionsForTile(t2.toUnwrapped());
              if (Bp(this.activeReplacements, n2)) return;
              if (this.activeReplacements = n2, 0 === this.centroidVertexArray.length) this.createCentroidsBuffer();
              else for (const t3 of this.centroidData) t3.flags &= 2147483647;
              const i2 = [];
              for (const e3 of this.activeReplacements) {
                if (e3.order < r2) continue;
                const n3 = Math.max(1, Math.pow(2, e3.footprintTileId.canonical.z - t2.canonical.z));
                for (const r3 of this.centroidData) if (!(r3.flags & Xp || e3.min.x > r3.max.x || r3.min.x > e3.max.x || e3.min.y > r3.max.y || r3.min.y > e3.max.y)) for (let s2 = 0; s2 < r3.footprintSegLen; s2++) {
                  const o2 = this.footprintSegments[r3.footprintSegIdx + s2];
                  if (i2.length = 0, yf(this.footprintVertices, o2.vertexOffset, o2.vertexCount, e3.footprintTileId.canonical, t2.canonical, i2), Dp(e3.footprint, i2, this.footprintIndices.uint16, o2.indexOffset, o2.indexCount, -o2.vertexOffset, -n3)) {
                    r3.flags |= Xp;
                    break;
                  }
                }
              }
              for (const t3 of this.centroidData) this.writeCentroidToBuffer(t3);
              this.borderDoneWithNeighborZ = [-1, -1, -1, -1];
            }
            footprintContainsPoint(t2, e2, r2) {
              let n2 = false;
              for (let i2 = 0; i2 < r2.footprintSegLen; i2++) {
                const s2 = this.footprintSegments[r2.footprintSegIdx + i2];
                let o2 = 0;
                for (const r3 of s2.ringIndices) {
                  for (let i3 = o2, a2 = r3 + o2 - 1; i3 < r3 + o2; a2 = i3++) {
                    const r4 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 0], o3 = this.footprintVertices.int16[2 * (i3 + s2.vertexOffset) + 1], l2 = this.footprintVertices.int16[2 * (a2 + s2.vertexOffset) + 1];
                    o3 > e2 != l2 > e2 && t2 < (this.footprintVertices.int16[2 * (a2 + s2.vertexOffset) + 0] - r4) * (e2 - o3) / (l2 - o3) + r4 && (n2 = !n2);
                  }
                  o2 = r3;
                }
              }
              return n2;
            }
            getHeightAtTileCoord(t2, e2) {
              let r2 = Number.NEGATIVE_INFINITY, n2 = true;
              const i2 = 4 * (t2 + Tn) * Tn + (e2 + Tn);
              if (this.partLookup.hasOwnProperty(i2)) {
                const t3 = this.partLookup[i2];
                return t3 ? { height: t3.height, hidden: !!(t3.flags & Xp) } : void 0;
              }
              for (const s2 of this.centroidData) t2 > s2.max.x || s2.min.x > t2 || e2 > s2.max.y || s2.min.y > e2 || this.footprintContainsPoint(t2, e2, s2) && s2 && s2.height > r2 && (r2 = s2.height, this.partLookup[i2] = s2, n2 = !!(s2.flags & Xp));
              if (r2 !== Number.NEGATIVE_INFINITY) return { height: r2, hidden: n2 };
              this.partLookup[i2] = void 0;
            }
          }
          function af(t2, e2) {
            const r2 = t2.add(e2)._unit();
            return t2.x * r2.x + t2.y * r2.y;
          }
          function lf(t2, e2, r2, n2) {
            const i2 = e2.sub(t2)._perp()._unit(), s2 = r2.sub(e2)._perp()._unit();
            return uf(t2, e2, r2, af(i2, s2), n2);
          }
          function uf(t2, e2, r2, n2, i2) {
            const s2 = Math.sqrt(1 - n2 * n2);
            return Math.min(t2.dist(e2) / 3, e2.dist(r2) / 3, i2 * s2 / n2);
          }
          function cf(t2, e2, r2) {
            return t2.x < r2[0].x && e2.x < r2[0].x || t2.x > r2[1].x && e2.x > r2[1].x || t2.y < r2[0].y && e2.y < r2[0].y || t2.y > r2[1].y && e2.y > r2[1].y;
          }
          function hf(t2, e2) {
            return t2.x < e2[0].x || t2.x > e2[1].x || t2.y < e2[0].y || t2.y > e2[1].y;
          }
          function pf(t2, e2, r2) {
            if (t2.x < 0 || t2.x >= Tn || e2.x < 0 || e2.x >= Tn || r2.x < 0 || r2.x >= Tn) return false;
            const n2 = r2.sub(e2), i2 = n2.perp(), s2 = t2.sub(e2);
            return (n2.x * s2.x + n2.y * s2.y) / Math.sqrt((n2.x * n2.x + n2.y * n2.y) * (s2.x * s2.x + s2.y * s2.y)) > -0.866 && i2.x * s2.x + i2.y * s2.y < 0;
          }
          function ff(t2, e2, r2) {
            const n2 = e2 ? 2 | t2 : -3 & t2;
            return r2 ? 1 | n2 : -2 & n2;
          }
          function df() {
            const t2 = Math.PI / 32, e2 = Math.tan(t2), r2 = Nl;
            return r2 * Math.sqrt(1 + 2 * e2 * e2) - r2;
          }
          function mf(t2, e2, r2) {
            const n2 = 1 << r2.z, i2 = Kl(r2.x / n2), s2 = Kl((r2.x + 1) / n2), o2 = Jl(r2.y / n2), a2 = Jl((r2.y + 1) / n2);
            return function(t3, e3, r3, n3, i3 = 0, s3) {
              const o3 = [];
              if (!t3.length || !r3 || !n3) return o3;
              const a3 = (t4, e4) => {
                for (const r4 of t4) o3.push({ polygon: r4, bounds: e4 });
              }, l2 = Math.ceil(Math.log2(r3)), u5 = Math.ceil(Math.log2(n3)), c2 = l2 - u5, h2 = [];
              for (let t4 = 0; t4 < Math.abs(c2); t4++) h2.push(c2 > 0 ? 0 : 1);
              for (let t4 = 0; t4 < Math.min(l2, u5); t4++) h2.push(0), h2.push(1);
              let p2 = t3;
              if (p2 = op(p2, e3[0].y - i3, e3[1].y + i3, 1), p2 = op(p2, e3[0].x - i3, e3[1].x + i3, 0), !p2.length) return o3;
              const f2 = [];
              for (h2.length ? f2.push({ polygons: p2, bounds: e3, depth: 0 }) : a3(p2, e3); f2.length; ) {
                const t4 = f2.pop(), e4 = t4.depth, r4 = h2[e4], n4 = t4.bounds[0], o4 = t4.bounds[1], l3 = 0 === r4 ? n4.x : n4.y, u6 = 0 === r4 ? o4.x : o4.y, c3 = s3 ? s3(r4, l3, u6) : 0.5 * (l3 + u6), p3 = op(t4.polygons, l3 - i3, c3 + i3, r4), d2 = op(t4.polygons, c3 - i3, u6 + i3, r4);
                if (p3.length) {
                  const t5 = [n4, new bt(0 === r4 ? c3 : o4.x, 1 === r4 ? c3 : o4.y)];
                  h2.length > e4 + 1 ? f2.push({ polygons: p3, bounds: t5, depth: e4 + 1 }) : a3(p3, t5);
                }
                if (d2.length) {
                  const t5 = [new bt(0 === r4 ? c3 : n4.x, 1 === r4 ? c3 : n4.y), o4];
                  h2.length > e4 + 1 ? f2.push({ polygons: d2, bounds: t5, depth: e4 + 1 }) : a3(d2, t5);
                }
              }
              return o3;
            }(t2, e2, Math.ceil((s2 - i2) / 11.25), Math.ceil((o2 - a2) / 11.25), 1, (t3, e3, i3) => {
              if (0 === t3) return 0.5 * (e3 + i3);
              {
                const t4 = Jl((r2.y + e3 / Tn) / n2);
                return (Wl(0.5 * (Jl((r2.y + i3 / Tn) / n2) + t4)) * n2 - r2.y) * Tn;
              }
            });
          }
          function yf(t2, e2, r2, n2, i2, s2) {
            const o2 = Math.pow(2, n2.z - i2.z);
            for (let a2 = 0; a2 < r2; a2++) {
              let r3 = t2.int16[2 * (a2 + e2) + 0], l2 = t2.int16[2 * (a2 + e2) + 1];
              r3 = (r3 + i2.x * Tn) * o2 - n2.x * Tn, l2 = (l2 + i2.y * Tn) * o2 - n2.y * Tn, s2.push(new bt(r3, l2));
            }
          }
          let gf, xf;
          js(of, "FillExtrusionBucket", { omit: ["layers", "features"] }), js(Qp, "PartData"), js(Jp, "FootprintSegment"), js(tf, "BorderCentroidData"), js(sf, "GroundEffect");
          class vf extends bt {
            constructor(t2, e2, r2) {
              super(t2, e2), this.z = r2;
            }
          }
          class bf extends vf {
            constructor(t2, e2, r2, n2) {
              super(t2, e2, r2), this.w = n2;
            }
          }
          function _f(t2, e2, r2, n2) {
            const i2 = "x" === r2 ? "y" : "x", s2 = (n2 - t2[r2]) / (e2[r2] - t2[r2]);
            t2[i2] = Math.round(t2[i2] + (e2[i2] - t2[i2]) * s2), t2[r2] = n2, t2.hasOwnProperty("z") && (t2.z = or(t2.z, e2.z, s2)), t2.hasOwnProperty("w") && (t2.w = or(t2.w, e2.w, s2));
          }
          function wf(t2, e2, r2, n2) {
            const i2 = r2, s2 = n2;
            for (const r3 of ["x", "y"]) {
              let n3 = t2, o2 = e2;
              n3[r3] >= o2[r3] && (n3 = e2, o2 = t2), n3[r3] < i2 && o2[r3] > i2 && _f(n3, o2, r3, i2), n3[r3] < s2 && o2[r3] > s2 && _f(o2, n3, r3, s2);
            }
          }
          function Af(t2, e2, r2, n2, i2, s2) {
            const o2 = [];
            for (let a2 = 0; a2 < t2.length; a2++) {
              const l2 = t2[a2];
              let u5;
              const c2 = o2.length;
              let h2 = 0;
              for (let t3 = 0; t3 < l2.length - 1; t3++) {
                let c3 = l2[t3], p2 = l2[t3 + 1], f2 = 0;
                const d2 = h2;
                let m2, y2;
                s2 && (f2 = Math.hypot(p2.x - c3.x, p2.y - c3.y), h2 += f2, m2 = c3, y2 = p2), c3.x < e2 && p2.x < e2 || (c3.x < e2 ? c3 = new bt(e2, c3.y + (e2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round() : p2.x < e2 && (p2 = new bt(e2, c3.y + (e2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round()), c3.y < r2 && p2.y < r2 || (c3.y < r2 ? c3 = new bt(c3.x + (r2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), r2)._round() : p2.y < r2 && (p2 = new bt(c3.x + (r2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), r2)._round()), c3.x >= n2 && p2.x >= n2 || (c3.x >= n2 ? c3 = new bt(n2, c3.y + (n2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round() : p2.x >= n2 && (p2 = new bt(n2, c3.y + (n2 - c3.x) / (p2.x - c3.x) * (p2.y - c3.y))._round()), c3.y >= i2 && p2.y >= i2 || (c3.y >= i2 ? c3 = new bt(c3.x + (i2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), i2)._round() : p2.y >= i2 && (p2 = new bt(c3.x + (i2 - c3.y) / (p2.y - c3.y) * (p2.x - c3.x), i2)._round()), u5 && c3.equals(u5[u5.length - 1]) || (u5 = [c3], o2.push(u5), s2 && s2.push({ progress: { min: d2 + If(m2, y2, c3) * f2, max: 1 }, parentIndex: a2, prevPoint: m2, nextPoint: y2 })), u5.push(p2), s2 && (s2[s2.length - 1].progress.max = d2 + If(m2, y2, p2) * f2, s2[s2.length - 1].nextPoint = y2)))));
              }
              if (s2 && h2 > 0) for (let t3 = c2; t3 < o2.length; t3++) s2[t3].progress.min /= h2, s2[t3].progress.max /= h2;
            }
            return o2;
          }
          function Mf(t2, e2, r2, n2, i2) {
            if (t2.length < 2) return void n2.push(t2);
            const s2 = [];
            for (; e2.valid(); ) {
              const [r3, n3] = e2.get();
              for (let e3 = 0; e3 < t2.length - 1; e3++) {
                const i3 = t2[e3], o3 = t2[e3 + 1], a3 = Iu(i3, o3, r3, n3);
                if (a3) {
                  const [t3] = a3, r4 = new bt(or(i3.x, o3.x, t3), or(i3.y, o3.y, t3));
                  s2.push({ t: e3 + t3, distance: 0, point: r4 });
                }
              }
              e2.next();
            }
            if (0 === s2.length) return void n2.push(t2);
            s2.sort((t3, e3) => t3.t - e3.t);
            let o2 = 0, a2 = 0, l2 = [];
            for (n2.push(l2); o2 !== t2.length; ) {
              if (a2 === s2.length) {
                for (; o2 !== t2.length; ) 0 !== l2.length && l2[l2.length - 1].equals(t2[o2]) || l2.push(t2[o2]), o2++;
                break;
              }
              s2[a2].t <= o2 ? (0 !== l2.length && l2[l2.length - 1].equals(s2[a2].point) || l2.push(s2[a2].point), Math.trunc(s2[a2].t), a2++) : (0 !== l2.length && l2[l2.length - 1].equals(t2[o2]) || l2.push(t2[o2]), o2++);
            }
          }
          function If(t2, e2, r2) {
            return t2.x !== e2.x ? (r2.x - t2.x) / (e2.x - t2.x) : t2.y !== e2.y ? (r2.y - t2.y) / (e2.y - t2.y) : 0;
          }
          function Sf(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function zf(t2, e2) {
            if (1 === t2.length) {
              let r2 = 0;
              const n2 = e2[r2++];
              let i2;
              for (; !i2 || n2.equals(i2); ) if (i2 = e2[r2++], !i2) return 1 / 0;
              for (; r2 < e2.length; r2++) {
                const s2 = e2[r2], o2 = t2[0], a2 = i2.sub(n2), l2 = s2.sub(n2), u5 = o2.sub(n2), c2 = Sf(a2, a2), h2 = Sf(a2, l2), p2 = Sf(l2, l2), f2 = Sf(u5, a2), d2 = Sf(u5, l2), m2 = c2 * p2 - h2 * h2, y2 = (p2 * f2 - h2 * d2) / m2, g2 = (c2 * d2 - h2 * f2) / m2, x2 = n2.z * (1 - y2 - g2) + i2.z * y2 + s2.z * g2;
                if (isFinite(x2)) return x2;
              }
              return 1 / 0;
            }
            {
              let t3 = 1 / 0;
              for (const r2 of e2) t3 = Math.min(t3, r2.z);
              return t3;
            }
          }
          function kf(t2, e2, r2, n2, i2, s2, o2, a2) {
            const l2 = o2 * i2.getElevationAt(t2, e2, true, true), u5 = 0 !== s2[0], c2 = u5 ? 0 === s2[1] ? o2 * (s2[0] / 7 - 450) : o2 * function(t3, e3, r3) {
              const n3 = Math.floor(e3[0] / 8), i3 = Math.floor(e3[1] / 8), s3 = 10 * (e3[0] - 8 * n3), o3 = 10 * (e3[1] - 8 * i3), a3 = t3.getElevationAt(n3, i3, true, true), l3 = t3.getMeterToDEM(r3), u6 = Math.floor(0.5 * (s3 * l3 - 1)), c3 = Math.floor(0.5 * (o3 * l3 - 1)), h2 = t3.tileCoordToPixel(n3, i3), p2 = 2 * u6 + 1, f2 = 2 * c3 + 1, d2 = function(t4, e4, r4, n4, i4) {
                return [t4.getElevationAtPixel(e4, r4, true), t4.getElevationAtPixel(e4 + i4, r4, true), t4.getElevationAtPixel(e4, r4 + i4, true), t4.getElevationAtPixel(e4 + n4, r4 + i4, true)];
              }(t3, h2.x - u6, h2.y - c3, p2, f2), m2 = Math.abs(d2[0] - d2[1]), y2 = Math.abs(d2[2] - d2[3]), g2 = Math.abs(d2[0] - d2[2]) + Math.abs(d2[1] - d2[3]), x2 = Math.min(0.25, 0.5 * l3 * (m2 + y2) / p2), v3 = Math.min(0.25, 0.5 * l3 * g2 / f2);
              return a3 + Math.max(x2 * s3, v3 * o3);
            }(i2, s2, a2) : l2;
            return { base: l2 + (0 === r2 ? -1 : r2), top: u5 ? Math.max(c2 + n2, l2 + r2 + 2) : l2 + n2 };
          }
          const Ef = Qo([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }, { name: "a_linesofar", components: 1, type: "Float32" }], 4), Pf = Qo([{ name: "a_z_offset_width", components: 3, type: "Float32" }], 4), { members: Tf } = Ef, Bf = Qo([{ name: "a_packed", components: 3, type: "Float32" }]), { members: Vf } = Bf, Cf = Qo([{ name: "a_pattern_data", components: 3, type: "Float32" }]), { members: Df } = Cf;
          class Ff {
            constructor(t2, e2) {
              this.width = t2, this.height = e2, this.nextRow = 0, this.image = new qc({ width: t2, height: e2 }), this.positions = {}, this.uploaded = false;
            }
            getDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              return this.positions[r2];
            }
            trim() {
              const t2 = this.width, e2 = this.height = Lt(this.nextRow);
              this.image.resize({ width: t2, height: e2 });
            }
            getKey(t2, e2) {
              return t2.join(",") + e2;
            }
            getDashRanges(t2, e2, r2) {
              const n2 = [];
              let i2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * r2 : 0, s2 = t2[0] * r2, o2 = true;
              n2.push({ left: i2, right: s2, isDash: o2, zeroLength: 0 === t2[0] });
              let a2 = t2[0];
              for (let e3 = 1; e3 < t2.length; e3++) {
                o2 = !o2;
                const l2 = t2[e3];
                i2 = a2 * r2, a2 += l2, s2 = a2 * r2, n2.push({ left: i2, right: s2, isDash: o2, zeroLength: 0 === l2 });
              }
              return n2;
            }
            addRoundDash(t2, e2, r2) {
              const n2 = e2 / 2;
              for (let e3 = -r2; e3 <= r2; e3++) {
                const i2 = this.width * (this.nextRow + r2 + e3);
                let s2 = 0, o2 = t2[s2];
                for (let a2 = 0; a2 < this.width; a2++) {
                  a2 / o2.right > 1 && (o2 = t2[++s2]);
                  const l2 = Math.abs(a2 - o2.left), u5 = Math.abs(a2 - o2.right), c2 = Math.min(l2, u5);
                  let h2;
                  const p2 = e3 / r2 * (n2 + 1);
                  if (o2.isDash) {
                    const t3 = n2 - Math.abs(p2);
                    h2 = Math.sqrt(c2 * c2 + t3 * t3);
                  } else h2 = n2 - Math.sqrt(c2 * c2 + p2 * p2);
                  this.image.data[i2 + a2] = Math.max(0, Math.min(255, h2 + 128));
                }
              }
            }
            addRegularDash(t2, e2) {
              for (let e3 = t2.length - 1; e3 >= 0; --e3) {
                const r3 = t2[e3], n3 = t2[e3 + 1];
                r3.zeroLength ? t2.splice(e3, 1) : n3 && n3.isDash === r3.isDash && (n3.left = r3.left, t2.splice(e3, 1));
              }
              const r2 = t2[0], n2 = t2[t2.length - 1];
              r2.isDash === n2.isDash && (r2.left = n2.left - this.width, n2.right = r2.right + this.width);
              const i2 = this.width * this.nextRow;
              let s2 = 0, o2 = t2[s2];
              for (let r3 = 0; r3 < this.width; r3++) {
                r3 / o2.right > 1 && (o2 = t2[++s2]);
                const n3 = Math.abs(r3 - o2.left), a2 = Math.abs(r3 - o2.right), l2 = Math.min(n3, a2);
                this.image.data[i2 + r3] = Math.max(0, Math.min(255, (o2.isDash ? l2 : -l2) + e2 + 128));
              }
            }
            addDash(t2, e2) {
              const r2 = this.getKey(t2, e2);
              if (this.positions[r2]) return this.positions[r2];
              const n2 = "round" === e2, i2 = n2 ? 7 : 0, s2 = 2 * i2 + 1;
              if (this.nextRow + s2 > this.height) return $t("LineAtlas out of space"), null;
              0 === t2.length && t2.push(1);
              let o2 = 0;
              for (let e3 = 0; e3 < t2.length; e3++) t2[e3] < 0 && ($t("Negative value is found in line dasharray, replacing values with 0"), t2[e3] = 0), o2 += t2[e3];
              if (0 !== o2) {
                const r3 = this.width / o2, s3 = this.getDashRanges(t2, this.width, r3);
                n2 ? this.addRoundDash(s3, r3, i2) : this.addRegularDash(s3, "square" === e2 ? 0.5 * r3 : 0);
              }
              const a2 = this.nextRow + i2;
              this.nextRow += s2;
              const l2 = { tl: [a2, i2], br: [o2, 0] };
              return this.positions[r2] = l2, l2;
            }
          }
          js(Ff, "LineAtlas");
          const Lf = Nh.VectorTileFeature.types, Rf = Math.cos(Math.PI / 180 * 37.5), Of = Math.cos(Math.PI / 180 * 5);
          class Uf {
            constructor(t2) {
              this.evaluationGlobals = { zoom: 0, lineProgress: void 0 }, this.elevationType = "none", this.zoom = t2.zoom, this.evaluationGlobals.zoom = this.zoom, this.overscaling = t2.overscaling, this.pixelRatio = t2.pixelRatio, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.projection = t2.projection, this.hasPattern = false, this.hasCrossSlope = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t3) => {
                this.gradients[t3.id] = {};
              }), this.layoutVertexArray = new la(), this.layoutVertexArray2 = new ua(), this.patternVertexArray = new ua(), this.indexArray = new wa(), this.programConfigurations = new Il(t2.layers, { zoom: t2.zoom, lut: t2.lut }), this.segments = new Ka(), this.maxLineLength = 0, this.zOffsetVertexArray = new ua(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.tessellationStep = t2.tessellationStep ? t2.tessellationStep : Tn / 64;
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.hasPattern = kh("line", this.layers, this.pixelRatio, e2);
              const i2 = this.layers[0].layout.get("line-sort-key");
              this.tileToMeter = iu(r2);
              const s2 = this.layers[0].layout.get("line-elevation-reference");
              if ("hd-road-markup" === s2) this.elevationType = "road";
              else {
                const t3 = this.layers[0].layout.get("line-z-offset"), e3 = t3.isConstant() && !t3.constantOr(0);
                this.elevationType = "sea" !== s2 && "ground" !== s2 && e3 ? "none" : "offset", "offset" === this.elevationType && "none" === s2 && $t(`line-elevation-reference: ground is used for the layer ${this.layerIds[0]} because non-zero line-z-offset value was found.`);
              }
              const o2 = this.layers[0].layout.get("line-cross-slope");
              this.hasCrossSlope = "offset" === this.elevationType && void 0 !== o2;
              const a2 = [];
              for (const { feature: e3, id: s3, index: o3, sourceLayerIndex: l3 } of t2) {
                const t3 = this.layers[0]._featureFilter.needGeometry, u6 = du(e3, t3);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u6, r2)) continue;
                const c3 = i2 ? i2.evaluate(u6, {}, r2) : void 0, h2 = { id: s3, properties: e3.properties, type: e3.type, sourceLayerIndex: l3, index: o3, geometry: t3 ? u6.geometry : fu(e3, r2, n2), patterns: {}, sortKey: c3 };
                a2.push(h2);
              }
              i2 && a2.sort((t3, e3) => t3.sortKey - e3.sortKey);
              const { lineAtlas: l2, featureIndex: u5 } = e2, c2 = this.addConstantDashes(l2);
              for (const n3 of a2) {
                const { geometry: i3, index: s3, sourceLayerIndex: o3 } = n3;
                if (c2 && this.addFeatureDashes(n3, l2), this.hasPattern) {
                  const t3 = Eh("line", this.layers, n3, this.zoom, this.pixelRatio, e2);
                  this.patternFeatures.push(t3);
                } else this.addFeature(n3, i3, s3, r2, l2.positions, e2.availableImages, e2.brightness, e2.elevationFeatures);
                u5.insert(t2[s3].feature, i3, s3, o3, this.index);
              }
            }
            addConstantDashes(t2) {
              let e2 = false;
              for (const r2 of this.layers) {
                const n2 = r2.paint.get("line-dasharray").value, i2 = r2.layout.get("line-cap").value;
                if ("constant" !== n2.kind || "constant" !== i2.kind) e2 = true;
                else {
                  const e3 = i2.value, r3 = n2.value;
                  if (!r3) continue;
                  t2.addDash(r3, e3);
                }
              }
              return e2;
            }
            addFeatureDashes(t2, e2) {
              const r2 = this.zoom;
              for (const n2 of this.layers) {
                const i2 = n2.paint.get("line-dasharray").value, s2 = n2.layout.get("line-cap").value;
                if ("constant" === i2.kind && "constant" === s2.kind) continue;
                let o2, a2;
                if ("constant" === i2.kind) {
                  if (o2 = i2.value, !o2) continue;
                } else o2 = i2.evaluate({ zoom: r2 }, t2);
                a2 = "constant" === s2.kind ? s2.value : s2.evaluate({ zoom: r2 }, t2), e2.addDash(o2, a2), t2.patterns[n2.id] = [e2.getKey(o2, a2)];
              }
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2);
            }
            addFeatures(t2, e2, r2, n2, i2, s2) {
              for (const t3 of this.patternFeatures) this.addFeature(t3, t3.geometry, t3.index, e2, r2, n2, s2);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t2) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Vf)), 0 !== this.patternVertexArray.length && (this.patternVertexBuffer = t2.createVertexBuffer(this.patternVertexArray, Df)), !this.zOffsetVertexBuffer && this.zOffsetVertexArray.length > 0 && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, Pf.members, true)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Tf), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy(), this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t2) {
              if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end")) return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
            }
            addFeature(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = this.layers[0].layout, u5 = l2.get("line-join").evaluate(t2, {}), c2 = l2.get("line-cap").evaluate(t2, {}), h2 = l2.get("line-miter-limit"), p2 = l2.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t2), this.lineFeature = t2, this.zOffsetValue = l2.get("line-z-offset").value;
              const f2 = this.layers[0].paint.get("line-width").value;
              if ("constant" !== f2.kind && false === f2.isLineProgressConstant && (this.variableWidthValue = f2), "road" === this.elevationType) {
                const r3 = this.layoutVertexArray.length;
                if (!this.addElevatedRoadFeature(t2, e2, n2, a2, u5, c2, h2, p2)) {
                  const [i3, s3] = this.clipRuntimeLinesToTile(e2, 1);
                  for (let e3 = 0; e3 < i3.length; e3++) {
                    const r4 = i3[e3], o3 = s3[e3], a3 = { progress: { min: o3.progress.min, max: o3.progress.max }, nextDir: this.computeSegNextDir(o3, r4), prevDir: this.computeSegPrevDir(o3, r4) };
                    this.addLine(r4, t2, n2, u5, c2, h2, p2, a3);
                  }
                  this.fillNonElevatedRoadSegment(r3);
                }
              } else for (const r3 of e2) this.addLine(r3, t2, n2, u5, c2, h2, p2);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, s2, n2, o2);
            }
            computeSegNextDir(t2, e2) {
              return t2.nextPoint.sub(e2.at(-2)).unit();
            }
            computeSegPrevDir(t2, e2) {
              return e2[1].sub(t2.prevPoint).unit();
            }
            clipLinesToTile(t2, e2) {
              return Af(t2, -e2, -e2, Tn + e2, Tn + e2);
            }
            clipRuntimeLinesToTile(t2, e2) {
              const r2 = [];
              return [Af(t2, -e2, -e2, Tn + e2, Tn + e2, r2), r2];
            }
            addElevatedRoadFeature(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = [], u5 = Kh.getElevationFeature(t2, n2);
              if (u5) {
                const t3 = this.clipLinesToTile(e2, 1), n3 = this.prepareElevatedLines(t3, u5, r2);
                for (const t4 of n3) l2.push({ geometry: t4, elevation: u5, elevationTileID: r2, segment: { progress: { min: 0, max: 1 }, nextDir: void 0, prevDir: void 0 } });
              }
              if (0 === l2.length) return false;
              for (const e3 of l2) {
                const n3 = this.layoutVertexArray.length;
                this.addLine(e3.geometry, t2, r2, i2, s2, o2, a2);
                const l3 = new Jh(r2, e3.elevationTileID);
                if (e3.elevation) for (let t3 = n3; t3 < this.layoutVertexArray.length; t3++) {
                  const r3 = new bt(this.layoutVertexArray.int16[6 * t3] >> 1, this.layoutVertexArray.int16[6 * t3 + 1] >> 1), n4 = l3.pointElevation(r3, e3.elevation, 0.05);
                  this.updateHeightRange(n4), this.zOffsetVertexArray.emplaceBack(n4, 0, 0);
                }
                else this.fillNonElevatedRoadSegment(n3);
              }
              return true;
            }
            prepareElevatedLines(t2, e2, r2) {
              if (null != e2.constantHeight) return t2;
              const n2 = [], i2 = 1 / iu(r2);
              for (const r3 of t2) Mf(r3, new Wh(e2, i2), 0, n2);
              return n2;
            }
            fillNonElevatedRoadSegment(t2) {
              for (let e2 = t2; e2 < this.layoutVertexArray.length; e2++) this.zOffsetVertexArray.emplaceBack(0, 0, 0);
            }
            updateHeightRange(t2) {
              this.heightRange ? (this.heightRange.min = Math.min(this.heightRange.min, t2), this.heightRange.max = Math.max(this.heightRange.max, t2)) : this.heightRange = { min: t2, max: t2 };
            }
            addLine(t2, e2, r2, n2, i2, s2, o2, a2) {
              this.distance = 0, this.prevDistance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.totalFeatureLength = 0, this.lineSoFar = 0, this.currentVertex = void 0;
              const l2 = "none" === n2;
              this.patternJoinNone = this.hasPattern && l2, this.segmentStart = 0, this.segmentStartf32 = 0, this.segmentPoints = [];
              const u5 = a2 && a2.progress.min > 0, c2 = a2 && a2.progress.max < 1;
              if (this.lineClips) {
                let r3 = { min: this.lineClips.start, max: this.lineClips.end }, n3 = 1;
                if (a2) {
                  const t3 = this.lineClips.end - this.lineClips.start;
                  r3 = function(t4, e3, r4) {
                    return { min: ee(t4.min, e3, r4), max: ee(t4.max, e3, r4) };
                  }(a2.progress, { min: 0, max: 1 }, r3), t3 > 0 && (n3 = (r3.max - r3.min) / t3);
                }
                const i3 = +e2.properties.mapbox_clip_feature_len, s3 = +e2.properties.mapbox_clip_seg_len;
                if (Number.isNaN(i3) || Number.isNaN(s3)) {
                  for (let e4 = 0; e4 < t2.length - 1; e4++) this.totalDistance += t2[e4].dist(t2[e4 + 1]);
                  const e3 = this.totalDistance / (r3.max - r3.min);
                  this.totalFeatureLength = Number.isFinite(e3) ? e3 : 0, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
                } else this.totalFeatureLength = i3, this.distance = s3 * n3, this.lineClips.start = r3.min, this.lineClips.end = r3.max, this.maxLineLength = Math.max(this.maxLineLength, this.distance);
                this.lineClipsArray.push(this.lineClips), this.updateScaledDistance();
              }
              const h2 = "Polygon" === Lf[e2.type];
              let p2 = t2.length;
              for (; p2 >= 2 && t2[p2 - 1].equals(t2[p2 - 2]); ) p2--;
              let f2 = 0;
              for (; f2 < p2 - 1 && t2[f2].equals(t2[f2 + 1]); ) f2++;
              if (p2 < (h2 ? 3 : 2)) return;
              "bevel" === n2 && (s2 = 1.05);
              const d2 = this.segments.prepareSegment(10 * p2, this.layoutVertexArray, this.indexArray);
              let m2, y2, g2, x2, v3, b2, _2, w2;
              a2 && a2.prevDir && (b2 = a2.prevDir.perp()), a2 && a2.nextDir && (_2 = a2.nextDir.perp()), this.e1 = this.e2 = -1, h2 && (m2 = t2[p2 - 2], v3 = t2[f2].sub(m2)._unit()._perp());
              for (let e3 = f2; e3 < p2; e3++) {
                if (g2 = e3 === p2 - 1 ? h2 ? t2[f2 + 1] : void 0 : t2[e3 + 1], g2 && t2[e3].equals(g2)) continue;
                v3 && (x2 = v3), m2 && (y2 = m2), m2 = t2[e3], w2 = this.evaluateLineProgressFeatures(y2 ? y2.dist(m2) : 0), v3 = g2 ? g2.sub(m2)._unit()._perp() : x2, x2 = x2 || v3;
                const r3 = y2 && g2;
                let a3 = r3 ? n2 : h2 || l2 ? "butt" : i2;
                const A2 = x2.x * v3.x + x2.y * v3.y;
                if (l2) {
                  const t3 = function(t4) {
                    if (t4.patternJoinNone) {
                      const e4 = t4.segmentPoints.length / 2, r4 = t4.lineSoFar - t4.segmentStart;
                      for (let n3 = 0; n3 < e4; ++n3) {
                        const e5 = t4.segmentPoints[2 * n3 + 1], i3 = Math.round(t4.segmentPoints[2 * n3]) + 0.5 + 0.25 * e5;
                        t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart), t4.patternVertexArray.emplaceBack(i3, r4, t4.segmentStart);
                      }
                      t4.segmentPoints.length = 0;
                    }
                    t4.e1 = t4.e2 = -1;
                  };
                  if (r3 && A2 < Of) {
                    this.updateDistance(y2, m2), this.addCurrentVertex(m2, x2, 1, 1, d2, w2), t3(this), this.addCurrentVertex(m2, v3, -1, -1, d2, w2);
                    continue;
                  }
                  if (y2) {
                    if (!g2) {
                      this.updateDistance(y2, m2), this.addCurrentVertex(m2, x2, 1, 1, d2, w2), t3(this);
                      continue;
                    }
                    a3 = "miter";
                  }
                }
                let M2 = x2.add(v3);
                0 === M2.x && 0 === M2.y || M2._unit();
                const I2 = M2.x * v3.x + M2.y * v3.y, S2 = 0 !== I2 ? 1 / I2 : 1 / 0, z2 = 2 * Math.sqrt(2 - 2 * I2), k2 = I2 < Rf && y2 && g2, E2 = x2.x * v3.y - x2.y * v3.x > 0, P2 = this.overscaling <= 16 ? 15 * Tn / (512 * this.overscaling) : 0;
                if (r3 && "round" === a3) {
                  if (S2 < o2) a3 = "miter";
                  else if (S2 <= 2) {
                    const t3 = Nf(m2, -10, Tn + 10);
                    a3 = "offset" === this.elevationType && (t3 || this.hasCrossSlope) ? "miter" : "fakeround";
                  }
                }
                if ("miter" === a3 && S2 > s2 && (a3 = "bevel"), "bevel" === a3 && (S2 > 2 && (a3 = "flipbevel"), S2 < s2 && (a3 = "miter")), y2 && !("miter" === a3 && k2) && this.updateDistance(y2, m2), "miter" === a3) if (k2) {
                  const t3 = m2.dist(y2);
                  if (t3 > 2 * P2) {
                    const e5 = m2.sub(m2.sub(y2)._mult(P2 / t3)._round());
                    this.updateDistance(y2, e5), this.addCurrentVertex(e5, x2, 0, 0, d2, w2), y2 = e5;
                  }
                  this.updateDistance(y2, m2), M2._mult(S2), this.addCurrentVertex(m2, M2, 0, 0, d2, w2);
                  const e4 = m2.dist(g2);
                  if (e4 > 2 * P2) {
                    const t4 = m2.add(g2.sub(m2)._mult(P2 / e4)._round());
                    this.updateDistance(m2, t4), this.addCurrentVertex(t4, v3, 0, 0, d2, w2), m2 = t4;
                  }
                } else M2._mult(S2), this.addCurrentVertex(m2, M2, 0, 0, d2, w2);
                else if ("flipbevel" === a3) {
                  if (S2 > 100) M2 = v3.mult(-1);
                  else {
                    const t3 = S2 * x2.add(v3).mag() / x2.sub(v3).mag();
                    M2._perp()._mult(t3 * (E2 ? -1 : 1));
                  }
                  this.addCurrentVertex(m2, M2, 0, 0, d2, w2), this.addCurrentVertex(m2, M2.mult(-1), 0, 0, d2, w2);
                } else if ("bevel" === a3 || "fakeround" === a3) {
                  null != w2 && y2 && this.addCurrentVertex(m2, _2 || x2, -1, -1, d2, w2);
                  const t3 = m2.dist(y2) <= 2 * P2 && "bevel" !== a3, e4 = M2.mult(E2 ? 1 : -1);
                  e4._mult(S2);
                  const r4 = v3.mult(E2 ? -1 : 1), n3 = x2.mult(E2 ? -1 : 1), i3 = this.evaluateLineProgressFeatures(this.distance);
                  if (null == w2 && (this.addHalfVertex(m2, e4.x, e4.y, false, !E2, 0, d2, i3), t3 || this.addHalfVertex(m2, e4.x + 2 * n3.x, e4.y + 2 * n3.y, false, E2, 0, d2, i3)), "fakeround" === a3) {
                    const t4 = Math.round(180 * z2 / Math.PI / 20);
                    this.addHalfVertex(m2, n3.x, n3.y, false, E2, 0, d2, i3);
                    for (let e5 = 0; e5 < t4; e5++) {
                      let s3 = e5 / t4;
                      if (0.5 !== s3) {
                        const t5 = s3 - 0.5;
                        s3 += s3 * t5 * (s3 - 1) * ((1.0904 + A2 * (A2 * (3.55645 - 1.43519 * A2) - 3.2452)) * t5 * t5 + (0.848013 + A2 * (0.215638 * A2 - 1.06021)));
                      }
                      const o3 = r4.sub(n3)._mult(s3)._add(n3)._unit();
                      this.addHalfVertex(m2, o3.x, o3.y, false, E2, 0, d2, i3);
                    }
                    this.addHalfVertex(m2, r4.x, r4.y, false, E2, 0, d2, i3);
                  }
                  t3 || null != w2 || this.addHalfVertex(m2, e4.x + 2 * r4.x, e4.y + 2 * r4.y, false, E2, 0, d2, i3), null != w2 && g2 && this.addCurrentVertex(m2, b2 || v3, 1, 1, d2, w2);
                } else if ("butt" === a3) this.addCurrentVertex(m2, M2, 0, 0, d2, w2);
                else if ("square" === a3) {
                  if (!y2) {
                    const t3 = u5 ? 0 : -1;
                    this.addCurrentVertex(m2, M2, t3, t3, d2, w2);
                  }
                  if (this.addCurrentVertex(m2, M2, 0, 0, d2, w2), y2) {
                    const t3 = c2 ? 0 : 1;
                    this.addCurrentVertex(m2, M2, t3, t3, d2, w2);
                  }
                } else if ("round" === a3) {
                  if (y2) {
                    const t3 = !r3 && _2 ? _2 : x2;
                    this.addCurrentVertex(m2, t3, 0, 0, d2, w2), !r3 && c2 || this.addCurrentVertex(m2, t3, 1, 1, d2, w2, true);
                  }
                  if (g2) {
                    const t3 = !r3 && b2 ? b2 : v3;
                    !r3 && u5 || this.addCurrentVertex(m2, t3, -1, -1, d2, w2, true), this.addCurrentVertex(m2, t3, 0, 0, d2, w2);
                  }
                }
              }
            }
            addVerticesTo(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) {
              const c2 = (e2.w - t2.w) / this.tessellationStep | 0;
              let h2 = 0;
              const p2 = this.scaledDistance;
              if (c2 > 1) {
                this.lineSoFar = t2.w;
                const p3 = (e2.x - t2.x) / c2, f3 = (e2.y - t2.y) / c2, d2 = (e2.z - t2.z) / c2, m2 = (e2.w - t2.w) / c2;
                for (let e3 = 1; e3 < c2; ++e3) {
                  t2.x += p3, t2.y += f3, t2.z += d2, this.lineSoFar += m2, h2 += m2;
                  const e4 = this.evaluateLineProgressFeatures(this.prevDistance + h2);
                  this.scaledDistance = (this.prevDistance + h2) / this.totalDistance, this.addHalfVertex(t2, r2, n2, u5, false, o2, l2, e4), this.addHalfVertex(t2, i2, s2, u5, true, -a2, l2, e4);
                }
              }
              this.lineSoFar = e2.w, this.scaledDistance = p2;
              const f2 = this.evaluateLineProgressFeatures(this.distance);
              this.addHalfVertex(e2, r2, n2, u5, false, o2, l2, f2), this.addHalfVertex(e2, i2, s2, u5, true, -a2, l2, f2);
            }
            evaluateLineProgressFeatures(t2) {
              if (!this.variableWidthValue && "offset" !== this.elevationType) return null;
              this.evaluationGlobals.lineProgress = 0, this.lineClips ? this.evaluationGlobals.lineProgress = Math.min(1, (this.totalFeatureLength * this.lineClips.start + t2) / this.totalFeatureLength) : $t(`line-progress evaluation for ${this.layerIds[0]} requires enabling 'lineMetrics' for the source.`);
              let e2 = 0;
              return this.variableWidthValue && "constant" !== this.variableWidthValue.kind && (e2 = this.variableWidthValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0), "offset" !== this.elevationType ? { zOffset: 0, variableWidth: e2 } : "constant" === this.zOffsetValue.kind ? { zOffset: this.zOffsetValue.value, variableWidth: e2 } : { zOffset: this.zOffsetValue.evaluate(this.evaluationGlobals, this.lineFeature) || 0, variableWidth: e2 };
            }
            addCurrentVertex(t2, e2, r2, n2, i2, s2, o2 = false) {
              const a2 = e2.x + e2.y * r2, l2 = e2.y - e2.x * r2, u5 = e2.y * n2 - e2.x, c2 = -e2.y - e2.x * n2;
              if (null != s2) {
                const e3 = "offset" === this.elevationType, h2 = -10, p2 = Tn + 10, f2 = s2.zOffset, d2 = new bf(t2.x, t2.y, f2, this.lineSoFar), m2 = !!e3 && Nf(t2, h2, p2), y2 = this.lineSoFar, g2 = this.distance;
                if (this.currentVertex) if (m2) {
                  const e4 = this.currentVertexIsOutside, s3 = this.currentVertex, m3 = new bf(t2.x, t2.y, f2, this.lineSoFar);
                  if (wf(s3, m3, h2, p2), !Nf(m3, h2, p2)) {
                    if (e4) {
                      this.e1 = this.e2 = -1, this.distance -= s3.dist(d2), this.lineSoFar = s3.w;
                      const t3 = this.evaluateLineProgressFeatures(s3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                      this.addHalfVertex(s3, a2, l2, o2, false, r2, i2, t3), this.addHalfVertex(s3, u5, c2, o2, true, -n2, i2, t3), this.prevDistance = this.distance;
                    }
                    this.distance = this.prevDistance + s3.dist(m3), this.scaledDistance = this.distance / this.totalDistance, this.addVerticesTo(s3, m3, a2, l2, u5, c2, r2, n2, i2, o2), this.distance = g2, this.scaledDistance = this.distance / this.totalDistance;
                  }
                } else {
                  const t3 = this.currentVertex;
                  if (this.currentVertexIsOutside) {
                    wf(t3, d2, h2, p2), this.e1 = this.e2 = -1, this.distance -= t3.dist(d2), this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = t3.w;
                    const e4 = this.evaluateLineProgressFeatures(t3.w - this.totalFeatureLength * (this.lineClips ? this.lineClips.start : 0));
                    this.addHalfVertex(t3, a2, l2, o2, false, r2, i2, e4), this.addHalfVertex(t3, u5, c2, o2, true, -n2, i2, e4), this.prevDistance = this.distance, this.distance = g2, this.scaledDistance = this.distance / this.totalDistance;
                  }
                  this.addVerticesTo(t3, d2, a2, l2, u5, c2, r2, n2, i2, o2);
                }
                else m2 || (this.addHalfVertex(t2, a2, l2, o2, false, r2, i2, s2), this.addHalfVertex(t2, u5, c2, o2, true, -n2, i2, s2));
                this.currentVertex = d2, this.currentVertexIsOutside = m2, this.lineSoFar = y2;
              } else this.addHalfVertex(t2, a2, l2, o2, false, r2, i2, s2), this.addHalfVertex(t2, u5, c2, o2, true, -n2, i2, s2);
            }
            addHalfVertex({ x: t2, y: e2 }, r2, n2, i2, s2, o2, a2, l2) {
              if (this.patternJoinNone && (0 === this.segmentPoints.length && (this.segmentStart = this.lineSoFar, this.segmentStartf32 = Math.fround(this.lineSoFar)), s2 || this.segmentPoints.push(this.lineSoFar - this.segmentStart, o2)), this.layoutVertexArray.emplaceBack((t2 << 1) + (i2 ? 1 : 0), (e2 << 1) + (s2 ? 1 : 0), Math.round(63 * r2) + 128, Math.round(63 * n2) + 128, 1 + (0 === o2 ? 0 : o2 < 0 ? -1 : 1), 0, this.lineSoFar - this.segmentStartf32), this.lineClips) {
                const t3 = or(this.lineClips.start, this.lineClips.end, this.scaledDistance);
                this.layoutVertexArray2.emplaceBack(this.scaledDistance, this.lineClipsArray.length, t3);
              }
              const u5 = a2.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u5), a2.primitiveLength++), s2 ? this.e2 = u5 : this.e1 = u5, null != l2 && this.zOffsetVertexArray.emplaceBack(l2.zOffset, l2.variableWidth, l2.variableWidth);
            }
            updateScaledDistance() {
              this.lineClips ? (this.scaledDistance = this.distance / this.totalDistance, this.lineSoFar = this.totalFeatureLength * this.lineClips.start + this.distance) : this.lineSoFar = this.distance;
            }
            updateDistance(t2, e2) {
              this.prevDistance = this.distance, this.distance += t2.dist(e2), this.updateScaledDistance();
            }
          }
          function Nf(t2, e2, r2) {
            return t2.x < e2 || t2.x > r2 || t2.y < e2 || t2.y > r2;
          }
          let jf, $f;
          function Gf(t2, e2, r2) {
            return e2 * (Tn / (t2.tileSize * Math.pow(2, r2 - t2.tileID.overscaledZ)));
          }
          js(Uf, "LineBucket", { omit: ["layers", "patternFeatures", "currentVertex", "currentVertexIsOutside"] });
          const qf = (t2, e2, r2) => (1 - r2) * t2 + r2 * e2;
          function Hf(t2, e2) {
            return 1 / Gf(t2, 1, e2.tileZoom);
          }
          function Xf(t2, e2, r2, n2) {
            return t2.translatePosMatrix(n2 || e2.tileID.projMatrix, e2, r2.paint.get("line-translate"), r2.paint.get("line-translate-anchor"));
          }
          const Zf = (t2) => {
            const e2 = [];
            Wf(t2) && e2.push("RENDER_LINE_DASH"), t2.paint.get("line-gradient") && e2.push("RENDER_LINE_GRADIENT");
            const r2 = t2.paint.get("line-trim-offset");
            0 === r2[0] && 0 === r2[1] || e2.push("RENDER_LINE_TRIM_OFFSET"), 0 !== t2.paint.get("line-border-width").constantOr(1) && e2.push("RENDER_LINE_BORDER");
            const n2 = "none" === t2.layout.get("line-join").constantOr("miter"), i2 = !!t2.paint.get("line-pattern").constantOr(1);
            return n2 && i2 && e2.push("LINE_JOIN_NONE"), e2;
          };
          function Wf(t2) {
            const e2 = t2.paint.get("line-dasharray").value;
            return e2.value || "constant" !== e2.kind;
          }
          let Yf;
          const Kf = () => Yf || (Yf = { layout: jf || (jf = new ko({ "line-cap": new So(Eo.layout_line["line-cap"]), "line-join": new So(Eo.layout_line["line-join"]), "line-miter-limit": new Io(Eo.layout_line["line-miter-limit"]), "line-round-limit": new Io(Eo.layout_line["line-round-limit"]), "line-sort-key": new So(Eo.layout_line["line-sort-key"]), "line-z-offset": new So(Eo.layout_line["line-z-offset"]), "line-elevation-reference": new Io(Eo.layout_line["line-elevation-reference"]), "line-cross-slope": new Io(Eo.layout_line["line-cross-slope"]), visibility: new Io(Eo.layout_line.visibility), "line-width-unit": new Io(Eo.layout_line["line-width-unit"]) })), paint: $f || ($f = new ko({ "line-opacity": new So(Eo.paint_line["line-opacity"]), "line-color": new So(Eo.paint_line["line-color"]), "line-translate": new Io(Eo.paint_line["line-translate"]), "line-translate-anchor": new Io(Eo.paint_line["line-translate-anchor"]), "line-width": new So(Eo.paint_line["line-width"]), "line-gap-width": new So(Eo.paint_line["line-gap-width"]), "line-offset": new So(Eo.paint_line["line-offset"]), "line-blur": new So(Eo.paint_line["line-blur"]), "line-dasharray": new So(Eo.paint_line["line-dasharray"]), "line-pattern": new So(Eo.paint_line["line-pattern"]), "line-pattern-cross-fade": new Io(Eo.paint_line["line-pattern-cross-fade"]), "line-gradient": new zo(Eo.paint_line["line-gradient"]), "line-trim-offset": new Io(Eo.paint_line["line-trim-offset"]), "line-trim-fade-range": new Io(Eo.paint_line["line-trim-fade-range"]), "line-trim-color": new Io(Eo.paint_line["line-trim-color"]), "line-emissive-strength": new Io(Eo.paint_line["line-emissive-strength"]), "line-border-width": new So(Eo.paint_line["line-border-width"]), "line-border-color": new So(Eo.paint_line["line-border-color"]), "line-occlusion-opacity": new Io(Eo.paint_line["line-occlusion-opacity"]), "line-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-gradient-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-trim-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "line-border-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, Yf);
          class Jf extends So {
            possiblyEvaluate(t2, e2) {
              return e2 = new yo(Math.floor(e2.zoom), { now: e2.now, fadeDuration: e2.fadeDuration, transition: e2.transition }), super.possiblyEvaluate(t2, e2);
            }
            evaluate(t2, e2, r2, n2) {
              return e2 = Ct({}, e2, { zoom: Math.floor(e2.zoom) }), super.evaluate(t2, e2, r2, n2);
            }
          }
          let Qf;
          function td(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          const ed = Qo([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_tex_size", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), rd = Qo([{ name: "a_globe_anchor", components: 3, type: "Int16" }, { name: "a_globe_normal", components: 3, type: "Float32" }], 4), nd = Qo([{ name: "a_projected_pos", components: 4, type: "Float32" }], 4);
          Qo([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const id = Qo([{ name: "a_auto_z_offset", components: 1, type: "Float32" }], 4), sd = Qo([{ name: "a_texb", components: 2, type: "Uint16" }]), od = Qo([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }, { name: "a_elevation_from_sea", components: 2, type: "Float32" }]), ad = Qo([{ name: "a_size_scale", components: 1, type: "Float32" }, { name: "a_padding", components: 2, type: "Float32" }, { name: "a_auto_z_offset", components: 1, type: "Float32" }]);
          Qo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "tileAnchorX" }, { type: "Int16", name: "tileAnchorY" }, { type: "Float32", name: "x1" }, { type: "Float32", name: "y1" }, { type: "Float32", name: "x2" }, { type: "Float32", name: "y2" }, { type: "Int16", name: "padding" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const ld = Qo([{ name: "a_pos", components: 3, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), ud = Qo([{ name: "a_pos_2f", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          Qo([{ name: "triangle", components: 3, type: "Uint16" }]), Qo([{ type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }, { type: "Uint8", name: "flipState" }]), Qo([{ type: "Float32", name: "tileAnchorX" }, { type: "Float32", name: "tileAnchorY" }, { type: "Int16", name: "projectedAnchorX" }, { type: "Int16", name: "projectedAnchorY" }, { type: "Int16", name: "projectedAnchorZ" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Float32", name: "zOffset" }, { type: "Uint8", name: "hasIconTextFit" }, { type: "Uint16", name: "elevationFeatureIndex" }]), Qo([{ type: "Float32", name: "offsetX" }]), Qo([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }]);
          var cd2 = 24;
          function hd(t2, e2, r2) {
            return t2.sections.forEach((t3) => {
              t3.text = function(t4, e3, r3) {
                const n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), mo.applyArabicShaping && (t4 = mo.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          const pd = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42", "\u2190": "\u2191", "\u2192": "\u2193" };
          function fd(t2) {
            return "\uFE36" === t2 || "\uFE48" === t2 || "\uFE38" === t2 || "\uFE44" === t2 || "\uFE42" === t2 || "\uFE3E" === t2 || "\uFE3C" === t2 || "\uFE3A" === t2 || "\uFE18" === t2 || "\uFE40" === t2 || "\uFE10" === t2 || "\uFE13" === t2 || "\uFE14" === t2 || "\uFF40" === t2 || "\uFFE3" === t2 || "\uFE11" === t2 || "\uFE12" === t2;
          }
          function dd(t2) {
            return "\uFE35" === t2 || "\uFE47" === t2 || "\uFE37" === t2 || "\uFE43" === t2 || "\uFE41" === t2 || "\uFE3D" === t2 || "\uFE3B" === t2 || "\uFE39" === t2 || "\uFE17" === t2 || "\uFE3F" === t2;
          }
          var md, yd, gd, xd = {};
          function vd() {
            return md || (md = 1, xd.read = function(t2, e2, r2, n2, i2) {
              var s2, o2, a2 = 8 * i2 - n2 - 1, l2 = (1 << a2) - 1, u5 = l2 >> 1, c2 = -7, h2 = r2 ? i2 - 1 : 0, p2 = r2 ? -1 : 1, f2 = t2[e2 + h2];
              for (h2 += p2, s2 = f2 & (1 << -c2) - 1, f2 >>= -c2, c2 += a2; c2 > 0; s2 = 256 * s2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
              for (o2 = s2 & (1 << -c2) - 1, s2 >>= -c2, c2 += n2; c2 > 0; o2 = 256 * o2 + t2[e2 + h2], h2 += p2, c2 -= 8) ;
              if (0 === s2) s2 = 1 - u5;
              else {
                if (s2 === l2) return o2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
                o2 += Math.pow(2, n2), s2 -= u5;
              }
              return (f2 ? -1 : 1) * o2 * Math.pow(2, s2 - n2);
            }, xd.write = function(t2, e2, r2, n2, i2, s2) {
              var o2, a2, l2, u5 = 8 * s2 - i2 - 1, c2 = (1 << u5) - 1, h2 = c2 >> 1, p2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : s2 - 1, d2 = n2 ? 1 : -1, m2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
              for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a2 = isNaN(e2) ? 1 : 0, o2 = c2) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -o2)) < 1 && (o2--, l2 *= 2), (e2 += o2 + h2 >= 1 ? p2 / l2 : p2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (o2++, l2 /= 2), o2 + h2 >= c2 ? (a2 = 0, o2 = c2) : o2 + h2 >= 1 ? (a2 = (e2 * l2 - 1) * Math.pow(2, i2), o2 += h2) : (a2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & a2, f2 += d2, a2 /= 256, i2 -= 8) ;
              for (o2 = o2 << i2 | a2, u5 += i2; u5 > 0; t2[r2 + f2] = 255 & o2, f2 += d2, o2 /= 256, u5 -= 8) ;
              t2[r2 + f2 - d2] |= 128 * m2;
            }), xd;
          }
          function bd2() {
            if (gd) return yd;
            gd = 1, yd = e2;
            var t2 = vd();
            function e2(t3) {
              this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t3) ? t3 : new Uint8Array(t3 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
            }
            e2.Varint = 0, e2.Fixed64 = 1, e2.Bytes = 2, e2.Fixed32 = 5;
            var r2 = 4294967296, n2 = 1 / r2, i2 = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
            function s2(t3) {
              return t3.type === e2.Bytes ? t3.readVarint() + t3.pos : t3.pos + 1;
            }
            function o2(t3, e3, r3) {
              return r3 ? 4294967296 * e3 + (t3 >>> 0) : 4294967296 * (e3 >>> 0) + (t3 >>> 0);
            }
            function a2(t3, e3, r3) {
              var n3 = e3 <= 16383 ? 1 : e3 <= 2097151 ? 2 : e3 <= 268435455 ? 3 : Math.floor(Math.log(e3) / (7 * Math.LN2));
              r3.realloc(n3);
              for (var i3 = r3.pos - 1; i3 >= t3; i3--) r3.buf[i3 + n3] = r3.buf[i3];
            }
            function l2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeVarint(t3[r3]);
            }
            function u5(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSVarint(t3[r3]);
            }
            function c2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFloat(t3[r3]);
            }
            function h2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeDouble(t3[r3]);
            }
            function p2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeBoolean(t3[r3]);
            }
            function f2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed32(t3[r3]);
            }
            function d2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed32(t3[r3]);
            }
            function m2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeFixed64(t3[r3]);
            }
            function y2(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++) e3.writeSFixed64(t3[r3]);
            }
            function g2(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + 16777216 * t3[e3 + 3];
            }
            function x2(t3, e3, r3) {
              t3[r3] = e3, t3[r3 + 1] = e3 >>> 8, t3[r3 + 2] = e3 >>> 16, t3[r3 + 3] = e3 >>> 24;
            }
            function v3(t3, e3) {
              return (t3[e3] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) + (t3[e3 + 3] << 24);
            }
            return e2.prototype = { destroy: function() {
              this.buf = null;
            }, readFields: function(t3, e3, r3) {
              for (r3 = r3 || this.length; this.pos < r3; ) {
                var n3 = this.readVarint(), i3 = n3 >> 3, s3 = this.pos;
                this.type = 7 & n3, t3(i3, e3, this), this.pos === s3 && this.skip(n3);
              }
              return e3;
            }, readMessage: function(t3, e3) {
              return this.readFields(t3, e3, this.readVarint() + this.pos);
            }, readFixed32: function() {
              var t3 = g2(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readSFixed32: function() {
              var t3 = v3(this.buf, this.pos);
              return this.pos += 4, t3;
            }, readFixed64: function() {
              var t3 = g2(this.buf, this.pos) + g2(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readSFixed64: function() {
              var t3 = g2(this.buf, this.pos) + v3(this.buf, this.pos + 4) * r2;
              return this.pos += 8, t3;
            }, readFloat: function() {
              var e3 = t2.read(this.buf, this.pos, true, 23, 4);
              return this.pos += 4, e3;
            }, readDouble: function() {
              var e3 = t2.read(this.buf, this.pos, true, 52, 8);
              return this.pos += 8, e3;
            }, readVarint: function(t3) {
              var e3, r3, n3 = this.buf;
              return e3 = 127 & (r3 = n3[this.pos++]), r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 7, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 14, r3 < 128 ? e3 : (e3 |= (127 & (r3 = n3[this.pos++])) << 21, r3 < 128 ? e3 : function(t4, e4, r4) {
                var n4, i3, s3 = r4.buf;
                if (n4 = (112 & (i3 = s3[r4.pos++])) >> 4, i3 < 128) return o2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 3, i3 < 128) return o2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 10, i3 < 128) return o2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 17, i3 < 128) return o2(t4, n4, e4);
                if (n4 |= (127 & (i3 = s3[r4.pos++])) << 24, i3 < 128) return o2(t4, n4, e4);
                if (n4 |= (1 & (i3 = s3[r4.pos++])) << 31, i3 < 128) return o2(t4, n4, e4);
                throw new Error("Expected varint not more than 10 bytes");
              }(e3 |= (15 & (r3 = n3[this.pos])) << 28, t3, this))));
            }, readVarint64: function() {
              return this.readVarint(true);
            }, readSVarint: function() {
              var t3 = this.readVarint();
              return t3 % 2 == 1 ? (t3 + 1) / -2 : t3 / 2;
            }, readBoolean: function() {
              return Boolean(this.readVarint());
            }, readString: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.pos;
              return this.pos = t3, t3 - e3 >= 12 && i2 ? function(t4, e4, r3) {
                return i2.decode(t4.subarray(e4, r3));
              }(this.buf, e3, t3) : function(t4, e4, r3) {
                for (var n3 = "", i3 = e4; i3 < r3; ) {
                  var s3, o3, a3, l3 = t4[i3], u6 = null, c3 = l3 > 239 ? 4 : l3 > 223 ? 3 : l3 > 191 ? 2 : 1;
                  if (i3 + c3 > r3) break;
                  1 === c3 ? l3 < 128 && (u6 = l3) : 2 === c3 ? 128 == (192 & (s3 = t4[i3 + 1])) && (u6 = (31 & l3) << 6 | 63 & s3) <= 127 && (u6 = null) : 3 === c3 ? (o3 = t4[i3 + 2], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & o3) && ((u6 = (15 & l3) << 12 | (63 & s3) << 6 | 63 & o3) <= 2047 || u6 >= 55296 && u6 <= 57343) && (u6 = null)) : 4 === c3 && (o3 = t4[i3 + 2], a3 = t4[i3 + 3], 128 == (192 & (s3 = t4[i3 + 1])) && 128 == (192 & o3) && 128 == (192 & a3) && ((u6 = (15 & l3) << 18 | (63 & s3) << 12 | (63 & o3) << 6 | 63 & a3) <= 65535 || u6 >= 1114112) && (u6 = null)), null === u6 ? (u6 = 65533, c3 = 1) : u6 > 65535 && (u6 -= 65536, n3 += String.fromCharCode(u6 >>> 10 & 1023 | 55296), u6 = 56320 | 1023 & u6), n3 += String.fromCharCode(u6), i3 += c3;
                }
                return n3;
              }(this.buf, e3, t3);
            }, readBytes: function() {
              var t3 = this.readVarint() + this.pos, e3 = this.buf.subarray(this.pos, t3);
              return this.pos = t3, e3;
            }, readPackedVarint: function(t3, r3) {
              if (this.type !== e2.Bytes) return t3.push(this.readVarint(r3));
              var n3 = s2(this);
              for (t3 = t3 || []; this.pos < n3; ) t3.push(this.readVarint(r3));
              return t3;
            }, readPackedSVarint: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSVarint());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSVarint());
              return t3;
            }, readPackedBoolean: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readBoolean());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readBoolean());
              return t3;
            }, readPackedFloat: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFloat());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFloat());
              return t3;
            }, readPackedDouble: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readDouble());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readDouble());
              return t3;
            }, readPackedFixed32: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed32());
              return t3;
            }, readPackedSFixed32: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSFixed32());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed32());
              return t3;
            }, readPackedFixed64: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readFixed64());
              return t3;
            }, readPackedSFixed64: function(t3) {
              if (this.type !== e2.Bytes) return t3.push(this.readSFixed64());
              var r3 = s2(this);
              for (t3 = t3 || []; this.pos < r3; ) t3.push(this.readSFixed64());
              return t3;
            }, skip: function(t3) {
              var r3 = 7 & t3;
              if (r3 === e2.Varint) for (; this.buf[this.pos++] > 127; ) ;
              else if (r3 === e2.Bytes) this.pos = this.readVarint() + this.pos;
              else if (r3 === e2.Fixed32) this.pos += 4;
              else {
                if (r3 !== e2.Fixed64) throw new Error("Unimplemented type: " + r3);
                this.pos += 8;
              }
            }, writeTag: function(t3, e3) {
              this.writeVarint(t3 << 3 | e3);
            }, realloc: function(t3) {
              for (var e3 = this.length || 16; e3 < this.pos + t3; ) e3 *= 2;
              if (e3 !== this.length) {
                var r3 = new Uint8Array(e3);
                r3.set(this.buf), this.buf = r3, this.length = e3;
              }
            }, finish: function() {
              return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
            }, writeFixed32: function(t3) {
              this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
            }, writeSFixed32: function(t3) {
              this.realloc(4), x2(this.buf, t3, this.pos), this.pos += 4;
            }, writeFixed64: function(t3) {
              this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeSFixed64: function(t3) {
              this.realloc(8), x2(this.buf, -1 & t3, this.pos), x2(this.buf, Math.floor(t3 * n2), this.pos + 4), this.pos += 8;
            }, writeVarint: function(t3) {
              (t3 = +t3 || 0) > 268435455 || t3 < 0 ? function(t4, e3) {
                var r3, n3;
                if (t4 >= 0 ? (r3 = t4 % 4294967296 | 0, n3 = t4 / 4294967296 | 0) : (n3 = ~(-t4 / 4294967296), 4294967295 ^ (r3 = ~(-t4 % 4294967296)) ? r3 = r3 + 1 | 0 : (r3 = 0, n3 = n3 + 1 | 0)), t4 >= 18446744073709552e3 || t4 < -18446744073709552e3) throw new Error("Given varint doesn't fit into 10 bytes");
                e3.realloc(10), function(t5, e4, r4) {
                  r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, t5 >>>= 7, r4.buf[r4.pos++] = 127 & t5 | 128, r4.buf[r4.pos] = 127 & (t5 >>>= 7);
                }(r3, 0, e3), function(t5, e4) {
                  var r4 = (7 & t5) << 4;
                  e4.buf[e4.pos++] |= r4 | ((t5 >>>= 3) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5 | ((t5 >>>= 7) ? 128 : 0), t5 && (e4.buf[e4.pos++] = 127 & t5)))));
                }(n3, e3);
              }(t3, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t3 | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = 127 & (t3 >>>= 7) | (t3 > 127 ? 128 : 0), t3 <= 127 || (this.buf[this.pos++] = t3 >>> 7 & 127))));
            }, writeSVarint: function(t3) {
              this.writeVarint(t3 < 0 ? 2 * -t3 - 1 : 2 * t3);
            }, writeBoolean: function(t3) {
              this.writeVarint(Boolean(t3));
            }, writeString: function(t3) {
              t3 = String(t3), this.realloc(4 * t3.length), this.pos++;
              var e3 = this.pos;
              this.pos = function(t4, e4, r4) {
                for (var n3, i3, s3 = 0; s3 < e4.length; s3++) {
                  if ((n3 = e4.charCodeAt(s3)) > 55295 && n3 < 57344) {
                    if (!i3) {
                      n3 > 56319 || s3 + 1 === e4.length ? (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189) : i3 = n3;
                      continue;
                    }
                    if (n3 < 56320) {
                      t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = n3;
                      continue;
                    }
                    n3 = i3 - 55296 << 10 | n3 - 56320 | 65536, i3 = null;
                  } else i3 && (t4[r4++] = 239, t4[r4++] = 191, t4[r4++] = 189, i3 = null);
                  n3 < 128 ? t4[r4++] = n3 : (n3 < 2048 ? t4[r4++] = n3 >> 6 | 192 : (n3 < 65536 ? t4[r4++] = n3 >> 12 | 224 : (t4[r4++] = n3 >> 18 | 240, t4[r4++] = n3 >> 12 & 63 | 128), t4[r4++] = n3 >> 6 & 63 | 128), t4[r4++] = 63 & n3 | 128);
                }
                return r4;
              }(this.buf, t3, this.pos);
              var r3 = this.pos - e3;
              r3 >= 128 && a2(e3, r3, this), this.pos = e3 - 1, this.writeVarint(r3), this.pos += r3;
            }, writeFloat: function(e3) {
              this.realloc(4), t2.write(this.buf, e3, this.pos, true, 23, 4), this.pos += 4;
            }, writeDouble: function(e3) {
              this.realloc(8), t2.write(this.buf, e3, this.pos, true, 52, 8), this.pos += 8;
            }, writeBytes: function(t3) {
              var e3 = t3.length;
              this.writeVarint(e3), this.realloc(e3);
              for (var r3 = 0; r3 < e3; r3++) this.buf[this.pos++] = t3[r3];
            }, writeRawMessage: function(t3, e3) {
              this.pos++;
              var r3 = this.pos;
              t3(e3, this);
              var n3 = this.pos - r3;
              n3 >= 128 && a2(r3, n3, this), this.pos = r3 - 1, this.writeVarint(n3), this.pos += n3;
            }, writeMessage: function(t3, r3, n3) {
              this.writeTag(t3, e2.Bytes), this.writeRawMessage(r3, n3);
            }, writePackedVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, l2, e3);
            }, writePackedSVarint: function(t3, e3) {
              e3.length && this.writeMessage(t3, u5, e3);
            }, writePackedBoolean: function(t3, e3) {
              e3.length && this.writeMessage(t3, p2, e3);
            }, writePackedFloat: function(t3, e3) {
              e3.length && this.writeMessage(t3, c2, e3);
            }, writePackedDouble: function(t3, e3) {
              e3.length && this.writeMessage(t3, h2, e3);
            }, writePackedFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, f2, e3);
            }, writePackedSFixed32: function(t3, e3) {
              e3.length && this.writeMessage(t3, d2, e3);
            }, writePackedFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, m2, e3);
            }, writePackedSFixed64: function(t3, e3) {
              e3.length && this.writeMessage(t3, y2, e3);
            }, writeBytesField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeBytes(r3);
            }, writeFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFixed32(r3);
            }, writeSFixed32Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeSFixed32(r3);
            }, writeFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeFixed64(r3);
            }, writeSFixed64Field: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeSFixed64(r3);
            }, writeVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeVarint(r3);
            }, writeSVarintField: function(t3, r3) {
              this.writeTag(t3, e2.Varint), this.writeSVarint(r3);
            }, writeStringField: function(t3, r3) {
              this.writeTag(t3, e2.Bytes), this.writeString(r3);
            }, writeFloatField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed32), this.writeFloat(r3);
            }, writeDoubleField: function(t3, r3) {
              this.writeTag(t3, e2.Fixed64), this.writeDouble(r3);
            }, writeBooleanField: function(t3, e3) {
              this.writeVarintField(t3, Boolean(e3));
            } }, yd;
          }
          var _d = dt(bd2());
          const wd = 3;
          function Ad(t2, e2, r2) {
            e2.glyphs = [], 1 === t2 && r2.readMessage(Md, e2);
          }
          function Md(t2, e2, r2) {
            if (3 === t2) {
              const { id: t3, bitmap: n2, width: i2, height: s2, left: o2, top: a2, advance: l2 } = r2.readMessage(Id, {});
              e2.glyphs.push({ id: t3, bitmap: new qc({ width: i2 + 2 * wd, height: s2 + 2 * wd }, n2), metrics: { width: i2, height: s2, left: o2, top: a2, advance: l2 } });
            } else 4 === t2 ? e2.ascender = r2.readSVarint() : 5 === t2 && (e2.descender = r2.readSVarint());
          }
          function Id(t2, e2, r2) {
            1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
          }
          const Sd = wd, zd = { horizontal: 1, vertical: 2, horizontalOnly: 3 };
          class kd {
            constructor() {
              this.scale = 1, this.fontStack = "", this.image = null;
            }
            static forText(t2, e2) {
              const r2 = new kd();
              return r2.scale = t2 || 1, r2.fontStack = e2, r2;
            }
            static forImage(t2) {
              const e2 = new kd();
              return e2.image = t2, e2;
            }
          }
          class Ed {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t2, e2, r2) {
              const n2 = new Ed();
              for (let i2 = 0; i2 < t2.sections.length; i2++) {
                const s2 = t2.sections[i2];
                s2.image ? n2.addImageSection(s2, r2) : n2.addTextSection(s2, e2);
              }
              return n2;
            }
            length() {
              return this.text.length;
            }
            getSection(t2) {
              return this.sections[this.sectionIndex[t2]];
            }
            getSections() {
              return this.sections;
            }
            getSectionIndex(t2) {
              return this.sectionIndex[t2];
            }
            getCodePoint(t2) {
              return this.text.codePointAt(t2);
            }
            verticalizePunctuation(t2) {
              this.text = function(t3, e2) {
                let r2 = "";
                for (let n2 = 0; n2 < t3.length; n2++) {
                  const i2 = t3.charCodeAt(n2 + 1) || null, s2 = t3.charCodeAt(n2 - 1) || null;
                  r2 += !e2 && (i2 && Js(i2) && !pd[t3[n2 + 1]] || s2 && Js(s2) && !pd[t3[n2 - 1]]) || !pd[t3[n2]] ? t3[n2] : pd[t3[n2]];
                }
                return r2;
              }(this.text, t2);
            }
            trim() {
              let t2 = 0;
              for (let e3 = 0; e3 < this.text.length && Td[this.text.charCodeAt(e3)]; e3++) t2++;
              let e2 = this.text.length;
              for (let r2 = this.text.length - 1; r2 >= 0 && r2 >= t2 && Td[this.text.charCodeAt(r2)]; r2--) e2--;
              this.text = this.text.substring(t2, e2), this.sectionIndex = this.sectionIndex.slice(t2, e2);
            }
            substring(t2, e2) {
              const r2 = new Ed();
              return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t2, e2) => Math.max(t2, this.sections[e2].scale), 0);
            }
            addTextSection(t2, e2) {
              this.text += t2.text, this.sections.push(kd.forText(t2.scale, t2.fontStack || e2));
              const r2 = this.sections.length - 1;
              for (let e3 = 0; e3 < t2.text.length; ++e3) this.sectionIndex.push(r2);
            }
            addImageSection(t2, e2) {
              const r2 = t2.image ? t2.image.getPrimary() : null;
              if (!r2) return void $t("Can't add FormattedSection with an empty image.");
              r2.scaleSelf(e2);
              const n2 = this.getNextImageSectionCharCode();
              n2 ? (this.text += String.fromCodePoint(n2), this.sections.push(kd.forImage(r2)), this.sectionIndex.push(this.sections.length - 1)) : $t("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function Pd(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2 = 1) {
            const y2 = Ed.fromFeature(t2, i2, m2);
            h2 === zd.vertical && y2.verticalizePunctuation(p2);
            let g2 = [];
            const x2 = function(t3, e3, r3, n3, i3, s3) {
              if (!t3) return [];
              const o3 = [], a3 = function(t4, e4, r4, n4, i4, s4) {
                let o4 = 0;
                for (let r5 = 0; r5 < t4.length(); r5++) {
                  const a4 = t4.getSection(r5);
                  o4 += Vd(t4.getCodePoint(r5), a4, n4, i4, e4, s4);
                }
                return o4 / Math.max(1, Math.ceil(o4 / r4));
              }(t3, e3, r3, n3, i3, s3), l3 = t3.text.indexOf("\u200B") >= 0;
              let u6 = 0;
              for (let r4 = 0; r4 < t3.length(); r4++) {
                const h3 = t3.getSection(r4), p3 = t3.getCodePoint(r4);
                if (Td[p3] || (u6 += Vd(p3, h3, n3, i3, e3, s3)), r4 < t3.length() - 1) {
                  const e4 = !((c3 = p3) < 11904 || !(Xs["Bopomofo Extended"](c3) || Xs.Bopomofo(c3) || Xs["CJK Compatibility Forms"](c3) || Xs["CJK Compatibility Ideographs"](c3) || Xs["CJK Compatibility"](c3) || Xs["CJK Radicals Supplement"](c3) || Xs["CJK Strokes"](c3) || Xs["CJK Symbols and Punctuation"](c3) || Xs["CJK Unified Ideographs Extension A"](c3) || Xs["CJK Unified Ideographs"](c3) || Xs["Enclosed CJK Letters and Months"](c3) || Xs["Halfwidth and Fullwidth Forms"](c3) || Xs.Hiragana(c3) || Xs["Ideographic Description Characters"](c3) || Xs["Kangxi Radicals"](c3) || Xs["Katakana Phonetic Extensions"](c3) || Xs.Katakana(c3) || Xs["Vertical Forms"](c3) || Xs["Yi Radicals"](c3) || Xs["Yi Syllables"](c3)));
                  (Bd[p3] || e4 || h3.image) && o3.push(Fd(r4 + 1, u6, a3, o3, Dd(p3, t3.getCodePoint(r4 + 1), e4 && l3), false));
                }
              }
              var c3;
              return Ld(Fd(t3.length(), u6, a3, o3, 0, true));
            }(y2, u5, s2, e2, n2, f2), { processBidirectionalText: v3, processStyledBidirectionalText: b2 } = mo;
            if (v3 && 1 === y2.sections.length) {
              const t3 = v3(y2.toString(), x2);
              for (const e3 of t3) {
                const t4 = new Ed();
                t4.text = e3, t4.sections = y2.sections;
                for (let r3 = 0; r3 < e3.length; r3++) t4.sectionIndex.push(0);
                g2.push(t4);
              }
            } else if (b2) {
              const t3 = b2(y2.text, y2.sectionIndex, x2);
              for (const e3 of t3) {
                const t4 = new Ed();
                t4.text = e3[0], t4.sectionIndex = e3[1], t4.sections = y2.sections, g2.push(t4);
              }
            } else g2 = function(t3, e3) {
              const r3 = [], n3 = t3.text;
              let i3 = 0;
              for (const n4 of e3) r3.push(t3.substring(i3, n4)), i3 = n4;
              return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
            }(y2, x2);
            const _2 = [], w2 = { positionedLines: _2, text: y2.toString(), top: c2[1], bottom: c2[1], left: c2[0], right: c2[0], writingMode: h2, iconsInText: false, verticalizable: false, hasBaseline: false };
            if (function(t3, e3, r3, n3, i3, s3, o3, a3, l3, u6, c3, h3) {
              let p3 = 0, f3 = 0, d3 = 0;
              const m3 = "right" === a3 ? 1 : "left" === a3 ? 0 : 0.5;
              let y3 = false;
              for (const t4 of i3) {
                const r4 = t4.getSections();
                for (const t5 of r4) {
                  if (t5.image) continue;
                  const r5 = e3[t5.fontStack];
                  if (r5 && (y3 = void 0 !== r5.ascender && void 0 !== r5.descender, !y3)) break;
                }
                if (!y3) break;
              }
              let g3 = 0;
              for (const o4 of i3) {
                o4.trim();
                const i4 = o4.getMaxScale(), a4 = (i4 - 1) * cd2, v5 = { positionedGlyphs: [], lineOffset: 0 };
                t3.positionedLines[g3] = v5;
                const b4 = v5.positionedGlyphs;
                let _4 = 0;
                if (!o4.length()) {
                  f3 += s3, ++g3;
                  continue;
                }
                let w3 = 0, A2 = 0;
                for (let s4 = 0; s4 < o4.length(); s4++) {
                  const a5 = o4.getSection(s4), d4 = o4.getSectionIndex(s4), m4 = o4.getCodePoint(s4);
                  let g4 = a5.scale, v6 = null, M3 = null, I2 = null, S2 = cd2, z2 = 0;
                  l3 === zd.vertical && (12312 === (x3 = m4) || 12313 === x3 || 12316 === x3 || 12540 === x3 || 12448 === x3) && (l3 = zd.horizontal);
                  const k2 = !(l3 === zd.horizontal || !c3 && !Ks(m4) || c3 && (Td[m4] || Qs(m4)));
                  if (a5.image) {
                    const e4 = n3.get(a5.image.toString());
                    if (!e4) continue;
                    I2 = a5.image, t3.iconsInText = t3.iconsInText || true, M3 = e4.paddedRect;
                    const r4 = e4.displaySize;
                    g4 = g4 * cd2 / h3, v6 = { width: r4[0], height: r4[1], left: 0, top: -Sd, advance: k2 ? r4[1] : r4[0], localGlyph: false }, z2 = y3 ? -v6.height * g4 : i4 * cd2 - 17 - r4[1] * g4, S2 = v6.advance;
                    const s5 = (k2 ? r4[0] : r4[1]) * g4 - cd2 * i4;
                    s5 > 0 && s5 > _4 && (_4 = s5);
                  } else {
                    const t4 = r3[a5.fontStack];
                    if (!t4) continue;
                    t4[m4] && (M3 = t4[m4]);
                    const n4 = e3[a5.fontStack];
                    if (!n4) continue;
                    const s5 = n4.glyphs[m4];
                    if (!s5) continue;
                    if (v6 = s5.metrics, S2 = 8203 !== m4 ? cd2 : 0, y3) {
                      const t5 = void 0 !== n4.ascender ? Math.abs(n4.ascender) : 0, e4 = void 0 !== n4.descender ? Math.abs(n4.descender) : 0, r4 = (t5 + e4) * g4;
                      w3 < r4 && (w3 = r4, A2 = (t5 - e4) / 2 * g4), z2 = -t5 * g4;
                    } else z2 = (i4 - g4) * cd2 - 17;
                  }
                  k2 ? (t3.verticalizable = true, b4.push({ glyph: m4, image: I2, x: p3, y: f3 + z2, vertical: k2, scale: g4, localGlyph: v6.localGlyph, fontStack: a5.fontStack, sectionIndex: d4, metrics: v6, rect: M3 }), p3 += S2 * g4 + u6) : (b4.push({ glyph: m4, image: I2, x: p3, y: f3 + z2, vertical: k2, scale: g4, localGlyph: v6.localGlyph, fontStack: a5.fontStack, sectionIndex: d4, metrics: v6, rect: M3 }), p3 += v6.advance * g4 + u6);
                }
                0 !== b4.length && (d3 = Math.max(p3 - u6, d3), y3 ? Od(b4, m3, _4, A2, s3 * i4 / 2) : Od(b4, m3, _4, 0, s3 / 2)), p3 = 0;
                const M2 = s3 * i4 + _4;
                v5.lineOffset = Math.max(_4, a4), f3 += M2, ++g3;
              }
              var x3;
              const v4 = f3, { horizontalAlign: b3, verticalAlign: _3 } = Rd(o3);
              (function(t4, e4, r4, n4, i4, s4) {
                const o4 = (e4 - r4) * i4, a4 = -s4 * n4;
                for (const e5 of t4) for (const t5 of e5.positionedGlyphs) t5.x += o4, t5.y += a4;
              })(t3.positionedLines, m3, b3, _3, d3, v4), t3.top += -_3 * v4, t3.bottom = t3.top + v4, t3.left += -b3 * d3, t3.right = t3.left + d3, t3.hasBaseline = y3;
            }(w2, e2, r2, n2, g2, o2, a2, l2, h2, u5, p2, d2), !function(t3) {
              for (const e3 of t3) if (0 !== e3.positionedGlyphs.length) return false;
              return true;
            }(_2)) return w2;
          }
          const Td = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Bd = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function Vd(t2, e2, r2, n2, i2, s2) {
            if (e2.image) {
              const t3 = n2.get(e2.image.toString());
              return t3 ? t3.displaySize[0] * e2.scale * cd2 / s2 + i2 : 0;
            }
            {
              const n3 = r2[e2.fontStack], s3 = n3 && n3.glyphs[t2];
              return s3 ? s3.metrics.advance * e2.scale + i2 : 0;
            }
          }
          function Cd(t2, e2, r2, n2) {
            const i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function Dd(t2, e2, r2) {
            let n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
          }
          function Fd(t2, e2, r2, n2, i2, s2) {
            let o2 = null, a2 = Cd(e2, r2, i2, s2);
            for (const t3 of n2) {
              const n3 = Cd(e2 - t3.x, r2, i2, s2) + t3.badness;
              n3 <= a2 && (o2 = t3, a2 = n3);
            }
            return { index: t2, x: e2, priorBreak: o2, badness: a2 };
          }
          function Ld(t2) {
            return t2 ? Ld(t2.priorBreak).concat(t2.index) : [];
          }
          function Rd(t2) {
            let e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Od(t2, e2, r2, n2, i2) {
            if (!(e2 || r2 || n2 || i2)) return;
            const s2 = t2.length - 1, o2 = t2[s2], a2 = (o2.x + o2.metrics.advance * o2.scale) * e2;
            for (let e3 = 0; e3 <= s2; e3++) t2[e3].x -= a2, t2[e3].y += r2 + n2 + i2;
          }
          function Ud(t2) {
            return void 0 !== t2.imagePrimary && void 0 !== t2.top && void 0 !== t2.bottom && void 0 !== t2.left && void 0 !== t2.right;
          }
          function Nd(t2, e2, r2, n2) {
            const { horizontalAlign: i2, verticalAlign: s2 } = Rd(n2), o2 = r2[0] - t2.displaySize[0] * i2, a2 = r2[1] - t2.displaySize[1] * s2;
            return { imagePrimary: t2, imageSecondary: e2, top: a2, bottom: a2 + t2.displaySize[1], left: o2, right: o2 + t2.displaySize[0] };
          }
          function jd(t2, e2, r2, n2, i2, s2) {
            const o2 = t2.imagePrimary;
            let a2;
            if (o2.content) {
              const t3 = o2.content, e3 = o2.pixelRatio || 1;
              a2 = [t3[0] / e3, t3[1] / e3, o2.displaySize[0] - t3[2] / e3, o2.displaySize[1] - t3[3] / e3];
            }
            const l2 = e2.left * s2, u5 = e2.right * s2;
            let c2, h2, p2, f2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + l2 - n2[3], h2 = i2[0] + u5 + n2[1]) : (f2 = i2[0] + (l2 + u5 - o2.displaySize[0]) / 2, h2 = f2 + o2.displaySize[0]);
            const d2 = e2.top * s2, m2 = e2.bottom * s2;
            return "height" === r2 || "both" === r2 ? (c2 = i2[1] + d2 - n2[0], p2 = i2[1] + m2 + n2[2]) : (c2 = i2[1] + (d2 + m2 - o2.displaySize[1]) / 2, p2 = c2 + o2.displaySize[1]), { imagePrimary: o2, imageSecondary: void 0, top: c2, right: h2, bottom: p2, left: f2, collisionPadding: a2 };
          }
          function $d(t2) {
            return !t2.imagePrimary.stretchX;
          }
          function Gd(t2) {
            return !t2.imagePrimary.stretchY;
          }
          function qd(t2) {
            return { width: t2.right - t2.left, height: t2.bottom - t2.top };
          }
          const Hd = 128;
          function Xd(t2, e2) {
            const { expression: r2 } = e2;
            if ("constant" === r2.kind) return { kind: "constant", layoutSize: r2.evaluate(new yo(t2 + 1)) };
            if ("source" === r2.kind) return { kind: "source" };
            {
              const { zoomStops: e3, interpolationType: n2 } = r2;
              let i2 = 0;
              for (; i2 < e3.length && e3[i2] <= t2; ) i2++;
              i2 = Math.max(0, i2 - 1);
              let s2 = i2;
              for (; s2 < e3.length && e3[s2] < t2 + 1; ) s2++;
              s2 = Math.min(e3.length - 1, s2);
              const o2 = e3[i2], a2 = e3[s2];
              return "composite" === r2.kind ? { kind: "composite", minZoom: o2, maxZoom: a2, interpolationType: n2 } : { kind: "camera", minZoom: o2, maxZoom: a2, minSize: r2.evaluate(new yo(o2)), maxSize: r2.evaluate(new yo(a2)), interpolationType: n2 };
            }
          }
          function Zd(t2, { uSize: e2, uSizeT: r2 }, { lowerSize: n2, upperSize: i2 }) {
            return "source" === t2.kind ? n2 / Hd : "composite" === t2.kind ? or(n2 / Hd, i2 / Hd, r2) : e2;
          }
          function Wd(t2, e2, r2 = 1) {
            let n2 = 0, i2 = 0;
            if ("constant" === t2.kind) i2 = t2.layoutSize * r2;
            else if ("source" !== t2.kind) {
              const { interpolationType: s2, minZoom: o2, maxZoom: a2 } = t2, l2 = s2 ? Pt(Oi.interpolationFactor(s2, e2, o2, a2), 0, 1) : 0;
              "camera" === t2.kind ? i2 = or(t2.minSize, t2.maxSize, l2) * r2 : n2 = l2 * r2;
            }
            return { uSizeT: n2, uSize: i2 };
          }
          class Yd extends bt {
            constructor(t2, e2, r2, n2, i2) {
              super(t2, e2), this.angle = n2, this.z = r2, void 0 !== i2 && (this.segment = i2);
            }
            clone() {
              return new Yd(this.x, this.y, this.z, this.angle, this.segment);
            }
          }
          function Kd(t2, e2, r2, n2, i2) {
            if (void 0 === e2.segment) return true;
            let s2 = e2, o2 = e2.segment + 1, a2 = 0;
            for (; a2 > -r2 / 2; ) {
              if (o2--, o2 < 0) return false;
              a2 -= t2[o2].dist(s2), s2 = t2[o2];
            }
            a2 += t2[o2].dist(t2[o2 + 1]), o2++;
            const l2 = [];
            let u5 = 0;
            for (; a2 < r2 / 2; ) {
              const e3 = t2[o2], r3 = t2[o2 + 1];
              if (!r3) return false;
              let s3 = t2[o2 - 1].angleTo(e3) - e3.angleTo(r3);
              for (s3 = Math.abs((s3 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l2.push({ distance: a2, angleDelta: s3 }), u5 += s3; a2 - l2[0].distance > n2; ) u5 -= l2.shift().angleDelta;
              if (u5 > i2) return false;
              o2++, a2 += e3.dist(r3);
            }
            return true;
          }
          function Jd(t2) {
            let e2 = 0;
            for (let r2 = 0; r2 < t2.length - 1; r2++) e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function Qd(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function tm(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function em(t2, e2, r2, n2, i2, s2) {
            const o2 = Qd(r2, i2, s2), a2 = tm(r2, n2) * s2;
            let l2 = 0;
            const u5 = Jd(t2) / 2;
            for (let r3 = 0; r3 < t2.length - 1; r3++) {
              const n3 = t2[r3], i3 = t2[r3 + 1], s3 = n3.dist(i3);
              if (l2 + s3 > u5) {
                const c2 = (u5 - l2) / s3, h2 = or(n3.x, i3.x, c2), p2 = or(n3.y, i3.y, c2), f2 = new Yd(h2, p2, 0, i3.angleTo(n3), r3);
                return !o2 || Kd(t2, f2, a2, o2, e2) ? f2 : void 0;
              }
              l2 += s3;
            }
          }
          function rm(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            const u5 = Qd(n2, s2, o2), c2 = tm(n2, i2), h2 = c2 * o2, p2 = 0 === t2[0].x || t2[0].x === l2 || 0 === t2[0].y || t2[0].y === l2;
            return e2 - h2 < e2 / 4 && (e2 = h2 + e2 / 4), nm(t2, p2 ? e2 / 2 * a2 % e2 : (c2 / 2 + 2 * s2) * o2 * a2 % e2, e2, u5, r2, h2, p2, false, l2);
          }
          function nm(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            const u5 = s2 / 2, c2 = Jd(t2);
            let h2 = 0, p2 = e2 - r2, f2 = [];
            for (let e3 = 0; e3 < t2.length - 1; e3++) {
              const o3 = t2[e3], a3 = t2[e3 + 1], d2 = o3.dist(a3), m2 = a3.angleTo(o3);
              for (; p2 + r2 < h2 + d2; ) {
                p2 += r2;
                const y2 = (p2 - h2) / d2, g2 = or(o3.x, a3.x, y2), x2 = or(o3.y, a3.y, y2);
                if (g2 >= 0 && g2 < l2 && x2 >= 0 && x2 < l2 && p2 - u5 >= 0 && p2 + u5 <= c2) {
                  const r3 = new Yd(g2, x2, 0, m2, e3);
                  n2 && !Kd(t2, r3, s2, n2, i2) || f2.push(r3);
                }
              }
              h2 += d2;
            }
            return a2 || f2.length || o2 || (f2 = nm(t2, h2 / 2, r2, n2, i2, s2, o2, true, l2)), f2;
          }
          function im(t2) {
            let e2 = 0, r2 = 0;
            for (const n3 of t2) e2 += n3.w * n3.h, r2 = Math.max(r2, n3.w);
            t2.sort((t3, e3) => e3.h - t3.h);
            const n2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }];
            let i2 = 0, s2 = 0;
            for (const e3 of t2) for (let t3 = n2.length - 1; t3 >= 0; t3--) {
              const r3 = n2[t3];
              if (!(e3.w > r3.w || e3.h > r3.h)) {
                if (e3.x = r3.x, e3.y = r3.y, s2 = Math.max(s2, e3.y + e3.h), i2 = Math.max(i2, e3.x + e3.w), e3.w === r3.w && e3.h === r3.h) {
                  const e4 = n2.pop();
                  t3 < n2.length && (n2[t3] = e4);
                } else e3.h === r3.h ? (r3.x += e3.w, r3.w -= e3.w) : e3.w === r3.w ? (r3.y += e3.h, r3.h -= e3.h) : (n2.push({ x: r3.x + e3.w, y: r3.y, w: r3.w - e3.w, h: e3.h }), r3.y += e3.h, r3.h -= e3.h);
                break;
              }
            }
            return { w: i2, h: s2, fill: e2 / (i2 * s2) || 0 };
          }
          js(Yd, "Anchor");
          const sm = 1;
          class om {
            static getImagePositionScale(t2, e2, r2) {
              if (e2 && t2 && t2.options && t2.options.transform) {
                const e3 = t2.options.transform;
                return { x: e3.a, y: e3.d };
              }
              return { x: r2, y: r2 };
            }
            constructor(t2, e2, r2, n2) {
              this.paddedRect = t2;
              const { pixelRatio: i2, version: s2, stretchX: o2, stretchY: a2, content: l2, sdf: u5, usvg: c2 } = e2;
              this.pixelRatio = i2, this.stretchX = o2, this.stretchY = a2, this.content = l2, this.version = s2, this.padding = r2, this.sdf = u5, this.scale = om.getImagePositionScale(n2, c2, i2);
            }
            get tl() {
              return [this.paddedRect.x + this.padding, this.paddedRect.y + this.padding];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - this.padding, this.paddedRect.y + this.paddedRect.h - this.padding];
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * this.padding) / this.scale.x, (this.paddedRect.h - 2 * this.padding) / this.scale.y];
            }
          }
          function am(t2, e2, r2) {
            const n2 = Br.parse(t2), i2 = function(t3, e3, r3 = [1, 1]) {
              return { x: 0, y: 0, w: (t3.data ? t3.data.width : t3.width * r3[0]) + 2 * e3, h: (t3.data ? t3.data.height : t3.height * r3[1]) + 2 * e3 };
            }(e2, r2, [n2.options.transform.a, n2.options.transform.d]);
            return { bin: i2, imagePosition: new om(i2, e2, r2, n2), imageVariant: n2 };
          }
          class lm {
            constructor(t2, e2, r2) {
              const n2 = /* @__PURE__ */ new Map(), i2 = /* @__PURE__ */ new Map();
              this.haveRenderCallbacks = [];
              const s2 = [];
              this.addImages(t2, n2, sm, s2), this.addImages(e2, i2, 2, s2);
              const { w: o2, h: a2 } = im(s2), l2 = new Hc({ width: o2 || 1, height: a2 || 1 });
              for (const [e3, i3] of t2.entries()) {
                const t3 = n2.get(e3).paddedRect;
                Hc.copy(i3.data, l2, { x: 0, y: 0 }, { x: t3.x + sm, y: t3.y + sm }, i3.data, r2, i3.sdf);
              }
              for (const [t3, n3] of e2.entries()) {
                const e3 = i2.get(t3), s3 = e3.paddedRect;
                let o3 = e3.padding;
                const a3 = s3.x + o3, u5 = s3.y + o3, c2 = n3.data.width, h2 = n3.data.height;
                o3 = o3 > 1 ? o3 - 1 : o3, Hc.copy(n3.data, l2, { x: 0, y: 0 }, { x: a3, y: u5 }, n3.data, r2), Hc.copy(n3.data, l2, { x: 0, y: h2 - o3 }, { x: a3, y: u5 - o3 }, { width: c2, height: o3 }, r2), Hc.copy(n3.data, l2, { x: 0, y: 0 }, { x: a3, y: u5 + h2 }, { width: c2, height: o3 }, r2), Hc.copy(n3.data, l2, { x: c2 - o3, y: 0 }, { x: a3 - o3, y: u5 }, { width: o3, height: h2 }, r2), Hc.copy(n3.data, l2, { x: 0, y: 0 }, { x: a3 + c2, y: u5 }, { width: o3, height: h2 }, r2), Hc.copy(n3.data, l2, { x: c2 - o3, y: h2 - o3 }, { x: a3 - o3, y: u5 - o3 }, { width: o3, height: o3 }, r2), Hc.copy(n3.data, l2, { x: 0, y: h2 - o3 }, { x: a3 + c2, y: u5 - o3 }, { width: o3, height: o3 }, r2), Hc.copy(n3.data, l2, { x: 0, y: 0 }, { x: a3 + c2, y: u5 + h2 }, { width: o3, height: o3 }, r2), Hc.copy(n3.data, l2, { x: c2 - o3, y: 0 }, { x: a3 - o3, y: u5 + h2 }, { width: o3, height: o3 }, r2);
              }
              this.lut = r2, this.image = l2, this.iconPositions = n2, this.patternPositions = i2;
            }
            addImages(t2, e2, r2, n2) {
              for (const [i2, s2] of t2.entries()) {
                const { bin: t3, imagePosition: o2, imageVariant: a2 } = am(i2, s2, r2);
                e2.set(i2, o2), n2.push(t3), s2.hasRenderCallback && this.haveRenderCallbacks.push(a2.id);
              }
            }
            patchUpdatedImages(t2, e2, r2) {
              this.haveRenderCallbacks = this.haveRenderCallbacks.filter((e3) => t2.hasImage(e3, r2)), t2.dispatchRenderCallbacks(this.haveRenderCallbacks, r2);
              for (const n2 of t2.getUpdatedImages(r2)) {
                for (const i2 of this.iconPositions.keys()) {
                  const s2 = Br.parse(i2);
                  if (tr.isEqual(s2.id, n2)) {
                    const s3 = t2.getImage(n2, r2);
                    this.patchUpdatedImage(this.iconPositions.get(i2), s3, e2);
                  }
                }
                for (const i2 of this.patternPositions.keys()) {
                  const s2 = Br.parse(i2);
                  if (tr.isEqual(s2.id, n2)) {
                    const s3 = t2.getImage(n2, r2);
                    this.patchUpdatedImage(this.patternPositions.get(i2), s3, e2);
                  }
                }
              }
            }
            patchUpdatedImage(t2, e2, r2) {
              if (!t2 || !e2) return;
              if (t2.version === e2.version) return;
              t2.version = e2.version;
              const [n2, i2] = t2.tl, s2 = t2.sdf;
              if (this.lut || s2) {
                const t3 = { width: e2.data.width, height: e2.data.height }, o2 = new Hc(t3);
                Hc.copy(e2.data, o2, { x: 0, y: 0 }, { x: 0, y: 0 }, t3, this.lut, s2), r2.update(o2, { position: { x: n2, y: i2 } });
              } else r2.update(e2.data, { position: { x: n2, y: i2 } });
            }
          }
          js(om, "ImagePosition"), js(lm, "ImageAtlas");
          const um = 1e20;
          function cm(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            for (let u5 = e2; u5 < e2 + n2; u5++) hm(t2, r2 * s2 + u5, s2, i2, o2, a2, l2);
            for (let u5 = r2; u5 < r2 + i2; u5++) hm(t2, u5 * s2 + e2, 1, n2, o2, a2, l2);
          }
          function hm(t2, e2, r2, n2, i2, s2, o2) {
            s2[0] = 0, o2[0] = -um, o2[1] = um, i2[0] = t2[e2];
            for (let a2 = 1, l2 = 0, u5 = 0; a2 < n2; a2++) {
              i2[a2] = t2[e2 + a2 * r2];
              const n3 = a2 * a2;
              do {
                const t3 = s2[l2];
                u5 = (i2[a2] - i2[t3] + n3 - t3 * t3) / (a2 - t3) / 2;
              } while (u5 <= o2[l2] && --l2 > -1);
              l2++, s2[l2] = a2, o2[l2] = u5, o2[l2 + 1] = um;
            }
            for (let a2 = 0, l2 = 0; a2 < n2; a2++) {
              for (; o2[l2 + 1] < a2; ) l2++;
              const n3 = s2[l2], u5 = a2 - n3;
              t2[e2 + a2 * r2] = i2[n3] + u5 * u5;
            }
          }
          const pm = 2, fm = { none: 0, ideographs: 1, all: 2 };
          class dm {
            constructor(t2, e2, r2) {
              this.requestManager = t2, this.localGlyphMode = e2, this.localFontFamily = r2, this.urls = {}, this.entries = {}, this.localGlyphs = { 200: {}, 400: {}, 500: {}, 900: {} };
            }
            setURL(t2, e2) {
              this.urls[e2] = t2;
            }
            getGlyphs(t2, e2, r2) {
              const n2 = [], i2 = this.urls[e2] || re.GLYPHS_URL;
              for (const e3 in t2) for (const r3 of t2[e3]) n2.push({ stack: e3, id: r3 });
              Vt(n2, ({ stack: t3, id: e3 }, r3) => {
                let n3 = this.entries[t3];
                n3 || (n3 = this.entries[t3] = { glyphs: {}, requests: {}, ranges: {}, ascender: void 0, descender: void 0 });
                let s2 = n3.glyphs[e3];
                if (void 0 !== s2) return void r3(null, { stack: t3, id: e3, glyph: s2 });
                if (s2 = this._tinySDF(n3, t3, e3), s2) return n3.glyphs[e3] = s2, void r3(null, { stack: t3, id: e3, glyph: s2 });
                const o2 = Math.floor(e3 / 256);
                if (256 * o2 > 65535) return $t("glyphs > 65535 not supported"), void r3(null, { stack: t3, id: e3, glyph: s2 });
                if (n3.ranges[o2]) return void r3(null, { stack: t3, id: e3, glyph: s2 });
                let a2 = n3.requests[o2];
                a2 || (a2 = n3.requests[o2] = [], dm.loadGlyphRange(t3, o2, i2, this.requestManager, (t4, e4) => {
                  if (e4) {
                    n3.ascender = e4.ascender, n3.descender = e4.descender;
                    for (const t5 in e4.glyphs) this._doesCharSupportLocalGlyph(+t5) || (n3.glyphs[+t5] = e4.glyphs[+t5]);
                    n3.ranges[o2] = true;
                  }
                  for (const r4 of a2) r4(t4, e4);
                  delete n3.requests[o2];
                })), a2.push((n4, i3) => {
                  n4 ? r3(n4) : i3 && r3(null, { stack: t3, id: e3, glyph: i3.glyphs[e3] || null });
                });
              }, (t3, e3) => {
                if (t3) r2(t3);
                else if (e3) {
                  const t4 = {};
                  for (const { stack: r3, id: n3, glyph: i3 } of e3) void 0 === t4[r3] && (t4[r3] = {}), void 0 === t4[r3].glyphs && (t4[r3].glyphs = {}), t4[r3].glyphs[n3] = i3 && { id: i3.id, bitmap: i3.bitmap.clone(), metrics: i3.metrics }, t4[r3].ascender = this.entries[r3].ascender, t4[r3].descender = this.entries[r3].descender;
                  r2(null, t4);
                }
              });
            }
            _doesCharSupportLocalGlyph(t2) {
              return this.localGlyphMode !== fm.none && (this.localGlyphMode === fm.all ? !!this.localFontFamily : !!this.localFontFamily && (Xs["CJK Unified Ideographs"](t2) || Xs["Hangul Syllables"](t2) || Xs.Hiragana(t2) || Xs.Katakana(t2) || Xs["CJK Symbols and Punctuation"](t2) || Xs["CJK Unified Ideographs Extension A"](t2) || Xs["CJK Unified Ideographs Extension B"](t2) || Xs.Osage(t2)));
            }
            _tinySDF(t2, e2, r2) {
              const n2 = this.localFontFamily;
              if (!n2 || !this._doesCharSupportLocalGlyph(r2)) return;
              let i2 = t2.tinySDF;
              if (!i2) {
                let r3 = "400";
                /bold/i.test(e2) ? r3 = "900" : /medium/i.test(e2) ? r3 = "500" : /light/i.test(e2) && (r3 = "200"), i2 = t2.tinySDF = new dm.TinySDF({ fontFamily: n2, fontWeight: r3, fontSize: 24 * pm, buffer: 3 * pm, radius: 8 * pm }), i2.fontWeight = r3;
              }
              if (this.localGlyphs[i2.fontWeight][r2]) return this.localGlyphs[i2.fontWeight][r2];
              const s2 = String.fromCodePoint(r2), { data: o2, width: a2, height: l2, glyphWidth: u5, glyphHeight: c2, glyphLeft: h2, glyphTop: p2, glyphAdvance: f2 } = i2.draw(s2);
              return this.localGlyphs[i2.fontWeight][r2] = { id: r2, bitmap: new qc({ width: a2, height: l2 }, o2), metrics: { width: u5 / pm, height: c2 / pm, left: h2 / pm, top: p2 / pm - 27, advance: f2 / pm, localGlyph: true } };
            }
          }
          dm.loadGlyphRange = function(t2, e2, r2, n2, i2) {
            const s2 = 256 * e2, o2 = s2 + 255, a2 = n2.transformRequest(n2.normalizeGlyphsURL(r2).replace("{fontstack}", t2).replace("{range}", `${s2}-${o2}`), Te.Glyphs);
            De(a2, (t3, e3) => {
              if (t3) i2(t3);
              else if (e3) {
                const t4 = {}, r3 = function(t5) {
                  return new _d(t5).readFields(Ad, {});
                }(e3);
                for (const e4 of r3.glyphs) t4[e4.id] = e4;
                i2(null, { glyphs: t4, ascender: r3.ascender, descender: r3.descender });
              }
            });
          }, dm.TinySDF = class {
            constructor({ fontSize: t2 = 24, buffer: e2 = 3, radius: r2 = 8, cutoff: n2 = 0.25, fontFamily: i2 = "sans-serif", fontWeight: s2 = "normal", fontStyle: o2 = "normal" } = {}) {
              this.buffer = e2, this.cutoff = n2, this.radius = r2;
              const a2 = this.size = t2 + 4 * e2, l2 = this._createCanvas(a2), u5 = this.ctx = l2.getContext("2d", { willReadFrequently: true });
              u5.font = `${o2} ${s2} ${t2}px ${i2}`, u5.textBaseline = "alphabetic", u5.textAlign = "left", u5.fillStyle = "black", this.gridOuter = new Float64Array(a2 * a2), this.gridInner = new Float64Array(a2 * a2), this.f = new Float64Array(a2), this.z = new Float64Array(a2 + 1), this.v = new Uint16Array(a2);
            }
            _createCanvas(t2) {
              const e2 = document.createElement("canvas");
              return e2.width = e2.height = t2, e2;
            }
            draw(t2) {
              const { width: e2, actualBoundingBoxAscent: r2, actualBoundingBoxDescent: n2, actualBoundingBoxLeft: i2, actualBoundingBoxRight: s2 } = this.ctx.measureText(t2), o2 = Math.ceil(r2), a2 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(s2 - i2))), l2 = Math.min(this.size - this.buffer, o2 + Math.ceil(n2)), u5 = a2 + 2 * this.buffer, c2 = l2 + 2 * this.buffer, h2 = Math.max(u5 * c2, 0), p2 = new Uint8ClampedArray(h2), f2 = { data: p2, width: u5, height: c2, glyphWidth: a2, glyphHeight: l2, glyphTop: o2, glyphLeft: 0, glyphAdvance: e2 };
              if (0 === a2 || 0 === l2) return f2;
              const { ctx: d2, buffer: m2, gridInner: y2, gridOuter: g2 } = this;
              d2.clearRect(m2, m2, a2, l2), d2.fillText(t2, m2, m2 + o2);
              const x2 = d2.getImageData(m2, m2, a2, l2);
              g2.fill(um, 0, h2), y2.fill(0, 0, h2);
              for (let t3 = 0; t3 < l2; t3++) for (let e3 = 0; e3 < a2; e3++) {
                const r3 = x2.data[4 * (t3 * a2 + e3) + 3] / 255;
                if (0 === r3) continue;
                const n3 = (t3 + m2) * u5 + e3 + m2;
                if (1 === r3) g2[n3] = 0, y2[n3] = um;
                else {
                  const t4 = 0.5 - r3;
                  g2[n3] = t4 > 0 ? t4 * t4 : 0, y2[n3] = t4 < 0 ? t4 * t4 : 0;
                }
              }
              cm(g2, 0, 0, u5, c2, u5, this.f, this.v, this.z), cm(y2, m2, m2, a2, l2, u5, this.f, this.v, this.z);
              for (let t3 = 0; t3 < h2; t3++) {
                const e3 = Math.sqrt(g2[t3]) - Math.sqrt(y2[t3]);
                p2[t3] = Math.round(255 - 255 * (e3 / this.radius + this.cutoff));
              }
              return f2;
            }
          };
          const mm = sm;
          function ym(t2, e2) {
            return t2 + e2[1] - e2[0];
          }
          function gm(t2, e2, r2, n2, i2 = 1) {
            const s2 = [], o2 = t2.imagePrimary, a2 = o2.pixelRatio, l2 = o2.paddedRect.w - 2 * mm, u5 = o2.paddedRect.h - 2 * mm, c2 = (t2.right - t2.left) * i2, h2 = (t2.bottom - t2.top) * i2, p2 = o2.stretchX || [[0, l2]], f2 = o2.stretchY || [[0, u5]], d2 = p2.reduce(ym, 0), m2 = f2.reduce(ym, 0), y2 = l2 - d2, g2 = u5 - m2;
            let x2 = 0, v3 = d2, b2 = 0, _2 = m2, w2 = 0, A2 = y2, M2 = 0, I2 = g2;
            if (o2.content && n2) {
              const t3 = o2.content;
              x2 = xm(p2, 0, t3[0]), b2 = xm(f2, 0, t3[1]), v3 = xm(p2, t3[0], t3[2]), _2 = xm(f2, t3[1], t3[3]), w2 = t3[0] - x2, M2 = t3[1] - b2, A2 = t3[2] - t3[0] - v3, I2 = t3[3] - t3[1] - _2;
            }
            const S2 = (n3, s3, l3, u6) => {
              const p3 = bm(n3.stretch - x2, v3, c2, t2.left * i2), f3 = _m(n3.fixed - w2, A2, n3.stretch, d2), y3 = bm(s3.stretch - b2, _2, h2, t2.top * i2), g3 = _m(s3.fixed - M2, I2, s3.stretch, m2), S3 = bm(l3.stretch - x2, v3, c2, t2.left * i2), z2 = _m(l3.fixed - w2, A2, l3.stretch, d2), k2 = bm(u6.stretch - b2, _2, h2, t2.top * i2), E2 = _m(u6.fixed - M2, I2, u6.stretch, m2), P2 = new bt(p3, y3), T2 = new bt(S3, y3), B3 = new bt(S3, k2), V2 = new bt(p3, k2), C3 = new bt(f3 / a2, g3 / a2), D3 = new bt(z2 / a2, E2 / a2), F2 = e2 * Math.PI / 180;
              if (F2) {
                const t3 = Math.sin(F2), e3 = Math.cos(F2), r3 = [e3, -t3, t3, e3];
                P2._matMult(r3), T2._matMult(r3), V2._matMult(r3), B3._matMult(r3);
              }
              const L2 = n3.stretch + n3.fixed, R2 = l3.stretch + l3.fixed, O2 = s3.stretch + s3.fixed, U2 = u6.stretch + u6.fixed, N2 = t2.imageSecondary;
              return { tl: P2, tr: T2, bl: V2, br: B3, texPrimary: { x: o2.paddedRect.x + mm + L2, y: o2.paddedRect.y + mm + O2, w: R2 - L2, h: U2 - O2 }, texSecondary: N2 ? { x: N2.paddedRect.x + mm + L2, y: N2.paddedRect.y + mm + O2, w: R2 - L2, h: U2 - O2 } : void 0, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: C3, pixelOffsetBR: D3, minFontScaleX: A2 / a2 / c2, minFontScaleY: I2 / a2 / h2, isSDF: r2 };
            };
            if (n2 && (o2.stretchX || o2.stretchY)) {
              const t3 = vm(p2, y2, d2), e3 = vm(f2, g2, m2);
              for (let r3 = 0; r3 < t3.length - 1; r3++) {
                const n3 = t3[r3], i3 = t3[r3 + 1];
                for (let t4 = 0; t4 < e3.length - 1; t4++) s2.push(S2(n3, e3[t4], i3, e3[t4 + 1]));
              }
            } else s2.push(S2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l2 + 1 }, { fixed: 0, stretch: u5 + 1 }));
            return s2;
          }
          function xm(t2, e2, r2) {
            let n2 = 0;
            for (const i2 of t2) n2 += Math.max(e2, Math.min(r2, i2[1])) - Math.max(e2, Math.min(r2, i2[0]));
            return n2;
          }
          function vm(t2, e2, r2) {
            const n2 = [{ fixed: -mm, stretch: 0 }];
            for (const [e3, r3] of t2) {
              const t3 = n2[n2.length - 1];
              n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch }), n2.push({ fixed: e3 - t3.stretch, stretch: t3.stretch + (r3 - e3) });
            }
            return n2.push({ fixed: e2 + mm, stretch: r2 }), n2;
          }
          function bm(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function _m(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          function wm(t2, e2, r2, n2) {
            const i2 = e2 + t2.positionedLines[n2].lineOffset;
            return 0 === n2 ? r2 + i2 / 2 : r2 + (i2 + (e2 + t2.positionedLines[n2 - 1].lineOffset)) / 2;
          }
          function Am(t2, e2 = 1, r2 = false) {
            let n2 = 1 / 0, i2 = 1 / 0, s2 = -1 / 0, o2 = -1 / 0;
            const a2 = t2[0];
            for (let t3 = 0; t3 < a2.length; t3++) {
              const e3 = a2[t3];
              (!t3 || e3.x < n2) && (n2 = e3.x), (!t3 || e3.y < i2) && (i2 = e3.y), (!t3 || e3.x > s2) && (s2 = e3.x), (!t3 || e3.y > o2) && (o2 = e3.y);
            }
            const l2 = Math.min(s2 - n2, o2 - i2);
            let u5 = l2 / 2;
            const c2 = new Pn([], Mm);
            if (0 === l2) return new bt(n2, i2);
            for (let e3 = n2; e3 < s2; e3 += l2) for (let r3 = i2; r3 < o2; r3 += l2) c2.push(new Im(e3 + u5, r3 + u5, u5, t2));
            let h2 = function(t3) {
              let e3 = 0, r3 = 0, n3 = 0;
              const i3 = t3[0];
              for (let t4 = 0, s3 = i3.length, o3 = s3 - 1; t4 < s3; o3 = t4++) {
                const s4 = i3[t4], a3 = i3[o3], l3 = s4.x * a3.y - a3.x * s4.y;
                r3 += (s4.x + a3.x) * l3, n3 += (s4.y + a3.y) * l3, e3 += 3 * l3;
              }
              return new Im(r3 / e3, n3 / e3, 0, t3);
            }(t2), p2 = c2.length;
            for (; c2.length; ) {
              const n3 = c2.pop();
              (n3.d > h2.d || !h2.d) && (h2 = n3, r2 && console.log("found best %d after %d probes", Math.round(1e4 * n3.d) / 1e4, p2)), n3.max - h2.d <= e2 || (u5 = n3.h / 2, c2.push(new Im(n3.p.x - u5, n3.p.y - u5, u5, t2)), c2.push(new Im(n3.p.x + u5, n3.p.y - u5, u5, t2)), c2.push(new Im(n3.p.x - u5, n3.p.y + u5, u5, t2)), c2.push(new Im(n3.p.x + u5, n3.p.y + u5, u5, t2)), p2 += 4);
            }
            return r2 && (console.log(`num probes: ${p2}`), console.log(`best distance: ${h2.d}`)), h2.p;
          }
          function Mm(t2, e2) {
            return e2.max - t2.max;
          }
          class Im {
            constructor(t2, e2, r2, n2) {
              this.p = new bt(t2, e2), this.h = r2, this.d = function(t3, e3) {
                let r3 = false, n3 = 1 / 0;
                for (let i2 = 0; i2 < e3.length; i2++) {
                  const s2 = e3[i2];
                  for (let e4 = 0, i3 = s2.length, o2 = i3 - 1; e4 < i3; o2 = e4++) {
                    const i4 = s2[e4], a2 = s2[o2];
                    i4.y > t3.y != a2.y > t3.y && t3.x < (a2.x - i4.x) * (t3.y - i4.y) / (a2.y - i4.y) + i4.x && (r3 = !r3), n3 = Math.min(n3, zu(t3, i4, a2));
                  }
                }
                return (r3 ? 1 : -1) * Math.sqrt(n3);
              }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
            }
          }
          const Sm = Object.keys, zm = Number.POSITIVE_INFINITY, km = Math.sqrt(2);
          function Em(t2, [e2, r2]) {
            let n2 = 0, i2 = 0;
            if (r2 === zm) {
              e2 < 0 && (e2 = 0);
              const r3 = e2 / km;
              switch (t2) {
                case "top-right":
                case "top-left":
                  i2 = r3 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  i2 = 7 - r3;
                  break;
                case "bottom":
                  i2 = 7 - e2;
                  break;
                case "top":
                  i2 = e2 - 7;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                  n2 = -r3;
                  break;
                case "top-left":
                case "bottom-left":
                  n2 = r3;
                  break;
                case "left":
                  n2 = e2;
                  break;
                case "right":
                  n2 = -e2;
              }
            } else {
              switch (e2 = Math.abs(e2), r2 = Math.abs(r2), t2) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t2) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e2;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e2;
              }
            }
            return [n2, i2];
          }
          function Pm(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            if (!e2 || !e2.usvg) return;
            const u5 = qd(n2), c2 = qd(i2), h2 = "both" !== s2 && "width" !== s2 || !$d(n2) ? 1 : Math.max(1, c2.width / u5.width), p2 = "both" !== s2 && "height" !== s2 || !Gd(n2) ? 1 : Math.max(1, c2.height / u5.height);
            r2.scaleSelf(h2, p2);
            const f2 = r2.toString();
            o2.set(f2, r2), a2.set(f2, e2);
            const { imagePosition: d2 } = am(f2, e2, sm);
            l2.set(f2, d2);
          }
          function Tm(t2, e2, r2, n2, i2, s2, o2, a2) {
            if (!t2) return;
            const l2 = function(t3, e3, r3, n3, i3) {
              if ("camera" === t3.kind) return t3.maxSize;
              if ("composite" === t3.kind) {
                const n4 = e3.possiblyEvaluate(new yo(t3.maxZoom), r3).evaluate(i3, {}, r3), s3 = e3.possiblyEvaluate(new yo(t3.minZoom), r3).evaluate(i3, {}, r3);
                return Math.max(n4, s3);
              }
              return e3.possiblyEvaluate(new yo(n3)).evaluate(i3, {}, r3);
            }(e2, r2, n2, i2, s2);
            return t2.scaleSelf(l2 * a2 * o2);
          }
          function Bm(t2, e2, r2, n2, i2, s2, o2, a2) {
            return { iconPrimary: Tm(t2.getPrimary(), e2, r2, n2, i2, s2, o2, a2), iconSecondary: Tm(t2.getSecondary(), e2, r2, n2, i2, s2, o2, a2) };
          }
          function Vm(t2, e2, r2, n2) {
            if (!t2) return;
            const i2 = e2.get(r2.toString());
            if (t2.imagePrimary = i2, n2) {
              const r3 = e2.get(n2.toString());
              t2.imageSecondary = r3;
            }
          }
          function Cm(t2, e2) {
            for (const r2 in t2.horizontal) Dm(t2.horizontal[r2], e2);
            Dm(t2.vertical, e2);
          }
          function Dm(t2, e2) {
            if (t2) {
              for (const r2 of t2.positionedLines) for (const t3 of r2.positionedGlyphs) if (null !== t3.image) {
                const r3 = t3.image.toString();
                t3.rect = e2.get(r3).paddedRect;
              }
            }
          }
          function Fm(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Lm(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            const u5 = jm(s2.horizontal) || s2.vertical, c2 = r2.get("icon-text-fit-padding").evaluate(n2, {}, i2);
            let h2, p2 = e2;
            return e2 && "none" !== l2 && (t2.allowVerticalPlacement && s2.vertical && (h2 = jd(e2, s2.vertical, l2, c2, a2, o2)), u5 && (p2 = jd(e2, u5, l2, c2, a2, o2))), { defaultShapedIcon: p2, verticallyShapedIcon: h2 };
          }
          function Rm(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2, x2, v3) {
            let b2 = o2.textMaxSize.evaluate(e2, {}, p2);
            void 0 === b2 ? b2 = a2 * o2.textScaleFactor : b2 *= o2.textScaleFactor;
            const _2 = t2.layers[0].layout, w2 = jm(r2.horizontal) || r2.vertical, A2 = "globe" === f2.name, M2 = cd2, I2 = t2.tilePixelRatio * b2 / M2, S2 = (B3 = t2.overscaling, t2.zoom > 18 && B3 > 2 && (B3 >>= 1), Math.max(Tn / (512 * B3), 1) * _2.get("symbol-spacing")), z2 = _2.get("text-padding") * t2.tilePixelRatio, k2 = _2.get("icon-padding") * t2.tilePixelRatio, E2 = Mt(_2.get("text-max-angle")), P2 = "map" === _2.get("icon-rotation-alignment") && "point" !== v3, T2 = S2 / 2;
            var B3;
            false === t2.hasAnyIconTextFit && "none" !== y2 && (t2.hasAnyIconTextFit = true);
            const V2 = e2.properties ? +e2.properties[jh] : null, C3 = V2 && t2.elevationFeatureIdToIndex ? t2.elevationFeatureIdToIndex.get(V2) : 65535, D3 = (a3, l3, v4) => {
              if (l3.x < 0 || l3.x >= Tn || l3.y < 0 || l3.y >= Tn) return;
              let b3 = null;
              if (A2) {
                const { x: t3, y: e3, z: r3 } = f2.projectTilePoint(l3.x, l3.y, v4);
                b3 = { anchor: new Yd(t3, e3, r3, 0, void 0), up: f2.upVector(v4, l3.x, l3.y) };
              }
              !function(t3, e3, r3, n3, i3, s3, o3, a4, l4, u6, c3, h3, p3, f3, d3, m3, y3, g3, x3, v5, b4, _3, w3, A3, M3, I3, S3, z3, k3) {
                const E3 = t3.addToLineVertexArray(e3, n3);
                let P3, T3, B4, V3, C4, D4, F2, L2 = 0, R2 = 0, O2 = 0, U2 = 0, N2 = -1, j2 = -1;
                const $2 = {};
                let G2 = Ze("");
                const q2 = r3 ? r3.anchor : e3, H2 = "none" !== z3;
                let X2 = 0, Z2 = 0;
                if (void 0 === l4._unevaluatedLayout.getValue("text-radial-offset")) {
                  const t4 = l4.layout.get("text-offset").evaluate(b4, {}, M3);
                  X2 = t4[0] * cd2, Z2 = t4[1] * cd2;
                } else X2 = l4.layout.get("text-radial-offset").evaluate(b4, {}, M3) * cd2, Z2 = zm;
                if (t3.allowVerticalPlacement && i3.vertical) {
                  const t4 = i3.vertical;
                  if (d3) D4 = Gm(t4), a4 && (F2 = Gm(a4));
                  else {
                    const r4 = l4.layout.get("text-rotate").evaluate(b4, {}, M3) + 90;
                    B4 = $m(u6, q2, e3, c3, h3, p3, t4, f3, r4, m3), a4 && (V3 = $m(u6, q2, e3, c3, h3, p3, a4, g3, r4));
                  }
                }
                if (s3) {
                  const n4 = t3.iconSizeData, i4 = l4.layout.get("icon-rotate").evaluate(b4, {}, M3), o4 = gm(s3, i4, w3, H2, _3.iconScaleFactor), f4 = a4 ? gm(a4, i4, w3, H2, _3.iconScaleFactor) : void 0;
                  T3 = $m(u6, q2, e3, c3, h3, p3, s3, g3, i4, null), L2 = 4 * o4.length;
                  let d4 = null;
                  "source" === n4.kind ? (d4 = [Hd * l4.layout.get("icon-size").evaluate(b4, {}, M3) * _3.iconScaleFactor], d4[0] > Um && $t(`${t3.layerIds[0]}: Value for "icon-size" is >= ${Om}. Reduce your "icon-size".`)) : "composite" === n4.kind && (d4 = [Hd * _3.compositeIconSizes[0].evaluate(b4, {}, M3) * _3.iconScaleFactor, Hd * _3.compositeIconSizes[1].evaluate(b4, {}, M3) * _3.iconScaleFactor], (d4[0] > Um || d4[1] > Um) && $t(`${t3.layerIds[0]}: Value for "icon-size" is >= ${Om}. Reduce your "icon-size".`)), t3.addSymbols(t3.icon, o4, d4, v5, x3, b4, void 0, r3, e3, E3.lineStartIndex, E3.lineLength, -1, A3, M3, I3, S3), N2 = t3.icon.placedSymbolArray.length - 1, f4 && (R2 = 4 * f4.length, t3.addSymbols(t3.icon, f4, d4, v5, x3, b4, zd.vertical, r3, e3, E3.lineStartIndex, E3.lineLength, -1, A3, M3, I3, S3), j2 = t3.icon.placedSymbolArray.length - 1);
                }
                for (const n4 in i3.horizontal) {
                  const s4 = n4, a5 = i3.horizontal[s4];
                  P3 || (G2 = Ze(a5.text), d3 ? C4 = Gm(a5) : P3 = $m(u6, q2, e3, c3, h3, p3, a5, f3, l4.layout.get("text-rotate").evaluate(b4, {}, M3), m3));
                  const y4 = 1 === a5.positionedLines.length;
                  if (O2 += Nm(t3, r3, e3, a5, o3, l4, d3, b4, m3, E3, i3.vertical ? zd.horizontal : zd.horizontalOnly, y4 ? Sm(i3.horizontal) : [s4], $2, N2, _3, A3, M3, I3), y4) break;
                }
                i3.vertical && (U2 += Nm(t3, r3, e3, i3.vertical, o3, l4, d3, b4, m3, E3, zd.vertical, ["vertical"], $2, j2, _3, A3, M3, I3));
                let W2 = -1;
                const Y2 = (t4, e4) => t4 ? Math.max(t4, e4) : e4;
                W2 = Y2(C4, W2), W2 = Y2(D4, W2), W2 = Y2(F2, W2);
                const K2 = W2 > -1 ? 1 : 0;
                t3.glyphOffsetArray.length >= 65535 && $t("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t3.addToSortKeyRanges(t3.symbolInstances.length, b4.sortKey), t3.symbolInstances.emplaceBack(e3.x, e3.y, q2.x, q2.y, q2.z, $2.right >= 0 ? $2.right : -1, $2.center >= 0 ? $2.center : -1, $2.left >= 0 ? $2.left : -1, $2.vertical >= 0 ? $2.vertical : -1, N2, j2, G2, void 0 !== P3 ? P3 : t3.collisionBoxArray.length, void 0 !== P3 ? P3 + 1 : t3.collisionBoxArray.length, void 0 !== B4 ? B4 : t3.collisionBoxArray.length, void 0 !== B4 ? B4 + 1 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 : t3.collisionBoxArray.length, void 0 !== T3 ? T3 + 1 : t3.collisionBoxArray.length, V3 || t3.collisionBoxArray.length, V3 ? V3 + 1 : t3.collisionBoxArray.length, c3, O2, U2, L2, R2, K2, 0, X2, Z2, W2, 0, H2 ? 1 : 0, k3);
              }(t2, l3, b3, a3, r2, n2, s2, i2, t2.layers[0], t2.collisionBoxArray, e2.index, e2.sourceLayerIndex, t2.index, z2, x2, u5, 0, k2, P2, g2, e2, o2, c2, h2, p2, d2, m2, y2, C3);
            };
            if ("line" === v3) for (const i3 of Af(e2.geometry, 0, 0, Tn, Tn)) {
              const e3 = rm(i3, S2, E2, r2.vertical || w2, n2, M2, I2, t2.overscaling, Tn);
              for (const r3 of e3) w2 && qm(t2, w2.text, T2, r3) || D3(i3, r3, p2);
            }
            else if ("line-center" === v3) {
              for (const t3 of e2.geometry) if (t3.length > 1) {
                const e3 = em(t3, E2, r2.vertical || w2, n2, M2, I2);
                e3 && D3(t3, e3, p2);
              }
            } else if ("Polygon" === e2.type) for (const t3 of Ih(e2.geometry, 0)) {
              const e3 = Am(t3, 16);
              D3(t3[0], new Yd(e3.x, e3.y, 0, 0, void 0), p2);
            }
            else if ("LineString" === e2.type) for (const t3 of e2.geometry) D3(t3, new Yd(t3[0].x, t3[0].y, 0, 0, void 0), p2);
            else if ("Point" === e2.type) for (const t3 of e2.geometry) for (const e3 of t3) D3([e3], new Yd(e3.x, e3.y, 0, 0, void 0), p2);
          }
          const Om = 255, Um = Om * Hd;
          function Nm(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2, g2) {
            const x2 = function(t3, e3, r3, n3, i3, s3, o3, a3) {
              const l3 = [];
              if (0 === e3.positionedLines.length) return l3;
              const u6 = n3.layout.get("text-rotate").evaluate(s3, {}) * Math.PI / 180, c3 = function(t4) {
                const e4 = t4[0], r4 = t4[1], n4 = e4 * r4;
                return n4 > 0 ? [e4, -r4] : n4 < 0 ? [-e4, r4] : 0 === e4 ? [r4, e4] : [r4, -e4];
              }(r3);
              let h3 = Math.abs(e3.top - e3.bottom);
              for (const t4 of e3.positionedLines) h3 -= t4.lineOffset;
              const p3 = e3.positionedLines.length, f3 = h3 / p3;
              let d3 = e3.top - r3[1];
              for (let t4 = 0; t4 < p3; ++t4) {
                const n4 = e3.positionedLines[t4];
                d3 = wm(e3, f3, d3, t4);
                for (const t5 of n4.positionedGlyphs) {
                  if (!t5.rect) continue;
                  const n5 = t5.rect || {};
                  let s4 = Sd + 1, h4 = true, p4 = 1, f4 = 0;
                  if (t5.image) {
                    const e4 = o3.get(t5.image.toString());
                    if (!e4) continue;
                    if (e4.sdf) {
                      $t("SDF images are not supported in formatted text and will be ignored.");
                      continue;
                    }
                    h4 = false, p4 = e4.pixelRatio, s4 = sm / p4;
                  }
                  const m3 = (i3 || a3) && t5.vertical, y3 = t5.metrics.advance * t5.scale / 2, g3 = t5.metrics, x3 = t5.rect;
                  if (null === x3) continue;
                  a3 && e3.verticalizable && (f4 = t5.image ? y3 - t5.metrics.width * t5.scale / 2 : 0);
                  const v4 = i3 ? [t5.x + y3, t5.y] : [0, 0];
                  let b3 = [0, 0], _2 = [0, 0], w2 = false;
                  i3 || (m3 ? (_2 = [t5.x + y3 + c3[0], t5.y + c3[1] - f4], w2 = true) : b3 = [t5.x + y3 + r3[0], t5.y + r3[1] - f4]);
                  const A2 = x3.w * t5.scale / (p4 * (t5.localGlyph ? pm : 1)), M2 = x3.h * t5.scale / (p4 * (t5.localGlyph ? pm : 1));
                  let I2, S2, z2, k2;
                  if (m3) {
                    const e4 = t5.y - d3, r4 = new bt(-y3, y3 - e4), n6 = -Math.PI / 2, i4 = new bt(..._2);
                    I2 = new bt(-y3 + b3[0], b3[1]), I2._rotateAround(n6, r4)._add(i4), I2.x += -e4 + y3, I2.y -= (g3.left - s4) * t5.scale;
                    const o4 = t5.image ? g3.advance * t5.scale : cd2 * t5.scale, a4 = String.fromCodePoint(t5.glyph);
                    fd(a4) ? I2.x += (1 - s4) * t5.scale : dd(a4) ? I2.x += o4 - g3.height * t5.scale + (-s4 - 1) * t5.scale : I2.x += t5.image || g3.width + 2 * s4 === x3.w && g3.height + 2 * s4 === x3.h ? (o4 - M2) / 2 : (o4 - (g3.height + 2 * s4) * t5.scale) / 2, S2 = new bt(I2.x, I2.y - A2), z2 = new bt(I2.x + M2, I2.y), k2 = new bt(I2.x + M2, I2.y - A2);
                  } else {
                    const e4 = (g3.left - s4) * t5.scale - y3 + b3[0], r4 = (-g3.top - s4) * t5.scale + b3[1], n6 = e4 + A2, i4 = r4 + M2;
                    I2 = new bt(e4, r4), S2 = new bt(n6, r4), z2 = new bt(e4, i4), k2 = new bt(n6, i4);
                  }
                  if (u6) {
                    let t6;
                    t6 = i3 ? new bt(0, 0) : w2 ? new bt(c3[0], c3[1]) : new bt(r3[0], r3[1]), I2._rotateAround(u6, t6), S2._rotateAround(u6, t6), z2._rotateAround(u6, t6), k2._rotateAround(u6, t6);
                  }
                  const E2 = new bt(0, 0), P2 = new bt(0, 0);
                  l3.push({ tl: I2, tr: S2, bl: z2, br: k2, texPrimary: n5, texSecondary: void 0, writingMode: e3.writingMode, glyphOffset: v4, sectionIndex: t5.sectionIndex, isSDF: h4, pixelOffsetTL: E2, pixelOffsetBR: P2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              }
              return l3;
            }(0, n2, l2, s2, o2, a2, i2, t2.allowVerticalPlacement), v3 = t2.textSizeData;
            let b2 = null;
            "source" === v3.kind ? (b2 = [Hd * s2.layout.get("text-size").evaluate(a2, {}, y2) * d2.textScaleFactor], b2[0] > Um && $t(`${t2.layerIds[0]}: Value for "text-size" is >= ${Om}. Reduce your "text-size".`)) : "composite" === v3.kind && (b2 = [Hd * d2.compositeTextSizes[0].evaluate(a2, {}, y2) * d2.textScaleFactor, Hd * d2.compositeTextSizes[1].evaluate(a2, {}, y2) * d2.textScaleFactor], (b2[0] > Um || b2[1] > Um) && $t(`${t2.layerIds[0]}: Value for "text-size" is >= ${Om}. Reduce your "text-size".`)), t2.addSymbols(t2.text, x2, b2, l2, o2, a2, c2, e2, r2, u5.lineStartIndex, u5.lineLength, f2, m2, y2, g2, false);
            for (const e3 of h2) p2[e3] = t2.text.placedSymbolArray.length - 1;
            return 4 * x2.length;
          }
          function jm(t2) {
            for (const e2 in t2) return t2[e2];
            return null;
          }
          function $m(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) {
            let c2 = o2.top, h2 = o2.bottom, p2 = o2.left, f2 = o2.right;
            if (Ud(o2) && o2.collisionPadding) {
              const t3 = o2.collisionPadding;
              p2 -= t3[0], c2 -= t3[1], f2 += t3[2], h2 += t3[3];
            }
            if (l2) {
              const t3 = new bt(p2, c2), e3 = new bt(f2, c2), r3 = new bt(p2, h2), n3 = new bt(f2, h2), i3 = Mt(l2);
              let s3 = new bt(0, 0);
              u5 && (s3 = new bt(u5[0], u5[1])), t3._rotateAround(i3, s3), e3._rotateAround(i3, s3), r3._rotateAround(i3, s3), n3._rotateAround(i3, s3), p2 = Math.min(t3.x, e3.x, r3.x, n3.x), f2 = Math.max(t3.x, e3.x, r3.x, n3.x), c2 = Math.min(t3.y, e3.y, r3.y, n3.y), h2 = Math.max(t3.y, e3.y, r3.y, n3.y);
            }
            return t2.emplaceBack(e2.x, e2.y, e2.z, r2.x, r2.y, p2, c2, f2, h2, a2, n2, i2, s2), t2.length - 1;
          }
          function Gm(t2) {
            Ud(t2) && t2.collisionPadding && (t2.top -= t2.collisionPadding[1], t2.bottom += t2.collisionPadding[3]);
            const e2 = t2.bottom - t2.top;
            return e2 > 0 ? Math.max(10, e2) : null;
          }
          function qm(t2, e2, r2, n2) {
            const i2 = t2.compareText;
            if (e2 in i2) {
              const t3 = i2[e2];
              for (let e3 = t3.length - 1; e3 >= 0; e3--) if (n2.dist(t3[e3]) < r2) return true;
            } else i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          function Hm(t2, e2) {
            const r2 = t2.fovAboveCenter, n2 = t2.elevation ? t2.elevation.getMinElevationBelowMSL() * e2 : 0, i2 = (t2._camera.position[2] * t2.worldSize - n2) / Math.cos(t2._pitch), s2 = Math.sin(r2) * i2 / Math.sin(Math.max(Math.PI / 2 - t2._pitch - r2, 0.01));
            let o2 = Math.sin(t2._pitch) * s2 + i2;
            const a2 = i2 * (1 / t2._horizonShift);
            if (!t2.elevation || 0 === t2.elevation.exaggeration()) {
              let e3 = Math.max(t2.zoom - 17, 0);
              t2.isOrthographic && (e3 /= 10), o2 *= 1 + e3;
            }
            return Math.min(1.01 * o2, a2);
          }
          function Xm(t2, e2) {
            if (!e2.isReprojectedInTileSpace) return { scale: 1 << t2.z, x: t2.x, y: t2.y, x2: t2.x + 1, y2: t2.y + 1, projection: e2 };
            const r2 = Math.pow(2, -t2.z), n2 = t2.x * r2, i2 = (t2.x + 1) * r2, s2 = t2.y * r2, o2 = (t2.y + 1) * r2, a2 = Kl(n2), l2 = Kl(i2), u5 = Jl(s2), c2 = Jl(o2), h2 = e2.project(a2, u5), p2 = e2.project(l2, u5), f2 = e2.project(l2, c2), d2 = e2.project(a2, c2);
            let m2 = Math.min(h2.x, p2.x, f2.x, d2.x), y2 = Math.min(h2.y, p2.y, f2.y, d2.y), g2 = Math.max(h2.x, p2.x, f2.x, d2.x), x2 = Math.max(h2.y, p2.y, f2.y, d2.y);
            const v3 = r2 / 16;
            function b2(t3, r3, n3, i3, s3, o3) {
              const a3 = (n3 + s3) / 2, l3 = (i3 + o3) / 2, u6 = e2.project(Kl(a3), Jl(l3)), c3 = Math.max(0, m2 - u6.x, y2 - u6.y, u6.x - g2, u6.y - x2);
              m2 = Math.min(m2, u6.x), g2 = Math.max(g2, u6.x), y2 = Math.min(y2, u6.y), x2 = Math.max(x2, u6.y), c3 > v3 && (b2(t3, u6, n3, i3, a3, l3), b2(u6, r3, a3, l3, s3, o3));
            }
            b2(h2, p2, n2, s2, i2, s2), b2(p2, f2, i2, s2, i2, o2), b2(f2, d2, i2, o2, n2, o2), b2(d2, h2, n2, o2, n2, s2), m2 -= v3, y2 -= v3, g2 += v3, x2 += v3;
            const _2 = 1 / Math.max(g2 - m2, x2 - y2);
            return { scale: _2, x: m2 * _2, y: y2 * _2, x2: g2 * _2, y2: x2 * _2, projection: e2 };
          }
          function Zm(t2, { x: e2, y: r2 }, n2 = 0) {
            return new bt(((e2 - n2) * t2.scale - t2.x) * Tn, (r2 * t2.scale - t2.y) * Tn);
          }
          const Wm = l(new Float32Array(16));
          class Ym {
            constructor(t2) {
              this.spec = t2, this.name = t2.name, this.wrap = false, this.requiresDraping = false, this.supportsWorldCopies = false, this.supportsTerrain = false, this.supportsFog = false, this.supportsFreeCamera = false, this.zAxisUnit = "meters", this.isReprojectedInTileSpace = true, this.unsupportedLayers = ["custom"], this.center = [0, 0], this.range = [3.5, 7];
            }
            project(t2, e2) {
              return { x: 0, y: 0, z: 0 };
            }
            unproject(t2, e2) {
              return new $l(0, 0);
            }
            projectTilePoint(t2, e2, r2) {
              return { x: t2, y: e2, z: 0 };
            }
            locationPoint(t2, e2, r2, n2 = true) {
              return t2._coordinatePoint(t2.locationCoordinate(e2, r2), n2);
            }
            pixelsPerMeter(t2, e2) {
              return Yl(1, t2) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              return 1;
            }
            farthestPixelDistance(t2) {
              return Hm(t2, t2.pixelsPerMeter);
            }
            pointCoordinate(t2, e2, r2, n2) {
              const i2 = t2.horizonLineFromTop(false), s2 = new bt(e2, Math.max(i2, r2));
              return t2.rayIntersectionCoordinate(t2.pointRayIntersection(s2, n2));
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = new bt(e2, r2);
              if (t2.elevation) return t2.elevation.pointCoordinate(n2);
              {
                const e3 = this.pointCoordinate(t2, n2.x, n2.y, 0);
                return [e3.x, e3.y, e3.z];
              }
            }
            isPointAboveHorizon(t2, e2) {
              if (t2.elevation && t2.elevation.visibleDemTiles.length) return !this.pointCoordinate3D(t2, e2.x, e2.y);
              const r2 = t2.horizonLineFromTop();
              return e2.y < r2;
            }
            createInversionMatrix(t2, e2) {
              return Wm;
            }
            createTileMatrix(t2, e2, r2) {
              let n2, i2, s2;
              const o2 = r2.canonical, a2 = l(new Float64Array(16));
              if (this.isReprojectedInTileSpace) {
                const l2 = Xm(o2, this);
                n2 = 1, i2 = l2.x + r2.wrap * l2.scale, s2 = l2.y, p(a2, a2, [n2 / l2.scale, n2 / l2.scale, t2.pixelsPerMeter / e2]);
              } else n2 = e2 / t2.zoomScale(o2.z), i2 = (o2.x + Math.pow(2, o2.z) * r2.wrap) * n2, s2 = o2.y * n2;
              return h(a2, a2, [i2, s2, 0]), p(a2, a2, [n2 / Tn, n2 / Tn, 1]), a2;
            }
            upVector(t2, e2, r2) {
              return [0, 0, 1];
            }
            upVectorScale(t2, e2, r2) {
              return { metersToTile: 1 };
            }
          }
          class Km extends Ym {
            constructor(t2) {
              super(t2), this.range = [4, 7], this.center = t2.center || [-96, 37.5];
              const [e2, r2] = this.parallels = t2.parallels || [29.5, 45.5], n2 = Math.sin(Mt(e2));
              this.n = (n2 + Math.sin(Mt(r2))) / 2, this.c = 1 + n2 * (2 * this.n - n2), this.r0 = Math.sqrt(this.c) / this.n;
            }
            project(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = Mt(t2 - this.center[0]), o2 = Mt(e2), a2 = Math.sqrt(n2 - 2 * r2 * Math.sin(o2)) / r2;
              return { x: a2 * Math.sin(s2 * r2), y: a2 * Math.cos(s2 * r2) - i2, z: 0 };
            }
            unproject(t2, e2) {
              const { n: r2, c: n2, r0: i2 } = this, s2 = i2 + e2;
              let o2 = Math.atan2(t2, Math.abs(s2)) * Math.sign(s2);
              s2 * r2 < 0 && (o2 -= Math.PI * Math.sign(t2) * Math.sign(s2));
              const a2 = Mt(this.center[0]) * r2;
              o2 = Bt(o2, -Math.PI - a2, Math.PI - a2);
              const l2 = Pt(It(o2 / r2) + this.center[0], -180, 180), u5 = Math.asin(Pt((n2 - (t2 * t2 + s2 * s2) * r2 * r2) / (2 * r2), -1, 1)), c2 = Pt(It(u5), -tu, tu);
              return new $l(l2, c2);
            }
          }
          const Jm = 1.340264, Qm = -0.081106, ty = 893e-6, ey = 3796e-6, ry = Math.sqrt(3) / 2;
          class ny extends Ym {
            project(t2, e2) {
              e2 = e2 / 180 * Math.PI, t2 = t2 / 180 * Math.PI;
              const r2 = Math.asin(ry * Math.sin(e2)), n2 = r2 * r2, i2 = n2 * n2 * n2;
              return { x: 0.5 * (t2 * Math.cos(r2) / (ry * (Jm + 3 * Qm * n2 + i2 * (7 * ty + 9 * ey * n2))) / Math.PI + 0.5), y: 1 - 0.5 * (r2 * (Jm + Qm * n2 + i2 * (ty + ey * n2)) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = r2 * r2, i2 = n2 * n2 * n2;
              for (let t3, s3, o3, a3 = 0; a3 < 12 && (s3 = r2 * (Jm + Qm * n2 + i2 * (ty + ey * n2)) - e2, o3 = Jm + 3 * Qm * n2 + i2 * (7 * ty + 9 * ey * n2), t3 = s3 / o3, r2 = Pt(r2 - t3, -Math.PI / 3, Math.PI / 3), n2 = r2 * r2, i2 = n2 * n2 * n2, !(Math.abs(t3) < 1e-12)); ++a3) ;
              const s2 = ry * t2 * (Jm + 3 * Qm * n2 + i2 * (7 * ty + 9 * ey * n2)) / Math.cos(r2), o2 = Math.asin(Math.sin(r2) / ry), a2 = Pt(180 * s2 / Math.PI, -180, 180), l2 = Pt(180 * o2 / Math.PI, -tu, tu);
              return new $l(a2, l2);
            }
          }
          class iy extends Ym {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              return { x: 0.5 + t2 / 360, y: 0.5 - e2 / 360, z: 0 };
            }
            unproject(t2, e2) {
              const r2 = 360 * (t2 - 0.5), n2 = Pt(360 * (0.5 - e2), -tu, tu);
              return new $l(r2, n2);
            }
          }
          const sy = Math.PI / 2;
          function oy(t2) {
            return Math.tan((sy + t2) / 2);
          }
          class ay extends Ym {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 30];
              const [e2, r2] = this.parallels = t2.parallels || [30, 30];
              let n2 = Mt(e2), i2 = Mt(r2);
              this.southernCenter = n2 + i2 < 0, this.southernCenter && (n2 = -n2, i2 = -i2);
              const s2 = Math.cos(n2), o2 = oy(n2);
              this.n = n2 === i2 ? Math.sin(n2) : Math.log(s2 / Math.cos(i2)) / Math.log(oy(i2) / o2), this.f = s2 * Math.pow(oy(n2), this.n) / this.n;
            }
            project(t2, e2) {
              e2 = Mt(e2), this.southernCenter && (e2 = -e2), t2 = Mt(t2 - this.center[0]);
              const r2 = 1e-6, { n: n2, f: i2 } = this;
              i2 > 0 ? e2 < -sy + r2 && (e2 = -sy + r2) : e2 > sy - r2 && (e2 = sy - r2);
              const s2 = i2 / Math.pow(oy(e2), n2);
              let o2 = s2 * Math.sin(n2 * t2), a2 = i2 - s2 * Math.cos(n2 * t2);
              return o2 = 0.5 * (o2 / Math.PI + 0.5), a2 = 0.5 * (a2 / Math.PI + 0.5), { x: o2, y: this.southernCenter ? a2 : 1 - a2, z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI, this.southernCenter && (e2 = 1 - e2), e2 = (2 * (1 - e2) - 0.5) * Math.PI;
              const { n: r2, f: n2 } = this, i2 = n2 - e2, s2 = Math.sign(i2), o2 = Math.sign(r2) * Math.sqrt(t2 * t2 + i2 * i2);
              let a2 = Math.atan2(t2, Math.abs(i2)) * s2;
              i2 * r2 < 0 && (a2 -= Math.PI * Math.sign(t2) * s2);
              const l2 = Pt(It(a2 / r2) + this.center[0], -180, 180), u5 = Pt(It(2 * Math.atan(Math.pow(n2 / o2, 1 / r2)) - sy), -tu, tu);
              return new $l(l2, this.southernCenter ? -u5 : u5);
            }
          }
          class ly extends Ym {
            constructor(t2) {
              super(t2), this.wrap = true, this.supportsWorldCopies = true, this.supportsTerrain = true, this.supportsFog = true, this.supportsFreeCamera = true, this.isReprojectedInTileSpace = false, this.unsupportedLayers = [], this.range = null;
            }
            project(t2, e2) {
              return { x: Zl(t2), y: Wl(e2), z: 0 };
            }
            unproject(t2, e2) {
              const r2 = Kl(t2), n2 = Jl(e2);
              return new $l(r2, n2);
            }
          }
          const uy = Mt(tu);
          class cy extends Ym {
            project(t2, e2) {
              const r2 = (e2 = Mt(e2)) * e2, n2 = r2 * r2;
              return { x: 0.5 * ((t2 = Mt(t2)) * (0.8707 - 0.131979 * r2 + n2 * (n2 * (3971e-6 * r2 - 1529e-6 * n2) - 0.013791)) / Math.PI + 0.5), y: 1 - 0.5 * (e2 * (1.007226 + r2 * (0.015085 + n2 * (0.028874 * r2 - 0.044475 - 5916e-6 * n2))) / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              t2 = (2 * t2 - 0.5) * Math.PI;
              let r2 = e2 = (2 * (1 - e2) - 1) * Math.PI, n2 = 25, i2 = 0, s2 = r2 * r2;
              do {
                s2 = r2 * r2;
                const t3 = s2 * s2;
                i2 = (r2 * (1.007226 + s2 * (0.015085 + t3 * (0.028874 * s2 - 0.044475 - 5916e-6 * t3))) - e2) / (1.007226 + s2 * (0.045255 + t3 * (0.259866 * s2 - 0.311325 - 5916e-6 * 11 * t3))), r2 = Pt(r2 - i2, -uy, uy);
              } while (Math.abs(i2) > 1e-6 && --n2 > 0);
              s2 = r2 * r2;
              const o2 = Pt(It(t2 / (0.8707 + s2 * (s2 * (s2 * s2 * s2 * (3971e-6 - 1529e-6 * s2) - 0.013791) - 0.131979))), -180, 180), a2 = It(r2);
              return new $l(o2, a2);
            }
          }
          const hy = Mt(tu);
          class py extends Ym {
            project(t2, e2) {
              e2 = Mt(e2), t2 = Mt(t2);
              const r2 = Math.cos(e2), n2 = 2 / Math.PI, i2 = Math.acos(r2 * Math.cos(t2 / 2)), s2 = Math.sin(i2) / i2, o2 = 0.5 * (t2 * n2 + 2 * r2 * Math.sin(t2 / 2) / s2) || 0, a2 = 0.5 * (e2 + Math.sin(e2) / s2) || 0;
              return { x: 0.5 * (o2 / Math.PI + 0.5), y: 1 - 0.5 * (a2 / Math.PI + 1), z: 0 };
            }
            unproject(t2, e2) {
              let r2 = t2 = (2 * t2 - 0.5) * Math.PI, n2 = e2 = (2 * (1 - e2) - 1) * Math.PI, i2 = 25;
              const s2 = 1e-6;
              let o2 = 0, a2 = 0;
              do {
                const i3 = Math.cos(n2), s3 = Math.sin(n2), l2 = 2 * s3 * i3, u5 = s3 * s3, c2 = i3 * i3, h2 = Math.cos(r2 / 2), p2 = Math.sin(r2 / 2), f2 = 2 * h2 * p2, d2 = p2 * p2, m2 = 1 - c2 * h2 * h2, y2 = m2 ? 1 / m2 : 0, g2 = m2 ? Math.acos(i3 * h2) * Math.sqrt(1 / m2) : 0, x2 = 0.5 * (2 * g2 * i3 * p2 + 2 * r2 / Math.PI) - t2, v3 = 0.5 * (g2 * s3 + n2) - e2, b2 = 0.5 * y2 * (c2 * d2 + g2 * i3 * h2 * u5) + 1 / Math.PI, _2 = y2 * (f2 * l2 / 4 - g2 * s3 * p2), w2 = 0.125 * y2 * (l2 * p2 - g2 * s3 * c2 * f2), A2 = 0.5 * y2 * (u5 * h2 + g2 * d2 * i3) + 0.5, M2 = _2 * w2 - A2 * b2;
                o2 = (v3 * _2 - x2 * A2) / M2, a2 = (x2 * w2 - v3 * b2) / M2, r2 = Pt(r2 - o2, -Math.PI, Math.PI), n2 = Pt(n2 - a2, -hy, hy);
              } while ((Math.abs(o2) > s2 || Math.abs(a2) > s2) && --i2 > 0);
              return new $l(It(r2), It(n2));
            }
          }
          class fy extends Ym {
            constructor(t2) {
              super(t2), this.center = t2.center || [0, 0], this.parallels = t2.parallels || [0, 0], this.cosPhi = Math.max(0.01, Math.cos(Mt(this.parallels[0]))), this.scale = 1 / (2 * Math.max(Math.PI * this.cosPhi, 1 / this.cosPhi)), this.wrap = true, this.supportsWorldCopies = true;
            }
            project(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this;
              return { x: Mt(t2) * n2 * r2 + 0.5, y: -Math.sin(Mt(e2)) / n2 * r2 + 0.5, z: 0 };
            }
            unproject(t2, e2) {
              const { scale: r2, cosPhi: n2 } = this, i2 = -(e2 - 0.5) / r2, s2 = Pt(It((t2 - 0.5) / r2) / n2, -180, 180), o2 = Math.asin(Pt(i2 * n2, -1, 1)), a2 = Pt(It(o2), -tu, tu);
              return new $l(s2, a2);
            }
          }
          class dy extends ly {
            constructor(t2) {
              super(t2), this.requiresDraping = true, this.supportsWorldCopies = false, this.supportsFog = true, this.zAxisUnit = "pixels", this.unsupportedLayers = ["debug"], this.range = [3, 5];
            }
            projectTilePoint(t2, e2, r2) {
              const n2 = yc(t2, e2, r2);
              return R(n2, n2, vc(cc2(r2))), { x: n2[0], y: n2[1], z: n2[2] };
            }
            locationPoint(t2, e2, r2) {
              const n2 = Ul(e2.lat, e2.lng), i2 = C([], n2), s2 = r2 ? t2._centerAltitude + r2 : t2.elevation ? t2.elevation.getAtPointOrZero(t2.locationCoordinate(e2), t2._centerAltitude) : t2._centerAltitude;
              P(n2, n2, i2, Yl(1, 0) * Tn * s2);
              const o2 = l(new Float64Array(16));
              return c(o2, t2.pixelMatrix, t2.globeMatrix), R(n2, n2, o2), new bt(n2[0], n2[1]);
            }
            pixelsPerMeter(t2, e2) {
              return Yl(1, 0) * e2;
            }
            pixelSpaceConversion(t2, e2, r2) {
              const n2 = Yl(1, t2) * e2, i2 = or(Yl(1, 45) * e2, n2, r2);
              return this.pixelsPerMeter(t2, e2) / i2;
            }
            createTileMatrix(t2, e2, r2) {
              const n2 = bc4(cc2(r2.canonical));
              return c(new Float64Array(16), t2.globeMatrix, n2);
            }
            createInversionMatrix(t2, e2) {
              const { center: r2 } = t2, n2 = vc(cc2(e2));
              return d(n2, n2, Mt(r2.lng)), f(n2, n2, Mt(r2.lat)), p(n2, n2, [t2._pixelsPerMercatorPixel, t2._pixelsPerMercatorPixel, 1]), Float32Array.from(n2);
            }
            pointCoordinate(t2, e2, r2, n2) {
              return ac2(t2, e2, r2, true) || new su(0, 0);
            }
            pointCoordinate3D(t2, e2, r2) {
              const n2 = this.pointCoordinate(t2, e2, r2, 0);
              return [n2.x, n2.y, n2.z];
            }
            isPointAboveHorizon(t2, e2) {
              return !ac2(t2, e2.x, e2.y, false);
            }
            farthestPixelDistance(t2) {
              const e2 = function(t3, e3) {
                const r3 = t3.cameraToCenterDistance, n2 = t3._centerAltitude * e3, i2 = t3._camera, s2 = t3._camera.forward(), o2 = M([], E([], s2, -r3), [0, 0, n2]), a2 = t3.worldSize / (2 * Math.PI), l2 = [0, 0, -a2], u5 = t3.width / t3.height, c2 = Math.tan(t3.fovAboveCenter), h2 = E([], i2.up(), c2), p2 = E([], i2.right(), c2 * u5), f2 = C([], M([], M([], s2, h2), p2)), d2 = [];
                let m2;
                if (new Ku(o2, f2).closestPointOnSphere(l2, a2, d2)) {
                  const e4 = M([], d2, l2), r4 = j([], e4, o2);
                  m2 = Math.cos(t3.fovAboveCenter) * w(r4);
                } else {
                  const t4 = j([], o2, l2), e4 = j([], l2, o2);
                  C(e4, e4);
                  const r4 = w(t4) - a2;
                  m2 = Math.sqrt(r4 * (r4 + 2 * a2));
                  const n3 = Math.acos(m2 / (a2 + r4)) - Math.acos(D2(s2, e4));
                  m2 *= Math.cos(n3);
                }
                return 1.01 * m2;
              }(t2, this.pixelsPerMeter(t2.center.lat, t2.worldSize)), r2 = Mc(t2.zoom);
              if (r2 > 0) {
                const n2 = Hm(t2, Yl(1, t2.center.lat) * t2.worldSize), i2 = t2.worldSize / (2 * Math.PI), s2 = Math.max(t2.width, t2.height) / t2.worldSize * Math.PI;
                return or(e2, n2 + i2 * (1 - Math.cos(s2)), Math.pow(r2, 10));
              }
              return e2;
            }
            upVector(t2, e2, r2) {
              return yc(e2, r2, t2, 1);
            }
            upVectorScale(t2) {
              return { metersToTile: sc(gc(cc2(t2))) };
            }
          }
          function my(t2) {
            const e2 = t2.parallels, r2 = !!e2 && Math.abs(e2[0] + e2[1]) < 0.01;
            switch (t2.name) {
              case "mercator":
                return new ly(t2);
              case "equirectangular":
                return new iy(t2);
              case "naturalEarth":
                return new cy(t2);
              case "equalEarth":
                return new ny(t2);
              case "winkelTripel":
                return new py(t2);
              case "albers":
                return r2 ? new fy(t2) : new Km(t2);
              case "lambertConformalConic":
                return r2 ? new fy(t2) : new ay(t2);
              case "globe":
                return new dy(t2);
            }
            throw new Error(`Invalid projection name: ${t2.name}`);
          }
          const yy = Nh.VectorTileFeature.types, gy = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function xy(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2) {
            const f2 = a2 ? Math.min(Um, Math.round(a2[0])) : 0, d2 = a2 ? Math.min(Um, Math.round(a2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), s2, o2, (f2 << 1) + (l2 ? 1 : 0), d2, 16 * u5, 16 * c2, 256 * h2, 256 * p2);
          }
          function vy(t2, e2, r2) {
            t2.emplaceBack(e2, r2);
          }
          function by(t2, e2, r2, n2, i2, s2, o2) {
            t2.emplaceBack(e2, r2, n2, i2, s2, o2);
          }
          function _y(t2, e2, r2, n2, i2) {
            t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2), t2.emplaceBack(e2, r2, n2, i2);
          }
          function wy(t2) {
            for (const e2 of t2.sections) if (ro(e2.text)) return true;
            return false;
          }
          class Ay {
            constructor(t2) {
              this.layoutVertexArray = new fa(), this.indexArray = new wa(), this.programConfigurations = t2, this.segments = new Ka(), this.dynamicLayoutVertexArray = new ma(), this.opacityVertexArray = new ya(), this.placedSymbolArray = new Oa(), this.iconTransitioningVertexArray = new ga(), this.globeExtVertexArray = new da2(), this.zOffsetVertexArray = new ia();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length && 0 === this.iconTransitioningVertexArray.length;
            }
            upload(t2, e2, r2, n2, i2) {
              this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ed.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, nd.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, gy, true), this.iconTransitioningVertexArray.length > 0 && (this.iconTransitioningVertexBuffer = t2.createVertexBuffer(this.iconTransitioningVertexArray, sd.members, true)), this.globeExtVertexArray.length > 0 && (this.globeExtVertexBuffer = t2.createVertexBuffer(this.globeExtVertexArray, rd.members, true)), !this.zOffsetVertexBuffer && (this.zOffsetVertexArray.length > 0 || i2) && (this.zOffsetVertexBuffer = t2.createVertexBuffer(this.zOffsetVertexArray, id.members, true)), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy(), this.iconTransitioningVertexBuffer && this.iconTransitioningVertexBuffer.destroy(), this.globeExtVertexBuffer && this.globeExtVertexBuffer.destroy(), this.zOffsetVertexBuffer && this.zOffsetVertexBuffer.destroy());
            }
          }
          js(Ay, "SymbolBuffers");
          class My {
            constructor(t2, e2, r2) {
              this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new Ka(), this.collisionVertexArray = new _a(), this.collisionVertexArrayExt = new ma();
            }
            upload(t2) {
              this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, od.members, true), this.collisionVertexBufferExt = t2.createVertexBuffer(this.collisionVertexArrayExt, ad.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy(), this.collisionVertexBufferExt.destroy());
            }
          }
          js(My, "CollisionBuffers");
          class Iy {
            constructor(t2) {
              this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.lut = t2.lut, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.fullyClipped = false, this.hasAnyIconTextFit = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = l([]), this.placementViewportMatrix = l([]);
              const e2 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Xd(this.zoom, e2["text-size"]), this.iconSizeData = Xd(this.zoom, e2["icon-size"]);
              const r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
              this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, this.writingModes = r2.get("text-writing-mode").map((t3) => zd[t3]), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.sourceID = t2.sourceID, this.projection = t2.projection, this.hasAnyZOffset = false, this.zOffsetSortDirty = false, this.zOffsetBuffersNeedUpload = false, this.elevationType = "none", this.elevationStateComplete = false, this.activeReplacements = [], this.replacementUpdateTime = 0;
            }
            createArrays() {
              this.text = new Ay(new Il(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("text") || t2.startsWith("symbol"))), this.icon = new Ay(new Il(this.layers, { zoom: this.zoom, lut: this.lut }, (t2) => t2.startsWith("icon") || t2.startsWith("symbol"))), this.glyphOffsetArray = new ja(), this.lineVertexArray = new $a(), this.symbolInstances = new Na();
            }
            calculateGlyphDependencies(t2, e2, r2, n2, i2) {
              for (const r3 of t2) {
                const t3 = r3.codePointAt(0);
                if (void 0 === t3) break;
                if (e2[t3] = true, n2 && i2 && t3 <= 65535) {
                  const t4 = pd[r3];
                  t4 && (e2[t4.charCodeAt(0)] = true);
                }
              }
            }
            updateFootprints(t2, e2) {
            }
            updateReplacement(t2, e2) {
              if (e2.updateTime === this.replacementUpdateTime) return false;
              this.replacementUpdateTime = e2.updateTime;
              const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
              return !Bp(this.activeReplacements, r2) && (this.activeReplacements = r2, true);
            }
            populate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = i2.layout, o2 = "globe" === this.projection.name, a2 = s2.get("text-font"), l2 = s2.get("text-field"), u5 = s2.get("icon-image"), [c2, h2] = s2.get("icon-size-scale-range"), p2 = Pt(e2.scaleFactor || 1, c2, h2), f2 = ("constant" !== l2.value.kind || l2.value.value instanceof Tr && !l2.value.value.isEmpty() || l2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), d2 = "constant" !== u5.value.kind || !!u5.value.value || Object.keys(u5.parameters).length > 0, m2 = s2.get("symbol-sort-key");
              if (this.features = [], !f2 && !d2) return;
              const y2 = e2.iconDependencies, g2 = e2.glyphDependencies, x2 = e2.availableImages, v3 = new yo(this.zoom);
              for (const { feature: e3, id: l3, index: u6, sourceLayerIndex: c3 } of t2) {
                const t3 = i2._featureFilter.needGeometry, h3 = du(e3, t3);
                if (!i2._featureFilter.filter(v3, h3, r2)) continue;
                if (t3 || (h3.geometry = fu(e3, r2, n2)), o2 && 1 !== e3.type && r2.z <= 5) {
                  const t4 = h3.geometry, e4 = 0.98078528056, n3 = (t5, n4) => D2(yc(t5.x, t5.y, r2, 1), yc(n4.x, n4.y, r2, 1)) < e4;
                  for (let e5 = 0; e5 < t4.length; e5++) t4[e5] = uu(t4[e5], n3);
                }
                let b2, _2;
                if (f2) {
                  const t4 = i2.getValueAndResolveTokens("text-field", h3, r2, x2), e4 = Tr.factory(t4);
                  wy(e4) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === po() || this.hasRTLText && mo.isParsed()) && (b2 = hd(e4, i2, h3));
                }
                if (d2) {
                  const t4 = i2.getValueAndResolveTokens("icon-image", h3, r2, x2);
                  _2 = "string" == typeof t4 ? Vr.build(t4) : t4;
                }
                if (!b2 && !_2) continue;
                const w2 = this.sortFeaturesByKey ? m2.evaluate(h3, {}, r2) : void 0, A2 = { id: l3, text: b2, icon: _2, index: u6, sourceLayerIndex: c3, geometry: h3.geometry, properties: e3.properties, type: yy[e3.type], sortKey: w2 };
                if (this.features.push(A2), _2) {
                  const t4 = this.layers[0]._unevaluatedLayout._values, { iconPrimary: e4, iconSecondary: n3 } = Bm(_2, this.iconSizeData, t4["icon-size"], r2, this.zoom, A2, this.pixelRatio, p2), i3 = e4.id.toString();
                  if (y2.has(i3) ? y2.get(i3).push(e4) : y2.set(i3, [e4]), n3) {
                    const t5 = n3.id.toString();
                    y2.has(t5) ? y2.get(t5).push(n3) : y2.set(t5, [n3]);
                  }
                }
                if (b2) {
                  const t4 = a2.evaluate(h3, {}, r2).join(","), e4 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(zd.vertical) >= 0;
                  for (const r3 of b2.sections) if (r3.image) {
                    const t5 = r3.image.getPrimary().scaleSelf(this.pixelRatio), e5 = t5.id.toString(), n3 = y2.get(e5) || [];
                    n3.push(t5), y2.set(e5, n3);
                  } else {
                    const n3 = Zs(b2.toString()), i3 = r3.fontStack || t4, s3 = g2[i3] = g2[i3] || {};
                    this.calculateGlyphDependencies(r3.text, s3, e4, this.allowVerticalPlacement, n3);
                  }
                }
              }
              if ("line" === s2.get("symbol-placement") && (this.features = function(t3) {
                const e3 = {}, r3 = {}, n3 = [];
                let i3 = 0;
                function s3(e4) {
                  n3.push(t3[e4]), i3++;
                }
                function o3(t4, e4, i4) {
                  const s4 = r3[t4];
                  return delete r3[t4], r3[e4] = s4, n3[s4].geometry[0].pop(), n3[s4].geometry[0] = n3[s4].geometry[0].concat(i4[0]), s4;
                }
                function a3(t4, r4, i4) {
                  const s4 = e3[r4];
                  return delete e3[r4], e3[t4] = s4, n3[s4].geometry[0].shift(), n3[s4].geometry[0] = i4[0].concat(n3[s4].geometry[0]), s4;
                }
                function l3(t4, e4, r4) {
                  const n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return `${t4}:${n4.x}:${n4.y}`;
                }
                for (let u6 = 0; u6 < t3.length; u6++) {
                  const c3 = t3[u6], h3 = c3.geometry, p3 = c3.text ? c3.text.toString() : null;
                  if (!p3) {
                    s3(u6);
                    continue;
                  }
                  const f3 = l3(p3, h3), d3 = l3(p3, h3, true);
                  if (f3 in r3 && d3 in e3 && r3[f3] !== e3[d3]) {
                    const t4 = a3(f3, d3, h3), i4 = o3(f3, d3, n3[t4].geometry);
                    delete e3[f3], delete r3[d3], r3[l3(p3, n3[i4].geometry, true)] = i4, n3[t4].geometry = null;
                  } else f3 in r3 ? o3(f3, d3, h3) : d3 in e3 ? a3(f3, d3, h3) : (s3(u6), e3[f3] = i3 - 1, r3[d3] = i3 - 1);
                }
                return n3.filter((t4) => t4.geometry);
              }(this.features)), "hd-road-markup" === s2.get("symbol-elevation-reference")) {
                if (this.elevationType = "road", e2.elevationFeatures) {
                  !this.elevationFeatures && e2.elevationFeatures.length > 0 && (this.elevationFeatures = [], this.elevationFeatureIdToIndex = /* @__PURE__ */ new Map());
                  for (const t3 of e2.elevationFeatures) this.elevationFeatureIdToIndex.set(t3.id, this.elevationFeatures.length), this.elevationFeatures.push(t3);
                }
              } else s2.get("symbol-z-elevate") && (this.elevationType = "offset");
              "none" !== this.elevationType && (this.zOffsetBuffersNeedUpload = true), this.sortFeaturesByKey && this.features.sort((t3, e3) => t3.sortKey - e3.sortKey);
            }
            update(t2, e2, r2, n2, i2, s2, o2) {
              this.text.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2), this.icon.programConfigurations.updatePaintArrays(t2, e2, i2, r2, n2, s2, o2);
            }
            updateRoadElevation() {
              if ("road" !== this.elevationType || !this.elevationFeatures) return;
              if (this.elevationStateComplete) return;
              this.elevationStateComplete = true, this.hasAnyZOffset = false;
              let t2 = false;
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                if (65535 === r2.elevationFeatureIndex) continue;
                const n2 = this.elevationFeatures[r2.elevationFeatureIndex];
                if (n2) {
                  const e3 = 0.05 + n2.pointElevation(new bt(r2.tileAnchorX, r2.tileAnchorY));
                  r2.zOffset !== e3 && (t2 = true, r2.zOffset = e3);
                }
              }
              t2 && (this.zOffsetBuffersNeedUpload = true, this.zOffsetSortDirty = true);
            }
            updateZOffset() {
              const t2 = (t3, e3, n3) => {
                r2 += e3, r2 > t3.length && t3.resize(r2);
                for (let i2 = -e3; i2 < 0; i2++) t3.emplace(i2 + r2, n3);
              }, e2 = (t3, e3, r3) => {
                n2 += e3, n2 > t3.length && t3.resize(n2);
                for (let i2 = -e3; i2 < 0; i2++) t3.emplace(i2 + n2, r3);
              };
              if (!this.zOffsetBuffersNeedUpload) return;
              this.zOffsetBuffersNeedUpload = false;
              let r2 = 0, n2 = 0;
              for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
                const n3 = this.symbolInstances.get(r3), { numHorizontalGlyphVertices: i2, numVerticalGlyphVertices: s2, numIconVertices: o2 } = n3, a2 = n3.zOffset, l2 = o2 > 0;
                if ((i2 > 0 || s2 > 0) && (t2(this.text.zOffsetVertexArray, i2, a2), t2(this.text.zOffsetVertexArray, s2, a2)), l2) {
                  const { placedIconSymbolIndex: t3, verticalPlacedIconSymbolIndex: r4 } = n3;
                  t3 >= 0 && e2(this.icon.zOffsetVertexArray, o2, a2), r4 >= 0 && e2(this.icon.zOffsetVertexArray, n3.numVerticalIconVertices, a2);
                }
              }
              this.text.zOffsetVertexBuffer && this.text.zOffsetVertexBuffer.updateData(this.text.zOffsetVertexArray), this.icon.zOffsetVertexBuffer && this.icon.zOffsetVertexBuffer.updateData(this.icon.zOffsetVertexArray);
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t2) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload, this.zOffsetBuffersNeedUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            getProjection() {
              return this.projectionInstance || (this.projectionInstance = my(this.projection)), this.projectionInstance;
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t2, e2) {
              const r2 = this.lineVertexArray.length;
              if (void 0 !== t2.segment) for (const { x: t3, y: r3 } of e2) this.lineVertexArray.emplaceBack(t3, r3);
              return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
            }
            addSymbols(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2) {
              const y2 = t2.indexArray, g2 = t2.layoutVertexArray, x2 = t2.globeExtVertexArray, v3 = t2.segments.prepareSegment(4 * e2.length, g2, y2, this.canOverlap ? s2.sortKey : void 0), b2 = this.glyphOffsetArray.length, _2 = v3.vertexLength, w2 = this.allowVerticalPlacement && o2 === zd.vertical ? Math.PI / 2 : 0, A2 = s2.text && s2.text.sections;
              for (let n3 = 0; n3 < e2.length; n3++) {
                const { tl: i3, tr: o3, bl: u6, br: c3, texPrimary: h3, texSecondary: b3, pixelOffsetTL: _3, pixelOffsetBR: M3, minFontScaleX: I2, minFontScaleY: S2, glyphOffset: z2, isSDF: k2, sectionIndex: E2 } = e2[n3], P2 = v3.vertexLength, T2 = z2[1];
                if (xy(g2, l2.x, l2.y, i3.x, T2 + i3.y, h3.x, h3.y, r2, k2, _3.x, _3.y, I2, S2), xy(g2, l2.x, l2.y, o3.x, T2 + o3.y, h3.x + h3.w, h3.y, r2, k2, M3.x, _3.y, I2, S2), xy(g2, l2.x, l2.y, u6.x, T2 + u6.y, h3.x, h3.y + h3.h, r2, k2, _3.x, M3.y, I2, S2), xy(g2, l2.x, l2.y, c3.x, T2 + c3.y, h3.x + h3.w, h3.y + h3.h, r2, k2, M3.x, M3.y, I2, S2), a2) {
                  const { x: e3, y: r3, z: n4 } = a2.anchor, [i4, s3, o4] = a2.up;
                  by(x2, e3, r3, n4, i4, s3, o4), by(x2, e3, r3, n4, i4, s3, o4), by(x2, e3, r3, n4, i4, s3, o4), by(x2, e3, r3, n4, i4, s3, o4), _y(t2.dynamicLayoutVertexArray, e3, r3, n4, w2);
                } else _y(t2.dynamicLayoutVertexArray, l2.x, l2.y, l2.z, w2);
                if (m2) {
                  const e3 = b3 || h3;
                  vy(t2.iconTransitioningVertexArray, e3.x, e3.y), vy(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y), vy(t2.iconTransitioningVertexArray, e3.x, e3.y + e3.h), vy(t2.iconTransitioningVertexArray, e3.x + e3.w, e3.y + e3.h);
                }
                y2.emplaceBack(P2, P2 + 1, P2 + 2), y2.emplaceBack(P2 + 1, P2 + 2, P2 + 3), v3.vertexLength += 4, v3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(z2[0]), n3 !== e2.length - 1 && E2 === e2[n3 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(g2.length, s2, s2.index, {}, p2, f2, d2, A2 && A2[E2]);
              }
              const M2 = a2 ? a2.anchor : l2;
              t2.placedSymbolArray.emplaceBack(M2.x, M2.y, M2.z, l2.x, l2.y, b2, this.glyphOffsetArray.length - b2, _2, u5, c2, l2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], o2, 0, 0, 0, h2, 0);
            }
            _commitLayoutVertex(t2, e2, r2, n2, i2, s2, o2) {
              t2.emplaceBack(e2, r2, n2, i2, s2, Math.round(o2.x), Math.round(o2.y));
            }
            _addCollisionDebugVertices(t2, e2, r2, n2, i2, s2, o2) {
              const a2 = r2.segments.prepareSegment(4, r2.layoutVertexArray, r2.indexArray), l2 = a2.vertexLength, u5 = o2.tileAnchorX, c2 = o2.tileAnchorY;
              for (let t3 = 0; t3 < 4; t3++) r2.collisionVertexArray.emplaceBack(0, 0, 0, 0, 0, 0);
              this._commitDebugCollisionVertexUpdate(r2.collisionVertexArrayExt, e2, t2.padding, o2.zOffset), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u5, c2, new bt(t2.x1, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u5, c2, new bt(t2.x2, t2.y1)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u5, c2, new bt(t2.x2, t2.y2)), this._commitLayoutVertex(r2.layoutVertexArray, n2, i2, s2, u5, c2, new bt(t2.x1, t2.y2)), a2.vertexLength += 4;
              const h2 = r2.indexArray;
              h2.emplaceBack(l2, l2 + 1), h2.emplaceBack(l2 + 1, l2 + 2), h2.emplaceBack(l2 + 2, l2 + 3), h2.emplaceBack(l2 + 3, l2), a2.primitiveLength += 4;
            }
            _addTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let o2 = n2; o2 < i2; o2++) {
                const n3 = r2.get(o2), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, o2);
                this._addCollisionDebugVertices(n3, i3, this.textCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            _addIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2) {
              for (let o2 = n2; o2 < i2; o2++) {
                const n3 = r2.get(o2), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
                this._addCollisionDebugVertices(n3, i3, this.iconCollisionBox, n3.projectedAnchorX, n3.projectedAnchorY, n3.projectedAnchorZ, s2);
              }
            }
            generateCollisionDebugBuffers(t2, e2, r2) {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new My(va, ld.members, ga), this.iconCollisionBox = new My(va, ld.members, ga);
              const n2 = Wd(this.iconSizeData, t2), i2 = Wd(this.textSizeData, t2, r2);
              for (let r3 = 0; r3 < this.symbolInstances.length; r3++) {
                const s2 = this.symbolInstances.get(r3);
                this._addTextDebugCollisionBoxes(i2, t2, e2, s2.textBoxStartIndex, s2.textBoxEndIndex, s2), this._addTextDebugCollisionBoxes(i2, t2, e2, s2.verticalTextBoxStartIndex, s2.verticalTextBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n2, t2, e2, s2.iconBoxStartIndex, s2.iconBoxEndIndex, s2), this._addIconDebugCollisionBoxes(n2, t2, e2, s2.verticalIconBoxStartIndex, s2.verticalIconBoxEndIndex, s2);
              }
            }
            getSymbolInstanceTextSize(t2, e2, r2, n2) {
              const i2 = this.text.placedSymbolArray.get(e2.rightJustifiedTextSymbolIndex >= 0 ? e2.rightJustifiedTextSymbolIndex : e2.centerJustifiedTextSymbolIndex >= 0 ? e2.centerJustifiedTextSymbolIndex : e2.leftJustifiedTextSymbolIndex >= 0 ? e2.leftJustifiedTextSymbolIndex : e2.verticalPlacedTextSymbolIndex >= 0 ? e2.verticalPlacedTextSymbolIndex : n2), s2 = Zd(this.textSizeData, t2, i2) / cd2;
              return this.tilePixelRatio * s2;
            }
            getSymbolInstanceIconSize(t2, e2, r2) {
              const n2 = this.icon.placedSymbolArray.get(r2), i2 = Zd(this.iconSizeData, t2, n2);
              return this.tilePixelRatio * i2;
            }
            _commitDebugCollisionVertexUpdate(t2, e2, r2, n2) {
              t2.emplaceBack(e2, -r2, -r2, n2), t2.emplaceBack(e2, r2, -r2, n2), t2.emplaceBack(e2, r2, r2, n2), t2.emplaceBack(e2, -r2, r2, n2);
            }
            _updateTextDebugCollisionBoxes(t2, e2, r2, n2, i2, s2, o2) {
              for (let o3 = n2; o3 < i2; o3++) {
                const n3 = r2.get(o3), i3 = this.getSymbolInstanceTextSize(t2, s2, e2, o3);
                this._commitDebugCollisionVertexUpdate(this.textCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
              }
            }
            _updateIconDebugCollisionBoxes(t2, e2, r2, n2, i2, s2, o2) {
              for (let o3 = n2; o3 < i2; o3++) {
                const n3 = r2.get(o3), i3 = this.getSymbolInstanceIconSize(t2, e2, s2.placedIconSymbolIndex);
                this._commitDebugCollisionVertexUpdate(this.iconCollisionBox.collisionVertexArrayExt, i3, n3.padding, s2.zOffset);
              }
            }
            updateCollisionDebugBuffers(t2, e2, r2, n2) {
              if (!this.hasDebugData()) return;
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexArrayExt.clear(), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexArrayExt.clear();
              const i2 = Wd(this.iconSizeData, t2, n2), s2 = Wd(this.textSizeData, t2, r2);
              for (let o2 = 0; o2 < this.symbolInstances.length; o2++) {
                const a2 = this.symbolInstances.get(o2);
                this._updateTextDebugCollisionBoxes(s2, t2, e2, a2.textBoxStartIndex, a2.textBoxEndIndex, a2, r2), this._updateTextDebugCollisionBoxes(s2, t2, e2, a2.verticalTextBoxStartIndex, a2.verticalTextBoxEndIndex, a2, r2), this._updateIconDebugCollisionBoxes(i2, t2, e2, a2.iconBoxStartIndex, a2.iconBoxEndIndex, a2, n2), this._updateIconDebugCollisionBoxes(i2, t2, e2, a2.verticalIconBoxStartIndex, a2.verticalIconBoxEndIndex, a2, n2);
              }
              this.hasTextCollisionBoxData() && this.textCollisionBox.collisionVertexBufferExt && this.textCollisionBox.collisionVertexBufferExt.updateData(this.textCollisionBox.collisionVertexArrayExt), this.hasIconCollisionBoxData() && this.iconCollisionBox.collisionVertexBufferExt && this.iconCollisionBox.collisionVertexBufferExt.updateData(this.iconCollisionBox.collisionVertexArrayExt);
            }
            _deserializeCollisionBoxesForSymbol(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
              const u5 = {};
              if (e2 < r2) {
                const { x1: r3, y1: n3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(e2);
                u5.textBox = { x1: r3, y1: n3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u5.textFeatureIndex = f2;
              }
              if (n2 < i2) {
                const { x1: e3, y1: r3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(n2);
                u5.verticalTextBox = { x1: e3, y1: r3, x2: i3, y2: s3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u5.verticalTextFeatureIndex = f2;
              }
              if (s2 < o2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(s2);
                u5.iconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: o3, projectedAnchorX: a3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u5.iconFeatureIndex = f2;
              }
              if (a2 < l2) {
                const { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2, featureIndex: f2 } = t2.get(a2);
                u5.verticalIconBox = { x1: e3, y1: r3, x2: n3, y2: i3, padding: s3, projectedAnchorX: o3, projectedAnchorY: l3, projectedAnchorZ: c2, tileAnchorX: h2, tileAnchorY: p2 }, u5.verticalIconFeatureIndex = f2;
              }
              return u5;
            }
            deserializeCollisionBoxes(t2) {
              this.collisionArrays = [];
              for (let e2 = 0; e2 < this.symbolInstances.length; e2++) {
                const r2 = this.symbolInstances.get(e2);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            hasIconTextFit() {
              return this.hasAnyIconTextFit;
            }
            addIndicesForPlacedSymbol(t2, e2) {
              const r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs;
              for (let e3 = r2.vertexStartIndex; e3 < n2; e3 += 4) t2.indexArray.emplaceBack(e3, e3 + 1, e3 + 2), t2.indexArray.emplaceBack(e3 + 1, e3 + 2, e3 + 3);
            }
            getSortedSymbolIndexes(t2) {
              if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes) return this.symbolInstanceIndexes;
              const e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], s2 = [];
              for (let t3 = 0; t3 < this.symbolInstances.length; ++t3) {
                s2.push(t3);
                const o2 = this.symbolInstances.get(t3);
                n2.push(0 | Math.round(e2 * o2.tileAnchorX + r2 * o2.tileAnchorY)), i2.push(o2.featureIndex);
              }
              return s2.sort((t3, e3) => n2[t3] - n2[e3] || i2[e3] - i2[t3]), s2;
            }
            getSortedIndexesByZOffset() {
              if (!this.zOffsetSortDirty) return this.symbolInstanceIndexesSortedZOffset;
              if (!this.symbolInstanceIndexesSortedZOffset) {
                this.symbolInstanceIndexesSortedZOffset = [];
                for (let t2 = 0; t2 < this.symbolInstances.length; ++t2) this.symbolInstanceIndexesSortedZOffset.push(t2);
              }
              return this.zOffsetSortDirty = false, this.symbolInstanceIndexesSortedZOffset.sort((t2, e2) => this.symbolInstances.get(e2).zOffset - this.symbolInstances.get(t2).zOffset);
            }
            addToSortKeyRanges(t2, e2) {
              const r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
            }
            sortFeatures(t2) {
              if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t3 of this.symbolInstanceIndexes) {
                  const e2 = this.symbolInstances.get(t3);
                  this.featureSortOrder.push(e2.featureIndex);
                  const { rightJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, leftJustifiedTextSymbolIndex: i2, verticalPlacedTextSymbolIndex: s2, placedIconSymbolIndex: o2, verticalPlacedIconSymbolIndex: a2 } = e2;
                  r2 >= 0 && this.addIndicesForPlacedSymbol(this.text, r2), n2 >= 0 && n2 !== r2 && this.addIndicesForPlacedSymbol(this.text, n2), i2 >= 0 && i2 !== n2 && i2 !== r2 && this.addIndicesForPlacedSymbol(this.text, i2), s2 >= 0 && this.addIndicesForPlacedSymbol(this.text, s2), o2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, o2), a2 >= 0 && this.addIndicesForPlacedSymbol(this.icon, a2);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Sy, zy, ky;
          js(Iy, "SymbolBucket", { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Iy.addDynamicAttributes = _y;
          class Ey {
            constructor(t2) {
              this.type = t2.property.overrides ? t2.property.overrides.runtimeType : fr, this.defaultValue = t2;
            }
            evaluate(t2) {
              if (t2.formattedSection) {
                const e2 = this.defaultValue.property.overrides;
                if (e2 && e2.hasOverride(t2.formattedSection)) return e2.getOverride(t2.formattedSection);
              }
              return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t2) {
              this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          js(Ey, "FormatSectionOverride", { omit: ["defaultValue"] });
          const Py = () => ky || (ky = { layout: Sy || (Sy = new ko({ "symbol-placement": new Io(Eo.layout_symbol["symbol-placement"]), "symbol-spacing": new Io(Eo.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new Io(Eo.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new So(Eo.layout_symbol["symbol-sort-key"]), "symbol-z-order": new Io(Eo.layout_symbol["symbol-z-order"]), "symbol-z-elevate": new Io(Eo.layout_symbol["symbol-z-elevate"]), "symbol-elevation-reference": new Io(Eo.layout_symbol["symbol-elevation-reference"]), "icon-allow-overlap": new Io(Eo.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new Io(Eo.layout_symbol["icon-ignore-placement"]), "icon-optional": new Io(Eo.layout_symbol["icon-optional"]), "icon-rotation-alignment": new Io(Eo.layout_symbol["icon-rotation-alignment"]), "icon-size": new So(Eo.layout_symbol["icon-size"]), "icon-size-scale-range": new Io(Eo.layout_symbol["icon-size-scale-range"]), "icon-text-fit": new So(Eo.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new So(Eo.layout_symbol["icon-text-fit-padding"]), "icon-image": new So(Eo.layout_symbol["icon-image"]), "icon-rotate": new So(Eo.layout_symbol["icon-rotate"]), "icon-padding": new Io(Eo.layout_symbol["icon-padding"]), "icon-keep-upright": new Io(Eo.layout_symbol["icon-keep-upright"]), "icon-offset": new So(Eo.layout_symbol["icon-offset"]), "icon-anchor": new So(Eo.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new Io(Eo.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new Io(Eo.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new Io(Eo.layout_symbol["text-rotation-alignment"]), "text-field": new So(Eo.layout_symbol["text-field"]), "text-font": new So(Eo.layout_symbol["text-font"]), "text-size": new So(Eo.layout_symbol["text-size"]), "text-size-scale-range": new Io(Eo.layout_symbol["text-size-scale-range"]), "text-max-width": new So(Eo.layout_symbol["text-max-width"]), "text-line-height": new So(Eo.layout_symbol["text-line-height"]), "text-letter-spacing": new So(Eo.layout_symbol["text-letter-spacing"]), "text-justify": new So(Eo.layout_symbol["text-justify"]), "text-radial-offset": new So(Eo.layout_symbol["text-radial-offset"]), "text-variable-anchor": new Io(Eo.layout_symbol["text-variable-anchor"]), "text-anchor": new So(Eo.layout_symbol["text-anchor"]), "text-max-angle": new Io(Eo.layout_symbol["text-max-angle"]), "text-writing-mode": new Io(Eo.layout_symbol["text-writing-mode"]), "text-rotate": new So(Eo.layout_symbol["text-rotate"]), "text-padding": new Io(Eo.layout_symbol["text-padding"]), "text-keep-upright": new Io(Eo.layout_symbol["text-keep-upright"]), "text-transform": new So(Eo.layout_symbol["text-transform"]), "text-offset": new So(Eo.layout_symbol["text-offset"]), "text-allow-overlap": new Io(Eo.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new Io(Eo.layout_symbol["text-ignore-placement"]), "text-optional": new Io(Eo.layout_symbol["text-optional"]), visibility: new Io(Eo.layout_symbol.visibility) })), paint: zy || (zy = new ko({ "icon-opacity": new So(Eo.paint_symbol["icon-opacity"]), "icon-occlusion-opacity": new So(Eo.paint_symbol["icon-occlusion-opacity"]), "icon-emissive-strength": new So(Eo.paint_symbol["icon-emissive-strength"]), "text-emissive-strength": new So(Eo.paint_symbol["text-emissive-strength"]), "icon-color": new So(Eo.paint_symbol["icon-color"]), "icon-halo-color": new So(Eo.paint_symbol["icon-halo-color"]), "icon-halo-width": new So(Eo.paint_symbol["icon-halo-width"]), "icon-halo-blur": new So(Eo.paint_symbol["icon-halo-blur"]), "icon-translate": new Io(Eo.paint_symbol["icon-translate"]), "icon-translate-anchor": new Io(Eo.paint_symbol["icon-translate-anchor"]), "icon-image-cross-fade": new Io(Eo.paint_symbol["icon-image-cross-fade"]), "text-opacity": new So(Eo.paint_symbol["text-opacity"]), "text-occlusion-opacity": new So(Eo.paint_symbol["text-occlusion-opacity"]), "text-color": new So(Eo.paint_symbol["text-color"], { runtimeType: gr, getOverride: (t2) => t2.textColor, hasOverride: (t2) => !!t2.textColor }), "text-halo-color": new So(Eo.paint_symbol["text-halo-color"]), "text-halo-width": new So(Eo.paint_symbol["text-halo-width"]), "text-halo-blur": new So(Eo.paint_symbol["text-halo-blur"]), "text-translate": new Io(Eo.paint_symbol["text-translate"]), "text-translate-anchor": new Io(Eo.paint_symbol["text-translate-anchor"]), "icon-color-saturation": new Io(Eo.paint_symbol["icon-color-saturation"]), "icon-color-contrast": new Io(Eo.paint_symbol["icon-color-contrast"]), "icon-color-brightness-min": new Io(Eo.paint_symbol["icon-color-brightness-min"]), "icon-color-brightness-max": new Io(Eo.paint_symbol["icon-color-brightness-max"]), "symbol-z-offset": new So(Eo.paint_symbol["symbol-z-offset"]), "icon-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "icon-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "text-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "text-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, ky);
          class Ty extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, Py(), e2, r2, n2), this._colorAdjustmentMatrix = l([]), this.hasInitialOcclusionOpacityProperties = void 0 !== t2.paint && ("icon-occlusion-opacity" in t2.paint || "text-occlusion-opacity" in t2.paint);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment"));
              const r2 = this.layout.get("text-writing-mode");
              if (r2) {
                const t3 = [];
                for (const e3 of r2) t3.indexOf(e3) < 0 && t3.push(e3);
                this.layout._values["text-writing-mode"] = t3;
              } else this.layout._values["text-writing-mode"] = "point" === this.layout.get("symbol-placement") ? ["horizontal"] : ["horizontal", "vertical"];
              this._setPaintOverrides();
            }
            getColorAdjustmentMatrix(t2, e2, r2, n2) {
              return this._saturation === t2 && this._contrast === e2 && this._brightnessMin === r2 && this._brightnessMax === n2 || (this._colorAdjustmentMatrix = function(t3, e3, r3, n3) {
                t3 = te(t3), e3 = Qt(e3);
                const i2 = a(), s2 = t3 / 3, o2 = 1 - 2 * s2, l2 = [o2, s2, s2, 0, s2, o2, s2, 0, s2, s2, o2, 0, 0, 0, 0, 1], u5 = 0.5 - 0.5 * e3, h2 = n3 - r3;
                return c(i2, [h2, 0, 0, 0, 0, h2, 0, 0, 0, 0, h2, 0, r3, r3, r3, 1], [e3, 0, 0, 0, 0, e3, 0, 0, 0, 0, e3, 0, u5, u5, u5, 1]), c(i2, i2, l2), i2;
              }(t2, e2, r2, n2), this._saturation = t2, this._contrast = e2, this._brightnessMin = r2, this._brightnessMax = n2), this._colorAdjustmentMatrix;
            }
            getValueAndResolveTokens(t2, e2, r2, n2) {
              const i2 = this.layout.get(t2).evaluate(e2, {}, r2, n2), s2 = this._unevaluatedLayout._values[t2];
              return s2.isDataDriven() || Ps(s2.value) || !i2 ? i2 : function(t3, e3) {
                return e3.replace(/{([^{}]+)}/g, (e4, r3) => r3 in t3 ? String(t3[r3]) : "");
              }(e2.properties, i2);
            }
            createBucket(t2) {
              return new Iy(t2);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            _setPaintOverrides() {
              for (const t2 of Py().paint.overridableProperties) {
                if (!Ty.hasPaintOverride(this.layout, t2)) continue;
                const e2 = this.paint.get(t2), r2 = new Ey(e2), n2 = new Es(r2, e2.property.specification, this.scope, this.options);
                let i2 = null;
                i2 = "constant" === e2.value.kind || "source" === e2.value.kind ? new Bs("source", n2) : new Vs("composite", n2, e2.value.zoomStops, e2.value.interpolationType), this.paint._values[t2] = new Ao(e2.property, i2, e2.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven()) && Ty.hasPaintOverride(this.layout, t2);
            }
            static hasPaintOverride(t2, e2) {
              const r2 = t2.get("text-field"), n2 = Py().paint.properties[e2];
              let i2 = false;
              const s2 = (t3) => {
                for (const e3 of t3) if (n2.overrides && n2.overrides.hasOverride(e3)) return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof Tr) s2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                const t3 = (e4) => {
                  i2 || (e4 instanceof Rr && Fr(e4.value) === _r ? s2(e4.value.sections) : e4 instanceof jr ? s2(e4.sections) : e4.eachChild(t3));
                }, e3 = r2.value;
                e3._styleExpression && t3(e3._styleExpression.expression);
              }
              return i2;
            }
            getProgramIds() {
              return ["symbol"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { config: new Ml(this, { zoom: e2, lut: r2 }), overrideFog: false };
            }
            hasElevation() {
              return this.layout && "hd-road-markup" === this.layout.get("symbol-elevation-reference");
            }
          }
          let By, Vy, Cy, Dy;
          var Fy = Qo([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          function Ly(t2) {
            switch (t2) {
              case WebGL2RenderingContext.RGBA8:
                return WebGL2RenderingContext.RGBA;
              case WebGL2RenderingContext.DEPTH_COMPONENT16:
                return WebGL2RenderingContext.DEPTH_COMPONENT;
              case WebGL2RenderingContext.DEPTH24_STENCIL8:
                return WebGL2RenderingContext.DEPTH_STENCIL;
              case WebGL2RenderingContext.R8:
              case WebGL2RenderingContext.R32F:
                return WebGL2RenderingContext.RED;
            }
          }
          function Ry(t2) {
            switch (t2) {
              case WebGL2RenderingContext.RGBA8:
                return WebGL2RenderingContext.UNSIGNED_BYTE;
              case WebGL2RenderingContext.DEPTH_COMPONENT16:
                return WebGL2RenderingContext.UNSIGNED_SHORT;
              case WebGL2RenderingContext.DEPTH24_STENCIL8:
                return WebGL2RenderingContext.UNSIGNED_INT_24_8;
              case WebGL2RenderingContext.R8:
                return WebGL2RenderingContext.UNSIGNED_BYTE;
              case WebGL2RenderingContext.R32F:
                return WebGL2RenderingContext.FLOAT;
            }
          }
          class Oy {
            constructor(t2, e2, r2, n2) {
              this.context = t2, this.format = r2, this.useMipmap = n2 && n2.useMipmap, this.texture = t2.gl.createTexture(), this.update(e2, { premultiply: n2 && n2.premultiply });
            }
            update(t2, e2) {
              const r2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.width ? t2.videoWidth : t2.width, n2 = t2 && t2 instanceof HTMLVideoElement && 0 === t2.height ? t2.videoHeight : t2.height, { context: i2 } = this, { gl: s2 } = i2, { x: o2, y: a2 } = e2 && e2.position ? e2.position : { x: 0, y: 0 }, l2 = o2 + r2, u5 = a2 + n2;
              !this.size || this.size[0] === l2 && this.size[1] === u5 || (s2.bindTexture(s2.TEXTURE_2D, null), s2.deleteTexture(this.texture), this.texture = s2.createTexture(), this.size = null), s2.bindTexture(s2.TEXTURE_2D, this.texture), i2.pixelStoreUnpackFlipY.set(false), i2.pixelStoreUnpack.set(1), i2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA8 && (!e2 || false !== e2.premultiply));
              const c2 = t2 instanceof HTMLImageElement || t2 instanceof HTMLCanvasElement || t2 instanceof HTMLVideoElement || t2 instanceof ImageData || ImageBitmap && t2 instanceof ImageBitmap;
              if (!this.size && l2 > 0 && u5 > 0) {
                const t3 = this.useMipmap ? Math.floor(Math.log2(Math.max(l2, u5))) + 1 : 1;
                s2.texStorage2D(s2.TEXTURE_2D, t3, this.format, l2, u5), this.size = [l2, u5];
              }
              if (this.size) if (c2) s2.texSubImage2D(s2.TEXTURE_2D, 0, o2, a2, Ly(this.format), Ry(this.format), t2);
              else {
                const e3 = t2.data;
                e3 && s2.texSubImage2D(s2.TEXTURE_2D, 0, o2, a2, r2, n2, Ly(this.format), Ry(this.format), e3);
              }
              this.useMipmap && s2.generateMipmap(s2.TEXTURE_2D);
            }
            bind(t2, e2, r2 = false) {
              const { context: n2 } = this, { gl: i2 } = n2;
              i2.bindTexture(i2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, t2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, this.useMipmap && !r2 ? t2 === i2.NEAREST ? i2.NEAREST_MIPMAP_NEAREST : i2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), e2 !== this.wrapS && (i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, e2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
            bindExtraParam(t2, e2, r2, n2) {
              const { context: i2 } = this, { gl: s2 } = i2;
              s2.bindTexture(s2.TEXTURE_2D, this.texture), e2 !== this.magFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MAG_FILTER, e2), this.magFilter = e2), t2 !== this.minFilter && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_MIN_FILTER, this.useMipmap ? t2 === s2.NEAREST ? s2.NEAREST_MIPMAP_NEAREST : s2.LINEAR_MIPMAP_LINEAR : t2), this.minFilter = t2), r2 !== this.wrapS && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_S, r2), this.wrapS = r2), n2 !== this.wrapT && (s2.texParameteri(s2.TEXTURE_2D, s2.TEXTURE_WRAP_T, n2), this.wrapT = n2);
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }
          class Uy {
            constructor(t2, e2) {
              this.context = t2, this.texture = e2;
            }
            bind(t2, e2) {
              const { context: r2 } = this, { gl: n2 } = r2;
              n2.bindTexture(n2.TEXTURE_2D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
          }
          function Ny(t2, e2, r2, n2, i2, a2, l2, u5) {
            const c2 = [t2, e2, 1, r2, n2, 1, i2, a2, 1], h2 = [l2, u5, 1], p2 = s([], c2), [f2, d2, m2] = O(h2, h2, p2);
            return o(c2, c2, [f2, 0, 0, 0, d2, 0, 0, 0, m2]);
          }
          function jy(t2, e2, r2, n2, i2, a2, l2, u5) {
            const c2 = function(t3, e3, r3, n3, i3, a3, l3, u6) {
              const c3 = Ny(0, 0, 1, 0, 1, 1, 0, 1), h2 = Ny(t3, e3, r3, n3, i3, a3, l3, u6);
              return o(h2, h2, s([], c3));
            }(t2, e2, r2, n2, i2, a2, l2, u5);
            return [c2[2] / c2[8] / Tn, c2[5] / c2[8] / Tn];
          }
          function $y(t2) {
            return [t2[0], Math.min(Math.max(t2[1], -tu), tu)];
          }
          class Gy extends Qe {
            constructor(t2, e2, r2, n2) {
              super(), this.id = t2, this.dispatcher = r2, this.coordinates = e2.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.onNorthPole = false, this.onSouthPole = false, this.setEventedParent(n2), this.options = e2, this._dirty = false;
            }
            load(t2, e2) {
              if (this._loaded = e2 || false, this.fire(new We("dataloading", { dataType: "source" })), this.url = this.options.url, !this.url) return t2 && (this.coordinates = t2), this._loaded = true, void this._finishLoading();
              this._imageRequest = Ue(this.map._requestManager.transformRequest(this.url, Te.Image), (e3, r2) => {
                this._imageRequest = null, this._loaded = true, e3 ? this.fire(new Ye(e3)) : r2 && (this.image = r2 instanceof HTMLImageElement ? pe.getImageData(r2) : r2, this._dirty = true, this.width = this.image.width, this.height = this.image.height, t2 && (this.coordinates = t2), this._finishLoading());
              });
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t2) {
              return t2.url ? (this._imageRequest && t2.url !== this.options.url && (this._imageRequest.cancel(), this._imageRequest = null), this.options.url = t2.url, this.load(t2.coordinates, this._loaded), this) : this;
            }
            setTexture(t2) {
              if (!(t2.handle instanceof WebGLTexture)) throw new Error("The provided handle is not a WebGLTexture instance");
              return this.texture = new Uy(this.map.painter.context, t2.handle), this.width = t2.dimensions[0], this.height = t2.dimensions[1], this._dirty = false, this._loaded = true, this._finishLoading(), this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new We("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t2) {
              this.map = t2, this.load();
            }
            onRemove(t2) {
              this._imageRequest && (this._imageRequest.cancel(), this._imageRequest = null), !this.texture || this.texture instanceof Uy || this.texture.destroy(), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy());
            }
            setCoordinates(t2) {
              if (this.coordinates = t2, this._boundsArray = void 0, this._unsupportedCoords = false, !t2.length) return this;
              this.onNorthPole = false, this.onSouthPole = false;
              let e2 = t2[0][1], r2 = t2[0][1];
              for (const n3 of t2) n3[1] > r2 && (r2 = n3[1]), n3[1] < e2 && (e2 = n3[1]);
              const n2 = (r2 + e2) / 2;
              if (n2 > tu ? this.onNorthPole = true : n2 < -tu && (this.onSouthPole = true), !this.onNorthPole && !this.onSouthPole) {
                const e3 = t2.map(su.fromLngLat);
                this.tileID = function(t3) {
                  let e4 = 1 / 0, r3 = 1 / 0, n3 = -1 / 0, i2 = -1 / 0;
                  for (const s3 of t3) e4 = Math.min(e4, s3.x), r3 = Math.min(r3, s3.y), n3 = Math.max(n3, s3.x), i2 = Math.max(i2, s3.y);
                  const s2 = Math.max(n3 - e4, i2 - r3), o2 = Math.max(0, Math.floor(-Math.log(s2) / Math.LN2)), a2 = Math.pow(2, o2);
                  let l2 = Math.floor((e4 + n3) / 2 * a2);
                  return l2 > 1 && (l2 -= 1), new Nu(o2, l2, Math.floor((r3 + i2) / 2 * a2));
                }(e3), this.minzoom = this.maxzoom = this.tileID.z;
              }
              return this.fire(new We("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            _clear() {
              this._boundsArray = void 0, this._unsupportedCoords = false;
            }
            _prepareData(t2) {
              for (const t3 in this.tiles) {
                const e3 = this.tiles[t3];
                "loaded" !== e3.state && (e3.state = "loaded", e3.texture = this.texture);
              }
              if (this._boundsArray || this.onNorthPole || this.onSouthPole || this._unsupportedCoords) return;
              const e2 = Xm(new Nu(0, 0, 0), this.map.transform.projection), r2 = [e2.projection.project(this.coordinates[0][0], this.coordinates[0][1]), e2.projection.project(this.coordinates[1][0], this.coordinates[1][1]), e2.projection.project(this.coordinates[2][0], this.coordinates[2][1]), e2.projection.project(this.coordinates[3][0], this.coordinates[3][1])];
              if (!function(t3) {
                const e3 = t3[1].x - t3[0].x, r3 = t3[1].y - t3[0].y, n3 = t3[2].x - t3[1].x, i3 = t3[2].y - t3[1].y, s2 = t3[3].x - t3[2].x, o2 = t3[3].y - t3[2].y, a3 = t3[0].x - t3[3].x, l3 = t3[0].y - t3[3].y, u6 = e3 * i3 - n3 * r3, c3 = n3 * o2 - s2 * i3, h3 = s2 * l3 - a3 * o2, p3 = a3 * r3 - e3 * l3;
                return u6 > 0 && c3 > 0 && h3 > 0 && p3 > 0 || u6 < 0 && c3 < 0 && h3 < 0 && p3 < 0;
              }(r2)) return console.warn("Image source coordinates are defining non-convex area in the Mercator projection"), void (this._unsupportedCoords = true);
              const n2 = Xm(this.tileID, this.map.transform.projection), [i2, a2, l2, u5] = this.coordinates.map((t3) => {
                const e3 = n2.projection.project(t3[0], t3[1]);
                return Zm(n2, e3)._round();
              });
              this.perspectiveTransform = jy(i2.x, i2.y, a2.x, a2.y, l2.x, l2.y, u5.x, u5.y);
              const c2 = this._boundsArray = new na();
              c2.emplaceBack(i2.x, i2.y, 0, 0), c2.emplaceBack(a2.x, a2.y, Tn, 0), c2.emplaceBack(u5.x, u5.y, 0, Tn), c2.emplaceBack(l2.x, l2.y, Tn, Tn), this.boundsBuffer && (this.boundsBuffer.destroy(), this.elevatedGlobeVertexBuffer && this.elevatedGlobeVertexBuffer.destroy(), this.elevatedGlobeIndexBuffer && this.elevatedGlobeIndexBuffer.destroy()), this.boundsBuffer = t2.createVertexBuffer(c2, Fy.members), this.boundsSegments = Ka.simpleSegment(0, 0, 4, 2);
              const h2 = [], p2 = [$y((f2 = this.coordinates)[0]), $y(f2[1]), $y(f2[2]), $y(f2[3])];
              var f2;
              const [d2, m2, y2, g2] = function(t3) {
                let e3 = t3[0][0], r3 = e3, n3 = t3[0][1], i3 = n3;
                for (let s2 = 1; s2 < t3.length; s2++) t3[s2][0] < e3 ? e3 = t3[s2][0] : t3[s2][0] > r3 && (r3 = t3[s2][0]), t3[s2][1] < n3 ? n3 = t3[s2][1] : t3[s2][1] > i3 && (i3 = t3[s2][1]);
                return [e3, n3, r3 - e3, i3 - n3];
              }(p2);
              {
                const n3 = new na(), [i3, a3, l3, u6] = function(t3) {
                  let e3 = t3[0].x, r3 = e3, n4 = t3[0].y, i4 = n4;
                  for (let s2 = 1; s2 < t3.length; s2++) t3[s2].x < e3 ? e3 = t3[s2].x : t3[s2].x > r3 && (r3 = t3[s2].x), t3[s2].y < n4 ? n4 = t3[s2].y : t3[s2].y > i4 && (i4 = t3[s2].y);
                  return [e3, n4, r3 - e3, i4 - n4];
                }(r2), c3 = (t3) => [(t3.x - i3) / l3, (t3.y - a3) / u6], [p3, f3, x2, v3] = r2.map(c3), b2 = function(t3, e3, r3, n4, i4, a4, l4, u7) {
                  const c4 = Ny(0, 0, 1, 0, 1, 1, 0, 1);
                  return o(c4, c4, s([], Ny(t3, e3, r3, n4, i4, a4, l4, u7)));
                }(p3[0], p3[1], f3[0], f3[1], x2[0], x2[1], v3[0], v3[1]);
                this.elevatedGlobePerspectiveTransform = jy(p3[0], p3[1], f3[0], f3[1], x2[0], x2[1], v3[0], v3[1]);
                const _2 = (t3, e3) => {
                  h2.push(t3.lng);
                  const r3 = Math.round((t3.lng - d2) / y2 * Tn), i4 = Math.round((t3.lat - m2) / g2 * Tn), s2 = c3(e3), o2 = O([], [s2[0], s2[1], 1], b2), a4 = Math.round(o2[0] / o2[2] * Tn), l4 = Math.round(o2[1] / o2[2] * Tn);
                  n3.emplaceBack(r3, i4, a4, l4);
                }, w2 = r2[3].x - r2[0].x, A2 = r2[3].y - r2[0].y, M2 = r2[2].x - r2[1].x, I2 = r2[2].y - r2[1].y;
                for (let t3 = 0; t3 < 65; t3++) {
                  const n4 = t3 / 64, i4 = [r2[0].x + n4 * w2, r2[0].y + n4 * A2], s2 = [r2[1].x + n4 * M2, r2[1].y + n4 * I2], o2 = s2[0] - i4[0], a4 = s2[1] - i4[1];
                  for (let t4 = 0; t4 < 65; t4++) {
                    const r3 = t4 / 64, n5 = { x: i4[0] + o2 * r3, y: i4[1] + a4 * r3, z: 0 };
                    _2(e2.projection.unproject(n5.x, n5.y), n5);
                  }
                }
                this.elevatedGlobeVertexBuffer = t2.createVertexBuffer(n3, Fy.members);
              }
              {
                this.maxLongitudeTriangleSize = 0;
                let e3 = [], r3 = new wa();
                const n3 = (t3, n4, i3) => {
                  r3.emplaceBack(t3, n4, i3);
                  const s2 = h2[t3], o2 = h2[n4], a3 = h2[i3], l3 = Math.min(Math.min(s2, o2), a3), u6 = Math.max(Math.max(s2, o2), a3) - l3;
                  u6 > this.maxLongitudeTriangleSize && (this.maxLongitudeTriangleSize = u6), e3.push(l3 + u6 / 2);
                };
                for (let t3 = 0; t3 < 64; t3++) for (let e4 = 0; e4 < 64; e4++) {
                  const r4 = 65 * t3 + e4, i3 = r4 + 1, s2 = r4 + 65, o2 = s2 + 1;
                  n3(r4, s2, i3), n3(i3, s2, o2);
                }
                [e3, r3] = function(t3, e4) {
                  const r4 = Array.from({ length: t3.length }, (t4, e5) => e5);
                  r4.sort((e5, r5) => t3[e5] - t3[r5]);
                  const n4 = [], i3 = new wa();
                  for (let s2 = 0; s2 < r4.length; s2++) {
                    const o2 = r4[s2];
                    n4.push(t3[o2]);
                    const a3 = 3 * o2, l3 = a3 + 1;
                    i3.emplaceBack(e4.uint16[a3], e4.uint16[l3], e4.uint16[l3 + 1]);
                  }
                  return [n4, i3];
                }(e3, r3), this.elevatedGlobeTrianglesCenterLongitudes = e3, this.elevatedGlobeIndexBuffer = t2.createIndexBuffer(r3);
              }
              this.elevatedGlobeSegments = Ka.simpleSegment(0, 0, 4225, 8192), this.elevatedGlobeGridMatrix = new Float32Array([0, y2 / Tn, 0, g2 / Tn, 0, 0, m2, d2, 0]);
            }
            prepare() {
              const t2 = 0 !== Object.keys(this.tiles).length;
              if (this.tileID && !t2) return;
              const e2 = this.map.painter.context, r2 = e2.gl;
              !this._dirty || this.texture instanceof Uy || (this.texture ? this.texture.update(this.image) : (this.texture = new Oy(e2, this.image, r2.RGBA8), this.texture.bind(r2.LINEAR, r2.CLAMP_TO_EDGE)), this._dirty = false), t2 && this._prepareData(e2);
            }
            loadTile(t2, e2) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e2(null)) : (t2.state = "errored", e2(null));
            }
            serialize() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }
            hasTransition() {
              return false;
            }
            getSegmentsForLongitude(t2) {
              const e2 = this.elevatedGlobeSegments;
              if (!this.elevatedGlobeTrianglesCenterLongitudes || !e2) return null;
              const r2 = this.elevatedGlobeTrianglesCenterLongitudes;
              let n2 = (i2 = t2 + 180) + 360 * Math.round((r2[0] - i2) / 360);
              var i2;
              const s2 = new Ka(), o2 = (t3, r3) => {
                s2.segments.push({ vertexOffset: 0, primitiveOffset: t3, vertexLength: e2.segments[0].vertexLength, primitiveLength: r3, sortKey: void 0, vaos: {} });
              }, a2 = 0.51 * this.maxLongitudeTriangleSize;
              if (Math.abs(r2[0] - n2) <= a2) {
                const t3 = Jt(r2, 0, r2.length, n2 + a2);
                return t3 === r2.length || o2(t3, Kt(r2, t3 + 1, r2.length, n2 + 360 - a2) - t3), s2;
              }
              n2 < r2[0] && (n2 += 360);
              const l2 = Kt(r2, 0, r2.length, n2 - a2);
              if (l2 === r2.length) return o2(0, r2.length), s2;
              o2(0, l2 - 0);
              const u5 = Jt(r2, l2 + 1, r2.length, n2 + a2);
              return u5 !== r2.length && o2(u5, r2.length - u5), s2;
            }
          }
          const qy = (Math.pow(256, 2) - 1) / 16907520;
          class Hy extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Cy || (Cy = new ko({ visibility: new Io(Eo.layout_raster.visibility) })), paint: Dy || (Dy = new ko({ "raster-opacity": new Io(Eo.paint_raster["raster-opacity"]), "raster-color": new zo(Eo.paint_raster["raster-color"]), "raster-color-mix": new Io(Eo.paint_raster["raster-color-mix"]), "raster-color-range": new Io(Eo.paint_raster["raster-color-range"]), "raster-hue-rotate": new Io(Eo.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new Io(Eo.paint_raster["raster-brightness-min"]), "raster-brightness-max": new Io(Eo.paint_raster["raster-brightness-max"]), "raster-saturation": new Io(Eo.paint_raster["raster-saturation"]), "raster-contrast": new Io(Eo.paint_raster["raster-contrast"]), "raster-resampling": new Io(Eo.paint_raster["raster-resampling"]), "raster-fade-duration": new Io(Eo.paint_raster["raster-fade-duration"]), "raster-emissive-strength": new Io(Eo.paint_raster["raster-emissive-strength"]), "raster-array-band": new Io(Eo.paint_raster["raster-array-band"]), "raster-elevation": new Io(Eo.paint_raster["raster-elevation"]), "raster-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this.updateColorRamp(), this._curRampRange = [NaN, NaN];
            }
            getProgramIds() {
              return ["raster"];
            }
            hasColorMap() {
              return !!this._transitionablePaint._values["raster-color"].value.value;
            }
            tileCoverLift() {
              return this.paint.get("raster-elevation");
            }
            isDraped(t2) {
              return !(t2 && t2._source instanceof Gy && (t2._source.onNorthPole || t2._source.onSouthPole)) && 0 === this.paint.get("raster-elevation");
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "raster-color" !== t2 && "raster-color-range" !== t2 || (this._curRampRange = [NaN, NaN], this.updateColorRamp());
            }
            updateColorRamp(t2) {
              if (!this.hasColorMap()) return;
              if (!this._curRampRange) return;
              const e2 = this._transitionablePaint._values["raster-color"].value.expression, [r2, n2] = t2 || this._transitionablePaint._values["raster-color-range"].value.expression.evaluate({ zoom: 0 }) || [NaN, NaN];
              isNaN(r2) && isNaN(n2) || r2 === this._curRampRange[0] && n2 === this._curRampRange[1] || (this.colorRamp = Zc({ expression: e2, evaluationKey: "rasterValue", image: this.colorRamp, clips: [{ start: r2, end: n2 }], resolution: 256 }), this.colorRampTexture = null, this._curRampRange = [r2, n2]);
            }
          }
          let Xy, Zy, Wy, Yy, Ky;
          class Jy extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Xy || (Xy = new ko({ visibility: new Io(Eo["layout_raster-particle"].visibility) })), paint: Zy || (Zy = new ko({ "raster-particle-array-band": new Io(Eo["paint_raster-particle"]["raster-particle-array-band"]), "raster-particle-count": new Io(Eo["paint_raster-particle"]["raster-particle-count"]), "raster-particle-color": new zo(Eo["paint_raster-particle"]["raster-particle-color"]), "raster-particle-max-speed": new Io(Eo["paint_raster-particle"]["raster-particle-max-speed"]), "raster-particle-speed-factor": new Io(Eo["paint_raster-particle"]["raster-particle-speed-factor"]), "raster-particle-fade-opacity-factor": new Io(Eo["paint_raster-particle"]["raster-particle-fade-opacity-factor"]), "raster-particle-reset-rate-factor": new Io(Eo["paint_raster-particle"]["raster-particle-reset-rate-factor"]), "raster-particle-elevation": new Io(Eo["paint_raster-particle"]["raster-particle-elevation"]), "raster-particle-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp(), this.lastInvalidatedAt = pe.now();
            }
            onRemove(t2) {
              this.colorRampTexture && this.colorRampTexture.destroy(), this.tileFramebuffer && this.tileFramebuffer.destroy(), this.particleFramebuffer && this.particleFramebuffer.destroy();
            }
            hasColorMap() {
              return !!this._transitionablePaint._values["raster-particle-color"].value.value;
            }
            getProgramIds() {
              return ["rasterParticle"];
            }
            hasOffscreenPass() {
              return "none" !== this.visibility;
            }
            isDraped(t2) {
              return false;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "raster-particle-color" !== t2 && "raster-particle-max-speed" !== t2 || (this._updateColorRamp(), this._invalidateAnimationState()), "raster-particle-count" === t2 && this._invalidateAnimationState();
            }
            _updateColorRamp() {
              if (!this.hasColorMap()) return;
              const t2 = this._transitionablePaint._values["raster-particle-color"].value.expression, e2 = this._transitionablePaint._values["raster-particle-max-speed"].value.expression.evaluate({ zoom: 0 });
              this.colorRamp = Zc({ expression: t2, evaluationKey: "rasterParticleSpeed", image: this.colorRamp, clips: [{ start: 0, end: e2 }], resolution: 256 }), this.colorRampTexture = null;
            }
            _invalidateAnimationState() {
              this.lastInvalidatedAt = pe.now();
            }
            tileCoverLift() {
              return this.paint.get("raster-particle-elevation");
            }
          }
          class Qy extends Wo {
            constructor(t2, e2) {
              super(t2, {}, e2, null), this.implementation = t2, t2.slot && (this.slot = t2.slot);
            }
            is3D(t2) {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            isDraped(t2) {
              return void 0 !== this.implementation.renderToTile;
            }
            shouldRedrape() {
              return !!this.implementation.shouldRerenderTiles && this.implementation.shouldRerenderTiles();
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
            }
            onAdd(t2) {
              this.implementation.onAdd && this.implementation.onAdd(t2, t2.painter.context.gl);
            }
            onRemove(t2) {
              this.implementation.onRemove && this.implementation.onRemove(t2, t2.painter.context.gl);
            }
          }
          function tg(t2, e2, r2) {
            const n2 = [0, 0, 1], i2 = Y([]);
            return J(i2, i2, r2 ? -Mt(t2) + Math.PI : Mt(t2)), K(i2, i2, -Mt(e2)), U(n2, n2, i2), C(n2, n2);
          }
          function eg(t2, e2) {
            const r2 = ng(t2.projection, t2.zoom, t2.width, t2.height), n2 = function(t3, e3, r3, n3, i3) {
              const s2 = new $l(r3.lng - 180 * ig, r3.lat), o2 = new $l(r3.lng + 180 * ig, r3.lat), a2 = t3.project(s2.lng, s2.lat), u5 = t3.project(o2.lng, o2.lat), h2 = -Math.atan2(u5.y - a2.y, u5.x - a2.x), f2 = su.fromLngLat(r3);
              f2.y = Pt(f2.y, -1 + ig, 1 - ig);
              const d2 = f2.toLngLat(), y2 = t3.project(d2.lng, d2.lat), g2 = su.fromLngLat(d2);
              g2.x += ig;
              const x2 = g2.toLngLat(), v3 = t3.project(x2.lng, x2.lat), b2 = og(v3.x - y2.x, v3.y - y2.y, h2), _2 = su.fromLngLat(d2);
              _2.y += ig;
              const w2 = _2.toLngLat(), A2 = t3.project(w2.lng, w2.lat), M2 = og(A2.x - y2.x, A2.y - y2.y, h2), I2 = Math.abs(b2.x) / Math.abs(M2.y), S2 = l([]);
              m(S2, S2, -h2 * (1 - (i3 ? 0 : n3)));
              const z2 = l([]);
              return p(z2, z2, [1, 1 - (1 - I2) * n3, 1]), z2[4] = -M2.x / M2.y * n3, m(z2, z2, h2), c(z2, S2, z2), z2;
            }(t2.projection, 0, t2.center, r2, e2), i2 = rg(t2);
            return p(n2, n2, [i2, i2, 1]), n2;
          }
          function rg(t2) {
            const e2 = t2.projection, r2 = ng(t2.projection, t2.zoom, t2.width, t2.height), n2 = sg(e2, t2.center), i2 = sg(e2, $l.convert(e2.center));
            return Math.pow(2, n2 * r2 + (1 - r2) * i2);
          }
          function ng(t2, e2, r2, n2, i2 = 1 / 0) {
            const s2 = t2.range;
            if (!s2) return 0;
            const o2 = Math.min(i2, Math.max(r2, n2)), a2 = Math.log(o2 / 1024) / Math.LN2;
            return Tt(s2[0] + a2, s2[1] + a2, e2);
          }
          const ig = 1 / 4e4;
          function sg(t2, e2) {
            const r2 = Pt(e2.lat, -tu, tu), n2 = new $l(e2.lng - 180 * ig, r2), i2 = new $l(e2.lng + 180 * ig, r2), s2 = t2.project(n2.lng, r2), o2 = t2.project(i2.lng, r2), a2 = su.fromLngLat(n2), l2 = su.fromLngLat(i2), u5 = o2.x - s2.x, c2 = o2.y - s2.y, h2 = l2.x - a2.x, p2 = l2.y - a2.y, f2 = Math.sqrt((h2 * h2 + p2 * p2) / (u5 * u5 + c2 * c2));
            return Math.log(f2) / Math.LN2;
          }
          function og(t2, e2, r2) {
            const n2 = Math.cos(r2), i2 = Math.sin(r2);
            return { x: t2 * n2 - e2 * i2, y: t2 * i2 + e2 * n2 };
          }
          function ag(t2, e2, r2) {
            l(t2), m(t2, t2, Mt(e2[2])), f(t2, t2, Mt(e2[0])), d(t2, t2, Mt(e2[1])), p(t2, t2, r2), c(t2, t2, [1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1]);
          }
          function lg(t2, e2, r2, n2, i2, s2, o2, a2) {
            const l2 = [r2[0] - e2[0], r2[1] - e2[1], 0], u5 = [n2[0] - e2[0], n2[1] - e2[1], 0];
            if (w(l2) < 1e-12 || w(u5) < 1e-12) return Y(t2);
            const c2 = F([], l2, u5);
            C(c2, c2), I(u5, n2, e2), l2[2] = (s2 - i2) * a2, u5[2] = (o2 - i2) * a2;
            const h2 = l2;
            return F(h2, l2, u5), C(h2, h2), st(t2, c2, h2);
          }
          function ug(t2, e2, r2 = false) {
            const n2 = Mc(e2.zoom), i2 = function(t3, e3, r3) {
              const n3 = e3.worldSize, i3 = [t3[12], t3[13], t3[14]], s2 = Jl(i3[1] / n3), o2 = Kl(i3[0] / n3), a2 = l([]), u5 = Yl(1, s2) * n3, f2 = Yl(1, 0) * n3 * ru(s2, e3.zoom), d2 = 1 / _c(n3);
              let m2 = f2 * d2;
              if (r3) {
                const t4 = ng(e3.projection, e3.zoom, e3.width, e3.height, 1024);
                m2 = d2 * e3.projection.pixelSpaceConversion(e3.center.lat, n3, t4);
              }
              const y2 = Ul(s2, o2);
              M(y2, y2, E([], C([], y2), u5 * m2 * i3[2]));
              const g2 = function(t4) {
                const e4 = [t4[0], t4[1], t4[2]];
                let r4 = [0, 1, 0];
                const n4 = F([], r4, e4);
                return F(r4, e4, n4), 0 === B2(r4) && (r4 = [0, 1, 0], F(n4, e4, r4)), C(n4, n4), C(r4, r4), C(e4, e4), [n4[0], n4[1], n4[2], 0, r4[0], r4[1], r4[2], 0, e4[0], e4[1], e4[2], 0, t4[0], t4[1], t4[2], 1];
              }(y2);
              p(a2, a2, [m2, m2, m2 * u5]), h(a2, a2, [-i3[0], -i3[1], -i3[2]]);
              const x2 = c([], e3.globeMatrix, g2);
              return c(x2, x2, a2), c(x2, x2, t3), x2;
            }(t2, e2, r2);
            if (n2 > 0) {
              const r3 = function(t3, e3) {
                const r4 = e3.worldSize, n3 = Yl(1, 0) * r4 * ru(e3.center.lat, e3.zoom) / _c(r4), i3 = Yl(1, e3.center.lat) * r4, s2 = l([]);
                return d(s2, s2, Mt(e3.center.lng)), f(s2, s2, Mt(e3.center.lat)), h(s2, s2, [0, 0, Tl]), p(s2, s2, [n3, n3, n3 * i3]), h(s2, s2, [e3.point.x - 0.5 * r4, e3.point.y - 0.5 * r4, 0]), c(s2, s2, t3), c(s2, e3.globeMatrix, s2);
              }(t2, e2);
              return function(t3, e3, r4) {
                const n3 = (t4, e4, r5) => {
                  const n4 = w(t4), i4 = w(e4), s3 = hc(t4, e4, r5);
                  return E(s3, s3, 1 / w(s3) * or(n4, i4, r5));
                }, i3 = n3([t3[0], t3[1], t3[2]], [e3[0], e3[1], e3[2]], r4), s2 = n3([t3[4], t3[5], t3[6]], [e3[4], e3[5], e3[6]], r4), o2 = n3([t3[8], t3[9], t3[10]], [e3[8], e3[9], e3[10]], r4), a2 = hc([t3[12], t3[13], t3[14]], [e3[12], e3[13], e3[14]], r4);
                return [i3[0], i3[1], i3[2], 0, s2[0], s2[1], s2[2], 0, o2[0], o2[1], o2[2], 0, a2[0], a2[1], a2[2], 1];
              }(i2, r3, n2);
            }
            return i2;
          }
          function cg(t2, e2, r2, n2) {
            const i2 = ic.projectAabbCorners(n2, r2);
            let s2 = Number.MAX_VALUE, o2 = -1;
            for (let t3 = 0; t3 < i2.length; ++t3) {
              const r3 = i2[t3];
              r3[0] = (0.5 * r3[0] + 0.5) * e2.width, r3[1] = (0.5 - 0.5 * r3[1]) * e2.height, r3[2] < s2 && (o2 = t3, s2 = r3[2]);
            }
            const a2 = (t3) => new bt(i2[t3][0], i2[t3][1]);
            let l2;
            switch (o2) {
              case 0:
              case 6:
                l2 = [a2(1), a2(5), a2(4), a2(7), a2(3), a2(2), a2(1)];
                break;
              case 1:
              case 7:
                l2 = [a2(0), a2(4), a2(5), a2(6), a2(2), a2(3), a2(0)];
                break;
              case 3:
              case 5:
                l2 = [a2(1), a2(0), a2(4), a2(7), a2(6), a2(2), a2(1)];
                break;
              default:
                l2 = [a2(1), a2(5), a2(6), a2(7), a2(3), a2(0), a2(1)];
            }
            if (xu(t2, l2)) return s2;
          }
          const hg = Qo([{ name: "a_pos_3f", components: 3, type: "Float32" }]), pg = Qo([{ name: "a_color_3f", components: 3, type: "Float32" }]), fg = Qo([{ name: "a_color_4f", components: 4, type: "Float32" }]), dg = Qo([{ name: "a_uv_2f", components: 2, type: "Float32" }]), mg = Qo([{ name: "a_normal_3f", components: 3, type: "Float32" }]), yg = Qo([{ name: "a_normal_matrix0", components: 4, type: "Float32" }, { name: "a_normal_matrix1", components: 4, type: "Float32" }, { name: "a_normal_matrix2", components: 4, type: "Float32" }, { name: "a_normal_matrix3", components: 4, type: "Float32" }]), gg = Qo([{ name: "a_pbr", components: 4, type: "Uint16" }, { name: "a_heightBasedEmissiveStrength", components: 3, type: "Float32" }]), xg = { None: 0, Model: 1, Symbol: 2, FillExtrusion: 4, All: 7 };
          class vg {
            constructor(t2, e2, r2, n2) {
              this.message = (t2 ? `${t2}: ` : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
            }
          }
          function bg(t2, e2) {
            const r2 = -1 === t2.indexOf("://");
            try {
              return new URL(t2, r2 && e2 ? "http://example.com" : void 0), true;
            } catch (t3) {
              return false;
            }
          }
          class _g {
            constructor(t2, e2) {
              this.feature = t2, this.instancedDataOffset = e2, this.instancedDataCount = 0, this.rotation = [0, 0, 0], this.scale = [1, 1, 1], this.translation = [0, 0, 0];
            }
          }
          class wg {
            constructor() {
              this.instancedDataArray = new Ba(), this.instancesEvaluatedElevation = [], this.features = [], this.idToFeaturesIndex = {};
            }
          }
          class Ag {
            constructor(t2) {
              this.zoom = t2.zoom, this.canonical = t2.canonical, this.layers = t2.layers, this.layerIds = this.layers.map((t3) => t3.fqid), this.projection = t2.projection, this.index = t2.index, this.hasZoomDependentProperties = this.layers[0].isZoomDependent(), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.hasPattern = false, this.instancesPerModel = {}, this.validForExaggeration = 0, this.maxVerticalOffset = 0, this.maxScale = 0, this.maxHeight = 0, this.lookupDim = this.zoom > this.canonical.z ? 256 : this.zoom > 15 ? 75 : 100, this.instanceCount = 0, this.terrainElevationMin = 0, this.terrainElevationMax = 0, this.validForDEMTile = { id: null, timestamp: 0 }, this.modelUris = [], this.modelsRequested = false, this.activeReplacements = [], this.replacementUpdateTime = 0, this.styleDefinedModelURLs = t2.styleDefinedModelURLs;
            }
            updateFootprints(t2, e2) {
            }
            populate(t2, e2, r2, n2) {
              this.tileToMeter = iu(r2);
              const i2 = this.layers[0]._featureFilter.needGeometry;
              this.lookup = new Uint8Array(this.lookupDim * this.lookupDim);
              for (const { feature: s2, id: o2, index: a2, sourceLayerIndex: l2 } of t2) {
                const t3 = null != o2 ? o2 : s2.properties && s2.properties.hasOwnProperty("id") ? s2.properties.id : void 0, u5 = du(s2, i2);
                if (!this.layers[0]._featureFilter.filter(new yo(this.zoom), u5, r2)) continue;
                const c2 = { id: t3, sourceLayerIndex: l2, index: a2, geometry: i2 ? u5.geometry : fu(s2, r2, n2), properties: s2.properties, type: s2.type, patterns: {} }, h2 = this.addFeature(c2, c2.geometry, u5);
                h2 && e2.featureIndex.insert(s2, c2.geometry, a2, l2, this.index, this.instancesPerModel[h2].instancedDataArray.length, Tn / 32);
              }
              this.lookup = null;
            }
            update(t2, e2, r2, n2) {
              for (const e3 in this.instancesPerModel) {
                const r3 = this.instancesPerModel[e3];
                for (const e4 in t2) r3.idToFeaturesIndex.hasOwnProperty(e4) && (this.evaluate(r3.features[r3.idToFeaturesIndex[e4]], t2[e4], r3, true), this.uploaded = false);
              }
              this.maxHeight = 0;
            }
            updateZoomBasedPaintProperties() {
              if (!this.hasZoomDependentProperties) return false;
              let t2 = false;
              for (const e2 in this.instancesPerModel) {
                const r2 = this.instancesPerModel[e2];
                for (const e3 of r2.features) {
                  const n2 = this.layers[0], i2 = e3.feature, s2 = this.canonical, o2 = n2.paint.get("model-rotation").evaluate(i2, {}, s2), a2 = n2.paint.get("model-scale").evaluate(i2, {}, s2), l2 = n2.paint.get("model-translation").evaluate(i2, {}, s2);
                  N(e3.rotation, o2) && N(e3.scale, a2) && N(e3.translation, l2) || (this.evaluate(e3, e3.featureStates, r2, true), t2 = true);
                }
              }
              return t2;
            }
            updateReplacement(t2, e2, r2, n2) {
              if (e2.updateTime === this.replacementUpdateTime) return false;
              this.replacementUpdateTime = e2.updateTime;
              const i2 = e2.getReplacementRegionsForTile(t2.toUnwrapped(), true);
              if (Bp(this.activeReplacements, i2)) return false;
              this.activeReplacements = i2;
              let s2 = false;
              for (const e3 in this.instancesPerModel) {
                const i3 = this.instancesPerModel[e3], o2 = i3.instancedDataArray;
                for (const e4 of i3.features) {
                  const i4 = e4.instancedDataOffset, a2 = e4.instancedDataCount;
                  for (let e5 = 0; e5 < a2; e5++) {
                    const a3 = 16 * (e5 + i4);
                    let l2 = o2.float32[a3 + 0];
                    const u5 = l2 > Tn;
                    l2 = u5 ? l2 - Tn : l2;
                    const c2 = Math.floor(l2), h2 = o2.float32[a3 + 1];
                    let p2 = false;
                    for (const e6 of this.activeReplacements) if (!kp(e6, r2, xg.Model, n2) && !(e6.min.x > c2 || c2 > e6.max.x || e6.min.y > h2 || h2 > e6.max.y) && (p2 = Rp(Lp(c2, h2, t2.canonical, e6.footprintTileId.canonical), e6.footprint), p2)) break;
                    o2.float32[a3] = p2 ? l2 + Tn : l2, s2 = s2 || p2 !== u5;
                  }
                }
              }
              return s2;
            }
            isEmpty() {
              for (const t2 in this.instancesPerModel) if (0 !== this.instancesPerModel[t2].instancedDataArray.length) return false;
              return true;
            }
            uploadPending() {
              return !this.uploaded;
            }
            upload(t2) {
              if (!this.uploaded) for (const e2 in this.instancesPerModel) {
                const r2 = this.instancesPerModel[e2];
                r2.instancedDataArray.length < 0 || 0 === r2.instancedDataArray.length || (r2.instancedDataBuffer ? r2.instancedDataBuffer.updateData(r2.instancedDataArray) : r2.instancedDataBuffer = t2.createVertexBuffer(r2.instancedDataArray, yg.members, true, void 0, this.instanceCount));
              }
              this.uploaded = true;
            }
            destroy() {
              for (const t3 in this.instancesPerModel) {
                const e2 = this.instancesPerModel[t3];
                0 !== e2.instancedDataArray.length && e2.instancedDataBuffer && e2.instancedDataBuffer.destroy();
              }
              const t2 = this.layers[0].modelManager;
              if (t2 && this.modelUris && this.modelsRequested) for (const e2 of this.modelUris) t2.removeModel(e2, "", true);
            }
            addFeature(t2, e2, r2) {
              const n2 = this.layers[0], i2 = n2.layout.get("model-id").evaluate(r2, {}, this.canonical);
              if (!i2) return $t(`modelId is not evaluated for layer ${n2.id} and it is not going to get rendered.`), i2;
              (bg(i2, false) || void 0 !== this.styleDefinedModelURLs[i2]) && (this.modelUris.includes(i2) || this.modelUris.push(i2)), this.instancesPerModel[i2] || (this.instancesPerModel[i2] = new wg());
              const s2 = this.instancesPerModel[i2], o2 = s2.instancedDataArray, a2 = new _g(r2, o2.length);
              for (const t3 of e2) for (const e3 of t3) {
                if (e3.x < 0 || e3.x >= Tn || e3.y < 0 || e3.y >= Tn) continue;
                const t4 = (this.lookupDim - 1) / Tn, r3 = this.lookupDim * (e3.y * t4 | 0) + e3.x * t4 | 0;
                if (this.lookup) {
                  if (0 !== this.lookup[r3]) continue;
                  this.lookup[r3] = 1;
                }
                this.instanceCount++;
                const n3 = o2.length;
                o2.resize(n3 + 1), s2.instancesEvaluatedElevation.push(0), o2.float32[16 * n3] = e3.x, o2.float32[16 * n3 + 1] = e3.y;
              }
              return a2.instancedDataCount = s2.instancedDataArray.length - a2.instancedDataOffset, a2.instancedDataCount > 0 && (t2.id && (s2.idToFeaturesIndex[t2.id] = s2.features.length), s2.features.push(a2), this.evaluate(a2, {}, s2, false)), i2;
            }
            getModelUris() {
              return this.modelUris;
            }
            evaluate(t2, e2, r2, n2) {
              const i2 = this.layers[0], s2 = t2.feature, o2 = this.canonical, a2 = t2.rotation = i2.paint.get("model-rotation").evaluate(s2, e2, o2), l2 = t2.scale = i2.paint.get("model-scale").evaluate(s2, e2, o2), u5 = t2.translation = i2.paint.get("model-translation").evaluate(s2, e2, o2), c2 = i2.paint.get("model-color").evaluate(s2, e2, o2);
              c2.a = i2.paint.get("model-color-mix-intensity").evaluate(s2, e2, o2);
              const h2 = [];
              this.maxVerticalOffset < u5[2] && (this.maxVerticalOffset = u5[2]), this.maxScale = Math.max(Math.max(this.maxScale, l2[0]), Math.max(l2[1], l2[2])), ag(h2, a2, l2);
              const p2 = Math.round(100 * c2.a) + c2.b / 1.05;
              for (let e3 = 0; e3 < t2.instancedDataCount; ++e3) {
                const i3 = t2.instancedDataOffset + e3, s3 = 16 * i3, a3 = r2.instancedDataArray.float32;
                let l3 = 0;
                n2 && (l3 = a3[s3 + 6] - r2.instancesEvaluatedElevation[i3]);
                const f2 = 0 | a3[s3 + 1];
                a3[s3] = (0 | a3[s3]) + c2.r / 1.05, a3[s3 + 1] = f2 + c2.g / 1.05, a3[s3 + 2] = p2, a3[s3 + 3] = 1 / (o2.z > 10 ? this.tileToMeter : iu(o2, f2)), a3[s3 + 4] = u5[0], a3[s3 + 5] = u5[1], a3[s3 + 6] = u5[2] + l3, a3[s3 + 7] = h2[0], a3[s3 + 8] = h2[1], a3[s3 + 9] = h2[2], a3[s3 + 10] = h2[4], a3[s3 + 11] = h2[5], a3[s3 + 12] = h2[6], a3[s3 + 13] = h2[8], a3[s3 + 14] = h2[9], a3[s3 + 15] = h2[10], r2.instancesEvaluatedElevation[i3] = u5[2];
              }
            }
          }
          let Mg, Ig;
          js(Ag, "ModelBucket", { omit: ["layers"] }), js(wg, "PerModelAttributes"), js(_g, "ModelFeature");
          const Sg = 64, zg = { CoordinateSpaceTile: 1, CoordinateSpaceYUp: 2, HasMapboxMeshFeatures: 4, HasMeshoptCompression: 8 };
          function kg(t2, e2, r2, n2, i2, s2, o2, a2, u5, f2 = false) {
            const d2 = r2.zoom, m2 = r2.project(n2), y2 = ru(n2.lat, d2), g2 = 1 / y2;
            l(t2), h(t2, t2, [m2.x + o2[0] * g2, m2.y + o2[1] * g2, o2[2]]);
            let v3 = 1, b2 = 1;
            const _2 = r2.worldSize;
            if (f2) {
              if ("mercator" === r2.projection.name) {
                let t3 = 0;
                r2.elevation && (t3 = r2.elevation.getAtPointOrZero(new su(m2.x / _2, m2.y / _2), 0));
                const e3 = Z([], [m2.x, m2.y, t3, 1], r2.projMatrix)[3] / r2.cameraToCenterDistance;
                v3 = e3, b2 = e3 * ru(r2.center.lat, d2);
              } else if ("globe" === r2.projection.name) {
                const e3 = ug(t2, r2), i3 = [0, 0, 0, 1];
                Z(i3, i3, c([], r2.projMatrix, e3));
                const s3 = i3[3] / r2.cameraToCenterDistance, o3 = Mc(d2), a3 = r2.projection.pixelsPerMeter(n2.lat, _2) * ru(n2.lat, d2), l2 = r2.projection.pixelsPerMeter(r2.center.lat, _2) * ru(r2.center.lat, d2);
                v3 = s3 / or(a3, eu(r2.center.lat), o3), b2 = s3 * y2 / a3, v3 *= l2, b2 *= l2;
              }
            } else v3 = g2;
            p(t2, t2, [v3, v3, b2]);
            const w2 = [...t2], A2 = e2.orientation, M2 = [];
            if (ag(M2, [A2[0] + i2[0], A2[1] + i2[1], A2[2] + i2[2]], s2), c(t2, w2, M2), a2 && r2.elevation) {
              let i3 = 0;
              const s3 = [];
              if (u5 && r2.elevation) {
                i3 = function(t3, e3, r3, n3, i4) {
                  const s4 = e3.elevation;
                  if (!s4) return 0;
                  const o4 = ic.projectAabbCorners(r3, n3), a3 = Yl(1, i4.lat) * e3.worldSize, l2 = function(t4, e4) {
                    const r4 = [0, 0, 1], n4 = [{ corners: [0, 1, 3, 2], dotProductWithUp: 0 }, { corners: [1, 5, 2, 6], dotProductWithUp: 0 }, { corners: [0, 4, 1, 5], dotProductWithUp: 0 }, { corners: [2, 6, 3, 7], dotProductWithUp: 0 }, { corners: [4, 7, 5, 6], dotProductWithUp: 0 }, { corners: [0, 3, 4, 7], dotProductWithUp: 0 }];
                    for (const i5 of n4) {
                      const n5 = t4[i5.corners[0]], s5 = t4[i5.corners[1]], o5 = t4[i5.corners[2]], a4 = [s5[0] - n5[0], s5[1] - n5[1], e4 * (s5[2] - n5[2])], l3 = F(a4, a4, [o5[0] - n5[0], o5[1] - n5[1], e4 * (o5[2] - n5[2])]);
                      C(l3, l3), i5.dotProductWithUp = D2(l3, r4);
                    }
                    return n4.sort((t5, e5) => t5.dotProductWithUp - e5.dotProductWithUp), n4[0].corners;
                  }(o4, a3), u6 = o4[l2[0]], c2 = o4[l2[1]], h2 = o4[l2[2]], p2 = o4[l2[3]], f3 = s4.getAtPointOrZero(new su(u6[0] / e3.worldSize, u6[1] / e3.worldSize), 0), d3 = s4.getAtPointOrZero(new su(c2[0] / e3.worldSize, c2[1] / e3.worldSize), 0), m3 = s4.getAtPointOrZero(new su(h2[0] / e3.worldSize, h2[1] / e3.worldSize), 0), y3 = s4.getAtPointOrZero(new su(p2[0] / e3.worldSize, p2[1] / e3.worldSize), 0), g3 = (f3 + y3) / 2, x2 = (d3 + m3) / 2;
                  return g3 > x2 ? d3 < m3 ? lg(t3, c2, p2, u6, d3, y3, f3, a3) : lg(t3, h2, u6, p2, m3, f3, y3, a3) : f3 < y3 ? lg(t3, u6, c2, h2, f3, d3, m3, a3) : lg(t3, p2, h2, c2, y3, m3, d3, a3), Math.max(g3, x2);
                }(s3, r2, e2.aabb, t2, n2);
                const o3 = c([], x([], s3), M2);
                c(t2, w2, o3);
              } else i3 = r2.elevation.getAtPointOrZero(new su(m2.x / _2, m2.y / _2), 0);
              0 !== i3 && (t2[14] += i3);
            }
          }
          function Eg(t2, e2, r2 = false) {
            t2.uploaded || (t2.gfxTexture = new Oy(e2, t2.image, r2 ? e2.gl.R8 : e2.gl.RGBA8, { useMipmap: t2.sampler.minFilter >= e2.gl.NEAREST_MIPMAP_NEAREST }), t2.uploaded = true, t2.image = null);
          }
          function Pg(t2, e2, r2) {
            t2.indexBuffer = e2.createIndexBuffer(t2.indexArray, false, true), t2.vertexBuffer = e2.createVertexBuffer(t2.vertexArray, hg.members, false, true), t2.normalArray && (t2.normalBuffer = e2.createVertexBuffer(t2.normalArray, mg.members, false, true)), t2.texcoordArray && (t2.texcoordBuffer = e2.createVertexBuffer(t2.texcoordArray, dg.members, false, true)), t2.colorArray && (t2.colorBuffer = e2.createVertexBuffer(t2.colorArray, (12 === t2.colorArray.bytesPerElement ? pg : fg).members, false, true)), t2.featureArray && (t2.pbrBuffer = e2.createVertexBuffer(t2.featureArray, gg.members, true)), t2.segments = Ka.simpleSegment(0, 0, t2.vertexArray.length, t2.indexArray.length);
            const n2 = t2.material;
            n2.pbrMetallicRoughness.baseColorTexture && Eg(n2.pbrMetallicRoughness.baseColorTexture, e2), n2.pbrMetallicRoughness.metallicRoughnessTexture && Eg(n2.pbrMetallicRoughness.metallicRoughnessTexture, e2), n2.normalTexture && Eg(n2.normalTexture, e2), n2.occlusionTexture && Eg(n2.occlusionTexture, e2, r2), n2.emissionTexture && Eg(n2.emissionTexture, e2);
          }
          function Tg(t2, e2, r2) {
            if (t2.meshes) for (const n2 of t2.meshes) Pg(n2, e2, r2);
            if (t2.children) for (const n2 of t2.children) Tg(n2, e2, r2);
          }
          function Bg(t2) {
            if (t2.meshes) for (const e2 of t2.meshes) e2.indexArray.destroy(), e2.vertexArray.destroy(), e2.colorArray && e2.colorArray.destroy(), e2.normalArray && e2.normalArray.destroy(), e2.texcoordArray && e2.texcoordArray.destroy(), e2.featureArray && e2.featureArray.destroy();
            if (t2.children) for (const e2 of t2.children) Bg(e2);
          }
          function Vg(t2) {
            if (t2.meshes) for (const r2 of t2.meshes) r2.vertexBuffer && (r2.vertexBuffer.destroy(), r2.indexBuffer.destroy(), r2.normalBuffer && r2.normalBuffer.destroy(), r2.texcoordBuffer && r2.texcoordBuffer.destroy(), r2.colorBuffer && r2.colorBuffer.destroy(), r2.pbrBuffer && r2.pbrBuffer.destroy(), r2.segments.destroy(), r2.material && ((e2 = r2.material).pbrMetallicRoughness.baseColorTexture && e2.pbrMetallicRoughness.baseColorTexture.gfxTexture && e2.pbrMetallicRoughness.baseColorTexture.gfxTexture.destroy(), e2.pbrMetallicRoughness.metallicRoughnessTexture && e2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture && e2.pbrMetallicRoughness.metallicRoughnessTexture.gfxTexture.destroy(), e2.normalTexture && e2.normalTexture.gfxTexture && e2.normalTexture.gfxTexture.destroy(), e2.emissionTexture && e2.emissionTexture.gfxTexture && e2.emissionTexture.gfxTexture.destroy(), e2.occlusionTexture && e2.occlusionTexture.gfxTexture && e2.occlusionTexture.gfxTexture.destroy()));
            var e2;
            if (t2.children) for (const e3 of t2.children) Vg(e3);
          }
          class Cg {
            constructor(t2, e2, r2) {
              this._demTile = t2, this._dem = this._demTile.dem, this._scale = e2, this._offset = r2;
            }
            static create(t2, e2, r2) {
              const n2 = r2 || t2.findDEMTileFor(e2);
              if (!n2 || !n2.dem) return;
              const i2 = n2.dem, s2 = n2.tileID, o2 = 1 << e2.canonical.z - s2.canonical.z;
              return new Cg(n2, i2.dim / Tn / o2, [(e2.canonical.x / o2 - s2.canonical.x) * i2.dim, (e2.canonical.y / o2 - s2.canonical.y) * i2.dim]);
            }
            tileCoordToPixel(t2, e2) {
              const r2 = e2 * this._scale + this._offset[1], n2 = Math.floor(t2 * this._scale + this._offset[0]), i2 = Math.floor(r2);
              return new bt(n2, i2);
            }
            getElevationAt(t2, e2, r2, n2) {
              const i2 = t2 * this._scale + this._offset[0], s2 = e2 * this._scale + this._offset[1], o2 = Math.floor(i2), a2 = Math.floor(s2), l2 = this._dem;
              return n2 = !!n2, r2 ? or(or(l2.get(o2, a2, n2), l2.get(o2, a2 + 1, n2), s2 - a2), or(l2.get(o2 + 1, a2, n2), l2.get(o2 + 1, a2 + 1, n2), s2 - a2), i2 - o2) : l2.get(o2, a2, n2);
            }
            getElevationAtPixel(t2, e2, r2) {
              return this._dem.get(t2, e2, !!r2);
            }
            getMeterToDEM(t2) {
              return (1 << this._demTile.tileID.canonical.z) * Yl(1, t2) * this._dem.stride;
            }
          }
          const Dg = new Float32Array(262144), Fg = new Uint8Array(262144);
          function Lg(t2) {
            let e2 = 0;
            if (t2.meshes) for (const r2 of t2.meshes) e2 = Math.max(e2, r2.aabb.max[2]);
            if (t2.children) for (const r2 of t2.children) e2 = Math.max(e2, Lg(r2));
            return e2;
          }
          function Rg(t2, e2, r2) {
            if (t2.meshes) for (const n2 of t2.meshes) {
              if (n2.aabb.min[0] === 1 / 0) continue;
              const i2 = ic.applyTransform(n2.aabb, t2.matrix);
              r2.insert(e2, i2.min[0], i2.min[1], i2.max[0], i2.max[1]);
            }
            if (t2.children) for (const n2 of t2.children) Rg(n2, e2, r2);
          }
          const Og = ["", "wall", "door", "roof", "window", "lamp", "logo"];
          class Ug {
            constructor(t2) {
              this.node = t2, this.evaluatedRMEA = [[1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1], [0.4, 1, 0, 1], [1, 0, 0, 1], [1, 0, 0, 1]], this.hiddenByReplacement = false, this.evaluatedScale = [1, 1, 1], this.evaluatedColor = [], this.emissionHeightBasedParams = [], this.cameraCollisionOpacity = 1, this.feature = { type: "Point", id: t2.id, geometry: [], properties: { height: Lg(t2) } }, this.aabb = this._getLocalBounds(), this.state = null;
            }
            _getLocalBounds() {
              if (!this.node.meshes) return new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
              if (!this.aabb) {
                let t2 = 0;
                const e2 = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]);
                for (const r2 of this.node.meshes) this.node.lightMeshIndex !== t2 && (r2.transformedAabb = ic.applyTransformFast(r2.aabb, this.node.matrix), e2.encapsulate(r2.transformedAabb)), t2++;
                this.aabb = e2;
              }
              return this.aabb;
            }
          }
          class Ng {
            constructor(t2, e2, r2, n2, i2, s2, o2) {
              this.id = r2, this.layers = t2, this.layerIds = this.layers.map((t3) => t3.fqid), this.stateDependentLayerIds = this.layers.filter((t3) => t3.isStateDependent()).map((t3) => t3.id), this.modelTraits |= zg.CoordinateSpaceTile, this.uploaded = false, this.hasPattern = false, n2 && (this.modelTraits |= zg.HasMapboxMeshFeatures), i2 && (this.modelTraits |= zg.HasMeshoptCompression), this.zoom = -1, this.terrainExaggeration = 1, this.projection = { name: "mercator" }, this.replacementUpdateTime = 0, this.elevationReadFromZ = 255, this.brightness = s2, this.dirty = true, this.needsUpload = false, this.filter = null, this.nodesInfo = [];
              for (const t3 of e2) this.nodesInfo.push(new Ug(t3)), Rg(t3, o2.featureIndexArray.length, o2.grid), o2.featureIndexArray.emplaceBack(this.nodesInfo.length - 1, 0, o2.bucketLayerIDs.length - 1, 0);
              this.states = {};
            }
            updateFootprints(t2, e2) {
              for (const r2 of this.getNodesInfo()) {
                const n2 = r2.node;
                n2.footprint && e2.push({ footprint: n2.footprint, id: t2 });
              }
            }
            update(t2) {
              const e2 = 0 !== Object.keys(t2).length;
              if (e2 && !this.stateDependentLayers.length) return;
              const r2 = e2 ? this.stateDependentLayers : this.layers;
              if (!_t(t2, this.states)) for (const e3 of r2) this.evaluate(e3, t2);
              this.states = structuredClone(t2);
            }
            populate() {
              console.log("populate 3D model bucket");
            }
            uploadPending() {
              return !this.uploaded || this.needsUpload;
            }
            upload(t2) {
              if (!this.needsUpload) return;
              const e2 = this.getNodesInfo();
              for (const r2 of e2) {
                const e3 = r2.node;
                this.uploaded ? this.updatePbrBuffer(e3) : Tg(e3, t2, true);
              }
              for (const t3 of e2) Bg(t3.node);
              this.uploaded = true, this.needsUpload = false;
            }
            updatePbrBuffer(t2) {
              let e2 = false;
              if (!t2.meshes) return e2;
              for (const r2 of t2.meshes) r2.pbrBuffer && (r2.pbrBuffer.updateData(r2.featureArray), e2 = true);
              return e2;
            }
            needsReEvaluation(t2, e2, r2) {
              const n2 = t2.transform.projectionOptions, i2 = t2.style.getBrightness(), s2 = this.brightness !== i2;
              if (!this.uploaded || this.dirty || n2.name !== this.projection.name || jg(r2.paint.get("model-color").value, s2) || jg(r2.paint.get("model-color-mix-intensity").value, s2) || jg(r2.paint.get("model-roughness").value, s2) || jg(r2.paint.get("model-emissive-strength").value, s2) || jg(r2.paint.get("model-height-based-emissive-strength-multiplier").value, s2)) {
                this.projection = n2, this.brightness = i2;
                const t3 = this.getNodesInfo();
                for (const e3 of t3) e3.state = null;
                return true;
              }
              return false;
            }
            evaluateScale(t2, e2) {
              if (t2.transform.zoom === this.zoom) return;
              this.zoom = t2.transform.zoom;
              const r2 = this.getNodesInfo(), n2 = this.id.canonical;
              for (const t3 of r2) {
                const r3 = t3.feature;
                t3.evaluatedScale = e2.paint.get("model-scale").evaluate(r3, {}, n2);
              }
            }
            evaluate(t2, e2) {
              const r2 = this.getNodesInfo();
              for (const n2 of r2) {
                if (!n2.node.meshes) continue;
                const r3 = n2.feature, i2 = e2 && e2[r3.id];
                if (_t(i2, n2.state)) continue;
                n2.state = structuredClone(i2);
                const s2 = n2.node.meshes && n2.node.meshes[0].featureData, o2 = n2.evaluatedColor[2], a2 = n2.evaluatedRMEA[2], l2 = this.id.canonical;
                if (n2.hasTranslucentParts = false, s2) {
                  for (let e3 = 0; e3 < Og.length; e3++) {
                    const s3 = Og[e3];
                    s3.length && (r3.properties.part = s3);
                    const o3 = t2.paint.get("model-color").evaluate(r3, i2, l2).toRenderColor(null), a3 = t2.paint.get("model-color-mix-intensity").evaluate(r3, i2, l2);
                    n2.evaluatedColor[e3] = [o3.r, o3.g, o3.b, a3], n2.evaluatedRMEA[e3][0] = t2.paint.get("model-roughness").evaluate(r3, i2, l2), n2.evaluatedRMEA[e3][2] = t2.paint.get("model-emissive-strength").evaluate(r3, i2, l2), n2.evaluatedRMEA[e3][3] = o3.a, n2.emissionHeightBasedParams[e3] = t2.paint.get("model-height-based-emissive-strength-multiplier").evaluate(r3, i2, l2), !n2.hasTranslucentParts && o3.a < 1 && (n2.hasTranslucentParts = true);
                  }
                  delete r3.properties.part, Gg(n2, o2 !== n2.evaluatedColor[2] || a2 !== n2.evaluatedRMEA[2], this.modelTraits);
                } else n2.evaluatedRMEA[0][2] = t2.paint.get("model-emissive-strength").evaluate(r3, i2, l2);
                n2.evaluatedScale = t2.paint.get("model-scale").evaluate(r3, i2, l2), this.updatePbrBuffer(n2.node) || (this.needsUpload = true);
              }
              this.dirty = false;
            }
            elevationUpdate(t2, e2, r2, n2) {
              const i2 = t2.findDEMTileFor(r2);
              if (i2 && (i2.tileID.canonical !== this.terrainTile || e2 !== this.terrainExaggeration)) {
                if (i2.dem && i2.tileID.overscaledZ !== this.elevationReadFromZ) {
                  this.elevationReadFromZ = i2.tileID.overscaledZ;
                  const e3 = Cg.create(t2, r2, i2);
                  if (!e3) return;
                  this.modelTraits & zg.HasMapboxMeshFeatures && this.updateDEM(t2, e3, r2, n2);
                  for (const t3 of this.getNodesInfo()) {
                    const r3 = t3.node;
                    if (!r3.footprint || !r3.footprint.vertices || !r3.footprint.vertices.length) continue;
                    const n3 = r3.footprint.vertices;
                    let i3 = e3.getElevationAt(n3[0].x, n3[0].y, true, true);
                    for (let t4 = 1; t4 < n3.length; t4++) i3 = Math.min(i3, e3.getElevationAt(n3[t4].x, n3[t4].y, true, true));
                    r3.elevation = i3;
                  }
                }
                this.terrainTile = i2.tileID.canonical, this.terrainExaggeration = e2;
              }
            }
            updateDEM(t2, e2, r2, n2) {
              let i2 = e2._dem._modifiedForSources[n2];
              if (void 0 === i2 && (e2._dem._modifiedForSources[n2] = [], i2 = e2._dem._modifiedForSources[n2]), i2.includes(r2.canonical)) return;
              const s2 = e2._dem.dim;
              i2.push(r2.canonical);
              let o2 = false;
              for (const t3 of this.getNodesInfo()) {
                const r3 = t3.node;
                if (!r3.footprint || !r3.footprint.grid) continue;
                const n3 = r3.footprint.grid, i3 = e2.tileCoordToPixel(n3.min.x, n3.min.y), a2 = e2.tileCoordToPixel(n3.max.x, n3.max.y), l2 = Math.min(Math.min(s2 - a2.y, i3.x), Math.min(i3.y, s2 - a2.x));
                if (l2 < 0) continue;
                const u5 = Pt(l2, 2, 5);
                let c2 = Math.max(0, i3.x - u5), h2 = Math.max(0, i3.y - u5), p2 = Math.min(a2.x + u5, s2 - 1), f2 = Math.min(a2.y + u5, s2 - 1);
                for (let t4 = h2; t4 <= f2; ++t4) for (let e3 = c2; e3 <= p2; ++e3) Fg[t4 * s2 + e3] = 255;
                let d2 = 0, m2 = 0;
                for (let t4 = 0; t4 < n3.cellsY; ++t4) for (let r4 = 0; r4 < n3.cellsX; ++r4) {
                  if (!n3.cells[t4 * n3.cellsX + r4]) continue;
                  const i4 = e2.tileCoordToPixel(n3.min.x + r4 / n3.xScale, n3.min.y + t4 / n3.yScale), o3 = e2.tileCoordToPixel(n3.min.x + (r4 + 1) / n3.xScale, n3.min.y + (t4 + 1) / n3.yScale);
                  for (let t5 = i4.y; t5 <= Math.min(o3.y + 1, s2 - 1); ++t5) for (let r5 = i4.x; r5 <= Math.min(o3.x + 1, s2 - 1); ++r5) 255 === Fg[t5 * s2 + r5] && (Fg[t5 * s2 + r5] = 0, d2 += e2.getElevationAtPixel(r5, t5), m2++);
                }
                const y2 = d2 / m2;
                c2 = Math.max(1, i3.x - u5), h2 = Math.max(1, i3.y - u5), p2 = Math.min(a2.x + u5, s2 - 2), f2 = Math.min(a2.y + u5, s2 - 2), o2 = true;
                for (let t4 = h2; t4 <= f2; ++t4) for (let r4 = c2; r4 <= p2; ++r4) 0 === Fg[t4 * s2 + r4] && (Dg[t4 * s2 + r4] = e2._dem.set(r4, t4, y2));
                for (let t4 = 1; t4 < u5; ++t4) {
                  c2 = Math.max(1, i3.x - t4), h2 = Math.max(1, i3.y - t4), p2 = Math.min(a2.x + t4, s2 - 2), f2 = Math.min(a2.y + t4, s2 - 2);
                  for (let r4 = h2; r4 <= f2; ++r4) for (let n4 = c2; n4 <= p2; ++n4) {
                    const i4 = r4 * s2 + n4;
                    if (255 === Fg[i4]) {
                      let o3 = 0, a3 = 0, l3 = -1, c3 = -1;
                      for (let e3 = -1; e3 <= 1; ++e3) for (let i5 = -1; i5 <= 1; ++i5) {
                        const u6 = (r4 + e3) * s2 + n4 + i5;
                        if (Fg[u6] >= t4) continue;
                        const h3 = Dg[u6], p3 = Math.abs(h3);
                        p3 > a3 && (o3 = h3, a3 = p3, l3 = i5, c3 = e3);
                      }
                      if (a3 > 0.1) {
                        const s3 = 1 - (t4 + 0.5 * Math.abs(l3 * c3)) / u5;
                        let a4 = e2._dem.get(n4, r4) + o3 * s3;
                        const h3 = e2._dem.get(n4 + l3, r4 + c3), p3 = e2._dem.get(n4 - l3, r4 - c3, true);
                        (a4 - h3) * (a4 - p3) > 0 && (a4 = (h3 + p3) / 2), Dg[i4] = e2._dem.set(n4, r4, a4), Fg[i4] = t4;
                      }
                    }
                  }
                }
              }
              o2 && (e2._demTile.needsDEMTextureUpload = true, e2._dem._timestamp = pe.now());
            }
            setFilter(t2) {
              this.filter = t2 ? Vo(t2) : null;
            }
            getNodesInfo() {
              return this.filter ? this.nodesInfo.filter((t2) => this.filter.filter(new yo(this.id.overscaledZ), t2.feature, this.id.canonical)) : this.nodesInfo;
            }
            destroy() {
              const t2 = this.getNodesInfo();
              for (const e2 of t2) Bg(e2.node), Vg(e2.node);
            }
            isEmpty() {
              return !this.nodesInfo.length;
            }
            updateReplacement(t2, e2) {
              if (e2.updateTime === this.replacementUpdateTime) return;
              this.replacementUpdateTime = e2.updateTime;
              const r2 = e2.getReplacementRegionsForTile(t2.toUnwrapped()), n2 = this.getNodesInfo();
              for (let t3 = 0; t3 < this.nodesInfo.length; t3++) {
                const e3 = n2[t3].node;
                n2[t3].hiddenByReplacement = !!e3.footprint && !r2.find((t4) => t4.footprint === e3.footprint);
              }
            }
            getHeightAtTileCoord(t2, e2) {
              const r2 = this.getNodesInfo(), n2 = [], i2 = [0, 0, 0], s2 = l([]);
              for (let o2 = 0; o2 < this.nodesInfo.length; o2++) {
                const a2 = r2[o2], l2 = a2.node.meshes[0], c2 = l2.transformedAabb;
                if (t2 < c2.min[0] || e2 < c2.min[1] || t2 > c2.max[0] || e2 > c2.max[1]) continue;
                if (true === a2.node.hidden) return { height: 1 / 0, maxHeight: a2.feature.properties.height, hidden: false, verticalScale: a2.evaluatedScale[2] };
                u4(s2, a2.node.matrix), i2[0] = t2, i2[1] = e2, R(i2, i2, s2);
                const h2 = (i2[0] - l2.aabb.min[0]) / (l2.aabb.max[0] - l2.aabb.min[0]) * Sg | 0, p2 = Math.min(63, (i2[1] - l2.aabb.min[1]) / (l2.aabb.max[1] - l2.aabb.min[1]) * Sg | 0) * Sg + Math.min(63, h2), f2 = l2.heightmap[p2];
                if (!(f2 < 0 && a2.node.footprint)) {
                  if (a2.hiddenByReplacement) return;
                  return { height: f2, maxHeight: a2.feature.properties.height, hidden: false, verticalScale: a2.evaluatedScale[2] };
                }
                if (a2.node.footprint.grid.query(new bt(t2, e2), new bt(t2, e2), n2), n2.length > 0) return { height: void 0, maxHeight: a2.feature.properties.height, hidden: a2.hiddenByReplacement, verticalScale: a2.evaluatedScale[2] };
              }
            }
          }
          function jg(t2, e2) {
            return t2 instanceof Bs && !t2.isLightConstant && e2;
          }
          function $g(t2, e2, r2, n2, i2, s2, o2, a2) {
            let l2 = (61440 & e2 | (61440 & e2) >> 4) >> 8, u5 = (3840 & e2 | (3840 & e2) >> 4) >> 4, c2 = 240 & e2 | (240 & e2) >> 4;
            r2[3] > 0 && (l2 = or(l2, 255 * r2[0], r2[3]), u5 = or(u5, 255 * r2[1], r2[3]), c2 = or(c2, 255 * r2[2], r2[3]));
            const h2 = l2 << 8 | u5, p2 = c2 << 8 | Math.floor(255 * n2[3]), f2 = function(t3) {
              const e3 = Pt(t3, 0, 2);
              return Math.min(Math.round(0.5 * e3 * 255), 255);
            }(n2[2]) << 8 | 15 * n2[0] << 4 | 15 * n2[1], d2 = Pt(i2[0], 0, 1), m2 = Pt(i2[1], 0, 1), y2 = Pt(i2[2], 0, 1), g2 = Pt(i2[3], 0, 1);
            let x2, v3, b2, _2;
            if (d2 !== m2 && o2 !== s2 && m2 !== d2) {
              const t3 = o2 - s2;
              v3 = 1 / (t3 * (m2 - d2)), b2 = -(s2 + t3 * d2) / (t3 * (m2 - d2));
              const e3 = Pt(i2[4], -1, 1);
              _2 = Math.pow(10, e3), x2 = 255 * y2 << 8 | 255 * g2;
            } else x2 = 65535, v3 = 0, b2 = 1, _2 = 1;
            if (t2.emplaceBack(h2, p2, f2, x2, v3, b2, _2), a2) {
              const t3 = a2.length;
              a2.clear();
              for (let e3 = 0; e3 < t3; e3++) a2.emplaceBack(h2, p2, f2, x2, v3, b2, _2);
            }
          }
          function Gg(t2, e2, r2) {
            const n2 = t2.node;
            let i2 = 0;
            const s2 = r2 & zg.HasMeshoptCompression;
            for (const r3 of n2.meshes) {
              if (n2.lights && n2.lightMeshIndex === i2) continue;
              if (!r3.featureData) continue;
              r3.featureArray = new Va(), r3.featureArray.reserve(r3.featureData.length);
              let o2 = e2;
              for (const e3 of r3.featureData) {
                const i3 = s2 ? 65535 & e3 : e3 >> 16 & 65535, a2 = s2 ? e3 >> 16 & 65535 : 65535 & e3, l2 = (15 & a2) < 8 ? 15 & a2 : 0, u5 = t2.evaluatedRMEA[l2], c2 = t2.evaluatedColor[l2], h2 = t2.emissionHeightBasedParams[l2];
                let p2;
                if (o2 && 2 === l2 && n2.lights && (p2 = new Va(), p2.resize(10 * n2.lights.length)), $g(r3.featureArray, i3, c2, u5, h2, r3.aabb.min[2], r3.aabb.max[2], p2), p2 && o2) {
                  o2 = false;
                  const t3 = n2.meshes[n2.lightMeshIndex];
                  t3.featureArray = p2, t3.featureArray._trim();
                }
              }
              r3.featureArray._trim(), i2++;
            }
          }
          function qg(t2, e2, r2, n2) {
            const i2 = 1 << t2.z;
            e2.lat = Jl((n2 / Tn + t2.y) / i2), e2.lng = Kl((r2 / Tn + t2.x) / i2);
          }
          js(Ng, "Tiled3dModelBucket", { omit: ["layers"] }), js(Ug, "Tiled3dModelFeature");
          const Hg = { circle: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Ru || (Ru = new ko({ "circle-sort-key": new So(Eo.layout_circle["circle-sort-key"]), "circle-elevation-reference": new Io(Eo.layout_circle["circle-elevation-reference"]), visibility: new Io(Eo.layout_circle.visibility) })), paint: Ou || (Ou = new ko({ "circle-radius": new So(Eo.paint_circle["circle-radius"]), "circle-color": new So(Eo.paint_circle["circle-color"]), "circle-blur": new So(Eo.paint_circle["circle-blur"]), "circle-opacity": new So(Eo.paint_circle["circle-opacity"]), "circle-translate": new Io(Eo.paint_circle["circle-translate"]), "circle-translate-anchor": new Io(Eo.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new Io(Eo.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new Io(Eo.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new So(Eo.paint_circle["circle-stroke-width"]), "circle-stroke-color": new So(Eo.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new So(Eo.paint_circle["circle-stroke-opacity"]), "circle-emissive-strength": new Io(Eo.paint_circle["circle-emissive-strength"]), "circle-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "circle-stroke-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
            }
            createBucket(t2) {
              return new gu(t2);
            }
            queryRadius(t2) {
              const e2 = t2;
              return Cu("circle-radius", this, e2) + Cu("circle-stroke-width", this, e2) + Du(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = Lu(this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), u5 = this.paint.get("circle-radius").evaluate(e2, r2) + this.paint.get("circle-stroke-width").evaluate(e2, r2);
              return Bc(t2, n2, s2, o2, a2, "map" === this.paint.get("circle-pitch-alignment"), "map" === this.paint.get("circle-pitch-scale"), l2, u5);
            }
            getProgramIds() {
              return ["circle"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              const n2 = Tc(this);
              return { config: new Ml(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
            }
            hasElevation() {
              return this.layout && "none" !== this.layout.get("circle-elevation-reference");
            }
          }, heatmap: class extends Wo {
            createBucket(t2) {
              return new Lc(t2);
            }
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Rc || (Rc = new ko({ visibility: new Io(Eo.layout_heatmap.visibility) })), paint: Oc || (Oc = new ko({ "heatmap-radius": new So(Eo.paint_heatmap["heatmap-radius"]), "heatmap-weight": new So(Eo.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new Io(Eo.paint_heatmap["heatmap-intensity"]), "heatmap-color": new zo(Eo.paint_heatmap["heatmap-color"]), "heatmap-opacity": new Io(Eo.paint_heatmap["heatmap-opacity"]), "heatmap-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "heatmap-color" === t2 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = Zc({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius(t2) {
              return Cu("heatmap-radius", this, t2);
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, o2, a2) {
              const l2 = this.paint.get("heatmap-radius").evaluate(e2, r2);
              return Bc(t2, n2, s2, o2, a2, true, true, new bt(0, 0), l2);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["heatmap", "heatmapTexture"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return "heatmap" === t2 ? { config: new Ml(this, { zoom: e2, lut: r2 }), overrideFog: false } : {};
            }
          }, hillshade: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Uc || (Uc = new ko({ visibility: new Io(Eo.layout_hillshade.visibility) })), paint: Nc || (Nc = new ko({ "hillshade-illumination-direction": new Io(Eo.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new Io(Eo.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new Io(Eo.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new Io(Eo.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new Io(Eo.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new Io(Eo.paint_hillshade["hillshade-accent-color"]), "hillshade-emissive-strength": new Io(Eo.paint_hillshade["hillshade-emissive-strength"]), "hillshade-shadow-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-highlight-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "hillshade-accent-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
            }
            shouldRedrape() {
              return this.hasOffscreenPass() && "viewport" === this.paint.get("hillshade-illumination-anchor");
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
            getProgramIds() {
              return ["hillshade", "hillshadePrepare"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { overrideFog: false };
            }
          }, fill: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: fp || (fp = new ko({ "fill-sort-key": new So(Eo.layout_fill["fill-sort-key"]), visibility: new Io(Eo.layout_fill.visibility), "fill-elevation-reference": new Io(Eo.layout_fill["fill-elevation-reference"]), "fill-construct-bridge-guard-rail": new So(Eo.layout_fill["fill-construct-bridge-guard-rail"]) })), paint: dp || (dp = new ko({ "fill-antialias": new Io(Eo.paint_fill["fill-antialias"]), "fill-opacity": new So(Eo.paint_fill["fill-opacity"]), "fill-color": new So(Eo.paint_fill["fill-color"]), "fill-outline-color": new So(Eo.paint_fill["fill-outline-color"]), "fill-translate": new Io(Eo.paint_fill["fill-translate"]), "fill-translate-anchor": new Io(Eo.paint_fill["fill-translate-anchor"]), "fill-pattern": new So(Eo.paint_fill["fill-pattern"]), "fill-pattern-cross-fade": new Io(Eo.paint_fill["fill-pattern-cross-fade"]), "fill-emissive-strength": new Io(Eo.paint_fill["fill-emissive-strength"]), "fill-z-offset": new So(Eo.paint_fill["fill-z-offset"]), "fill-bridge-guard-rail-color": new So(Eo.paint_fill["fill-bridge-guard-rail-color"]), "fill-tunnel-structure-color": new So(Eo.paint_fill["fill-tunnel-structure-color"]), "fill-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-outline-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-bridge-guard-rail-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-tunnel-structure-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
            }
            getProgramIds() {
              const t2 = this.paint.get("fill-pattern"), e2 = t2 && t2.constantOr(1), r2 = [e2 ? "fillPattern" : "fill"];
              return this.paint.get("fill-antialias") && r2.push(e2 && !this.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline"), r2;
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { config: new Ml(this, { zoom: e2, lut: r2 }), overrideFog: false };
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
              const r2 = this.paint._values["fill-outline-color"];
              "constant" === r2.value.kind && void 0 === r2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t2) {
              return new pp(t2);
            }
            queryRadius() {
              return Du(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              return !t2.queryGeometry.isAboveHorizon && bu(Fu(t2.tilespaceGeometry, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), n2);
            }
            isTileClipped() {
              return 0 === this.paint.get("fill-z-offset").constantOr(1);
            }
            is3D(t2) {
              if (0 !== this.paint.get("fill-z-offset").constantOr(1)) return true;
              const e2 = this.layout && "none" !== this.layout.get("fill-elevation-reference");
              return null != t2 ? e2 && !t2 : e2;
            }
            hasElevation() {
              return this.layout && "none" !== this.layout.get("fill-elevation-reference");
            }
            hasShadowPass() {
              return this.layout && "none" !== this.layout.get("fill-elevation-reference");
            }
          }, "fill-extrusion": class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: gf || (gf = new ko({ visibility: new Io(Eo["layout_fill-extrusion"].visibility), "fill-extrusion-edge-radius": new Io(Eo["layout_fill-extrusion"]["fill-extrusion-edge-radius"]) })), paint: xf || (xf = new ko({ "fill-extrusion-opacity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new So(Eo["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new So(Eo["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-pattern-cross-fade": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-pattern-cross-fade"]), "fill-extrusion-height": new So(Eo["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new So(Eo["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-height-alignment": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-height-alignment"]), "fill-extrusion-base-alignment": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-base-alignment"]), "fill-extrusion-vertical-gradient": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]), "fill-extrusion-ambient-occlusion-intensity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-intensity"]), "fill-extrusion-ambient-occlusion-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-radius"]), "fill-extrusion-ambient-occlusion-wall-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-wall-radius"]), "fill-extrusion-ambient-occlusion-ground-radius": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-radius"]), "fill-extrusion-ambient-occlusion-ground-attenuation": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-ambient-occlusion-ground-attenuation"]), "fill-extrusion-flood-light-color": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-color"]), "fill-extrusion-flood-light-intensity": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-intensity"]), "fill-extrusion-flood-light-wall-radius": new So(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-wall-radius"]), "fill-extrusion-flood-light-ground-radius": new So(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-radius"]), "fill-extrusion-flood-light-ground-attenuation": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-flood-light-ground-attenuation"]), "fill-extrusion-vertical-scale": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-vertical-scale"]), "fill-extrusion-rounded-roof": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-rounded-roof"]), "fill-extrusion-cutoff-fade-range": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-cutoff-fade-range"]), "fill-extrusion-emissive-strength": new So(Eo["paint_fill-extrusion"]["fill-extrusion-emissive-strength"]), "fill-extrusion-line-width": new So(Eo["paint_fill-extrusion"]["fill-extrusion-line-width"]), "fill-extrusion-cast-shadows": new Io(Eo["paint_fill-extrusion"]["fill-extrusion-cast-shadows"]), "fill-extrusion-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "fill-extrusion-flood-light-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
            }
            createBucket(t2) {
              return new of(t2);
            }
            queryRadius() {
              return Du(this.paint.get("fill-extrusion-translate"));
            }
            is3D(t2) {
              return true;
            }
            hasShadowPass() {
              return this.paint.get("fill-extrusion-cast-shadows");
            }
            cutoffRange() {
              return this.paint.get("fill-extrusion-cutoff-fade-range");
            }
            canCastShadows() {
              return true;
            }
            getProgramIds() {
              return [this.paint.get("fill-extrusion-pattern").constantOr(1) ? "fillExtrusionPattern" : "fillExtrusion"];
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
              const u5 = Lu(this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), c2 = this.paint.get("fill-extrusion-height").evaluate(e2, r2), h2 = this.paint.get("fill-extrusion-base").evaluate(e2, r2), p2 = [0, 0], f2 = a2 && s2.elevation, d2 = s2.elevation ? s2.elevation.exaggeration() : 1, m2 = t2.tile.getBucket(this);
              if (f2 && m2 instanceof of) {
                const t3 = m2.centroidVertexArray, e3 = l2 + 1;
                e3 < t3.length && (p2[0] = t3.geta_centroid_pos0(e3), p2[1] = t3.geta_centroid_pos1(e3));
              }
              if (0 === p2[0] && 1 === p2[1]) return false;
              "globe" === s2.projection.name && (n2 = mf([n2], [new bt(0, 0), new bt(Tn, Tn)], t2.tileID.canonical).map((t3) => t3.polygon).flat());
              const y2 = f2 ? a2 : null, [g2, x2] = function(t3, e3, r3, n3, i3, s3, o3, a3, l3, u6, c3) {
                return "globe" === t3.projection.name ? function(t4, e4, r4, n4, i4, s4, o4, a4, l4, u7, c4) {
                  const h3 = [], p3 = [], f3 = t4.projection.upVectorScale(c4, t4.center.lat, t4.worldSize).metersToTile, d3 = [0, 0, 0, 1], m3 = [0, 0, 0, 1], y3 = (t5, e5, r5, n5) => {
                    t5[0] = e5, t5[1] = r5, t5[2] = n5, t5[3] = 1;
                  }, g3 = df();
                  r4 > 0 && (r4 += g3), n4 += g3;
                  for (const g4 of e4) {
                    const e5 = [], x3 = [];
                    for (const h4 of g4) {
                      const p4 = h4.x + i4.x, g5 = h4.y + i4.y, v4 = t4.projection.projectTilePoint(p4, g5, c4), b2 = t4.projection.upVector(c4, h4.x, h4.y);
                      let _2 = r4, w2 = n4;
                      if (o4) {
                        const t5 = kf(p4, g5, r4, n4, o4, a4, l4, u7);
                        _2 += t5.base, w2 += t5.top;
                      }
                      0 !== r4 ? y3(d3, v4.x + b2[0] * f3 * _2, v4.y + b2[1] * f3 * _2, v4.z + b2[2] * f3 * _2) : y3(d3, v4.x, v4.y, v4.z), y3(m3, v4.x + b2[0] * f3 * w2, v4.y + b2[1] * f3 * w2, v4.z + b2[2] * f3 * w2), R(d3, d3, s4), R(m3, m3, s4), e5.push(new vf(d3[0], d3[1], d3[2])), x3.push(new vf(m3[0], m3[1], m3[2]));
                    }
                    h3.push(e5), p3.push(x3);
                  }
                  return [h3, p3];
                }(t3, e3, r3, n3, i3, s3, o3, a3, l3, u6, c3) : o3 ? function(t4, e4, r4, n4, i4, s4, o4, a4, l4) {
                  const u7 = [], c4 = [], h3 = [0, 0, 0, 1];
                  for (const p3 of t4) {
                    const t5 = [], f3 = [];
                    for (const u8 of p3) {
                      const c5 = u8.x + n4.x, p4 = u8.y + n4.y, d3 = kf(c5, p4, e4, r4, s4, o4, a4, l4);
                      h3[0] = c5, h3[1] = p4, h3[2] = d3.base, h3[3] = 1, Z(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const m3 = new vf(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      h3[0] = c5, h3[1] = p4, h3[2] = d3.top, h3[3] = 1, Z(h3, h3, i4), h3[3] = Math.max(h3[3], 1e-5);
                      const y3 = new vf(h3[0] / h3[3], h3[1] / h3[3], h3[2] / h3[3]);
                      t5.push(m3), f3.push(y3);
                    }
                    u7.push(t5), c4.push(f3);
                  }
                  return [u7, c4];
                }(e3, r3, n3, i3, s3, o3, a3, l3, u6) : function(t4, e4, r4, n4, i4) {
                  const s4 = [], o4 = [], a4 = i4[8] * e4, l4 = i4[9] * e4, u7 = i4[10] * e4, c4 = i4[11] * e4, h3 = i4[8] * r4, p3 = i4[9] * r4, f3 = i4[10] * r4, d3 = i4[11] * r4;
                  for (const e5 of t4) {
                    const t5 = [], r5 = [];
                    for (const s5 of e5) {
                      const e6 = s5.x + n4.x, o5 = s5.y + n4.y, m3 = i4[0] * e6 + i4[4] * o5 + i4[12], y3 = i4[1] * e6 + i4[5] * o5 + i4[13], g3 = i4[2] * e6 + i4[6] * o5 + i4[14], x3 = i4[3] * e6 + i4[7] * o5 + i4[15], v4 = m3 + a4, b2 = y3 + l4, _2 = g3 + u7, w2 = Math.max(x3 + c4, 1e-5), A2 = m3 + h3, M2 = y3 + p3, I2 = g3 + f3, S2 = Math.max(x3 + d3, 1e-5);
                      t5.push(new vf(v4 / w2, b2 / w2, _2 / w2)), r5.push(new vf(A2 / S2, M2 / S2, I2 / S2));
                    }
                    s4.push(t5), o4.push(r5);
                  }
                  return [s4, o4];
                }(e3, r3, n3, i3, s3);
              }(s2, n2, h2, c2, u5, o2, y2, p2, d2, s2.center.lat, t2.tileID.canonical), v3 = t2.queryGeometry;
              return function(t3, e3, r3) {
                let n3 = 1 / 0;
                bu(r3, e3) && (n3 = zf(r3, e3[0]));
                for (let i3 = 0; i3 < e3.length; i3++) {
                  const s3 = e3[i3], o3 = t3[i3];
                  for (let t4 = 0; t4 < s3.length - 1; t4++) {
                    const e4 = s3[t4], i4 = [e4, s3[t4 + 1], o3[t4 + 1], o3[t4], e4];
                    xu(r3, i4) && (n3 = Math.min(n3, zf(r3, i4)));
                  }
                }
                return n3 !== 1 / 0 && n3;
              }(g2, x2, v3.isPointQuery() ? v3.screenBounds : v3.screenGeometry);
            }
          }, line: class extends Wo {
            constructor(t2, e2, r2, n2) {
              const i2 = Kf();
              super(t2, i2, e2, r2, n2), i2.layout && (this.layout = new Mo(i2.layout)), this.gradientVersion = 0, this.hasElevatedBuckets = false, this.hasNonElevatedBuckets = false;
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              if ("line-gradient" === t2) {
                const t3 = this._transitionablePaint._values["line-gradient"].value.expression;
                this.stepInterpolant = t3._styleExpression && t3._styleExpression.expression instanceof bi, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            widthExpression() {
              return this._transitionablePaint._values["line-width"].value.expression;
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2), this.paint._values["line-floorwidth"] = (() => {
                if (Qf) return Qf;
                const t3 = Kf();
                return Qf = new Jf(t3.paint.properties["line-width"].specification), Qf.useIntegerZoom = true, Qf;
              })().possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t2);
            }
            createBucket(t2) {
              return new Uf(t2);
            }
            getProgramIds() {
              return [this.paint.get("line-pattern").constantOr(1) ? "linePattern" : "line"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              const n2 = Zf(this);
              return { config: new Ml(this, { zoom: e2, lut: r2 }), defines: n2, overrideFog: false };
            }
            queryRadius(t2) {
              const e2 = t2, r2 = td(Cu("line-width", this, e2), Cu("line-gap-width", this, e2)), n2 = Cu("line-offset", this, e2);
              return r2 / 2 + Math.abs(n2) + Du(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              if (t2.queryGeometry.isAboveHorizon) return false;
              const o2 = Fu(t2.tilespaceGeometry, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s2.angle, t2.pixelToTileUnitsFactor), a2 = t2.pixelToTileUnitsFactor / 2 * td(this.paint.get("line-width").evaluate(e2, r2), this.paint.get("line-gap-width").evaluate(e2, r2)), l2 = this.paint.get("line-offset").evaluate(e2, r2);
              return l2 && (n2 = function(t3, e3) {
                const r3 = [], n3 = new bt(0, 0);
                for (let i3 = 0; i3 < t3.length; i3++) {
                  const s3 = t3[i3], o3 = [];
                  for (let t4 = 0; t4 < s3.length; t4++) {
                    const r4 = s3[t4], i4 = s3[t4 + 1], a3 = 0 === t4 ? n3 : r4.sub(s3[t4 - 1])._unit()._perp(), l3 = t4 === s3.length - 1 ? n3 : i4.sub(r4)._unit()._perp(), u5 = a3._add(l3)._unit();
                    u5._mult(1 / (u5.x * l3.x + u5.y * l3.y)), o3.push(u5._mult(e3)._add(r4));
                  }
                  r3.push(o3);
                }
                return r3;
              }(n2, l2 * t2.pixelToTileUnitsFactor)), function(t3, e3, r3) {
                for (let n3 = 0; n3 < e3.length; n3++) {
                  const i3 = e3[n3];
                  if (t3.length >= 3) {
                    for (let e4 = 0; e4 < i3.length; e4++) if (Eu(t3, i3[e4])) return true;
                  }
                  if (_u(t3, i3, r3)) return true;
                }
                return false;
              }(o2, n2, a2);
            }
            isTileClipped() {
              return this.hasNonElevatedBuckets;
            }
            isDraped(t2) {
              return !this.hasElevatedBuckets;
            }
            hasElevation() {
              return this.layout && "none" !== this.layout.get("line-elevation-reference");
            }
          }, symbol: Ty, background: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: By || (By = new ko({ visibility: new Io(Eo.layout_background.visibility) })), paint: Vy || (Vy = new ko({ "background-pitch-alignment": new Io(Eo.paint_background["background-pitch-alignment"]), "background-color": new Io(Eo.paint_background["background-color"]), "background-pattern": new Io(Eo.paint_background["background-pattern"]), "background-opacity": new Io(Eo.paint_background["background-opacity"]), "background-emissive-strength": new Io(Eo.paint_background["background-emissive-strength"]), "background-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2);
            }
            getProgramIds() {
              return [this.paint.get("background-pattern") ? "backgroundPattern" : "background"];
            }
            getDefaultProgramParams(t2, e2, r2) {
              return { overrideFog: false };
            }
            is3D(t2) {
              return "viewport" === this.paint.get("background-pitch-alignment");
            }
          }, raster: Hy, "raster-particle": Jy, sky: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Wy || (Wy = new ko({ visibility: new Io(Eo.layout_sky.visibility) })), paint: Yy || (Yy = new ko({ "sky-type": new Io(Eo.paint_sky["sky-type"]), "sky-atmosphere-sun": new Io(Eo.paint_sky["sky-atmosphere-sun"]), "sky-atmosphere-sun-intensity": new Io(Eo.paint_sky["sky-atmosphere-sun-intensity"]), "sky-gradient-center": new Io(Eo.paint_sky["sky-gradient-center"]), "sky-gradient-radius": new Io(Eo.paint_sky["sky-gradient-radius"]), "sky-gradient": new zo(Eo.paint_sky["sky-gradient"]), "sky-atmosphere-halo-color": new Io(Eo.paint_sky["sky-atmosphere-halo-color"]), "sky-atmosphere-color": new Io(Eo.paint_sky["sky-atmosphere-color"]), "sky-opacity": new Io(Eo.paint_sky["sky-opacity"]), "sky-gradient-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-halo-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }), "sky-atmosphere-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t2) {
              "sky-gradient" === t2 ? this._updateColorRamp() : "sky-atmosphere-sun" !== t2 && "sky-atmosphere-halo-color" !== t2 && "sky-atmosphere-color" !== t2 && "sky-atmosphere-sun-intensity" !== t2 || (this._skyboxInvalidated = true);
            }
            _updateColorRamp() {
              this.colorRamp = Zc({ expression: this._transitionablePaint._values["sky-gradient"].value.expression, evaluationKey: "skyRadialProgress" }), this.colorRampTexture && (this.colorRampTexture.destroy(), this.colorRampTexture = null);
            }
            needsSkyboxCapture(t2) {
              if (this._skyboxInvalidated || !this.skyboxTexture || !this.skyboxGeometry) return true;
              if (!this.paint.get("sky-atmosphere-sun")) {
                const e2 = t2.style.light.properties.get("position");
                return this._lightPosition.azimuthal !== e2.azimuthal || this._lightPosition.polar !== e2.polar;
              }
              return false;
            }
            getCenter(t2, e2) {
              if ("atmosphere" === this.paint.get("sky-type")) {
                const r3 = this.paint.get("sky-atmosphere-sun"), n2 = !r3, i2 = t2.style.light, s2 = i2.properties.get("position");
                return n2 && "viewport" === i2.properties.get("anchor") && $t("The sun direction is attached to a light with viewport anchor, lighting may behave unexpectedly."), n2 ? tg(s2.azimuthal, 90 - s2.polar, e2) : tg(r3[0], 90 - r3[1], e2);
              }
              const r2 = this.paint.get("sky-gradient-center");
              return tg(r2[0], 90 - r2[1], e2);
            }
            isSky() {
              return true;
            }
            markSkyboxValid(t2) {
              this._skyboxInvalidated = false, this._lightPosition = t2.style.light.properties.get("position");
            }
            hasOffscreenPass() {
              return true;
            }
            getProgramIds() {
              const t2 = this.paint.get("sky-type");
              return "atmosphere" === t2 ? ["skyboxCapture", "skybox"] : "gradient" === t2 ? ["skyboxGradient"] : null;
            }
          }, slot: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { paint: Ky || (Ky = new ko({})) }, e2, null);
            }
          }, model: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: Mg || (Mg = new ko({ visibility: new Io(Eo.layout_model.visibility), "model-id": new So(Eo.layout_model["model-id"]) })), paint: Ig || (Ig = new ko({ "model-opacity": new So(Eo.paint_model["model-opacity"]), "model-rotation": new So(Eo.paint_model["model-rotation"]), "model-scale": new So(Eo.paint_model["model-scale"]), "model-translation": new So(Eo.paint_model["model-translation"]), "model-color": new So(Eo.paint_model["model-color"]), "model-color-mix-intensity": new So(Eo.paint_model["model-color-mix-intensity"]), "model-type": new Io(Eo.paint_model["model-type"]), "model-cast-shadows": new Io(Eo.paint_model["model-cast-shadows"]), "model-receive-shadows": new Io(Eo.paint_model["model-receive-shadows"]), "model-ambient-occlusion-intensity": new Io(Eo.paint_model["model-ambient-occlusion-intensity"]), "model-emissive-strength": new So(Eo.paint_model["model-emissive-strength"]), "model-roughness": new So(Eo.paint_model["model-roughness"]), "model-height-based-emissive-strength-multiplier": new So(Eo.paint_model["model-height-based-emissive-strength-multiplier"]), "model-cutoff-fade-range": new Io(Eo.paint_model["model-cutoff-fade-range"]), "model-front-cutoff": new Io(Eo.paint_model["model-front-cutoff"]), "model-color-use-theme": new So({ type: "string", default: "default", "property-type": "data-driven" }) })) }, e2, r2, n2), this._stats = { numRenderedVerticesInShadowPass: 0, numRenderedVerticesInTransparentPass: 0 };
            }
            createBucket(t2) {
              return new Ag(t2);
            }
            getProgramIds() {
              return ["model"];
            }
            is3D(t2) {
              return true;
            }
            hasShadowPass() {
              return true;
            }
            canCastShadows() {
              return true;
            }
            hasLightBeamPass() {
              return true;
            }
            cutoffRange() {
              return this.paint.get("model-cutoff-fade-range");
            }
            queryRadius(t2) {
              return t2 instanceof Ng ? Tn - 1 : 0;
            }
            queryIntersectsFeature(t2, e2, r2, n2, i2, s2) {
              if (!this.modelManager) return false;
              const o2 = this.modelManager, l2 = t2.tile.getBucket(this);
              if (!(l2 && l2 instanceof Ag)) return false;
              for (const r3 in l2.instancesPerModel) {
                const n3 = l2.instancesPerModel[r3], i3 = void 0 !== e2.id ? e2.id : e2.properties && e2.properties.hasOwnProperty("id") ? e2.properties.id : void 0;
                if (n3.idToFeaturesIndex.hasOwnProperty(i3)) {
                  const e3 = n3.features[n3.idToFeaturesIndex[i3]], u5 = o2.getModel(r3, this.scope);
                  if (!u5) return false;
                  let h2 = a();
                  const p2 = new $l(0, 0), f2 = l2.canonical;
                  let d2 = Number.MAX_VALUE;
                  for (let r4 = 0; r4 < e3.instancedDataCount; ++r4) {
                    const i4 = 16 * (e3.instancedDataOffset + r4), o3 = n3.instancedDataArray.float32, a2 = [o3[i4 + 4], o3[i4 + 5], o3[i4 + 6]];
                    qg(f2, p2, o3[i4], 0 | o3[i4 + 1]), kg(h2, u5, s2, p2, e3.rotation, e3.scale, a2, false, false, false), "globe" === s2.projection.name && (h2 = ug(h2, s2));
                    const l3 = c([], s2.projMatrix, h2), m2 = t2.queryGeometry, y2 = cg(m2.isPointQuery() ? m2.screenBounds : m2.screenGeometry, s2, l3, u5.aabb);
                    null != y2 && (d2 = Math.min(y2, d2));
                  }
                  return d2 !== Number.MAX_VALUE && d2;
                }
              }
              return false;
            }
            _handleOverridablePaintPropertyUpdate(t2, e2, r2) {
              return !(!this.layout || e2.isDataDriven() || r2.isDataDriven() || "model-color" !== t2 && "model-color-mix-intensity" !== t2 && "model-rotation" !== t2 && "model-scale" !== t2 && "model-translation" !== t2 && "model-emissive-strength" !== t2);
            }
            _isPropertyZoomDependent(t2) {
              const e2 = this._transitionablePaint._values[t2];
              return null != e2 && null != e2.value && null != e2.value.expression && e2.value.expression instanceof Vs;
            }
            isZoomDependent() {
              return this._isPropertyZoomDependent("model-scale") || this._isPropertyZoomDependent("model-rotation") || this._isPropertyZoomDependent("model-translation");
            }
          }, clip: class extends Wo {
            constructor(t2, e2, r2, n2) {
              super(t2, { layout: mp || (mp = new ko({ "clip-layer-types": new Io(Eo.layout_clip["clip-layer-types"]), "clip-layer-scope": new Io(Eo.layout_clip["clip-layer-scope"]) })), paint: yp || (yp = new ko({})) }, e2, r2, n2);
            }
            recalculate(t2, e2) {
              super.recalculate(t2, e2);
            }
            createBucket(t2) {
              return new vp(t2);
            }
            is3D(t2) {
              return true;
            }
          } };
          class Xg {
            constructor(t2) {
              this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              this._channel = void 0, this._callback = () => {
              };
            }
          }
          class Zg {
            constructor() {
              this.tasks = {}, this.taskQueue = [], Rt(["process"], this), this.invoker = new Xg(this.process), this.nextId = 0;
            }
            add(t2, e2) {
              const r2 = this.nextId++, n2 = function({ type: t3, isSymbolTile: e3, zoom: r3 }) {
                return r3 = r3 || 0, "message" === t3 ? 0 : "maybePrepare" !== t3 || e3 ? "parseTile" !== t3 || e3 ? "parseTile" === t3 && e3 ? 300 - r3 : "maybePrepare" === t3 && e3 ? 400 - r3 : 500 : 200 - r3 : 100 - r3;
              }(e2);
              if (0 === n2) {
                try {
                  t2();
                } finally {
                }
                return null;
              }
              return this.tasks[r2] = { fn: t2, metadata: e2, priority: n2, id: r2 }, this.taskQueue.push(r2), this.invoker.trigger(), { cancel: () => {
                delete this.tasks[r2];
              } };
            }
            process() {
              try {
                if (this.taskQueue = this.taskQueue.filter((t3) => !!this.tasks[t3]), !this.taskQueue.length) return;
                const t2 = this.pick();
                if (null === t2) return;
                const e2 = this.tasks[t2];
                if (delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), !e2) return;
                e2.fn();
              } finally {
              }
            }
            pick() {
              let t2 = null, e2 = 1 / 0;
              for (let r3 = 0; r3 < this.taskQueue.length; r3++) {
                const n2 = this.tasks[this.taskQueue[r3]];
                n2.priority < e2 && (e2 = n2.priority, t2 = r3);
              }
              if (null === t2) return null;
              const r2 = this.taskQueue[t2];
              return this.taskQueue.splice(t2, 1), r2;
            }
            remove() {
              this.invoker.remove();
            }
          }
          class Wg {
            constructor(t2, e2, r2) {
              this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.cancelCallbacks = {}, Rt(["receive"], this), this.target.addEventListener("message", this.receive, false), this.scheduler = new Zg();
            }
            send(t2, e2, r2, n2, i2 = false, s2) {
              const o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r2 && (r2.metadata = s2, this.callbacks[o2] = r2);
              const a2 = /* @__PURE__ */ new Set();
              return this.target.postMessage({ id: o2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: qs(e2, a2) }, a2), { cancel: () => {
                r2 && delete this.callbacks[o2], this.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n2, sourceMapId: this.mapId });
              } };
            }
            receive(t2) {
              const e2 = t2.data;
              if (!e2) return;
              const r2 = e2.id;
              if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId)) if ("<cancel>" === e2.type) {
                const t3 = this.cancelCallbacks[r2];
                delete this.cancelCallbacks[r2], t3 && t3.cancel();
              } else if (e2.mustQueue || Xt(self)) {
                const t3 = this.callbacks[r2], n2 = this.scheduler.add(() => this.processTask(r2, e2), t3 && t3.metadata || { type: "message" });
                n2 && (this.cancelCallbacks[r2] = n2);
              } else this.processTask(r2, e2);
            }
            processTask(t2, e2) {
              if (delete this.cancelCallbacks[t2], "<response>" === e2.type) {
                const r2 = this.callbacks[t2];
                delete this.callbacks[t2], r2 && (e2.error ? r2(Hs(e2.error)) : r2(null, Hs(e2.data)));
              } else {
                const r2 = /* @__PURE__ */ new Set(), n2 = e2.hasCallback ? (e3, n3) => {
                  this.target.postMessage({ id: t2, type: "<response>", sourceMapId: this.mapId, error: e3 ? qs(e3) : null, data: qs(n3, r2) }, r2);
                } : () => {
                }, i2 = Hs(e2.data);
                if (this.parent[e2.type]) this.parent[e2.type](e2.sourceMapId, i2, n2);
                else if (this.parent.getWorkerSource) {
                  const t3 = e2.type.split("."), { source: r3, scope: s2 } = i2;
                  this.parent.getWorkerSource(e2.sourceMapId, t3[0], r3, s2)[t3[1]](i2, n2);
                } else n2(new Error(`Could not find function ${e2.type}`));
              }
            }
            remove() {
              this.scheduler.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }
          var Yg = { workerUrl: "", workerClass: null, workerParams: void 0 };
          const Kg = "mapboxgl_preloaded_worker_pool";
          class Jg {
            constructor() {
              this.active = {};
            }
            acquire(t2, e2 = Jg.workerCount) {
              if (!this.workers) for (this.workers = []; this.workers.length < e2; ) this.workers.push(null != Yg.workerClass ? new Yg.workerClass() : new self.Worker(Yg.workerUrl, Yg.workerParams));
              return this.active[t2] = true, this.workers.slice();
            }
            release(t2) {
              delete this.active[t2], this.workers && 0 === this.numActive() && (this.workers.forEach((t3) => {
                t3.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[Kg];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          Jg.workerCount = 2;
          class Qg {
            constructor(t2, e2, r2 = "Worker", n2 = Jg.workerCount) {
              this.workerPool = t2, this.actors = [], this.currentActor = 0, this.id = Ft();
              const i2 = this.workerPool.acquire(this.id, n2);
              for (let t3 = 0; t3 < i2.length; t3++) {
                const n3 = new Qg.Actor(i2[t3], e2, this.id);
                n3.name = `${r2} ${t3}`, this.actors.push(n3);
              }
              this.ready = false, this.broadcast("checkIfReady", null, () => {
                this.ready = true;
              });
            }
            broadcast(t2, e2, r2) {
              Vt(this.actors, (r3, n2) => {
                r3.send(t2, e2, n2);
              }, r2 = r2 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove() {
              this.actors.forEach((t2) => {
                t2.remove();
              }), this.actors = [], this.workerPool.release(this.id);
            }
          }
          let tx, ex;
          function rx() {
            return tx || (tx = new Jg()), tx;
          }
          Qg.Actor = Wg;
          const nx = new ir(0, 0, 0), ix = { PATH_RULE_UNSPECIFIED: 0, PATH_RULE_NON_ZERO: 1, PATH_RULE_EVEN_ODD: 2 }, sx = { LINE_CAP_UNSPECIFIED: 0, LINE_CAP_BUTT: 1, LINE_CAP_ROUND: 2, LINE_CAP_SQUARE: 3 }, ox = { LINE_JOIN_UNSPECIFIED: 0, LINE_JOIN_MITER: 1, LINE_JOIN_MITER_CLIP: 2, LINE_JOIN_ROUND: 3, LINE_JOIN_BEVEL: 4 }, ax = { PAINT_ORDER_UNSPECIFIED: 0, PAINT_ORDER_FILL_AND_STROKE: 1, PAINT_ORDER_STROKE_AND_FILL: 2 }, lx = { PATH_COMMAND_UNSPECIFIED: 0, PATH_COMMAND_MOVE: 1, PATH_COMMAND_LINE: 2, PATH_COMMAND_QUAD: 3, PATH_COMMAND_CUBIC: 4, PATH_COMMAND_CLOSE: 5 }, ux = { MASK_TYPE_UNSPECIFIED: 0, MASK_TYPE_LUMINANCE: 1, MASK_TYPE_ALPHA: 2 };
          function cx(t2, e2, r2) {
            1 === t2 && e2.icons.push(function(t3, e3) {
              return function(t4) {
                if (t4.usvg_tree.height || (t4.usvg_tree.height = t4.usvg_tree.width), !t4.metadata) return t4;
                const { metadata: e4 } = t4;
                if (e4.content_area) {
                  const { content_area: r3 } = e4;
                  null == r3.top && (r3.top = r3.left), null == r3.width && (r3.width = t4.usvg_tree.width), null == r3.height && (r3.height = r3.width);
                }
                return e4.stretch_x && e4.stretch_x.length && hx(e4, "x"), e4.stretch_y && e4.stretch_y.length && hx(e4, "y"), t4;
              }(t3.readFields(px, { name: void 0 }, e3));
            }(r2, r2.readVarint() + r2.pos));
          }
          function hx(t2, e2) {
            const r2 = [], n2 = t2[`stretch_${e2}`];
            let i2 = null;
            for (let t3 = 0; t3 < n2.length; t3++) null === i2 ? i2 = 0 === r2.length ? n2[0] : r2[r2.length - 1][1] + n2[t3] : (r2.push([i2, i2 + n2[t3]]), i2 = null);
            t2[`stretch_${e2}_areas`] = r2;
          }
          function px(t2, e2, r2) {
            1 === t2 ? e2.name = r2.readString() : 2 === t2 ? e2.metadata = function(t3, e3) {
              return t3.readFields(fx, { stretch_x: null, stretch_y: null, stretch_x_areas: null, stretch_y_areas: null, variables: [] }, e3);
            }(r2, r2.readVarint() + r2.pos) : 3 === t2 && (e2.usvg_tree = function(t3, e3) {
              return t3.readFields(yx, { width: 20, children: [], linear_gradients: [], radial_gradients: [], clip_paths: [], masks: [] }, e3);
            }(r2, r2.readVarint() + r2.pos), e2.data = "usvg_tree");
          }
          function fx(t2, e2, r2) {
            1 === t2 ? e2.stretch_x = r2.readPackedVarint() : 2 === t2 ? e2.stretch_y = r2.readPackedVarint() : 3 === t2 ? e2.content_area = function(t3, e3) {
              return t3.readFields(dx, { left: 0 }, e3);
            }(r2, r2.readVarint() + r2.pos) : 4 === t2 && e2.variables.push(function(t3, e3) {
              return t3.readFields(mx, { name: void 0 }, e3);
            }(r2, r2.readVarint() + r2.pos));
          }
          function dx(t2, e2, r2) {
            1 === t2 ? e2.left = r2.readVarint() : 2 === t2 ? e2.width = r2.readVarint() : 3 === t2 ? e2.top = r2.readVarint() : 4 === t2 && (e2.height = r2.readVarint());
          }
          function mx(t2, e2, r2) {
            1 === t2 ? e2.name = r2.readString() : 2 === t2 && (e2.rgb_color = Mx(r2.readVarint()), e2.value = "rgb_color");
          }
          function yx(t2, e2, r2) {
            1 === t2 ? e2.width = e2.height = r2.readVarint() : 2 === t2 ? e2.height = r2.readVarint() : 3 === t2 ? e2.children.push(gx(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.linear_gradients.push(function(t3, e3) {
              return t3.readFields(Sx, { spread_method: 1, stops: [], x1: 0, y1: 0, x2: 1, y2: 0 }, e3);
            }(r2, r2.readVarint() + r2.pos)) : 5 === t2 ? e2.radial_gradients.push(function(t3, e3) {
              return t3.readFields(Ex, { spread_method: 1, stops: [], cx: 0.5, cy: 0.5, r: 0.5, fx: 0.5, fy: 0.5, fr: 0 }, e3);
            }(r2, r2.readVarint() + r2.pos)) : 7 === t2 ? e2.clip_paths.push(function(t3, e3) {
              return t3.readFields(Px, { children: [] }, e3);
            }(r2, r2.readVarint() + r2.pos)) : 8 === t2 && e2.masks.push(function(t3, e3) {
              const r3 = t3.readFields(Tx, { left: 0, width: 20, mask_type: ux.MASK_TYPE_LUMINANCE, children: [] }, e3);
              return null == r3.height && (r3.height = r3.width), null == r3.top && (r3.top = r3.left), r3;
            }(r2, r2.readVarint() + r2.pos));
          }
          function gx(t2, e2) {
            return t2.readFields(xx, {}, e2);
          }
          function xx(t2, e2, r2) {
            1 === t2 ? (e2.group = function(t3, e3) {
              return t3.readFields(vx, { opacity: 255, children: [] }, e3);
            }(r2, r2.readVarint() + r2.pos), e2.node = "group") : 2 === t2 && (e2.path = function(t3, e3) {
              return t3.readFields(wx, { paint_order: 1, commands: [], step: 1, diffs: [], rule: ix.PATH_RULE_NON_ZERO }, e3);
            }(r2, r2.readVarint() + r2.pos), e2.node = "path");
          }
          function vx(t2, e2, r2) {
            1 === t2 ? e2.transform = bx(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.opacity = r2.readVarint() : 5 === t2 ? e2.clip_path_idx = r2.readVarint() : 6 === t2 ? e2.mask_idx = r2.readVarint() : 7 === t2 && e2.children.push(gx(r2, r2.readVarint() + r2.pos));
          }
          function bx(t2, e2) {
            return t2.readFields(_x, { sx: 1, ky: 0, kx: 0, sy: 1, tx: 0, ty: 0 }, e2);
          }
          function _x(t2, e2, r2) {
            1 === t2 ? e2.sx = r2.readFloat() : 2 === t2 ? e2.ky = r2.readFloat() : 3 === t2 ? e2.kx = r2.readFloat() : 4 === t2 ? e2.sy = r2.readFloat() : 5 === t2 ? e2.tx = r2.readFloat() : 6 === t2 && (e2.ty = r2.readFloat());
          }
          function wx(t2, e2, r2) {
            1 === t2 ? e2.fill = function(t3, e3) {
              return t3.readFields(Ax, { rgb_color: nx, paint: "rgb_color", opacity: 255 }, e3);
            }(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.stroke = function(t3, e3) {
              return t3.readFields(Ix, { rgb_color: nx, paint: "rgb_color", dasharray: [], dashoffset: 0, miterlimit: 4, opacity: 255, width: 1, linecap: 1, linejoin: 1 }, e3);
            }(r2, r2.readVarint() + r2.pos) : 3 === t2 ? e2.paint_order = r2.readVarint() : 5 === t2 ? r2.readPackedVarint(e2.commands) : 6 === t2 ? e2.step = r2.readFloat() : 7 === t2 ? r2.readPackedSVarint(e2.diffs) : 8 === t2 && (e2.rule = r2.readVarint());
          }
          function Ax(t2, e2, r2) {
            1 === t2 ? (e2.rgb_color = Mx(r2.readVarint()), e2.paint = "rgb_color") : 2 === t2 ? (e2.linear_gradient_idx = r2.readVarint(), e2.paint = "linear_gradient_idx") : 3 === t2 ? (e2.radial_gradient_idx = r2.readVarint(), e2.paint = "radial_gradient_idx") : 5 === t2 && (e2.opacity = r2.readVarint());
          }
          function Mx(t2) {
            return new ir((t2 >> 16 & 255) / 255, (t2 >> 8 & 255) / 255, (255 & t2) / 255, 1);
          }
          function Ix(t2, e2, r2) {
            1 === t2 ? (e2.rgb_color = Mx(r2.readVarint()), e2.paint = "rgb_color") : 2 === t2 ? (e2.linear_gradient_idx = r2.readVarint(), e2.paint = "linear_gradient_idx") : 3 === t2 ? (e2.radial_gradient_idx = r2.readVarint(), e2.paint = "radial_gradient_idx") : 5 === t2 ? r2.readPackedFloat(e2.dasharray) : 6 === t2 ? e2.dashoffset = r2.readFloat() : 7 === t2 ? e2.miterlimit = r2.readFloat() : 8 === t2 ? e2.opacity = r2.readVarint() : 9 === t2 ? e2.width = r2.readFloat() : 10 === t2 ? e2.linecap = r2.readVarint() : 11 === t2 && (e2.linejoin = r2.readVarint());
          }
          function Sx(t2, e2, r2) {
            1 === t2 ? e2.transform = bx(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.spread_method = r2.readVarint() : 3 === t2 ? e2.stops.push(zx(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.x1 = r2.readFloat() : 5 === t2 ? e2.y1 = r2.readFloat() : 6 === t2 ? e2.x2 = r2.readFloat() : 7 === t2 && (e2.y2 = r2.readFloat());
          }
          function zx(t2, e2) {
            return t2.readFields(kx, { offset: 0, opacity: 255, rgb_color: nx }, e2);
          }
          function kx(t2, e2, r2) {
            1 === t2 ? e2.offset = r2.readFloat() : 2 === t2 ? e2.opacity = r2.readVarint() : 3 === t2 && (e2.rgb_color = Mx(r2.readVarint()));
          }
          function Ex(t2, e2, r2) {
            1 === t2 ? e2.transform = bx(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.spread_method = r2.readVarint() : 3 === t2 ? e2.stops.push(zx(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.cx = r2.readFloat() : 5 === t2 ? e2.cy = r2.readFloat() : 6 === t2 ? e2.r = r2.readFloat() : 7 === t2 ? e2.fx = r2.readFloat() : 8 === t2 ? e2.fy = r2.readFloat() : 9 === t2 && (e2.fr = r2.readFloat());
          }
          function Px(t2, e2, r2) {
            1 === t2 ? e2.transform = bx(r2, r2.readVarint() + r2.pos) : 2 === t2 ? e2.clip_path_idx = r2.readVarint() : 3 === t2 && e2.children.push(gx(r2, r2.readVarint() + r2.pos));
          }
          function Tx(t2, e2, r2) {
            1 === t2 ? e2.left = e2.top = r2.readFloat() : 2 === t2 ? e2.width = e2.height = r2.readFloat() : 3 === t2 ? e2.top = r2.readFloat() : 4 === t2 ? e2.height = r2.readFloat() : 5 === t2 ? e2.mask_type = r2.readVarint() : 6 === t2 ? e2.mask_idx = r2.readVarint() : 7 === t2 && e2.children.push(gx(r2, r2.readVarint() + r2.pos));
          }
          class Bx {
            static calculate(t2 = {}, e2 = []) {
              const r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map();
              if (0 === Object.keys(t2).length) return r2;
              e2.forEach((t3) => {
                n2.set(t3.name, t3.rgb_color || new ir(0, 0, 0));
              });
              for (const [e3, i2] of Object.entries(t2)) n2.has(e3) ? r2.set(n2.get(e3).toStringPremultipliedAlpha(), i2) : console.warn(`Ignoring unknown image variable "${e3}"`);
              return r2;
            }
          }
          function Vx(t2, e2 = 255, r2) {
            const n2 = e2 / 255, i2 = t2.toStringPremultipliedAlpha(), s2 = r2.has(i2) ? r2.get(i2).clone() : t2.clone();
            return s2.a *= n2, s2.toString();
          }
          function Cx(t2, e2) {
            if (!he()) {
              const r2 = document.createElement("canvas");
              return r2.width = t2, r2.height = e2, r2;
            }
            return new OffscreenCanvas(t2, e2);
          }
          function Dx(t2, e2) {
            const r2 = Bx.calculate(e2.params, t2.metadata ? t2.metadata.variables : []), n2 = t2.usvg_tree, i2 = n2.width, s2 = n2.height, o2 = e2.transform ? e2.transform : new DOMMatrix(), a2 = Math.max(1, Math.round(i2 * o2.a)), l2 = Math.max(1, Math.round(s2 * o2.d)), u5 = new DOMMatrix([a2 / i2, 0, 0, l2 / s2, 0, 0]), c2 = Cx(a2, l2).getContext("2d");
            return Fx(c2, u5, n2, n2, r2), c2.getImageData(0, 0, a2, l2);
          }
          function Fx(t2, e2, r2, n2, i2) {
            for (const s2 of n2.children) Lx(t2, e2, r2, s2, i2);
          }
          function Lx(t2, e2, r2, n2, i2) {
            n2.group ? (t2.save(), function(t3, e3, r3, n3, i3) {
              const s2 = null != n3.mask_idx ? r3.masks[n3.mask_idx] : null, o2 = null != n3.clip_path_idx ? r3.clip_paths[n3.clip_path_idx] : null;
              if (n3.transform && (e3 = Hx(n3.transform).preMultiplySelf(e3)), !function(t4, e4, r4) {
                return 255 !== t4.opacity || e4 || r4;
              }(n3, null != o2, null != s2)) return void Fx(t3, e3, r3, n3, i3);
              const a2 = Cx(t3.canvas.width, t3.canvas.height), l2 = a2.getContext("2d");
              Fx(l2, e3, r3, n3, i3), o2 && Gx(l2, e3, r3, o2), s2 && qx(l2, e3, r3, s2, i3), t3.globalAlpha = n3.opacity / 255, t3.drawImage(a2, 0, 0);
            }(t2, e2, r2, n2.group, i2), t2.restore()) : n2.path && (t2.save(), function(t3, e3, r3, n3, i3) {
              const s2 = Xx(n3);
              t3.setTransform(e3), n3.paint_order === ax.PAINT_ORDER_FILL_AND_STROKE ? (Rx(t3, r3, n3, s2, i3), Ux(t3, r3, n3, s2, i3)) : (Ux(t3, r3, n3, s2, i3), Rx(t3, r3, n3, s2, i3));
            }(t2, e2, r2, n2.path, i2), t2.restore());
          }
          function Rx(t2, e2, r2, n2, i2) {
            const s2 = r2.fill;
            if (!s2) return;
            const o2 = s2.opacity / 255;
            switch (s2.paint) {
              case "rgb_color":
                t2.fillStyle = Vx(s2.rgb_color, s2.opacity, i2);
                break;
              case "linear_gradient_idx":
                t2.fillStyle = Nx(t2, e2.linear_gradients[s2.linear_gradient_idx], o2, i2);
                break;
              case "radial_gradient_idx":
                t2.fillStyle = jx(t2, e2.radial_gradients[s2.radial_gradient_idx], o2, i2);
            }
            t2.fill(n2, Ox(r2));
          }
          function Ox(t2) {
            return t2.rule === ix.PATH_RULE_NON_ZERO ? "nonzero" : t2.rule === ix.PATH_RULE_EVEN_ODD ? "evenodd" : void 0;
          }
          function Ux(t2, e2, r2, n2, i2) {
            const s2 = r2.stroke;
            if (!s2) return;
            t2.lineWidth = s2.width, t2.miterLimit = s2.miterlimit, t2.setLineDash(s2.dasharray), t2.lineDashOffset = s2.dashoffset;
            const o2 = s2.opacity / 255;
            switch (s2.paint) {
              case "rgb_color":
                t2.strokeStyle = Vx(s2.rgb_color, s2.opacity, i2);
                break;
              case "linear_gradient_idx":
                t2.strokeStyle = Nx(t2, e2.linear_gradients[s2.linear_gradient_idx], o2, i2);
                break;
              case "radial_gradient_idx":
                t2.strokeStyle = jx(t2, e2.radial_gradients[s2.radial_gradient_idx], o2, i2);
            }
            switch (s2.linejoin) {
              case ox.LINE_JOIN_MITER_CLIP:
              case ox.LINE_JOIN_MITER:
                t2.lineJoin = "miter";
                break;
              case ox.LINE_JOIN_ROUND:
                t2.lineJoin = "round";
                break;
              case ox.LINE_JOIN_BEVEL:
                t2.lineJoin = "bevel";
            }
            switch (s2.linecap) {
              case sx.LINE_CAP_BUTT:
                t2.lineCap = "butt";
                break;
              case sx.LINE_CAP_ROUND:
                t2.lineCap = "round";
                break;
              case sx.LINE_CAP_SQUARE:
                t2.lineCap = "square";
            }
            t2.stroke(n2);
          }
          function Nx(t2, e2, r2, n2) {
            if (1 === e2.stops.length) {
              const t3 = e2.stops[0];
              return Vx(t3.rgb_color, t3.opacity * r2, n2);
            }
            const i2 = Hx(e2.transform), { x1: s2, y1: o2, x2: a2, y2: l2 } = e2, u5 = i2.transformPoint(new DOMPoint(s2, o2)), c2 = i2.transformPoint(new DOMPoint(a2, l2)), h2 = t2.createLinearGradient(u5.x, u5.y, c2.x, c2.y);
            for (const t3 of e2.stops) h2.addColorStop(t3.offset, Vx(t3.rgb_color, t3.opacity * r2, n2));
            return h2;
          }
          function jx(t2, e2, r2, n2) {
            if (1 === e2.stops.length) {
              const t3 = e2.stops[0];
              return Vx(t3.rgb_color, t3.opacity * r2, n2);
            }
            const i2 = Hx(e2.transform), { fx: s2, fy: o2, cx: a2, cy: l2 } = e2, u5 = i2.transformPoint(new DOMPoint(s2, o2)), c2 = i2.transformPoint(new DOMPoint(a2, l2)), h2 = t2.createRadialGradient(u5.x, u5.y, 0, c2.x, c2.y, e2.r * ((i2.a + i2.d) / 2));
            for (const t3 of e2.stops) h2.addColorStop(t3.offset, Vx(t3.rgb_color, t3.opacity * r2, n2));
            return h2;
          }
          function $x(t2, e2, r2, n2) {
            const i2 = n2.transform ? Hx(n2.transform).preMultiplySelf(e2) : e2, s2 = Cx(t2.canvas.width, t2.canvas.height), o2 = s2.getContext("2d");
            for (const t3 of n2.children) if (t3.group) $x(o2, i2, r2, t3.group);
            else if (t3.path) {
              const e3 = t3.path, r3 = new Path2D();
              r3.addPath(Xx(e3), i2), o2.fill(r3, Ox(e3));
            }
            const a2 = null != n2.clip_path_idx ? r2.clip_paths[n2.clip_path_idx] : null;
            a2 && Gx(o2, i2, r2, a2), t2.globalCompositeOperation = "source-over", t2.drawImage(s2, 0, 0);
          }
          function Gx(t2, e2, r2, n2) {
            const i2 = Cx(t2.canvas.width, t2.canvas.height);
            $x(i2.getContext("2d"), e2, r2, n2), t2.globalCompositeOperation = "destination-in", t2.drawImage(i2, 0, 0);
          }
          function qx(t2, e2, r2, n2, i2) {
            if (0 === n2.children.length) return;
            const s2 = null != n2.mask_idx ? r2.masks[n2.mask_idx] : null;
            s2 && qx(t2, e2, r2, s2, i2);
            const o2 = t2.canvas.width, a2 = t2.canvas.height, l2 = Cx(o2, a2), u5 = l2.getContext("2d"), c2 = n2.width, h2 = n2.height, p2 = n2.left, f2 = n2.top, d2 = new Path2D(), m2 = new Path2D();
            m2.rect(p2, f2, c2, h2), d2.addPath(m2, e2), u5.clip(d2);
            for (const t3 of n2.children) Lx(u5, e2, r2, t3, i2);
            const y2 = u5.getImageData(0, 0, o2, a2), g2 = y2.data;
            if (n2.mask_type === ux.MASK_TYPE_LUMINANCE) for (let t3 = 0; t3 < g2.length; t3 += 4) g2[t3 + 3] = g2[t3 + 3] / 255 * (0.2126 * g2[t3] + 0.7152 * g2[t3 + 1] + 0.0722 * g2[t3 + 2]);
            u5.putImageData(y2, 0, 0), t2.globalCompositeOperation = "destination-in", t2.drawImage(l2, 0, 0);
          }
          function Hx(t2) {
            return t2 ? new DOMMatrix([t2.sx, t2.ky, t2.kx, t2.sy, t2.tx, t2.ty]) : new DOMMatrix();
          }
          function Xx(t2) {
            const e2 = new Path2D(), r2 = t2.step;
            let n2 = t2.diffs[0] * r2, i2 = t2.diffs[1] * r2;
            e2.moveTo(n2, i2);
            for (let s2 = 0, o2 = 2; s2 < t2.commands.length; s2++) switch (t2.commands[s2]) {
              case lx.PATH_COMMAND_MOVE:
                n2 += t2.diffs[o2++] * r2, i2 += t2.diffs[o2++] * r2, e2.moveTo(n2, i2);
                break;
              case lx.PATH_COMMAND_LINE:
                n2 += t2.diffs[o2++] * r2, i2 += t2.diffs[o2++] * r2, e2.lineTo(n2, i2);
                break;
              case lx.PATH_COMMAND_QUAD: {
                const s3 = n2 + t2.diffs[o2++] * r2, a2 = i2 + t2.diffs[o2++] * r2;
                n2 = s3 + t2.diffs[o2++] * r2, i2 = a2 + t2.diffs[o2++] * r2, e2.quadraticCurveTo(s3, a2, n2, i2);
                break;
              }
              case lx.PATH_COMMAND_CUBIC: {
                const s3 = n2 + t2.diffs[o2++] * r2, a2 = i2 + t2.diffs[o2++] * r2, l2 = s3 + t2.diffs[o2++] * r2, u5 = a2 + t2.diffs[o2++] * r2;
                n2 = l2 + t2.diffs[o2++] * r2, i2 = u5 + t2.diffs[o2++] * r2, e2.bezierCurveTo(s3, a2, l2, u5, n2, i2);
                break;
              }
              case lx.PATH_COMMAND_CLOSE:
                e2.closePath();
            }
            return e2;
          }
          class Zx {
            constructor(t2) {
              this.capacity = t2, this.cache = /* @__PURE__ */ new Map();
            }
            get(t2) {
              if (!this.cache.has(t2)) return;
              const e2 = this.cache.get(t2);
              return this.cache.delete(t2), this.cache.set(t2, e2), e2;
            }
            put(t2, e2) {
              this.cache.has(t2) ? this.cache.delete(t2) : this.cache.size === this.capacity && this.cache.delete(this.cache.keys().next().value), this.cache.set(t2, e2);
            }
            delete(t2) {
              this.cache.delete(t2);
            }
          }
          js(Zx, "LRUCache");
          class Wx {
            constructor() {
              this.cacheMap = /* @__PURE__ */ new Map(), this.cacheDependenciesMap = /* @__PURE__ */ new Map();
            }
            static _getImage(t2) {
              return new Hc(t2, t2.data);
            }
            getFromCache(t2, e2, r2) {
              return this.cacheMap.has(r2) || this.cacheMap.set(r2, new Zx(150)), this.cacheMap.get(r2).get(Ho(t2.toString(), e2));
            }
            setInCache(t2, e2, r2, n2) {
              this.cacheDependenciesMap.has(n2) || this.cacheDependenciesMap.set(n2, /* @__PURE__ */ new Map()), this.cacheMap.has(n2) || this.cacheMap.set(n2, new Zx(150));
              const i2 = this.cacheDependenciesMap.get(n2), s2 = Ho(t2.id.toString(), r2);
              i2.get(s2) || i2.set(s2, /* @__PURE__ */ new Set());
              const o2 = this.cacheMap.get(n2), a2 = t2.toString();
              i2.get(s2).add(a2), o2.put(Ho(t2.toString(), r2), e2);
            }
            removeImagesFromCacheByIds(t2, e2, r2 = 0) {
              if (!this.cacheMap.has(r2) || !this.cacheDependenciesMap.has(r2)) return;
              const n2 = this.cacheMap.get(r2), i2 = this.cacheDependenciesMap.get(r2);
              for (const r3 of t2) {
                const t3 = Ho(r3.toString(), e2);
                if (i2.has(t3)) {
                  for (const e3 of i2.get(t3)) n2.delete(e3);
                  i2.delete(t3);
                }
              }
            }
            rasterize(t2, e2, r2, n2, i2 = Dx) {
              const s2 = this.getFromCache(t2, r2, n2);
              if (s2) return s2.clone();
              const o2 = i2(e2.icon, t2.options), a2 = Wx._getImage(o2);
              return this.setInCache(t2, a2, r2, n2), a2.clone();
            }
          }
          class Yx {
            constructor(t2) {
              this.size = t2, this.minimums = [], this.maximums = [], this.leaves = [];
            }
            getElevation(t2, e2) {
              const r2 = this.toIdx(t2, e2);
              return { min: this.minimums[r2], max: this.maximums[r2] };
            }
            isLeaf(t2, e2) {
              return this.leaves[this.toIdx(t2, e2)];
            }
            toIdx(t2, e2) {
              return e2 * this.size + t2;
            }
          }
          function Kx(t2, e2, r2, n2) {
            let i2 = 0, s2 = Number.MAX_VALUE;
            for (let o2 = 0; o2 < 3; o2++) if (Math.abs(n2[o2]) < 1e-15) {
              if (r2[o2] < t2[o2] || r2[o2] > e2[o2]) return null;
            } else {
              const a2 = 1 / n2[o2];
              let l2 = (t2[o2] - r2[o2]) * a2, u5 = (e2[o2] - r2[o2]) * a2;
              if (l2 > u5) {
                const t3 = l2;
                l2 = u5, u5 = t3;
              }
              if (l2 > i2 && (i2 = l2), u5 < s2 && (s2 = u5), i2 > s2) return null;
            }
            return i2;
          }
          function Jx(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5, c2) {
            const h2 = n2 - t2, p2 = i2 - e2, f2 = s2 - r2, d2 = o2 - t2, m2 = a2 - e2, y2 = l2 - r2, g2 = c2[1] * y2 - c2[2] * m2, x2 = c2[2] * d2 - c2[0] * y2, v3 = c2[0] * m2 - c2[1] * d2, b2 = h2 * g2 + p2 * x2 + f2 * v3;
            if (Math.abs(b2) < 1e-15) return null;
            const _2 = 1 / b2, w2 = u5[0] - t2, A2 = u5[1] - e2, M2 = u5[2] - r2, I2 = (w2 * g2 + A2 * x2 + M2 * v3) * _2;
            if (I2 < 0 || I2 > 1) return null;
            const S2 = A2 * f2 - M2 * p2, z2 = M2 * h2 - w2 * f2, k2 = w2 * p2 - A2 * h2, E2 = (c2[0] * S2 + c2[1] * z2 + c2[2] * k2) * _2;
            return E2 < 0 || I2 + E2 > 1 ? null : (d2 * S2 + m2 * z2 + y2 * k2) * _2;
          }
          function Qx(t2, e2, r2) {
            return (t2 - e2) / (r2 - e2);
          }
          function tv(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            const u5 = 1 << r2, c2 = s2 - n2, h2 = o2 - i2, p2 = (t2 + 1) / u5 * c2 + n2, f2 = (e2 + 0) / u5 * h2 + i2, d2 = (e2 + 1) / u5 * h2 + i2;
            a2[0] = (t2 + 0) / u5 * c2 + n2, a2[1] = f2, l2[0] = p2, l2[1] = d2;
          }
          class ev {
            constructor(t2) {
              if (this.maximums = [], this.minimums = [], this.leaves = [], this.childOffsets = [], this.nodeCount = 0, this.dem = t2, this._siblingOffset = [[0, 0], [1, 0], [0, 1], [1, 1]], !this.dem) return;
              const e2 = function(t3) {
                const e3 = Math.ceil(Math.log2(t3.dim / 8)), r3 = [];
                let n3 = Math.ceil(Math.pow(2, e3));
                const i2 = 1 / n3, s2 = (t4, e4, r4, n4, i3) => {
                  const s3 = n4 ? 1 : 0, o3 = (t4 + 1) * r4 - s3, a3 = e4 * r4, l2 = (e4 + 1) * r4 - s3;
                  i3[0] = t4 * r4, i3[1] = a3, i3[2] = o3, i3[3] = l2;
                };
                let o2 = new Yx(n3);
                const a2 = [];
                for (let e4 = 0; e4 < n3 * n3; e4++) {
                  s2(e4 % n3, Math.floor(e4 / n3), i2, false, a2);
                  const r4 = nv(a2[0], a2[1], t3), l2 = nv(a2[2], a2[1], t3), u5 = nv(a2[2], a2[3], t3), c2 = nv(a2[0], a2[3], t3);
                  o2.minimums.push(Math.min(r4, l2, u5, c2)), o2.maximums.push(Math.max(r4, l2, u5, c2)), o2.leaves.push(1);
                }
                for (r3.push(o2), n3 /= 2; n3 >= 1; n3 /= 2) {
                  const t4 = r3[r3.length - 1];
                  o2 = new Yx(n3);
                  for (let e4 = 0; e4 < n3 * n3; e4++) {
                    s2(e4 % n3, Math.floor(e4 / n3), 2, true, a2);
                    const r4 = t4.getElevation(a2[0], a2[1]), i3 = t4.getElevation(a2[2], a2[1]), l2 = t4.getElevation(a2[2], a2[3]), u5 = t4.getElevation(a2[0], a2[3]), c2 = t4.isLeaf(a2[0], a2[1]), h2 = t4.isLeaf(a2[2], a2[1]), p2 = t4.isLeaf(a2[2], a2[3]), f2 = t4.isLeaf(a2[0], a2[3]), d2 = Math.min(r4.min, i3.min, l2.min, u5.min), m2 = Math.max(r4.max, i3.max, l2.max, u5.max), y2 = c2 && h2 && p2 && f2;
                    o2.maximums.push(m2), o2.minimums.push(d2), o2.leaves.push(m2 - d2 <= 5 && y2 ? 1 : 0);
                  }
                  r3.push(o2);
                }
                return r3;
              }(this.dem), r2 = e2.length - 1, n2 = e2[r2];
              this._addNode(n2.minimums[0], n2.maximums[0], n2.leaves[0]), this._construct(e2, 0, 0, r2, 0);
            }
            raycastRoot(t2, e2, r2, n2, i2, s2, o2 = 1) {
              return Kx([t2, e2, -100], [r2, n2, this.maximums[0] * o2], i2, s2);
            }
            raycast(t2, e2, r2, n2, i2, s2, o2 = 1) {
              if (!this.nodeCount) return null;
              const a2 = this.raycastRoot(t2, e2, r2, n2, i2, s2, o2);
              if (null == a2) return null;
              const l2 = [], u5 = [], c2 = [], h2 = [], p2 = [{ idx: 0, t: a2, nodex: 0, nodey: 0, depth: 0 }];
              for (; p2.length > 0; ) {
                const { idx: a3, t: f2, nodex: d2, nodey: m2, depth: y2 } = p2.pop();
                if (this.leaves[a3]) {
                  tv(d2, m2, y2, t2, e2, r2, n2, c2, h2);
                  const a4 = 1 << y2, l3 = (d2 + 0) / a4, u6 = (d2 + 1) / a4, p3 = (m2 + 0) / a4, g3 = (m2 + 1) / a4, x2 = nv(l3, p3, this.dem) * o2, v3 = nv(u6, p3, this.dem) * o2, b2 = nv(u6, g3, this.dem) * o2, _2 = nv(l3, g3, this.dem) * o2, w2 = Jx(c2[0], c2[1], x2, h2[0], c2[1], v3, h2[0], h2[1], b2, i2, s2), A2 = Jx(h2[0], h2[1], b2, c2[0], h2[1], _2, c2[0], c2[1], x2, i2, s2), M2 = Math.min(null !== w2 ? w2 : Number.MAX_VALUE, null !== A2 ? A2 : Number.MAX_VALUE);
                  if (M2 !== Number.MAX_VALUE) return M2;
                  {
                    const t3 = P([], i2, s2, f2);
                    if (rv(x2, v3, _2, b2, Qx(t3[0], c2[0], h2[0]), Qx(t3[1], c2[1], h2[1])) >= t3[2]) return f2;
                  }
                  continue;
                }
                let g2 = 0;
                for (let p3 = 0; p3 < this._siblingOffset.length; p3++) {
                  tv((d2 << 1) + this._siblingOffset[p3][0], (m2 << 1) + this._siblingOffset[p3][1], y2 + 1, t2, e2, r2, n2, c2, h2), c2[2] = -100, h2[2] = this.maximums[this.childOffsets[a3] + p3] * o2;
                  const f3 = Kx(c2, h2, i2, s2);
                  if (null != f3) {
                    const t3 = f3;
                    l2[p3] = t3;
                    let e3 = false;
                    for (let r3 = 0; r3 < g2 && !e3; r3++) t3 >= l2[u5[r3]] && (u5.splice(r3, 0, p3), e3 = true);
                    e3 || (u5[g2] = p3), g2++;
                  }
                }
                for (let t3 = 0; t3 < g2; t3++) {
                  const e3 = u5[t3];
                  p2.push({ idx: this.childOffsets[a3] + e3, t: l2[e3], nodex: (d2 << 1) + this._siblingOffset[e3][0], nodey: (m2 << 1) + this._siblingOffset[e3][1], depth: y2 + 1 });
                }
              }
              return null;
            }
            _addNode(t2, e2, r2) {
              return this.minimums.push(t2), this.maximums.push(e2), this.leaves.push(r2), this.childOffsets.push(0), this.nodeCount++;
            }
            _construct(t2, e2, r2, n2, i2) {
              if (1 === t2[n2].isLeaf(e2, r2)) return;
              this.childOffsets[i2] || (this.childOffsets[i2] = this.nodeCount);
              const s2 = n2 - 1, o2 = t2[s2];
              let a2 = 0, l2 = 0;
              for (let t3 = 0; t3 < this._siblingOffset.length; t3++) {
                const n3 = 2 * e2 + this._siblingOffset[t3][0], i3 = 2 * r2 + this._siblingOffset[t3][1], s3 = o2.getElevation(n3, i3), u5 = o2.isLeaf(n3, i3), c2 = this._addNode(s3.min, s3.max, u5);
                u5 && (a2 |= 1 << t3), l2 || (l2 = c2);
              }
              for (let n3 = 0; n3 < this._siblingOffset.length; n3++) a2 & 1 << n3 || this._construct(t2, 2 * e2 + this._siblingOffset[n3][0], 2 * r2 + this._siblingOffset[n3][1], s2, l2 + n3);
            }
          }
          function rv(t2, e2, r2, n2, i2, s2) {
            return or(or(t2, r2, s2), or(e2, n2, s2), i2);
          }
          function nv(t2, e2, r2) {
            const n2 = r2.dim, i2 = Pt(t2 * n2 - 0.5, 0, n2 - 1), s2 = Pt(e2 * n2 - 0.5, 0, n2 - 1), o2 = Math.floor(i2), a2 = Math.floor(s2), l2 = Math.min(o2 + 1, n2 - 1), u5 = Math.min(a2 + 1, n2 - 1);
            return rv(r2.get(o2, a2), r2.get(l2, a2), r2.get(o2, u5), r2.get(l2, u5), i2 - o2, s2 - a2);
          }
          const iv = { mapbox: [6553.6, 25.6, 0.1, 1e4], terrarium: [256, 1, 1 / 256, 32768] };
          function sv(t2, e2, r2) {
            return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
          }
          function ov(t2, e2, r2) {
            return 256 * t2 + e2 + r2 / 256 - 32768;
          }
          class av {
            get tree() {
              return this._tree || this._buildQuadTree(), this._tree;
            }
            constructor(t2, e2, r2, n2 = false) {
              if (this.uid = t2, e2.height !== e2.width) throw new RangeError("DEM tiles must be square");
              if (r2 && "mapbox" !== r2 && "terrarium" !== r2) return void $t(`"${r2}" is not a valid encoding type. Valid types include "mapbox" and "terrarium".`);
              this.stride = e2.height;
              const i2 = this.dim = e2.height - 2, s2 = new Uint32Array(e2.data.buffer);
              if (this.pixels = new Uint8Array(e2.data.buffer), this.floatView = new Float32Array(e2.data.buffer), this.borderReady = n2, this._modifiedForSources = {}, !n2) {
                for (let t3 = 0; t3 < i2; t3++) s2[this._idx(-1, t3)] = s2[this._idx(0, t3)], s2[this._idx(i2, t3)] = s2[this._idx(i2 - 1, t3)], s2[this._idx(t3, -1)] = s2[this._idx(t3, 0)], s2[this._idx(t3, i2)] = s2[this._idx(t3, i2 - 1)];
                s2[this._idx(-1, -1)] = s2[this._idx(0, 0)], s2[this._idx(i2, -1)] = s2[this._idx(i2 - 1, 0)], s2[this._idx(-1, i2)] = s2[this._idx(0, i2 - 1)], s2[this._idx(i2, i2)] = s2[this._idx(i2 - 1, i2 - 1)];
              }
              const o2 = "terrarium" === r2 ? ov : sv;
              for (let t3 = 0; t3 < s2.length; ++t3) {
                const e3 = 4 * t3;
                this.floatView[t3] = o2(this.pixels[e3], this.pixels[e3 + 1], this.pixels[e3 + 2]);
              }
              this._timestamp = pe.now();
            }
            _buildQuadTree() {
              this._tree = new ev(this);
            }
            get(t2, e2, r2 = false) {
              r2 && (t2 = Pt(t2, -1, this.dim), e2 = Pt(e2, -1, this.dim));
              const n2 = this._idx(t2, e2);
              return this.floatView[n2];
            }
            set(t2, e2, r2) {
              const n2 = this._idx(t2, e2), i2 = this.floatView[n2];
              return this.floatView[n2] = r2, r2 - i2;
            }
            static getUnpackVector(t2) {
              return iv[t2];
            }
            _idx(t2, e2) {
              if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1) throw new RangeError("out of range source coordinates for DEM data");
              return (e2 + 1) * this.stride + (t2 + 1);
            }
            static pack(t2, e2) {
              const r2 = [0, 0, 0, 0], n2 = av.getUnpackVector(e2);
              let i2 = Math.floor((t2 + n2[3]) / n2[2]);
              return r2[2] = i2 % 256, i2 = Math.floor(i2 / 256), r2[1] = i2 % 256, i2 = Math.floor(i2 / 256), r2[0] = i2, r2;
            }
            getPixels() {
              return new Xc({ width: this.stride, height: this.stride }, this.pixels);
            }
            backfillBorder(t2, e2, r2) {
              if (this.dim !== t2.dim) throw new Error("dem dimension mismatch");
              let n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, s2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
              switch (e2) {
                case -1:
                  n2 = i2 - 1;
                  break;
                case 1:
                  i2 = n2 + 1;
              }
              switch (r2) {
                case -1:
                  s2 = o2 - 1;
                  break;
                case 1:
                  o2 = s2 + 1;
              }
              const a2 = -e2 * this.dim, l2 = -r2 * this.dim;
              for (let e3 = s2; e3 < o2; e3++) for (let r3 = n2; r3 < i2; r3++) {
                const n3 = 4 * this._idx(r3, e3), i3 = 4 * this._idx(r3 + a2, e3 + l2);
                this.pixels[n3 + 0] = t2.pixels[i3 + 0], this.pixels[n3 + 1] = t2.pixels[i3 + 1], this.pixels[n3 + 2] = t2.pixels[i3 + 2], this.pixels[n3 + 3] = t2.pixels[i3 + 3];
              }
            }
            onDeserialize() {
              this._tree && (this._tree.dem = this);
            }
          }
          function lv(t2, e2, r2) {
            1 === t2 ? e2.headerLength = r2.readFixed32() : 2 === t2 ? e2.x = r2.readVarint() : 3 === t2 ? e2.y = r2.readVarint() : 4 === t2 ? e2.z = r2.readVarint() : 5 === t2 && e2.layers.push(function(t3, e3) {
              return t3.readFields(fv, { version: 0, name: "", units: "", tileSize: 0, buffer: 0, pixelFormat: 0, dataIndex: [] }, e3);
            }(r2, r2.readVarint() + r2.pos));
          }
          function uv(t2, e2, r2) {
            1 === t2 ? (e2.delta_filter = function(t3, e3) {
              return t3.readFields(cv, { blockSize: 0 }, e3);
            }(r2, r2.readVarint() + r2.pos), e2.filter = "delta_filter") : 2 === t2 ? (r2.readVarint(), e2.filter = "zigzag_filter") : 3 === t2 ? (r2.readVarint(), e2.filter = "bitshuffle_filter") : 4 === t2 && (r2.readVarint(), e2.filter = "byteshuffle_filter");
          }
          function cv(t2, e2, r2) {
            1 === t2 && (e2.blockSize = r2.readVarint());
          }
          function hv(t2, e2, r2) {
            1 === t2 ? (r2.readVarint(), e2.codec = "gzip_data") : 2 === t2 ? (r2.readVarint(), e2.codec = "jpeg_image") : 3 === t2 ? (r2.readVarint(), e2.codec = "webp_image") : 4 === t2 && (r2.readVarint(), e2.codec = "png_image");
          }
          function pv(t2, e2, r2) {
            let n2 = 0, i2 = 0;
            1 === t2 ? e2.firstByte = r2.readFixed64() : 2 === t2 ? e2.lastByte = r2.readFixed64() : 3 === t2 ? e2.filters.push(function(t3, e3) {
              return t3.readFields(uv, {}, e3);
            }(r2, r2.readVarint() + r2.pos)) : 4 === t2 ? e2.codec = function(t3, e3) {
              return t3.readFields(hv, {}, e3);
            }(r2, r2.readVarint() + r2.pos) : 5 === t2 ? i2 = r2.readFloat() : 6 === t2 ? n2 = r2.readFloat() : 7 === t2 ? e2.bands.push(r2.readString()) : 8 === t2 ? e2.offset = r2.readDouble() : 9 === t2 && (e2.scale = r2.readDouble()), 0 === e2.offset && (e2.offset = i2), 0 === e2.scale && (e2.scale = n2);
          }
          function fv(t2, e2, r2) {
            1 === t2 ? e2.version = r2.readVarint() : 2 === t2 ? e2.name = r2.readString() : 3 === t2 ? e2.units = r2.readString() : 4 === t2 ? e2.tileSize = r2.readVarint() : 5 === t2 ? e2.buffer = r2.readVarint() : 6 === t2 ? e2.pixelFormat = r2.readVarint() : 7 === t2 && e2.dataIndex.push(function(t3, e3) {
              return t3.readFields(pv, { firstByte: 0, lastByte: 0, filters: [], codec: null, offset: 0, scale: 0, bands: [] }, e3);
            }(r2, r2.readVarint() + r2.pos));
          }
          function dv(t2, e2, r2) {
            if (2 === t2) !function(t3, e3, r3) {
              t3.readFields(mv, r3, e3);
            }(r2, r2.readVarint() + r2.pos, e2);
            else if (3 === t2) throw new Error("Not implemented");
          }
          function mv(t2, e2, r2) {
            if (1 === t2) {
              let t3 = 0;
              const n2 = r2.readVarint() + r2.pos;
              for (; r2.pos < n2; ) e2[t3++] = r2.readVarint();
            }
          }
          function yv(t2, e2) {
            if (4 !== e2.length) throw new Error(`Expected data of dimension 4 but got ${e2.length}.`);
            let r2 = e2[3];
            for (let n2 = 2; n2 >= 1; n2--) {
              const i2 = 1 === n2 ? 1 : 0, s2 = 2 === n2 ? 1 : 0;
              for (let n3 = 0; n3 < e2[0]; n3++) {
                const o2 = e2[1] * n3;
                for (let n4 = i2; n4 < e2[1]; n4++) {
                  const i3 = e2[2] * (n4 + o2);
                  for (let n5 = s2; n5 < e2[2]; n5++) {
                    const s3 = e2[3] * (n5 + i3);
                    for (let n6 = 0; n6 < e2[3]; n6++) {
                      const e3 = s3 + n6;
                      t2[e3] += t2[e3 - r2];
                    }
                  }
                }
              }
              r2 *= e2[n2];
            }
            return t2;
          }
          function gv(t2) {
            for (let e2 = 0, r2 = t2.length; e2 < r2; e2++) t2[e2] = t2[e2] >>> 1 ^ -(1 & t2[e2]);
            return t2;
          }
          function xv(t2, e2) {
            switch (e2) {
              case "uint32":
                return t2;
              case "uint16":
                for (let e3 = 0; e3 < t2.length; e3 += 2) {
                  const r2 = t2[e3], n2 = t2[e3 + 1];
                  t2[e3] = (240 & r2) >> 4 | (61440 & r2) >> 8 | (240 & n2) << 4 | 61440 & n2, t2[e3 + 1] = 15 & r2 | (3840 & r2) >> 4 | (15 & n2) << 8 | (3840 & n2) << 4;
                }
                return t2;
              case "uint8":
                for (let e3 = 0; e3 < t2.length; e3 += 4) {
                  const r2 = t2[e3], n2 = t2[e3 + 1], i2 = t2[e3 + 2], s2 = t2[e3 + 3];
                  t2[e3 + 0] = (192 & r2) >> 6 | (192 & n2) >> 4 | (192 & i2) >> 2 | 192 & s2, t2[e3 + 1] = (48 & r2) >> 4 | (48 & n2) >> 2 | 48 & i2 | (48 & s2) << 2, t2[e3 + 2] = (12 & r2) >> 2 | 12 & n2 | (12 & i2) << 2 | (12 & s2) << 4, t2[e3 + 3] = 3 & r2 | (3 & n2) << 2 | (3 & i2) << 4 | (3 & s2) << 6;
                }
                return t2;
              default:
                throw new Error(`Invalid pixel format, "${e2}"`);
            }
          }
          js(av, "DEMData"), js(ev, "DemMinMaxQuadTree", { omit: ["dem"] });
          var vv = Uint8Array, bv = Uint16Array, _v = Int32Array, wv = new vv([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), Av = new vv([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), Mv = new vv([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Iv = function(t2, e2) {
            for (var r2 = new bv(31), n2 = 0; n2 < 31; ++n2) r2[n2] = e2 += 1 << t2[n2 - 1];
            var i2 = new _v(r2[30]);
            for (n2 = 1; n2 < 30; ++n2) for (var s2 = r2[n2]; s2 < r2[n2 + 1]; ++s2) i2[s2] = s2 - r2[n2] << 5 | n2;
            return { b: r2, r: i2 };
          }, Sv = Iv(wv, 2), zv = Sv.b, kv = Sv.r;
          zv[28] = 258, kv[258] = 28;
          for (var Ev = Iv(Av, 0).b, Pv = new bv(32768), Tv = 0; Tv < 32768; ++Tv) {
            var Bv = (43690 & Tv) >> 1 | (21845 & Tv) << 1;
            Pv[Tv] = ((65280 & (Bv = (61680 & (Bv = (52428 & Bv) >> 2 | (13107 & Bv) << 2)) >> 4 | (3855 & Bv) << 4)) >> 8 | (255 & Bv) << 8) >> 1;
          }
          var Vv = function(t2, e2, r2) {
            for (var n2 = t2.length, i2 = 0, s2 = new bv(e2); i2 < n2; ++i2) t2[i2] && ++s2[t2[i2] - 1];
            var o2, a2 = new bv(e2);
            for (i2 = 1; i2 < e2; ++i2) a2[i2] = a2[i2 - 1] + s2[i2 - 1] << 1;
            o2 = new bv(1 << e2);
            var l2 = 15 - e2;
            for (i2 = 0; i2 < n2; ++i2) if (t2[i2]) for (var u5 = i2 << 4 | t2[i2], c2 = e2 - t2[i2], h2 = a2[t2[i2] - 1]++ << c2, p2 = h2 | (1 << c2) - 1; h2 <= p2; ++h2) o2[Pv[h2] >> l2] = u5;
            return o2;
          }, Cv = new vv(288);
          for (Tv = 0; Tv < 144; ++Tv) Cv[Tv] = 8;
          for (Tv = 144; Tv < 256; ++Tv) Cv[Tv] = 9;
          for (Tv = 256; Tv < 280; ++Tv) Cv[Tv] = 7;
          for (Tv = 280; Tv < 288; ++Tv) Cv[Tv] = 8;
          var Dv = new vv(32);
          for (Tv = 0; Tv < 32; ++Tv) Dv[Tv] = 5;
          var Fv = Vv(Cv, 9), Lv = Vv(Dv, 5), Rv = function(t2) {
            for (var e2 = t2[0], r2 = 1; r2 < t2.length; ++r2) t2[r2] > e2 && (e2 = t2[r2]);
            return e2;
          }, Ov = function(t2, e2, r2) {
            var n2 = e2 / 8 | 0;
            return (t2[n2] | t2[n2 + 1] << 8) >> (7 & e2) & r2;
          }, Uv = function(t2, e2) {
            var r2 = e2 / 8 | 0;
            return (t2[r2] | t2[r2 + 1] << 8 | t2[r2 + 2] << 16) >> (7 & e2);
          }, Nv = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], jv = function(t2, e2, r2) {
            var n2 = new Error(e2 || Nv[t2]);
            if (n2.code = t2, Error.captureStackTrace && Error.captureStackTrace(n2, jv), !r2) throw n2;
            return n2;
          }, $v = new vv(0), Gv = "undefined" != typeof TextDecoder && new TextDecoder();
          try {
            Gv.decode($v, { stream: true });
          } catch (t2) {
          }
          const qv = { gzip_data: "gzip" };
          class Hv extends Error {
            constructor(t2) {
              super(t2), this.name = "MRTError";
            }
          }
          const Xv = { 0: "uint32", 1: "uint32", 2: "uint16", 3: "uint8" }, Zv = { uint32: 1, uint16: 2, uint8: 4 }, Wv = { uint32: Uint32Array, uint16: Uint16Array, uint8: Uint8Array };
          let Yv;
          class Kv {
            constructor(t2 = 5) {
              this.x = NaN, this.y = NaN, this.z = NaN, this.layers = {}, this._cacheSize = t2;
            }
            getLayer(t2) {
              const e2 = this.layers[t2];
              if (!e2) throw new Hv(`Layer '${t2}' not found`);
              return e2;
            }
            getHeaderLength(t2) {
              const e2 = new Uint8Array(t2), r2 = new DataView(t2);
              if (13 !== e2[0]) throw new Hv("File is not a valid MRT.");
              return r2.getUint32(1, true);
            }
            parseHeader(t2) {
              const e2 = new Uint8Array(t2), r2 = this.getHeaderLength(t2);
              if (e2.length < r2) throw new Hv(`Expected header with length >= ${r2} but got buffer of length ${e2.length}`);
              const n2 = function(t3, e3) {
                return t3.readFields(lv, { headerLength: 0, x: 0, y: 0, z: 0, layers: [] }, void 0);
              }(new Yv(e2.subarray(0, r2)));
              if (!isNaN(this.x) && (this.x !== n2.x || this.y !== n2.y || this.z !== n2.z)) throw new Hv(`Invalid attempt to parse header ${n2.z}/${n2.x}/${n2.y} for tile ${this.z}/${this.x}/${this.y}`);
              this.x = n2.x, this.y = n2.y, this.z = n2.z;
              for (const t3 of n2.layers) this.layers[t3.name] = new Jv(t3, { cacheSize: this._cacheSize });
              return this;
            }
            createDecodingTask(t2) {
              const e2 = [], r2 = this.getLayer(t2.layerName);
              for (let n2 of t2.blockIndices) {
                const i2 = r2.dataIndex[n2], s2 = i2.firstByte - t2.firstByte, o2 = i2.lastByte - t2.firstByte;
                if (r2._blocksInProgress.has(n2)) continue;
                const a2 = { layerName: r2.name, firstByte: s2, lastByte: o2, pixelFormat: r2.pixelFormat, blockIndex: n2, blockShape: [i2.bands.length].concat(r2.bandShape), buffer: r2.buffer, codec: i2.codec.codec, filters: i2.filters.map((t3) => t3.filter) };
                r2._blocksInProgress.add(n2), e2.push(a2);
              }
              return new Qv(e2, () => {
                e2.forEach((t3) => r2._blocksInProgress.delete(t3.blockIndex));
              }, (t3, n2) => {
                if (e2.forEach((t4) => r2._blocksInProgress.delete(t4.blockIndex)), t3) throw t3;
                n2.forEach((t4) => {
                  this.getLayer(t4.layerName).processDecodedData(t4);
                });
              });
            }
          }
          class Jv {
            constructor({ version: t2, name: e2, units: r2, tileSize: n2, pixelFormat: i2, buffer: s2, dataIndex: o2 }, a2) {
              if (this.version = t2, 1 !== this.version) throw new Hv(`Cannot parse raster layer encoded with MRT version ${t2}`);
              this.name = e2, this.units = r2, this.tileSize = n2, this.buffer = s2, this.pixelFormat = Xv[i2], this.dataIndex = o2, this.bandShape = [n2 + 2 * s2, n2 + 2 * s2, Zv[this.pixelFormat]], this._decodedBlocks = new Zx(a2 ? a2.cacheSize : 5), this._blocksInProgress = /* @__PURE__ */ new Set();
            }
            get dimension() {
              return Zv[this.pixelFormat];
            }
            get cacheSize() {
              return this._decodedBlocks.capacity;
            }
            getBandList() {
              return this.dataIndex.map(({ bands: t2 }) => t2).flat();
            }
            processDecodedData(t2) {
              const e2 = t2.blockIndex.toString();
              this._decodedBlocks.get(e2) || this._decodedBlocks.put(e2, t2.data);
            }
            getBlockForBand(t2) {
              let e2 = 0;
              switch (typeof t2) {
                case "string":
                  for (const [r2, n2] of this.dataIndex.entries()) {
                    for (const [i2, s2] of n2.bands.entries()) if (s2 === t2) return { bandIndex: e2 + i2, blockIndex: r2, blockBandIndex: i2 };
                    e2 += n2.bands.length;
                  }
                  break;
                case "number":
                  for (const [r2, n2] of this.dataIndex.entries()) {
                    if (t2 >= e2 && t2 < e2 + n2.bands.length) return { bandIndex: t2, blockIndex: r2, blockBandIndex: t2 - e2 };
                    e2 += n2.bands.length;
                  }
                  break;
                default:
                  throw new Hv(`Invalid band \`${JSON.stringify(t2)}\`. Expected string or integer.`);
              }
              return { blockIndex: -1, blockBandIndex: -1 };
            }
            getDataRange(t2) {
              let e2 = 1 / 0, r2 = -1 / 0;
              const n2 = [], i2 = /* @__PURE__ */ new Set();
              for (const s2 of t2) {
                const { blockIndex: t3 } = this.getBlockForBand(s2);
                if (t3 < 0) throw new Hv(`Invalid band: ${JSON.stringify(s2)}`);
                const o2 = this.dataIndex[t3];
                n2.includes(t3) || n2.push(t3), i2.add(t3), e2 = Math.min(e2, o2.firstByte), r2 = Math.max(r2, o2.lastByte);
              }
              if (i2.size > this.cacheSize) throw new Hv(`Number of blocks to decode (${i2.size}) exceeds cache size (${this.cacheSize}).`);
              return { layerName: this.name, firstByte: e2, lastByte: r2, blockIndices: n2 };
            }
            hasBand(t2) {
              const { blockIndex: e2 } = this.getBlockForBand(t2);
              return e2 >= 0;
            }
            hasDataForBand(t2) {
              const { blockIndex: e2 } = this.getBlockForBand(t2);
              return e2 >= 0 && !!this._decodedBlocks.get(e2.toString());
            }
            getBandView(t2) {
              const { blockIndex: e2, blockBandIndex: r2 } = this.getBlockForBand(t2);
              if (e2 < 0) throw new Hv(`Band not found: ${JSON.stringify(t2)}`);
              const n2 = this._decodedBlocks.get(e2.toString());
              if (!n2) throw new Hv(`Data for band ${JSON.stringify(t2)} of layer "${this.name}" not decoded.`);
              const i2 = this.dataIndex[e2], s2 = this.bandShape.reduce((t3, e3) => t3 * e3, 1), o2 = r2 * s2, a2 = n2.subarray(o2, o2 + s2);
              return { data: a2, bytes: new Uint8Array(a2.buffer).subarray(a2.byteOffset, a2.byteOffset + a2.byteLength), tileSize: this.tileSize, buffer: this.buffer, pixelFormat: this.pixelFormat, dimension: this.dimension, offset: i2.offset, scale: i2.scale };
            }
          }
          Kv.setPbf = function(t2) {
            Yv = t2;
          };
          class Qv {
            constructor(t2, e2, r2) {
              this.tasks = t2, this._onCancel = e2, this._onComplete = r2, this._finalized = false;
            }
            cancel() {
              this._finalized || (this._onCancel(), this._finalized = true);
            }
            complete(t2, e2) {
              this._finalized || (this._onComplete(t2, e2), this._finalized = true);
            }
          }
          Kv.performDecoding = function(t2, e2) {
            const r2 = new Uint8Array(t2);
            return Promise.all(e2.tasks.map((t3) => {
              const { layerName: e3, firstByte: n2, lastByte: i2, pixelFormat: s2, blockShape: o2, blockIndex: a2, filters: l2, codec: u5 } = t3, c2 = r2.subarray(n2, i2 + 1), h2 = new Uint32Array(o2[0] * o2[1] * o2[2]);
              let p2;
              if ("gzip_data" !== u5) throw new Hv(`Unhandled codec: ${u5}`);
              return p2 = function(t4, e4) {
                if (!globalThis.DecompressionStream && "gzip_data" === e4) return Promise.resolve(((s3 = function(t5) {
                  31 == t5[0] && 139 == t5[1] && 8 == t5[2] || jv(6, "invalid gzip data");
                  var e5 = t5[3], r4 = 10;
                  4 & e5 && (r4 += 2 + (t5[10] | t5[11] << 8));
                  for (var n4 = (e5 >> 3 & 1) + (e5 >> 4 & 1); n4 > 0; n4 -= !t5[r4++]) ;
                  return r4 + (2 & e5);
                }(i3 = t4)) + 8 > i3.length && jv(6, "invalid gzip data"), function(t5, e5, r4, n4) {
                  var i4 = t5.length;
                  if (!i4 || e5.f && !e5.l) return r4 || new vv(0);
                  var s4 = !r4, o4 = s4 || 2 != e5.i, a4 = e5.i;
                  s4 && (r4 = new vv(3 * i4));
                  var l3, u6, c3 = function(t6) {
                    var e6 = r4.length;
                    if (t6 > e6) {
                      var n5 = new vv(Math.max(2 * e6, t6));
                      n5.set(r4), r4 = n5;
                    }
                  }, h3 = e5.f || 0, p3 = e5.p || 0, f2 = e5.b || 0, d2 = e5.l, m2 = e5.d, y2 = e5.m, g2 = e5.n, x2 = 8 * i4;
                  do {
                    if (!d2) {
                      h3 = Ov(t5, p3, 1);
                      var v3 = Ov(t5, p3 + 1, 3);
                      if (p3 += 3, !v3) {
                        var b2 = t5[(T2 = 4 + ((p3 + 7) / 8 | 0)) - 4] | t5[T2 - 3] << 8, _2 = T2 + b2;
                        if (_2 > i4) {
                          a4 && jv(0);
                          break;
                        }
                        o4 && c3(f2 + b2), r4.set(t5.subarray(T2, _2), f2), e5.b = f2 += b2, e5.p = p3 = 8 * _2, e5.f = h3;
                        continue;
                      }
                      if (1 == v3) d2 = Fv, m2 = Lv, y2 = 9, g2 = 5;
                      else if (2 == v3) {
                        var w2 = Ov(t5, p3, 31) + 257, A2 = Ov(t5, p3 + 10, 15) + 4, M2 = w2 + Ov(t5, p3 + 5, 31) + 1;
                        p3 += 14;
                        for (var I2 = new vv(M2), S2 = new vv(19), z2 = 0; z2 < A2; ++z2) S2[Mv[z2]] = Ov(t5, p3 + 3 * z2, 7);
                        p3 += 3 * A2;
                        var k2 = Rv(S2), E2 = (1 << k2) - 1, P2 = Vv(S2, k2);
                        for (z2 = 0; z2 < M2; ) {
                          var T2, B3 = P2[Ov(t5, p3, E2)];
                          if (p3 += 15 & B3, (T2 = B3 >> 4) < 16) I2[z2++] = T2;
                          else {
                            var V2 = 0, C3 = 0;
                            for (16 == T2 ? (C3 = 3 + Ov(t5, p3, 3), p3 += 2, V2 = I2[z2 - 1]) : 17 == T2 ? (C3 = 3 + Ov(t5, p3, 7), p3 += 3) : 18 == T2 && (C3 = 11 + Ov(t5, p3, 127), p3 += 7); C3--; ) I2[z2++] = V2;
                          }
                        }
                        var D3 = I2.subarray(0, w2), F2 = I2.subarray(w2);
                        y2 = Rv(D3), g2 = Rv(F2), d2 = Vv(D3, y2), m2 = Vv(F2, g2);
                      } else jv(1);
                      if (p3 > x2) {
                        a4 && jv(0);
                        break;
                      }
                    }
                    o4 && c3(f2 + 131072);
                    for (var L2 = (1 << y2) - 1, R2 = (1 << g2) - 1, O2 = p3; ; O2 = p3) {
                      var U2 = (V2 = d2[Uv(t5, p3) & L2]) >> 4;
                      if ((p3 += 15 & V2) > x2) {
                        a4 && jv(0);
                        break;
                      }
                      if (V2 || jv(2), U2 < 256) r4[f2++] = U2;
                      else {
                        if (256 == U2) {
                          O2 = p3, d2 = null;
                          break;
                        }
                        var N2 = U2 - 254;
                        U2 > 264 && (N2 = Ov(t5, p3, (1 << (G2 = wv[z2 = U2 - 257])) - 1) + zv[z2], p3 += G2);
                        var j2 = m2[Uv(t5, p3) & R2], $2 = j2 >> 4;
                        if (j2 || jv(3), p3 += 15 & j2, F2 = Ev[$2], $2 > 3) {
                          var G2 = Av[$2];
                          F2 += Uv(t5, p3) & (1 << G2) - 1, p3 += G2;
                        }
                        if (p3 > x2) {
                          a4 && jv(0);
                          break;
                        }
                        o4 && c3(f2 + 131072);
                        var q2 = f2 + N2;
                        if (f2 < F2) {
                          var H2 = 0 - F2, X2 = Math.min(F2, q2);
                          for (H2 + f2 < 0 && jv(3); f2 < X2; ++f2) r4[f2] = (void 0)[H2 + f2];
                        }
                        for (; f2 < q2; ++f2) r4[f2] = r4[f2 - F2];
                      }
                    }
                    e5.l = d2, e5.p = O2, e5.b = f2, e5.f = h3, d2 && (h3 = 1, e5.m = y2, e5.d = m2, e5.n = g2);
                  } while (!h3);
                  return f2 != r4.length && s4 ? (l3 = r4, (null == (u6 = f2) || u6 > l3.length) && (u6 = l3.length), new vv(l3.subarray(0, u6))) : r4.subarray(0, f2);
                }(i3.subarray(s3, -8), { i: 2 }, new vv(((r3 = i3)[(n3 = r3.length) - 4] | r3[n3 - 3] << 8 | r3[n3 - 2] << 16 | r3[n3 - 1] << 24) >>> 0))));
                var r3, n3, i3, s3;
                const o3 = qv[e4];
                if (!o3) throw new Error(`Unhandled codec: ${e4}`);
                const a3 = new globalThis.DecompressionStream(o3);
                return new Response(new Blob([t4]).stream().pipeThrough(a3)).arrayBuffer().then((t5) => new Uint8Array(t5));
              }(c2, u5).then((t4) => (function(t5, e4) {
                t5.readFields(dv, e4);
              }(new Yv(t4), h2), new (0, Wv[s2])(h2.buffer))), p2.then((t4) => {
                for (let e4 = l2.length - 1; e4 >= 0; e4--) switch (l2[e4]) {
                  case "delta_filter":
                    yv(t4, o2);
                    break;
                  case "zigzag_filter":
                    gv(t4);
                    break;
                  case "bitshuffle_filter":
                    xv(t4, s2);
                    break;
                  default:
                    throw new Hv(`Unhandled filter "${l2[e4]}"`);
                }
                return { layerName: e3, blockIndex: a2, data: t4 };
              }).catch((t4) => {
                throw t4;
              });
            }));
          }, js(Qv, "MRTDecodingBatch", { omit: ["_onCancel", "_onComplete"] }), js(Kv, "MapboxRasterTile"), js(Jv, "MapboxRasterLayer", { omit: ["_blocksInProgress"] });
          let tb, eb2, rb, nb, ib, sb = null;
          function ob() {
            return Xt(self) && self.worker.dracoUrl ? self.worker.dracoUrl : eb2 || re.DRACO_URL;
          }
          function ab4() {
            if (Xt(self) && self.worker.meshoptUrl) return self.worker.meshoptUrl;
            if (nb) return nb;
            const t2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]);
            if ("object" != typeof WebAssembly) throw new Error("WebAssembly not supported, cannot instantiate meshoptimizer");
            return nb = WebAssembly.validate(t2) ? re.MESHOPT_SIMD_URL : re.MESHOPT_URL, nb;
          }
          const lb = { 5120: Int8Array, 5121: Uint8Array, 5122: Int16Array, 5123: Uint16Array, 5125: Uint32Array, 5126: Float32Array }, ub = { 5120: "DT_INT8", 5121: "DT_UINT8", 5122: "DT_INT16", 5123: "DT_UINT16", 5125: "DT_UINT32", 5126: "DT_FLOAT32" }, cb = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 };
          function hb(t2, e2, r2) {
            const n2 = r2.json.bufferViews.length, i2 = r2.buffers.length;
            e2.bufferView = n2, r2.json.bufferViews[n2] = { buffer: i2, byteLength: t2.byteLength }, r2.buffers[i2] = t2;
          }
          const pb = "KHR_draco_mesh_compression";
          function fb(t2, e2) {
            const r2 = t2.extensions && t2.extensions[pb];
            if (!r2) return;
            const n2 = new rb.Decoder(), i2 = bb2(e2, r2.bufferView), s2 = new rb.Mesh();
            if (!n2.DecodeArrayToMesh(i2, i2.byteLength, s2)) throw new Error("Failed to decode Draco mesh");
            const o2 = e2.json.accessors[t2.indices], a2 = lb[o2.componentType], l2 = o2.count * a2.BYTES_PER_ELEMENT, u5 = rb._malloc(l2);
            a2 === Uint16Array ? n2.GetTrianglesUInt16Array(s2, l2, u5) : n2.GetTrianglesUInt32Array(s2, l2, u5), hb(rb.memory.buffer.slice(u5, u5 + l2), o2, e2), rb._free(u5);
            for (const i3 of Object.keys(r2.attributes)) {
              const o3 = n2.GetAttributeByUniqueId(s2, r2.attributes[i3]), a3 = e2.json.accessors[t2.attributes[i3]], l3 = ub[a3.componentType], u6 = a3.count * cb[a3.type] * lb[a3.componentType].BYTES_PER_ELEMENT, c2 = rb._malloc(u6);
              n2.GetAttributeDataArrayForAllPoints(s2, o3, rb[l3], u6, c2), hb(rb.memory.buffer.slice(c2, c2 + u6), a3, e2), rb._free(c2);
            }
            n2.destroy(), s2.destroy(), delete t2.extensions[pb];
          }
          const db = "EXT_meshopt_compression";
          function mb(t2, e2) {
            if (!t2.extensions || !t2.extensions[db]) return;
            const r2 = t2.extensions[db], n2 = new Uint8Array(e2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength || 0), i2 = new Uint8Array(r2.count * r2.byteStride);
            ib.decodeGltfBuffer(i2, r2.count, r2.byteStride, n2, r2.mode, r2.filter), t2.buffer = e2.buffers.length, t2.byteOffset = 0, e2.buffers[t2.buffer] = i2.buffer, delete t2.extensions[db];
          }
          const yb = 1179937895, gb = new TextDecoder("utf8");
          function xb(t2, e2) {
            return new URL(t2, e2).href;
          }
          function vb(t2, e2, r2, n2) {
            return fetch(xb(t2.uri, n2)).then((t3) => t3.arrayBuffer()).then((t3) => {
              e2.buffers[r2] = t3;
            });
          }
          function bb2(t2, e2) {
            const r2 = t2.json.bufferViews[e2];
            return new Uint8Array(t2.buffers[r2.buffer], r2.byteOffset || 0, r2.byteLength);
          }
          function _b(t2, e2, r2, n2) {
            if (t2.uri) {
              const i2 = xb(t2.uri, n2);
              return fetch(i2).then((t3) => t3.blob()).then((t3) => createImageBitmap(t3)).then((t3) => {
                e2.images[r2] = t3;
              });
            }
            if (void 0 !== t2.bufferView) {
              const n3 = bb2(e2, t2.bufferView), i2 = new Blob([n3], { type: t2.mimeType });
              return createImageBitmap(i2).then((t3) => {
                e2.images[r2] = t3;
              });
            }
          }
          function wb(t2, e2 = 0, r2) {
            const n2 = { json: null, images: [], buffers: [] };
            if (new Uint32Array(t2, e2, 1)[0] === yb) {
              const r3 = new Uint32Array(t2, e2);
              let i3 = 2;
              const s3 = (r3[i3++] >> 2) - 3, o3 = r3[i3++] >> 2;
              if (i3++, n2.json = JSON.parse(gb.decode(r3.subarray(i3, i3 + o3))), i3 += o3, i3 < s3) {
                const s4 = r3[i3++];
                i3++;
                const o4 = e2 + (i3 << 2);
                n2.buffers[0] = t2.slice(o4, o4 + s4);
              }
            } else n2.json = JSON.parse(gb.decode(new Uint8Array(t2, e2)));
            const { buffers: i2, images: s2, meshes: o2, extensionsUsed: a2, bufferViews: l2 } = n2.json;
            let u5 = Promise.resolve();
            if (i2) {
              const t3 = [];
              for (let e3 = 0; e3 < i2.length; e3++) {
                const s3 = i2[e3];
                s3.uri ? t3.push(vb(s3, n2, e3, r2)) : n2.buffers[e3] || (n2.buffers[e3] = null);
              }
              u5 = Promise.all(t3);
            }
            return u5.then(() => {
              const t3 = [], e3 = a2 && a2.includes(pb), i3 = a2 && a2.includes(db);
              if (e3 && t3.push(function() {
                if (!rb) return null != tb ? tb : (tb = function(t4) {
                  let e4, r3 = null;
                  function n3() {
                    e4 = new Uint8Array(r3.buffer);
                  }
                  function i4() {
                    throw new Error("Unexpected Draco error.");
                  }
                  const s3 = { a: { a: i4, d: function(t5, r4, n4) {
                    return e4.copyWithin(t5, r4, r4 + n4);
                  }, c: function(t5) {
                    const i5 = e4.length, s4 = Math.max(t5 >>> 0, Math.ceil(1.2 * i5)), o3 = Math.ceil((s4 - i5) / 65536);
                    try {
                      return r3.grow(o3), n3(), true;
                    } catch (t6) {
                      return false;
                    }
                  }, b: i4 } };
                  return (WebAssembly.instantiateStreaming ? WebAssembly.instantiateStreaming(t4, s3) : t4.then((t5) => t5.arrayBuffer()).then((t5) => WebAssembly.instantiate(t5, s3))).then((t5) => {
                    const { Rb: i5, Qb: s4, P: o3, T: a3, X: l3, Ja: u6, La: c2, Qa: h2, Va: p2, Wa: f2, eb: d2, jb: m2, f: y2, e: g2, yb: x2, zb: v3, Ab: b2, Bb: _2, Db: w2, Gb: A2 } = t5.instance.exports;
                    r3 = g2;
                    const M2 = /* @__PURE__ */ (() => {
                      let t6 = 0, r4 = 0, n4 = 0, o4 = 0;
                      return (a4) => {
                        n4 && (i5(o4), i5(t6), r4 += n4, n4 = t6 = 0), t6 || (r4 += 128, t6 = s4(r4));
                        const l4 = a4.length + 7 & -8;
                        let u7 = t6;
                        l4 >= r4 && (n4 = l4, u7 = o4 = s4(l4));
                        for (let t7 = 0; t7 < a4.length; t7++) e4[u7 + t7] = a4[t7];
                        return u7;
                      };
                    })();
                    return n3(), y2(), { memory: g2, _free: i5, _malloc: s4, Mesh: class {
                      constructor() {
                        this.ptr = o3();
                      }
                      destroy() {
                        a3(this.ptr);
                      }
                    }, Decoder: class {
                      constructor() {
                        this.ptr = u6();
                      }
                      destroy() {
                        m2(this.ptr);
                      }
                      DecodeArrayToMesh(t6, e5, r4) {
                        const n4 = M2(t6), i6 = c2(this.ptr, n4, e5, r4.ptr);
                        return !!l3(i6);
                      }
                      GetAttributeByUniqueId(t6, e5) {
                        return { ptr: h2(this.ptr, t6.ptr, e5) };
                      }
                      GetTrianglesUInt16Array(t6, e5, r4) {
                        p2(this.ptr, t6.ptr, e5, r4);
                      }
                      GetTrianglesUInt32Array(t6, e5, r4) {
                        f2(this.ptr, t6.ptr, e5, r4);
                      }
                      GetAttributeDataArrayForAllPoints(t6, e5, r4, n4, i6) {
                        d2(this.ptr, t6.ptr, e5.ptr, r4, n4, i6);
                      }
                    }, DT_INT8: x2(), DT_UINT8: v3(), DT_INT16: b2(), DT_UINT16: _2(), DT_UINT32: w2(), DT_FLOAT32: A2() };
                  });
                }(fetch(ob())), tb.then((t4) => {
                  rb = t4, tb = void 0;
                }));
              }()), i3 && t3.push(function() {
                if (ib) return;
                const t4 = function(t5) {
                  let e4;
                  const r3 = WebAssembly.instantiateStreaming(t5, {}).then((t6) => {
                    e4 = t6.instance, e4.exports.__wasm_call_ctors();
                  }), n3 = { NONE: "", OCTAHEDRAL: "meshopt_decodeFilterOct", QUATERNION: "meshopt_decodeFilterQuat", EXPONENTIAL: "meshopt_decodeFilterExp" }, i4 = { ATTRIBUTES: "meshopt_decodeVertexBuffer", TRIANGLES: "meshopt_decodeIndexBuffer", INDICES: "meshopt_decodeIndexSequence" };
                  return { ready: r3, supported: true, decodeGltfBuffer(t6, r4, s3, o3, a3, l3) {
                    !function(t7, e5, r5, n4, i5, s4, o4) {
                      const a4 = t7.exports.sbrk, l4 = n4 + 3 & -4, u6 = a4(l4 * i5), c2 = a4(s4.length), h2 = new Uint8Array(t7.exports.memory.buffer);
                      h2.set(s4, c2);
                      const p2 = e5(u6, n4, i5, c2, s4.length);
                      if (0 === p2 && o4 && o4(u6, l4, i5), r5.set(h2.subarray(u6, u6 + n4 * i5)), a4(u6 - a4(0)), 0 !== p2) throw new Error(`Malformed buffer data: ${p2}`);
                    }(e4, e4.exports[i4[a3]], t6, r4, s3, o3, e4.exports[n3[l3]]);
                  } };
                }(fetch(ab4()));
                return t4.ready.then(() => {
                  ib = t4;
                });
              }()), s2) for (let e4 = 0; e4 < s2.length; e4++) t3.push(_b(s2[e4], n2, e4, r2));
              return (t3.length ? Promise.all(t3) : Promise.resolve()).then(() => {
                if (e3 && o2) for (const { primitives: t4 } of o2) for (const e4 of t4) fb(e4, n2);
                if (i3 && o2 && l2) for (const t4 of l2) mb(t4, n2);
                return n2;
              });
            });
          }
          function Ab(t2, e2) {
            const r2 = t2.json.bufferViews[e2.bufferView], n2 = lb[e2.componentType];
            return new n2(t2.buffers[r2.buffer], (e2.byteOffset || 0) + (r2.byteOffset || 0), e2.count * (r2.byteStride && r2.byteStride !== cb[e2.type] * n2.BYTES_PER_ELEMENT ? r2.byteStride / n2.BYTES_PER_ELEMENT : cb[e2.type]));
          }
          function Mb(t2, e2, r2, n2) {
            const i2 = lb[e2.componentType], s2 = function(t3) {
              switch (t3) {
                case Int8Array:
                  return 1 / 127;
                case Uint8Array:
                  return 1 / 255;
                case Int16Array:
                  return 1 / 32767;
                case Uint16Array:
                  return 1 / 65535;
                default:
                  return 1;
              }
            }(i2), o2 = t2.json.bufferViews[e2.bufferView], a2 = o2.byteStride ? o2.byteStride / i2.BYTES_PER_ELEMENT : cb[e2.type], l2 = r2.float32, u5 = l2.length / r2.capacity;
            for (let t3 = 0, r3 = 0; t3 < e2.count * a2; t3 += a2, r3 += u5) for (let e3 = 0; e3 < u5; e3++) l2[r3 + e3] = n2[t3 + e3] * s2;
            r2._trim();
          }
          function Ib(t2, e2, r2) {
            const n2 = t2.indices, i2 = t2.attributes, s2 = {};
            s2.indexArray = new wa();
            const o2 = e2.json.accessors[n2], a2 = o2.count / 3;
            s2.indexArray.reserve(a2);
            const l2 = Ab(e2, o2);
            for (let t3 = 0; t3 < a2; t3++) s2.indexArray.emplaceBack(l2[3 * t3], l2[3 * t3 + 1], l2[3 * t3 + 2]);
            s2.indexArray._trim(), s2.vertexArray = new ua();
            const u5 = e2.json.accessors[i2.POSITION];
            s2.vertexArray.reserve(u5.count);
            const c2 = Ab(e2, u5);
            for (let t3 = 0; t3 < u5.count; t3++) s2.vertexArray.emplaceBack(c2[3 * t3], c2[3 * t3 + 1], c2[3 * t3 + 2]);
            if (s2.vertexArray._trim(), s2.aabb = new ic(u5.min, u5.max), s2.centroid = function(t3, e3) {
              const r3 = [0, 0, 0], n3 = t3.length;
              if (n3 > 0) {
                for (let i3 = 0; i3 < n3; i3++) {
                  const n4 = 3 * t3[i3];
                  r3[0] += e3[n4], r3[1] += e3[n4 + 1], r3[2] += e3[n4 + 2];
                }
                r3[0] /= n3, r3[1] /= n3, r3[2] /= n3;
              }
              return r3;
            }(l2, c2), void 0 !== i2.COLOR_0) {
              const t3 = e2.json.accessors[i2.COLOR_0], r3 = cb[t3.type], n3 = Ab(e2, t3);
              s2.colorArray = 3 === r3 ? new ua() : new ma(), s2.colorArray.resize(t3.count), Mb(e2, t3, s2.colorArray, n3);
            }
            if (void 0 !== i2.NORMAL) {
              s2.normalArray = new ua();
              const t3 = e2.json.accessors[i2.NORMAL];
              s2.normalArray.resize(t3.count);
              const r3 = Ab(e2, t3);
              Mb(e2, t3, s2.normalArray, r3);
            }
            if (void 0 !== i2.TEXCOORD_0 && r2.length > 0) {
              s2.texcoordArray = new Ea();
              const t3 = e2.json.accessors[i2.TEXCOORD_0];
              s2.texcoordArray.resize(t3.count);
              const r3 = Ab(e2, t3);
              Mb(e2, t3, s2.texcoordArray, r3);
            }
            if (void 0 !== i2._FEATURE_ID_RGBA4444) {
              const t3 = e2.json.accessors[i2._FEATURE_ID_RGBA4444];
              e2.json.extensionsUsed && e2.json.extensionsUsed.includes("EXT_meshopt_compression") && (s2.featureData = Ab(e2, t3));
            }
            void 0 !== i2._FEATURE_RGBA4444 && (s2.featureData = new Uint32Array(Ab(e2, e2.json.accessors[i2._FEATURE_RGBA4444]).buffer));
            const h2 = t2.material;
            return s2.material = function(t3, e3) {
              const { emissiveFactor: r3 = [0, 0, 0], alphaMode: n3 = "OPAQUE", alphaCutoff: i3 = 0.5, normalTexture: s3, occlusionTexture: o3, emissiveTexture: a3, doubleSided: l3 } = t3, { baseColorFactor: u6 = [1, 1, 1, 1], metallicFactor: c3 = 1, roughnessFactor: h3 = 1, baseColorTexture: p2, metallicRoughnessTexture: f2 } = t3.pbrMetallicRoughness || {}, d2 = o3 ? e3[o3.index] : void 0;
              if (o3 && o3.extensions && o3.extensions.KHR_texture_transform && d2) {
                const t4 = o3.extensions.KHR_texture_transform;
                d2.offsetScale = [t4.offset[0], t4.offset[1], t4.scale[0], t4.scale[1]];
              }
              return { pbrMetallicRoughness: { baseColorFactor: new ir(...u6), metallicFactor: c3, roughnessFactor: h3, baseColorTexture: p2 ? e3[p2.index] : void 0, metallicRoughnessTexture: f2 ? e3[f2.index] : void 0 }, doubleSided: l3, emissiveFactor: r3, alphaMode: n3, alphaCutoff: i3, normalTexture: s3 ? e3[s3.index] : void 0, occlusionTexture: d2, emissionTexture: a3 ? e3[a3.index] : void 0, defined: void 0 === t3.defined };
            }(void 0 !== h2 ? e2.json.materials[h2] : { defined: false }, r2), s2;
          }
          function Sb(t2, e2, r2) {
            const { matrix: n2, rotation: i2, translation: s2, scale: o2, mesh: a2, extras: l2, children: u5 } = t2, c2 = {};
            if (c2.matrix = n2 || function(t3, e3, r3, n3) {
              var i3 = e3[0], s3 = e3[1], o3 = e3[2], a3 = e3[3], l3 = i3 + i3, u6 = s3 + s3, c3 = o3 + o3, h2 = i3 * l3, p2 = i3 * u6, f2 = i3 * c3, d2 = s3 * u6, m2 = s3 * c3, y2 = o3 * c3, g2 = a3 * l3, x2 = a3 * u6, v3 = a3 * c3, b2 = n3[0], _2 = n3[1], w2 = n3[2];
              return t3[0] = (1 - (d2 + y2)) * b2, t3[1] = (p2 + v3) * b2, t3[2] = (f2 - x2) * b2, t3[3] = 0, t3[4] = (p2 - v3) * _2, t3[5] = (1 - (h2 + y2)) * _2, t3[6] = (m2 + g2) * _2, t3[7] = 0, t3[8] = (f2 + x2) * w2, t3[9] = (m2 - g2) * w2, t3[10] = (1 - (h2 + d2)) * w2, t3[11] = 0, t3[12] = r3[0], t3[13] = r3[1], t3[14] = r3[2], t3[15] = 1, t3;
            }([], i2 || [0, 0, 0, 1], s2 || [0, 0, 0], o2 || [1, 1, 1]), void 0 !== a2) {
              c2.meshes = r2[a2];
              const t3 = c2.anchor = [0, 0];
              for (const e3 of c2.meshes) {
                const { min: r3, max: n3 } = e3.aabb;
                t3[0] += r3[0] + n3[0], t3[1] += r3[1] + n3[1];
              }
              t3[0] = Math.floor(t3[0] / c2.meshes.length / 2), t3[1] = Math.floor(t3[1] / c2.meshes.length / 2);
            }
            if (l2 && (l2.id && (c2.id = l2.id), l2.lights && (c2.lights = function(t3) {
              if (!t3.length) return [];
              const e3 = function(t4) {
                const e4 = atob(t4), r4 = new Uint8Array(e4.length);
                for (let t5 = 0; t5 < e4.length; t5++) r4[t5] = e4.codePointAt(t5);
                return r4;
              }(t3), r3 = [], n3 = e3.length / 24, i3 = new Uint16Array(e3.buffer), s3 = new Float32Array(e3.buffer);
              for (let t4 = 0; t4 < n3; t4++) {
                const e4 = i3[2 * t4 * 6] / 30, n4 = i3[2 * t4 * 6 + 1] / 30, o3 = i3[2 * t4 * 6 + 10] / 100, a3 = s3[6 * t4 + 1], l3 = s3[6 * t4 + 2], u6 = s3[6 * t4 + 3], c3 = s3[6 * t4 + 4], h2 = u6 - a3, p2 = c3 - l3, f2 = Math.hypot(h2, p2);
                r3.push({ pos: [a3 + 0.5 * h2, l3 + 0.5 * p2, n4], normal: [p2 / f2, -h2 / f2, 0], width: f2, height: e4, depth: o3, points: [a3, l3, u6, c3] });
              }
              return r3;
            }(l2.lights))), u5) {
              const t3 = [];
              for (const n3 of u5) t3.push(Sb(e2.json.nodes[n3], e2, r2));
              c2.children = t3;
            }
            return c2;
          }
          function zb(t2) {
            if (0 === t2.vertices.length || 0 === t2.indices.length) return null;
            const e2 = new gp(t2.vertices, t2.indices, 8, 256), [r2, n2] = [e2.min.clone(), e2.max.clone()];
            return { vertices: t2.vertices, indices: t2.indices, grid: e2, min: r2, max: n2 };
          }
          function kb(t2) {
            if (!t2.extras || !t2.extras.ground) return null;
            const e2 = t2.extras.ground;
            if (!e2 || !Array.isArray(e2) || 0 === e2.length) return null;
            const r2 = e2[0];
            if (!r2 || !Array.isArray(r2) || 0 === r2.length) return null;
            const n2 = [];
            for (const t3 of r2) {
              if (!Array.isArray(t3) || 2 !== t3.length) continue;
              const e3 = t3[0], r3 = t3[1];
              "number" == typeof e3 && "number" == typeof r3 && n2.push(new bt(e3, r3));
            }
            if (n2.length < 3) return null;
            n2.length > 1 && n2[n2.length - 1].equals(n2[0]) && n2.pop();
            let i2 = 0;
            for (let t3 = 0; t3 < n2.length; t3++) {
              const e3 = n2[t3], r3 = n2[(t3 + 1) % n2.length], s3 = n2[(t3 + 2) % n2.length];
              i2 += (e3.x - r3.x) * (s3.y - r3.y) - (s3.x - r3.x) * (e3.y - r3.y);
            }
            i2 > 0 && n2.reverse();
            const s2 = Qc(n2.flatMap((t3) => [t3.x, t3.y]), []);
            return 0 === s2.length ? null : { vertices: n2, indices: s2 };
          }
          function Eb(t2, e2) {
            const r2 = [], n2 = [];
            let i2 = 0;
            const s2 = [];
            for (const o2 of t2) {
              i2 = r2.length;
              const t3 = o2.vertexArray.float32, a2 = o2.indexArray.uint16;
              for (let n3 = 0; n3 < o2.vertexArray.length; n3++) s2[0] = t3[3 * n3 + 0], s2[1] = t3[3 * n3 + 1], s2[2] = t3[3 * n3 + 2], R(s2, s2, e2), r2.push(new bt(s2[0], s2[1]));
              for (let t4 = 0; t4 < 3 * o2.indexArray.length; t4++) n2.push(a2[t4] + i2);
            }
            if (n2.length % 3 != 0) return null;
            for (let t3 = 0; t3 < n2.length; t3 += 3) {
              const e3 = r2[n2[t3 + 0]], i3 = r2[n2[t3 + 1]], s3 = r2[n2[t3 + 2]];
              (e3.x - i3.x) * (s3.y - i3.y) - (s3.x - i3.x) * (e3.y - i3.y) > 0 && ([n2[t3 + 1], n2[t3 + 2]] = [n2[t3 + 2], n2[t3 + 1]]);
            }
            return { vertices: r2, indices: n2 };
          }
          function Pb(t2) {
            const e2 = function(t3, e3) {
              const r3 = [], n3 = WebGL2RenderingContext;
              if (t3.json.textures) for (const i3 of t3.json.textures) {
                const s3 = { magFilter: n3.LINEAR, minFilter: n3.NEAREST, wrapS: n3.REPEAT, wrapT: n3.REPEAT };
                void 0 !== i3.sampler && Object.assign(s3, t3.json.samplers[i3.sampler]), r3.push({ image: e3[i3.source], sampler: s3, uploaded: false });
              }
              return r3;
            }(t2, t2.images), r2 = function(t3, e3) {
              const r3 = [];
              for (const n3 of t3.json.meshes) {
                const i3 = [];
                for (const r4 of n3.primitives) i3.push(Ib(r4, t3, e3));
                r3.push(i3);
              }
              return r3;
            }(t2, e2), { scenes: n2, scene: i2, nodes: s2 } = t2.json, o2 = n2 ? n2[i2 || 0].nodes : s2, a2 = [];
            for (const e3 of o2) a2.push(Sb(s2[e3], t2, r2));
            return function(t3, e3, r3) {
              const n3 = {}, i3 = /* @__PURE__ */ new Set();
              for (let s3 = 0; s3 < t3.length; s3++) {
                const t4 = r3[e3[s3]];
                if (!t4.extras) continue;
                const o3 = t4.extras["mapbox:footprint:version"], a3 = t4.extras["mapbox:footprint:id"];
                (o3 || a3) && i3.add(s3), "1.0.0" === o3 && a3 && (n3[a3] = s3);
              }
              for (let s3 = 0; s3 < t3.length; s3++) {
                if (i3.has(s3)) continue;
                const o3 = t3[s3], a3 = r3[e3[s3]];
                if (!a3.extras) continue;
                let l2 = null;
                o3.id in n3 && (l2 = Eb(t3[n3[o3.id]].meshes, o3.matrix)), l2 || (l2 = kb(a3)), l2 && (o3.footprint = zb(l2));
              }
              if (i3.size > 0) {
                const e4 = Array.from(i3.values()).sort((t4, e5) => t4 - e5);
                for (let r4 = e4.length - 1; r4 >= 0; r4--) t3.splice(e4[r4], 1);
              }
            }(a2, o2, t2.json.nodes), a2;
          }
          function Tb(t2) {
            t2.heightmap = new Float32Array(4096), t2.heightmap.fill(-1);
            const e2 = t2.vertexArray.float32, r2 = t2.aabb.min[0] - 1, n2 = t2.aabb.min[1] - 1, i2 = Sg / (t2.aabb.max[0] - r2 + 2), s2 = Sg / (t2.aabb.max[1] - n2 + 2);
            for (let o2 = 0; o2 < e2.length; o2 += 3) {
              const a2 = e2[o2 + 2], l2 = (e2[o2 + 0] - r2) * i2 | 0, u5 = (e2[o2 + 1] - n2) * s2 | 0;
              a2 > t2.heightmap[u5 * Sg + l2] && (t2.heightmap[u5 * Sg + l2] = a2);
            }
          }
          function Bb(t2, e2) {
            const r2 = {};
            r2.indexArray = new wa(), r2.indexArray.reserve(4 * t2.length), r2.vertexArray = new ua(), r2.vertexArray.reserve(10 * t2.length), r2.colorArray = new ma(), r2.vertexArray.reserve(10 * t2.length);
            let n2 = 0;
            for (const i3 of t2) {
              const t3 = Math.min(10, Math.max(4, 1.3 * i3.height)) * e2, s3 = [-i3.normal[1], i3.normal[0], 0], o2 = Math.min(0.29, 0.1 * i3.width / i3.depth), a2 = i3.width - 2 * i3.depth * e2 * (o2 + 0.01), l2 = P([], i3.pos, s3, a2 / 2), u5 = P([], i3.pos, s3, -a2 / 2), c2 = [l2[0], l2[1], l2[2] + i3.height], h2 = [u5[0], u5[1], u5[2] + i3.height], p2 = P([], i3.normal, s3, o2);
              E(p2, p2, t3);
              const f2 = P([], i3.normal, s3, -o2);
              E(f2, f2, t3), M(p2, l2, p2), M(f2, u5, f2), l2[2] += 0.1, u5[2] += 0.1, r2.vertexArray.emplaceBack(p2[0], p2[1], p2[2]), r2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]), r2.vertexArray.emplaceBack(l2[0], l2[1], l2[2]), r2.vertexArray.emplaceBack(u5[0], u5[1], u5[2]), r2.vertexArray.emplaceBack(c2[0], c2[1], c2[2]), r2.vertexArray.emplaceBack(h2[0], h2[1], h2[2]), r2.vertexArray.emplaceBack(l2[0], l2[1], l2[2]), r2.vertexArray.emplaceBack(u5[0], u5[1], u5[2]), r2.vertexArray.emplaceBack(p2[0], p2[1], p2[2]), r2.vertexArray.emplaceBack(f2[0], f2[1], f2[2]);
              const d2 = a2 / t3 / 2;
              r2.colorArray.emplaceBack(-d2 - o2, -1, d2, 0.8), r2.colorArray.emplaceBack(d2 + o2, -1, d2, 0.8), r2.colorArray.emplaceBack(-d2, 0, d2, 1.3), r2.colorArray.emplaceBack(d2, 0, d2, 1.3), r2.colorArray.emplaceBack(d2 + o2, -0.8, d2, 0.7), r2.colorArray.emplaceBack(d2 + o2, -0.8, d2, 0.7), r2.colorArray.emplaceBack(0, 0, d2, 1.3), r2.colorArray.emplaceBack(0, 0, d2, 1.3), r2.colorArray.emplaceBack(d2 + o2, -1.2, d2, 0.8), r2.colorArray.emplaceBack(d2 + o2, -1.2, d2, 0.8), r2.indexArray.emplaceBack(6 + n2, 4 + n2, 8 + n2), r2.indexArray.emplaceBack(7 + n2, 9 + n2, 5 + n2), r2.indexArray.emplaceBack(0 + n2, 1 + n2, 2 + n2), r2.indexArray.emplaceBack(1 + n2, 3 + n2, 2 + n2), n2 += 10;
            }
            const i2 = { defined: true, emissiveFactor: [0, 0, 0] }, s2 = {};
            return s2.baseColorFactor = ir.white, i2.pbrMetallicRoughness = s2, r2.material = i2, r2.aabb = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), r2;
          }
          class Vb {
            constructor(t2) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e2 = 0; e2 < t2.length; e2++) {
                const r2 = t2[e2];
                this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
              }
            }
            encode(t2) {
              return this._stringToNumber[t2];
            }
            decode(t2) {
              return this._numberToString[t2];
            }
          }
          const Cb = ["id", "tile", "layer", "source", "sourceLayer", "state"];
          class Db {
            constructor(t2, e2, r2, n2, i2) {
              this.type = "Feature", this._vectorTileFeature = t2, this._z = e2, this._x = r2, this._y = n2, this.properties = t2.properties, this.id = i2;
            }
            clone() {
              const t2 = new Db(this._vectorTileFeature, this._z, this._x, this._y, this.id);
              return this.state && (t2.state = Object.assign({}, this.state)), this.layer && (t2.layer = Object.assign({}, this.layer)), this.source && (t2.source = this.source), this.sourceLayer && (t2.sourceLayer = this.sourceLayer), t2;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._x, this._y, this._z).geometry), this._geometry;
            }
            set geometry(t2) {
              this._geometry = t2;
            }
            toJSON() {
              const t2 = { type: "Feature", state: void 0, geometry: this.geometry, properties: this.properties };
              for (const e2 of Cb) void 0 !== this[e2] && (t2[e2] = this[e2]);
              return t2;
            }
          }
          class Fb {
            constructor(t2, e2) {
              this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Us(Tn, 16, 0), this.featureIndexArray = new qa(), this.promoteId = e2, this.is3DTile = false, this.serializedLayersCache = /* @__PURE__ */ new Map();
            }
            insert(t2, e2, r2, n2, i2, s2 = 0, o2 = 0) {
              const a2 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r2, n2, i2, s2);
              const l2 = this.grid;
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = e2[t3], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t4 = 0; t4 < r3.length; t4++) {
                  const e3 = r3[t4];
                  n3[0] = Math.min(n3[0], e3.x), n3[1] = Math.min(n3[1], e3.y), n3[2] = Math.max(n3[2], e3.x), n3[3] = Math.max(n3[3], e3.y);
                }
                0 !== o2 && (n3[0] -= o2, n3[1] -= o2, n3[2] += o2, n3[3] += o2), n3[0] < Tn && n3[1] < Tn && n3[2] >= 0 && n3[3] >= 0 && l2.insert(a2, n3[0], n3[1], n3[2], n3[3]);
              }
            }
            loadVTLayers() {
              if (!this.vtLayers) {
                this.vtLayers = new Nh.VectorTile(new _d(this.rawTileData)).layers, this.sourceLayerCoder = new Vb(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"]), this.vtFeatures = {};
                for (const t2 in this.vtLayers) this.vtFeatures[t2] = [];
              }
              return this.vtLayers;
            }
            query(t2, e2) {
              const { tilespaceGeometry: r2, transform: n2, tileTransform: i2, pixelPosMatrix: s2, availableImages: o2 } = e2;
              this.loadVTLayers(), this.serializedLayersCache.clear();
              const a2 = r2.bufferedTilespaceBounds, l2 = this.grid.query(a2.min.x, a2.min.y, a2.max.x, a2.max.y, (t3, e3, n3, i3) => Pu(r2.bufferedTilespaceGeometry, t3, e3, n3, i3));
              l2.sort(Rb);
              let u5 = null;
              n2.elevation && l2.length > 0 && (u5 = Cg.create(n2.elevation, this.tileID));
              const c2 = {};
              let h2;
              for (let e3 = 0; e3 < l2.length; e3++) {
                const a3 = l2[e3];
                if (a3 === h2) continue;
                h2 = a3;
                const p2 = this.featureIndexArray.get(a3);
                let f2 = null;
                this.is3DTile ? this.loadMatchingModelFeature(c2, p2, t2, r2, n2) : this.loadMatchingFeature(c2, p2, t2, o2, (t3, e4, o3, a4 = 0) => (f2 || (f2 = fu(t3, this.tileID.canonical, i2)), e4.queryIntersectsFeature(r2, t3, o3, f2, this.z, n2, s2, u5, a4)));
              }
              return c2;
            }
            loadMatchingFeature(t2, e2, r2, n2, i2) {
              const { featureIndex: s2, bucketIndex: o2, sourceLayerIndex: a2, layoutVertexArrayOffset: l2 } = e2, u5 = this.bucketLayerIDs[o2], c2 = r2.layers, h2 = Object.keys(c2);
              if (h2.length && !function(t3, e3) {
                for (let r3 = 0; r3 < t3.length; r3++) if (e3.indexOf(t3[r3]) >= 0) return true;
                return false;
              }(h2, u5)) return;
              const p2 = r2.sourceCache, f2 = this.sourceLayerCoder.decode(a2), d2 = this.vtLayers[f2].feature(s2), m2 = this.getId(d2, f2);
              for (let e3 = 0; e3 < u5.length; e3++) {
                const r3 = u5[e3];
                if (!c2[r3]) continue;
                const { styleLayer: o3, targets: a3 } = c2[r3];
                let h3 = {};
                void 0 !== m2 && (h3 = p2.getFeatureState(o3.sourceLayer, m2));
                const f3 = !i2 || i2(d2, o3, h3, l2);
                if (!f3) continue;
                const y2 = new Db(d2, this.z, this.x, this.y, m2);
                y2.tile = this.tileID.canonical, y2.state = h3;
                let g2 = this.serializedLayersCache.get(r3);
                g2 || (g2 = o3.serialize(), g2.id = r3, this.serializedLayersCache.set(r3, g2)), y2.source = g2.source, y2.sourceLayer = g2["source-layer"], y2.layer = Ct({}, g2), y2.layer.paint = Lb(g2.paint, o3.paint, d2, h3, n2), y2.layer.layout = Lb(g2.layout, o3.layout, d2, h3, n2);
                let x2 = false;
                for (const t3 of a3) {
                  this.updateFeatureProperties(y2, t3);
                  const { filter: e4 } = t3;
                  if (e4) {
                    if (d2.properties = y2.properties, e4.needGeometry) {
                      const t4 = du(d2, true);
                      if (!e4.filter(new yo(this.tileID.overscaledZ), t4, this.tileID.canonical)) continue;
                    } else if (!e4.filter(new yo(this.tileID.overscaledZ), d2)) continue;
                  }
                  x2 = true, t3.targetId && this.addFeatureVariant(y2, t3);
                }
                x2 && this.appendToResult(t2, r3, s2, y2, f3);
              }
            }
            loadMatchingModelFeature(t2, e2, r2, n2, i2) {
              const s2 = this.bucketLayerIDs[0][0], o2 = r2.layers;
              if (!o2[s2]) return;
              const { styleLayer: a2, targets: l2 } = o2[s2];
              if ("model" !== a2.type) return;
              const u5 = n2.tile, f2 = e2.featureIndex, d2 = u5.getBucket(a2);
              if (!(d2 && d2 instanceof Ng)) return;
              const m2 = function(t3, e3, r3, n3) {
                const i3 = t3.getNodesInfo()[e3];
                if (i3.hiddenByReplacement || !i3.node.meshes) return;
                let s3 = Number.MAX_VALUE;
                const o3 = i3.node, a3 = r3.tile, l3 = n3.calculatePosMatrix(a3.tileID.toUnwrapped(), n3.worldSize), u6 = i3.evaluatedScale;
                let f3 = 0;
                n3.elevation && o3.elevation && (f3 = o3.elevation * n3.elevation.exaggeration()), h(l3, l3, [(o3.anchor ? o3.anchor[0] : 0) * (u6[0] - 1), (o3.anchor ? o3.anchor[1] : 0) * (u6[1] - 1), f3]), p(l3, l3, u6);
                const d3 = r3.queryGeometry, m3 = d3.isPointQuery() ? d3.screenBounds : d3.screenGeometry, y3 = function(t4) {
                  const e4 = c([], l3, t4.matrix);
                  c(e4, n3.expandedFarZProjMatrix, e4);
                  for (let r4 = 0; r4 < t4.meshes.length; ++r4) {
                    const i4 = t4.meshes[r4];
                    if (r4 === t4.lightMeshIndex) continue;
                    const o4 = cg(m3, n3, e4, i4.aabb);
                    null != o4 && (s3 = Math.min(o4, s3));
                  }
                  if (t4.children) for (const e5 of t4.children) y3(e5);
                };
                if (y3(o3), s3 === Number.MAX_VALUE) return;
                const g3 = new $l(0, 0);
                return qg(a3.tileID.canonical, g3, i3.node.anchor[0], i3.node.anchor[1]), { intersectionZ: s3, position: g3, feature: i3.feature };
              }(d2, f2, n2, i2);
              if (!m2) return;
              const { z: y2, x: g2, y: x2 } = u5.tileID.canonical, { feature: v3, intersectionZ: b2, position: _2 } = m2;
              let w2 = {};
              void 0 !== v3.id && (w2 = r2.sourceCache.getFeatureState(a2.sourceLayer, v3.id));
              const A2 = new Db({}, y2, g2, x2, v3.id);
              A2.tile = this.tileID.canonical, A2.state = w2, A2.properties = v3.properties, A2.geometry = { type: "Point", coordinates: [_2.lng, _2.lat] };
              let M2 = this.serializedLayersCache.get(s2);
              M2 || (M2 = a2.serialize(), M2.id = s2, this.serializedLayersCache.set(s2, M2)), A2.source = M2.source, A2.sourceLayer = M2["source-layer"], A2.layer = Ct({}, M2);
              let I2 = false;
              for (const t3 of l2) {
                this.updateFeatureProperties(A2, t3);
                const { filter: e3 } = t3;
                if (e3) {
                  if (v3.properties = A2.properties, e3.needGeometry) {
                    if (!e3.filter(new yo(this.tileID.overscaledZ), v3, this.tileID.canonical)) continue;
                  } else if (!e3.filter(new yo(this.tileID.overscaledZ), v3)) continue;
                }
                I2 = true, t3.targetId && this.addFeatureVariant(A2, t3);
              }
              I2 && this.appendToResult(t2, s2, f2, A2, b2);
            }
            updateFeatureProperties(t2, e2, r2) {
              if (e2.properties) {
                const n2 = {};
                for (const i2 in e2.properties) {
                  const s2 = e2.properties[i2].evaluate({ zoom: this.z }, t2._vectorTileFeature, t2.state, t2.tile, r2);
                  null != s2 && (n2[i2] = s2);
                }
                t2.properties = n2;
              }
            }
            addFeatureVariant(t2, e2, r2) {
              const n2 = { target: e2.target, namespace: e2.namespace, uniqueFeatureID: e2.uniqueFeatureID };
              e2.properties && (n2.properties = t2.properties), t2.variants = t2.variants || {}, t2.variants[e2.targetId] = t2.variants[e2.targetId] || [], t2.variants[e2.targetId].push(n2);
            }
            appendToResult(t2, e2, r2, n2, i2) {
              let s2 = t2[e2];
              void 0 === s2 && (s2 = t2[e2] = []), s2.push({ featureIndex: r2, feature: n2, intersectionZ: i2 });
            }
            lookupSymbolFeatures(t2, e2, r2, n2, i2) {
              const s2 = {};
              this.loadVTLayers();
              for (const o2 of t2) this.loadMatchingFeature(s2, { bucketIndex: e2, sourceLayerIndex: r2, featureIndex: o2, layoutVertexArrayOffset: 0 }, n2, i2);
              return s2;
            }
            loadFeature(t2) {
              const { featureIndex: e2, sourceLayerIndex: r2 } = t2;
              this.loadVTLayers();
              const n2 = this.sourceLayerCoder.decode(r2), i2 = this.vtFeatures[n2];
              if (i2[e2]) return i2[e2];
              const s2 = this.vtLayers[n2].feature(e2);
              return i2[e2] = s2, s2;
            }
            hasLayer(t2) {
              for (const e2 of this.bucketLayerIDs) for (const r2 of e2) if (t2 === r2) return true;
              return false;
            }
            getId(t2, e2) {
              let r2 = t2.id;
              if (this.promoteId) {
                const n2 = Array.isArray(this.promoteId) || "object" != typeof this.promoteId ? this.promoteId : this.promoteId[e2];
                if (null != n2) if (Array.isArray(n2)) {
                  if (!this.promoteIdExpression) {
                    const t3 = Ts(n2);
                    if ("success" !== t3.result) {
                      const e3 = t3.value.map((t4) => `${t4.key}: ${t4.message}`).join(", ");
                      return void $t(`Failed to create expression for promoteId: ${e3}`);
                    }
                    this.promoteIdExpression = t3.value;
                  }
                  this.promoteIdExpression._evaluator || (this.promoteIdExpression._evaluator = new Zr()), r2 = this.promoteIdExpression.evaluate({ zoom: 0 }, t2);
                } else r2 = t2.properties[n2];
                "boolean" == typeof r2 && (r2 = Number(r2));
              }
              return r2;
            }
          }
          function Lb(t2, e2, r2, n2, i2) {
            return Ot(t2, (t3, s2) => {
              const o2 = e2 instanceof Mo ? e2.get(s2) : null;
              return o2 && o2.evaluate ? o2.evaluate(r2, n2, void 0, i2) : o2;
            });
          }
          function Rb(t2, e2) {
            return e2 - t2;
          }
          js(Fb, "FeatureIndex", { omit: ["rawTileData", "sourceLayerCoder"] });
          const Ob = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class Ub {
            static from(t2) {
              if (!(t2 instanceof ArrayBuffer)) throw new Error("Data must be an instance of ArrayBuffer.");
              const [e2, r2] = new Uint8Array(t2, 0, 2);
              if (219 !== e2) throw new Error("Data does not appear to be in a KDBush format.");
              const n2 = r2 >> 4;
              if (1 !== n2) throw new Error(`Got v${n2} data when expected v1.`);
              const i2 = Ob[15 & r2];
              if (!i2) throw new Error("Unrecognized array type.");
              const [s2] = new Uint16Array(t2, 2, 1), [o2] = new Uint32Array(t2, 4, 1);
              return new Ub(o2, s2, i2, t2);
            }
            constructor(t2, e2 = 64, r2 = Float64Array, n2) {
              if (isNaN(t2) || t2 < 0) throw new Error(`Unpexpected numItems value: ${t2}.`);
              this.numItems = +t2, this.nodeSize = Math.min(Math.max(+e2, 2), 65535), this.ArrayType = r2, this.IndexArrayType = t2 < 65536 ? Uint16Array : Uint32Array;
              const i2 = Ob.indexOf(this.ArrayType), s2 = 2 * t2 * this.ArrayType.BYTES_PER_ELEMENT, o2 = t2 * this.IndexArrayType.BYTES_PER_ELEMENT, a2 = (8 - o2 % 8) % 8;
              if (i2 < 0) throw new Error(`Unexpected typed array class: ${r2}.`);
              n2 && n2 instanceof ArrayBuffer ? (this.data = n2, this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + o2 + a2, 2 * t2), this._pos = 2 * t2, this._finished = true) : (this.data = new ArrayBuffer(8 + s2 + o2 + a2), this.ids = new this.IndexArrayType(this.data, 8, t2), this.coords = new this.ArrayType(this.data, 8 + o2 + a2, 2 * t2), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i2]), new Uint16Array(this.data, 2, 1)[0] = e2, new Uint32Array(this.data, 4, 1)[0] = t2);
            }
            add(t2, e2) {
              const r2 = this._pos >> 1;
              return this.ids[r2] = r2, this.coords[this._pos++] = t2, this.coords[this._pos++] = e2, r2;
            }
            finish() {
              const t2 = this._pos >> 1;
              if (t2 !== this.numItems) throw new Error(`Added ${t2} items when expected ${this.numItems}.`);
              return Nb(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t2, e2, r2, n2) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i2, coords: s2, nodeSize: o2 } = this, a2 = [0, i2.length - 1, 0], l2 = [];
              for (; a2.length; ) {
                const u5 = a2.pop() || 0, c2 = a2.pop() || 0, h2 = a2.pop() || 0;
                if (c2 - h2 <= o2) {
                  for (let o3 = h2; o3 <= c2; o3++) {
                    const a3 = s2[2 * o3], u6 = s2[2 * o3 + 1];
                    a3 >= t2 && a3 <= r2 && u6 >= e2 && u6 <= n2 && l2.push(i2[o3]);
                  }
                  continue;
                }
                const p2 = h2 + c2 >> 1, f2 = s2[2 * p2], d2 = s2[2 * p2 + 1];
                f2 >= t2 && f2 <= r2 && d2 >= e2 && d2 <= n2 && l2.push(i2[p2]), (0 === u5 ? t2 <= f2 : e2 <= d2) && (a2.push(h2), a2.push(p2 - 1), a2.push(1 - u5)), (0 === u5 ? r2 >= f2 : n2 >= d2) && (a2.push(p2 + 1), a2.push(c2), a2.push(1 - u5));
              }
              return l2;
            }
            within(t2, e2, r2) {
              if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n2, coords: i2, nodeSize: s2 } = this, o2 = [0, n2.length - 1, 0], a2 = [], l2 = r2 * r2;
              for (; o2.length; ) {
                const u5 = o2.pop() || 0, c2 = o2.pop() || 0, h2 = o2.pop() || 0;
                if (c2 - h2 <= s2) {
                  for (let r3 = h2; r3 <= c2; r3++) qb(i2[2 * r3], i2[2 * r3 + 1], t2, e2) <= l2 && a2.push(n2[r3]);
                  continue;
                }
                const p2 = h2 + c2 >> 1, f2 = i2[2 * p2], d2 = i2[2 * p2 + 1];
                qb(f2, d2, t2, e2) <= l2 && a2.push(n2[p2]), (0 === u5 ? t2 - r2 <= f2 : e2 - r2 <= d2) && (o2.push(h2), o2.push(p2 - 1), o2.push(1 - u5)), (0 === u5 ? t2 + r2 >= f2 : e2 + r2 >= d2) && (o2.push(p2 + 1), o2.push(c2), o2.push(1 - u5));
              }
              return a2;
            }
          }
          function Nb(t2, e2, r2, n2, i2, s2) {
            if (i2 - n2 <= r2) return;
            const o2 = n2 + i2 >> 1;
            jb(t2, e2, o2, n2, i2, s2), Nb(t2, e2, r2, n2, o2 - 1, 1 - s2), Nb(t2, e2, r2, o2 + 1, i2, 1 - s2);
          }
          function jb(t2, e2, r2, n2, i2, s2) {
            for (; i2 > n2; ) {
              if (i2 - n2 > 600) {
                const o3 = i2 - n2 + 1, a3 = r2 - n2 + 1, l3 = Math.log(o3), u5 = 0.5 * Math.exp(2 * l3 / 3), c2 = 0.5 * Math.sqrt(l3 * u5 * (o3 - u5) / o3) * (a3 - o3 / 2 < 0 ? -1 : 1);
                jb(t2, e2, r2, Math.max(n2, Math.floor(r2 - a3 * u5 / o3 + c2)), Math.min(i2, Math.floor(r2 + (o3 - a3) * u5 / o3 + c2)), s2);
              }
              const o2 = e2[2 * r2 + s2];
              let a2 = n2, l2 = i2;
              for ($b(t2, e2, n2, r2), e2[2 * i2 + s2] > o2 && $b(t2, e2, n2, i2); a2 < l2; ) {
                for ($b(t2, e2, a2, l2), a2++, l2--; e2[2 * a2 + s2] < o2; ) a2++;
                for (; e2[2 * l2 + s2] > o2; ) l2--;
              }
              e2[2 * n2 + s2] === o2 ? $b(t2, e2, n2, l2) : (l2++, $b(t2, e2, l2, i2)), l2 <= r2 && (n2 = l2 + 1), r2 <= l2 && (i2 = l2 - 1);
            }
          }
          function $b(t2, e2, r2, n2) {
            Gb(t2, r2, n2), Gb(e2, 2 * r2, 2 * n2), Gb(e2, 2 * r2 + 1, 2 * n2 + 1);
          }
          function Gb(t2, e2, r2) {
            const n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function qb(t2, e2, r2, n2) {
            const i2 = t2 - r2, s2 = e2 - n2;
            return i2 * i2 + s2 * s2;
          }
          t.$ = Wr, t.A = We, t.B = Br, t.C = Ho, t.D = Qg, t.E = Qe, t.F = 2, t.G = om, t.H = im, t.I = tr, t.J = class extends vg {
          }, t.K = Gr, t.L = cr, t.M = Po, t.N = bs, t.O = gs, t.P = bt, t.Q = vs, t.R = Te, t.S = Ps, t.T = Oy, t.U = To, t.V = vg, t.W = Cs, t.X = Ts, t.Y = pi, t.Z = di, t._ = hi, t.a = function(t2) {
            return re.API_CDN_URL_REGEX.test(t2);
          }, t.a$ = Ft, t.a0 = nr, t.a1 = Bo, t.a2 = _s, t.a3 = xs, t.a4 = function(t2) {
            const e2 = t2.value;
            let r2 = [];
            if (!e2) return r2;
            const n2 = Gr(e2);
            return "string" !== n2 ? (r2 = r2.concat([new vg(t2.key, e2, `string expected, "${n2}" found`)]), r2) : (bg(e2, true) || (r2 = r2.concat([new vg(t2.key, e2, `invalid url "${e2}"`)])), r2);
          }, t.a5 = Eo, t.a6 = vo, t.a7 = ko, t.a8 = Io, t.a9 = class {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return Ht(t2.expression.evaluate(e2));
            }
            interpolate(t2, e2, r2) {
              return { x: or(t2.x, e2.x, r2), y: or(t2.y, e2.y, r2), z: or(t2.z, e2.z, r2), azimuthal: or(t2.azimuthal, e2.azimuthal, r2), polar: or(t2.polar, e2.polar, r2) };
            }
          }, t.aA = Z, t.aB = Eu, t.aC = au, t.aD = Pt, t.aE = Tl, t.aF = function(t2, e2) {
            const r2 = {};
            for (let n2 = 0; n2 < e2.length; n2++) {
              const i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.aG = Gl, t.aH = Wl, t.aI = class {
            constructor(t2) {
              this.entries = {}, this.scheduler = t2;
            }
            request(t2, e2, r2, n2) {
              const i2 = this.entries[t2] = this.entries[t2] || { callbacks: [] };
              if (i2.result) {
                const [t3, r3] = i2.result;
                return this.scheduler ? this.scheduler.add(() => {
                  n2(t3, r3);
                }, e2) : n2(t3, r3), () => {
                };
              }
              return i2.callbacks.push(n2), i2.cancel || (i2.cancel = r2((r3, n3) => {
                i2.result = [r3, n3];
                for (const t3 of i2.callbacks) this.scheduler ? this.scheduler.add(() => {
                  t3(r3, n3);
                }, e2) : t3(r3, n3);
                setTimeout(() => delete this.entries[t2], 3e3);
              })), () => {
                i2.result || (i2.callbacks = i2.callbacks.filter((t3) => t3 !== n2), i2.callbacks.length || (i2.cancel(), delete this.entries[t2]));
              };
            }
          }, t.aJ = function(t2, e2, r2) {
            const n2 = JSON.stringify(t2.request);
            return t2.data && (this.deduped.entries[n2] = { result: [null, t2.data] }), this.deduped.request(n2, { type: "parseTile", isSymbolTile: t2.isSymbolTile, zoom: t2.tileZoom }, (e3) => {
              const n3 = De(t2.request, (t3, n4, i2, s2) => {
                t3 ? e3(t3) : n4 && e3(null, { vectorTile: r2 ? void 0 : new Nh.VectorTile(new _d(n4)), rawData: n4, cacheControl: i2, expires: s2 });
              });
              return () => {
                n3.cancel(), e3();
              };
            }, e2);
          }, t.aK = function(t2) {
            Ae++, Ae > ge && (t2.getActor().send("enforceCacheSizeLimit", ye), Ae = 0);
          }, t.aL = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.floor(Math.log(t2) / Math.LN2));
          }, t.aM = $u, t.aN = Hy, t.aO = Jy, t.aP = Gy, t.aQ = function(t2, e2) {
            const r2 = document.createElement("video");
            r2.muted = true, r2.onloadstart = function() {
              e2(null, r2);
            };
            for (let e3 = 0; e3 < t2.length; e3++) {
              const n2 = document.createElement("source");
              Fe(t2[e3]) || (r2.crossOrigin = "Anonymous"), n2.src = t2[e3], r2.appendChild(n2);
            }
            return { cancel: () => {
            } };
          }, t.aR = Uy, t.aS = function(t2) {
            return fetch(t2).then((t3) => t3.arrayBuffer()).then((e2) => wb(e2, 0, t2));
          }, t.aT = Pb, t.aU = class {
            constructor(t2, e2, r2, n2) {
              this.id = t2, this.position = null != e2 ? new $l(e2[0], e2[1]) : new $l(0, 0), this.orientation = null != r2 ? r2 : [0, 0, 0], this.nodes = n2, this.uploaded = false, this.aabb = new ic([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), this.matrix = [];
            }
            _applyTransformations(t2, e2) {
              if (c(t2.matrix, e2, t2.matrix), t2.meshes) for (const e3 of t2.meshes) {
                const r2 = ic.applyTransformFast(e3.aabb, t2.matrix);
                this.aabb.encapsulate(r2);
              }
              if (t2.children) for (const e3 of t2.children) this._applyTransformations(e3, t2.matrix);
            }
            computeBoundsAndApplyParent() {
              const t2 = l([]);
              for (const e2 of this.nodes) this._applyTransformations(e2, t2);
            }
            computeModelMatrix(t2, e2, r2, n2, i2, s2, o2 = false) {
              kg(this.matrix, this, t2.transform, this.position, e2, r2, n2, i2, s2, o2);
            }
            upload(t2) {
              if (!this.uploaded) {
                for (const e2 of this.nodes) Tg(e2, t2);
                for (const t3 of this.nodes) Bg(t3);
                this.uploaded = true;
              }
            }
            destroy() {
              for (const t2 of this.nodes) Vg(t2);
            }
          }, t.aV = Rt, t.aW = Xm, t.aX = Kl, t.aY = Jl, t.aZ = na, t.a_ = wa, t.aa = yo, t.ab = Vs, t.ac = su, t.ad = R, t.ae = w, t.af = Tt, t.ag = Mo, t.ah = Mc, t.ai = or, t.aj = Tn, t.ak = ar, t.al = Mt, t.am = ir, t.an = class {
            constructor(t2) {
              this.specification = t2;
            }
            possiblyEvaluate(t2, e2) {
              return function([t3, e3]) {
                const r2 = Ht([1, t3, e3]);
                return { x: r2.x, y: r2.y, z: r2.z };
              }(t2.expression.evaluate(e2));
            }
            interpolate(t2, e2, r2) {
              return { x: or(t2.x, e2.x, r2), y: or(t2.y, e2.y, r2), z: or(t2.z, e2.z, r2) };
            }
          }, t.ao = function(t2, e2, r2 = 0, n2 = true) {
            const i2 = new bt(r2, r2), s2 = t2.sub(i2), o2 = e2.add(i2), a2 = [s2, new bt(o2.x, s2.y), o2, new bt(s2.x, o2.y)];
            return n2 && a2.push(s2.clone()), a2;
          }, t.ap = function(t2, e2) {
            const r2 = [];
            for (let n2 = 0; n2 < t2.length; n2++) {
              const i2 = Bt(n2 - 1, -1, t2.length - 1), s2 = Bt(n2 + 1, -1, t2.length - 1), o2 = t2[n2], a2 = t2[s2], l2 = t2[i2].sub(o2).unit(), u5 = a2.sub(o2).unit(), c2 = u5.angleWithSep(l2.x, l2.y), h2 = l2.add(u5).unit().mult(-1 * e2 / Math.sin(c2 / 2));
              r2.push(o2.add(h2));
            }
            return r2;
          }, t.aq = Zm, t.ar = Pu, t.as = function(t2, e2, r2 = 0) {
            return A(((e2.x - r2) * t2.scale - t2.x) * Tn, (e2.y * t2.scale - t2.y) * Tn, Ql(e2.z, e2.y));
          }, t.at = j, t.au = C, t.av = Ku, t.aw = Gf, t.ax = function(t2) {
            let e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0;
            for (const s2 of t2) e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            return { min: new bt(e2, r2), max: new bt(n2, i2) };
          }, t.ay = Zl, t.az = c, t.b = function(t2) {
            return re.API_FONTS_REGEX.test(t2);
          }, t.b$ = E, t.b0 = La, t.b1 = Iy, t.b2 = function() {
            mo.isLoading() || mo.isLoaded() || "deferred" !== po() || fo();
          }, t.b3 = Vo, t.b4 = du, t.b5 = Db, t.b6 = Zt, t.b7 = Uf, t.b8 = pp, t.b9 = fu, t.bA = function(t2, e2) {
            const { x: r2, y: n2 } = t2.point, i2 = Ac(r2, n2, t2.worldSize / t2._pixelsPerMercatorPixel, 0, 0);
            return c(i2, i2, bc4(cc2(e2)));
          }, t.bB = n, t.bC = function(t2) {
            return t2[0] = 0, t2[1] = 0, t2[2] = 0, t2;
          }, t.bD = function(t2, e2) {
            return Math.hypot(e2[0] - t2[0], e2[1] - t2[1], e2[2] - t2[2]);
          }, t.bE = D2, t.bF = P, t.bG = F, t.bH = Wd, t.bI = zd, t.bJ = Zd, t.bK = function(t2, e2, r2, n2, i2) {
            const s2 = 5 * e2 + 2;
            t2.float32[s2 + 0] = r2, t2.float32[s2 + 1] = n2, t2.float32[s2 + 2] = i2;
          }, t.bL = _y, t.bM = Af, t.bN = xu, t.bO = cd2, t.bP = kp, t.bQ = xg, t.bR = Lp, t.bS = Rp, t.bT = Fm, t.bU = Em, t.bV = Rd, t.bW = Ub, t.bX = Bt, t.bY = Y, t.bZ = function(t2, e2, r2) {
            r2 *= 0.5;
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 + i2 * a2, t2[1] = i2 * l2 - n2 * a2, t2[2] = s2 * l2 + o2 * a2, t2[3] = o2 * l2 - s2 * a2, t2;
          }, t.b_ = K, t.ba = ea2, t.bb = Ta, t.bc = Wu, t.bd = Ka, t.be = Qc, t.bf = Fy, t.bg = function(t2, e2) {
            const r2 = Mc(e2.zoom);
            if (0 === r2) return cc2(t2);
            const n2 = dc(t2), i2 = mc(n2), s2 = Zl(n2.getWest()) * e2.worldSize, o2 = Zl(n2.getEast()) * e2.worldSize, a2 = Wl(n2.getNorth()) * e2.worldSize, l2 = Wl(n2.getSouth()) * e2.worldSize, c2 = [s2, a2, 0], h2 = [o2, a2, 0], p2 = [s2, l2, 0], f2 = [o2, l2, 0], d2 = u4([], e2.globeMatrix);
            return R(c2, c2, d2), R(h2, h2, d2), R(p2, p2, d2), R(f2, f2, d2), i2[0] = hc(i2[0], p2, r2), i2[1] = hc(i2[1], f2, r2), i2[2] = hc(i2[2], h2, r2), i2[3] = hc(i2[3], c2, r2), ic.fromPoints(i2);
          }, t.bh = vc, t.bi = u4, t.bj = yc, t.bk = hc, t.bl = ra, t.bm = Zu, t.bn = y, t.bo = h, t.bp = Kv, t.bq = _d, t.br = De, t.bs = function(t2, e2) {
            const r2 = [];
            for (const n2 in t2) n2 in e2 || r2.push(n2);
            return r2;
          }, t.bt = Vt, t.bu = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.bv = _t, t.bw = function(t2) {
            var e2 = new r(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.bx = l, t.by = m, t.bz = a, t.c = ie, t.c$ = function(t2) {
            return t2({ pluginStatus: ao, pluginURL: lo }), ho.on("pluginStateChange", t2), t2;
          }, t.c0 = G, t.c1 = Yt, t.c2 = function(t2, e2) {
            return t2[0] = -e2[0], t2[1] = -e2[1], t2[2] = -e2[2], t2[3] = e2[3], t2;
          }, t.c3 = x, t.c4 = function(t2, e2, r2, n2, i2) {
            var s2, o2 = 1 / Math.tan(e2 / 2);
            return t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (s2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * s2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.c5 = function(t2, e2, r2, n2, i2, s2, o2) {
            var a2 = 1 / (e2 - r2), l2 = 1 / (n2 - i2), u5 = 1 / (s2 - o2);
            return t2[0] = -2 * a2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * l2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * u5, t2[11] = 0, t2[12] = (e2 + r2) * a2, t2[13] = (i2 + n2) * l2, t2[14] = (o2 + s2) * u5, t2[15] = 1, t2;
          }, t.c6 = Yl, t.c7 = function(t2, e2, r2) {
            t2[4 * e2 + 0] = r2[0], t2[4 * e2 + 1] = r2[1], t2[4 * e2 + 2] = r2[2], t2[4 * e2 + 3] = r2[3];
          }, t.c8 = dl, t.c9 = ul, t.cA = ng, t.cB = v2, t.cC = eg, t.cD = function(t2) {
            const e2 = eg(t2, true);
            return n([], [e2[0], e2[1], e2[4], e2[5]]);
          }, t.cE = p, t.cF = Ju, t.cG = f, t.cH = function(t2) {
            const { x: e2, y: r2 } = t2.point, { lng: n2, lat: i2 } = t2._center;
            return Ac(e2, r2, t2.worldSize, n2, i2);
          }, t.cI = S, t.cJ = It, t.cK = Gu, t.cL = Bl, t.cM = function(t2, e2, r2) {
            let n2 = 0;
            for (let r3 = 0; r3 < 2; ++r3) {
              const i2 = 0;
              t2[r3] > i2 && (n2 += (t2[r3] - i2) * (t2[r3] - i2)), e2[r3] < i2 && (n2 += (i2 - e2[r3]) * (i2 - e2[r3]));
            }
            return n2;
          }, t.cN = 45, t.cO = lr, t.cP = Xl, t.cQ = hl, t.cR = function(t2, e2, r2) {
            const n2 = Math.sqrt(t2 * t2 + e2 * e2 + r2 * r2), i2 = n2 > 0 ? Math.acos(r2 / n2) * At : 0;
            let s2 = 0 !== t2 || 0 !== e2 ? Math.atan2(-e2, -t2) * At + 90 : 0;
            return s2 < 0 && (s2 += 360), [n2, s2, i2];
          }, t.cS = A, t.cT = iu, t.cU = M, t.cV = ic, t.cW = Ht, t.cX = function(t2) {
            return [Math.pow(t2[0], 1 / 2.2), Math.pow(t2[1], 1 / 2.2), Math.pow(t2[2], 1 / 2.2)];
          }, t.cY = I, t.cZ = bg, t.c_ = function(t2, e2) {
            return t2.readFields(cx, { icons: [] }, e2);
          }, t.ca = cl, t.cb = ll, t.cc = al, t.cd = $l, t.ce = my, t.cf = function() {
            var t2 = new r(4);
            return r != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
          }, t.cg = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], s2 = e2[2], o2 = e2[3], a2 = Math.sin(r2), l2 = Math.cos(r2);
            return t2[0] = n2 * l2 + s2 * a2, t2[1] = i2 * l2 + o2 * a2, t2[2] = n2 * -a2 + s2 * l2, t2[3] = i2 * -a2 + o2 * l2, t2;
          }, t.ch = function(t2, e2) {
            return t2[0] === e2[0] && t2[1] === e2[1] && t2[2] === e2[2] && t2[3] === e2[3];
          }, t.ci = N, t.cj = function(t2) {
            return Math.hypot(t2[0], t2[1], t2[2], t2[3]);
          }, t.ck = it, t.cl = U, t.cm = ju, t.cn = nc, t.co = rg, t.cp = Nu, t.cq = fc, t.cr = function(t2, e2, r2, n2, i2, s2, o2, a2, l2) {
            if ("globe" === l2.name) return fc(t2, e2, new Nu(r2, n2, i2), false);
            const u5 = Xm({ z: r2, x: n2, y: i2 }, l2);
            return new ic([(s2 + u5.x / u5.scale) * e2, e2 * (u5.y / u5.scale), o2], [(s2 + u5.x2 / u5.scale) * e2, e2 * (u5.y2 / u5.scale), a2]);
          }, t.cs = function(t2, e2, r2) {
            return t2[0] = Math.min(e2[0], r2[0]), t2[1] = Math.min(e2[1], r2[1]), t2[2] = Math.min(e2[2], r2[2]), t2[3] = Math.min(e2[3], r2[3]), t2;
          }, t.ct = function(t2, e2, r2) {
            return t2[0] = Math.max(e2[0], r2[0]), t2[1] = Math.max(e2[1], r2[1]), t2[2] = Math.max(e2[2], r2[2]), t2[3] = Math.max(e2[3], r2[3]), t2;
          }, t.cu = function(t2) {
            const e2 = Math.round((t2 + 45 + 360) % 360 / 90) % 4;
            return St[e2];
          }, t.cv = tu, t.cw = H, t.cx = Vl, t.cy = function(t2) {
            const e2 = l(new Float64Array(16));
            c(e2, t2.pixelMatrix, t2.globeMatrix);
            const r2 = [0, Ll, 0], n2 = [0, Rl, 0];
            return R(r2, r2, e2), R(n2, n2, e2), [r2[0] > 0 && r2[0] <= t2.width && r2[1] > 0 && r2[1] <= t2.height && !Sc(t2, new $l(t2.center.lat, 90)), n2[0] > 0 && n2[0] <= t2.width && n2[1] > 0 && n2[1] <= t2.height && !Sc(t2, new $l(t2.center.lat, -90))];
          }, t.cz = function(t2, e2) {
            const { scale: r2 } = t2.tileTransform, n2 = r2 * Tn / (t2.tileSize * Math.pow(2, e2.zoom - t2.tileID.overscaledZ + t2.tileID.canonical.z));
            return function(t3, e3, r3) {
              var n3 = e3[1], i2 = e3[2], s2 = e3[3], o2 = r3[0], a2 = r3[1];
              return t3[0] = e3[0] * o2, t3[1] = n3 * o2, t3[2] = i2 * a2, t3[3] = s2 * a2, t3;
            }(new Float32Array(4), e2.inverseAdjustmentMatrix, [n2, n2]);
          }, t.d = function(t2) {
            return re.API_TILEJSON_REGEX.test(t2);
          }, t.d$ = Ca, t.d0 = rx, t.d1 = dm, t.d2 = fm, t.d3 = Ve, t.d4 = uo, t.d5 = de2, t.d6 = Ze, t.d7 = Nt, t.d8 = function(t2) {
            const e2 = t2.indexOf(qo);
            return e2 >= 0 ? t2.slice(0, e2) : t2;
          }, t.d9 = function(t2) {
            return t2.indexOf(qo) >= 0;
          }, t.dA = wc, t.dB = te, t.dC = Qt, t.dD = 256, t.dE = function(t2, e2) {
            const r2 = [0, 0, 0];
            return R(r2, r2, vc(cc2(e2.canonical))), R(r2, r2, t2), r2;
          }, t.dF = (t2) => ({ u_camera_to_center_distance: new ll(t2), u_extrude_scale: new gl(t2), u_device_pixel_ratio: new ll(t2), u_matrix: new dl(t2), u_inv_rot_matrix: new dl(t2), u_merc_center: new ul(t2), u_tile_id: new cl(t2), u_zoom_transition: new ll(t2), u_up_dir: new cl(t2), u_emissive_strength: new ll(t2) }), t.dG = (t2) => ({ u_matrix: new dl(t2), u_pixels_to_tile_units: new gl(t2), u_device_pixel_ratio: new ll(t2), u_width_scale: new ll(t2), u_floor_width_scale: new ll(t2), u_units_to_pixels: new ul(t2), u_dash_image: new al(t2), u_gradient_image: new al(t2), u_image_height: new ll(t2), u_texsize: new ul(t2), u_tile_units_to_pixels: new ll(t2), u_alpha_discard_threshold: new ll(t2), u_trim_offset: new ul(t2), u_trim_fade_range: new ul(t2), u_trim_color: new hl(t2), u_emissive_strength: new ll(t2), u_zbias_factor: new ll(t2), u_tile_to_meter: new ll(t2), u_ground_shadow_factor: new cl(t2) }), t.dH = (t2) => ({ u_matrix: new dl(t2), u_texsize: new ul(t2), u_pixels_to_tile_units: new gl(t2), u_device_pixel_ratio: new ll(t2), u_width_scale: new ll(t2), u_floor_width_scale: new ll(t2), u_image: new al(t2), u_units_to_pixels: new ul(t2), u_tile_units_to_pixels: new ll(t2), u_alpha_discard_threshold: new ll(t2), u_trim_offset: new ul(t2), u_trim_fade_range: new ul(t2), u_trim_color: new hl(t2), u_emissive_strength: new ll(t2), u_zbias_factor: new ll(t2), u_tile_to_meter: new ll(t2), u_ground_shadow_factor: new cl(t2), u_pattern_transition: new ll(t2) }), t.dI = ba, t.dJ = ud, t.dK = Tc, t.dL = (t2, e2, r2, n2, i2, s2) => {
            const o2 = t2.transform, a2 = "globe" === o2.projection.name;
            let l2;
            if ("map" === s2.paint.get("circle-pitch-alignment")) if (a2) {
              const t3 = wc(o2.zoom, e2.canonical) * o2._pixelsPerMercatorPixel;
              l2 = Float32Array.from([t3, 0, 0, t3]);
            } else l2 = o2.calculatePixelsToTileUnitsMatrix(r2);
            else l2 = new Float32Array([o2.pixelsToGLUnits[0], 0, 0, o2.pixelsToGLUnits[1]]);
            const u5 = { u_camera_to_center_distance: t2.transform.getCameraToCenterDistance(o2.projection), u_matrix: t2.translatePosMatrix(e2.projMatrix, r2, s2.paint.get("circle-translate"), s2.paint.get("circle-translate-anchor")), u_device_pixel_ratio: pe.devicePixelRatio, u_extrude_scale: l2, u_inv_rot_matrix: Pc, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0], u_emissive_strength: s2.paint.get("circle-emissive-strength") };
            if (a2) {
              u5.u_inv_rot_matrix = n2, u5.u_merc_center = i2, u5.u_tile_id = [e2.canonical.x, e2.canonical.y, 1 << e2.canonical.z], u5.u_zoom_transition = Mc(o2.zoom);
              const t3 = i2[0] * Tn, r3 = i2[1] * Tn;
              u5.u_up_dir = o2.projection.upVector(new Nu(0, 0, 0), t3, r3);
            }
            return u5;
          }, t.dM = Zf, t.dN = Vr, t.dO = (t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) => {
            const c2 = t2.transform, h2 = c2.pitch < 15 ? qf(0.07, 0.7, Pt((14 - c2.zoom) / 5, 0, 1)) : 0.07, p2 = "none" === r2.paint.get("line-trim-color-use-theme").constantOr("default");
            return { u_matrix: Xf(t2, e2, r2, n2), u_texsize: e2.imageAtlasTexture ? e2.imageAtlasTexture.size : [0, 0], u_pixels_to_tile_units: c2.calculatePixelsToTileUnitsMatrix(e2), u_device_pixel_ratio: i2, u_width_scale: s2, u_floor_width_scale: o2, u_image: 0, u_tile_units_to_pixels: Hf(e2, c2), u_units_to_pixels: [1 / c2.pixelsToGLUnits[0], 1 / c2.pixelsToGLUnits[1]], u_alpha_discard_threshold: 0, u_trim_offset: a2, u_trim_fade_range: r2.paint.get("line-trim-fade-range"), u_trim_color: r2.paint.get("line-trim-color").toRenderColor(p2 ? null : r2.lut).toArray01(), u_emissive_strength: r2.paint.get("line-emissive-strength"), u_zbias_factor: h2, u_tile_to_meter: iu(e2.tileID.canonical, 0), u_ground_shadow_factor: l2, u_pattern_transition: u5 };
          }, t.dP = (t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) => {
            const c2 = t2.transform, h2 = c2.calculatePixelsToTileUnitsMatrix(e2), p2 = "none" === r2.paint.get("line-trim-color-use-theme").constantOr("default"), f2 = c2.pitch < 15 ? qf(0.07, 0.7, Pt((14 - c2.zoom) / 5, 0, 1)) : 0.07;
            return { u_matrix: Xf(t2, e2, r2, n2), u_pixels_to_tile_units: h2, u_device_pixel_ratio: s2, u_width_scale: o2, u_floor_width_scale: a2, u_units_to_pixels: [1 / c2.pixelsToGLUnits[0], 1 / c2.pixelsToGLUnits[1]], u_dash_image: 0, u_gradient_image: 1, u_image_height: i2, u_texsize: Wf(r2) && e2.lineAtlasTexture ? e2.lineAtlasTexture.size : [0, 0], u_tile_units_to_pixels: Hf(e2, t2.transform), u_alpha_discard_threshold: 0, u_trim_offset: l2, u_trim_fade_range: r2.paint.get("line-trim-fade-range"), u_trim_color: r2.paint.get("line-trim-color").toRenderColor(p2 ? null : r2.lut).toArray01(), u_emissive_strength: r2.paint.get("line-emissive-strength"), u_zbias_factor: f2, u_tile_to_meter: iu(e2.tileID.canonical, 0), u_ground_shadow_factor: u5 };
          }, t.dQ = Lt, t.dR = Zc, t.dS = Ql, t.dT = df, t.dU = qu, t.dV = of, t.dW = Xp, t.dX = 450, t.dY = 7, t.dZ = qy, t.d_ = Qo, t.da = function(t2) {
            const e2 = t2.lastIndexOf(qo);
            return e2 >= 0 ? t2.slice(e2 + 1) : "";
          }, t.db = function(t2) {
            const e2 = [], r2 = t2.id;
            return void 0 === r2 && e2.push({ message: `layers.${r2}: missing required property "id"` }), void 0 === t2.render && e2.push({ message: `layers.${r2}: missing required method "render"` }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: `layers.${r2}: property "renderingMode" must be either "2d" or "3d"` }), e2;
          }, t.dc = function(t2, e2, r2, n2) {
            return "custom" === t2.type ? new Qy(t2, e2) : new Hg[t2.type](t2, e2, r2, n2);
          }, t.dd = Ut, t.de = function(t2) {
            const e2 = t2.indexOf(qo);
            return e2 >= 0 ? t2.slice(e2 + 1) : "";
          }, t.df = class extends Db {
            constructor(t2, e2) {
              super(t2._vectorTileFeature, t2._z, t2._x, t2._y, t2.id), t2.state && (this.state = Object.assign({}, t2.state)), this.target = e2.target, this.namespace = e2.namespace, e2.properties && (this.properties = e2.properties), this.target && ("featuresetId" in this.target && !this.target.importId || "layerId" in this.target) && (this.source = t2.source, this.sourceLayer = t2.sourceLayer, this.layer = t2.layer);
            }
            toJSON() {
              const t2 = super.toJSON();
              return t2.target = this.target, t2.namespace = this.namespace, t2;
            }
          }, t.dg = ho, t.dh = Ce, t.di = pl, t.dj = class extends ol {
            constructor(t2) {
              super(t2), this.current = ml;
            }
            set(t2, e2, r2) {
              if (this.fetchUniformLocation(t2, e2)) {
                for (let t3 = 0; t3 < 9; t3++) if (r2[t3] !== this.current[t3]) {
                  this.current = r2, this.gl.uniformMatrix3fv(this.location, false, r2);
                  break;
                }
              }
            }
          }, t.dk = zt, t.dl = function(t2, e2, r2) {
            const n2 = Mc(r2.zoom), i2 = t2.style.map._antialias, s2 = t2.terrain && t2.terrain.exaggeration() > 0;
            return 0 === n2 && !i2 && !s2;
          }, t.dm = function(t2) {
            const e2 = t2.pixelsPerMeter, r2 = e2 / Yl(1, t2.center.lat), n2 = l(new Float64Array(16));
            return h(n2, n2, [t2.point.x, t2.point.y, 0]), p(n2, n2, [r2, r2, e2]), Float32Array.from(n2);
          }, t.dn = dc, t.dp = function(t2) {
            const e2 = tu - 5;
            t2 = Pt(t2, -e2, e2) / e2 * 90;
            const r2 = Math.pow(Math.abs(Math.sin(Mt(t2))), 3);
            return Math.round(r2 * (Fl.length - 1));
          }, t.dq = function(t2, e2, r2, n2) {
            const i2 = e2.getNorth(), s2 = e2.getSouth(), a2 = e2.getWest(), l2 = e2.getEast(), u5 = 1 << t2.z, c2 = l2 - a2, h2 = i2 - s2, p2 = c2 / Dl, f2 = -h2 / Fl[r2], d2 = [0, p2, 0, f2, 0, 0, i2, a2, 0];
            if (t2.z > 0) {
              const t3 = 180 / n2;
              o(d2, d2, [t3 / c2 + 1, 0, 0, 0, t3 / h2 + 1, 0, -0.5 * t3 / p2, 0.5 * t3 / f2, 1]);
            }
            return d2[2] = u5, d2[5] = t2.x, d2[8] = t2.y, d2;
          }, t.dr = cc2, t.ds = function(t2, e2, r2) {
            const n2 = l(new Float64Array(16)), i2 = (e2 / (1 << t2) - 0.5) * Math.PI * 2;
            return d(n2, r2.globeMatrix, i2), Float32Array.from(n2);
          }, t.dt = class {
            isDataAvailableAtPoint(t2) {
              const e2 = this._source();
              if (this.isUsingMockSource() || !e2 || t2.y < 0 || t2.y > 1) return false;
              const r2 = e2.getSource().maxzoom, n2 = 1 << r2, i2 = Math.floor(t2.x), s2 = Math.floor((t2.x - i2) * n2), o2 = Math.floor(t2.y * n2), a2 = this.findDEMTileFor(new $u(r2, i2, r2, s2, o2));
              return !(!a2 || !a2.dem);
            }
            getAtPointOrZero(t2, e2 = 0) {
              return this.getAtPoint(t2, e2) || 0;
            }
            getAtPoint(t2, e2, r2 = true) {
              if (this.isUsingMockSource()) return null;
              null == e2 && (e2 = null);
              const n2 = this._source();
              if (!n2) return e2;
              if (t2.y < 0 || t2.y > 1) return e2;
              const i2 = n2.getSource().maxzoom, s2 = 1 << i2, o2 = Math.floor(t2.x), a2 = t2.x - o2, l2 = new $u(i2, o2, i2, Math.floor(a2 * s2), Math.floor(t2.y * s2)), u5 = this.findDEMTileFor(l2);
              if (!u5 || !u5.dem) return e2;
              const c2 = u5.dem, h2 = 1 << u5.tileID.canonical.z, p2 = (a2 * h2 - u5.tileID.canonical.x) * c2.dim, f2 = (t2.y * h2 - u5.tileID.canonical.y) * c2.dim, d2 = Math.floor(p2), m2 = Math.floor(f2);
              return (r2 ? this.exaggeration() : 1) * or(or(c2.get(d2, m2), c2.get(d2, m2 + 1), f2 - m2), or(c2.get(d2 + 1, m2), c2.get(d2 + 1, m2 + 1), f2 - m2), p2 - d2);
            }
            getAtTileOffset(t2, e2, r2) {
              const n2 = 1 << t2.canonical.z;
              return this.getAtPointOrZero(new su(t2.wrap + (t2.canonical.x + e2 / Tn) / n2, (t2.canonical.y + r2 / Tn) / n2));
            }
            getAtTileOffsetFunc(t2, e2, r2, n2) {
              return (i2) => {
                const s2 = this.getAtTileOffset(t2, i2.x, i2.y), o2 = n2.upVector(t2.canonical, i2.x, i2.y);
                return E(o2, o2, s2 * n2.upVectorScale(t2.canonical, e2, r2).metersToTile), o2;
              };
            }
            getForTilePoints(t2, e2, r2, n2) {
              if (this.isUsingMockSource()) return false;
              const i2 = Cg.create(this, t2, n2);
              return !!i2 && (e2.forEach((t3) => {
                t3[2] = this.exaggeration() * i2.getElevationAt(t3[0], t3[1], r2);
              }), true);
            }
            getMinMaxForTile(t2) {
              if (this.isUsingMockSource()) return null;
              const e2 = this.findDEMTileFor(t2);
              if (!e2 || !e2.dem) return null;
              const r2 = e2.dem.tree, n2 = e2.tileID, i2 = 1 << t2.canonical.z - n2.canonical.z;
              let s2 = t2.canonical.x / i2 - n2.canonical.x, o2 = t2.canonical.y / i2 - n2.canonical.y, a2 = 0;
              for (let e3 = 0; e3 < t2.canonical.z - n2.canonical.z && !r2.leaves[a2]; e3++) {
                s2 *= 2, o2 *= 2;
                const t3 = 2 * Math.floor(o2) + Math.floor(s2);
                a2 = r2.childOffsets[a2] + t3, s2 %= 1, o2 %= 1;
              }
              return { min: this.exaggeration() * r2.minimums[a2], max: this.exaggeration() * r2.maximums[a2] };
            }
            getMinElevationBelowMSL() {
              throw new Error("Pure virtual method called.");
            }
            raycast(t2, e2, r2) {
              throw new Error("Pure virtual method called.");
            }
            pointCoordinate(t2) {
              throw new Error("Pure virtual method called.");
            }
            _source() {
              throw new Error("Pure virtual method called.");
            }
            isUsingMockSource() {
              throw new Error("Pure virtual method called.");
            }
            exaggeration() {
              throw new Error("Pure virtual method called.");
            }
            findDEMTileFor(t2) {
              throw new Error("Pure virtual method called.");
            }
            get visibleDemTiles() {
              throw new Error("Getter must be implemented in subclass.");
            }
            getMinMaxForVisibleTiles() {
              const t2 = this.visibleDemTiles;
              if (0 === t2.length) return null;
              let e2 = false, r2 = Number.MAX_VALUE, n2 = Number.MIN_VALUE;
              for (const i2 of t2) {
                const t3 = this.getMinMaxForTile(i2.tileID);
                t3 && (r2 = Math.min(r2, t3.min), n2 = Math.max(n2, t3.max), e2 = true);
              }
              return e2 ? { min: r2, max: n2 } : null;
            }
          }, t.du = Xc, t.dv = sc, t.dw = function(t2, e2) {
            return [Math.pow(t2[0], 2.2) * e2, Math.pow(t2[1], 2.2) * e2, Math.pow(t2[2], 2.2) * e2];
          }, t.dx = i, t.dy = function(t2, e2) {
            var r2 = Math.sin(e2), n2 = Math.cos(e2);
            return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.dz = O, t.e = re, t.e$ = Vb, t.e0 = 256, t.e1 = bc4, t.e2 = ua, t.e3 = d, t.e4 = function(t2, e2) {
            return t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[4], t2[4] = e2[5], t2[5] = e2[6], t2[6] = e2[8], t2[7] = e2[9], t2[8] = e2[10], t2;
          }, t.e5 = Ia, t.e6 = Sa, t.e7 = function(t2, e2, r2, n2, i2) {
            return Pt((t2 - e2) / (r2 - e2) * (i2 - n2) + n2, n2, i2);
          }, t.e8 = J, t.e9 = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], s2 = e2[3], o2 = e2[4], a2 = e2[5], l2 = e2[6], u5 = e2[7], c2 = e2[8], h2 = c2 * o2 - a2 * u5, p2 = -c2 * s2 + a2 * l2, f2 = u5 * s2 - o2 * l2, d2 = r2 * h2 + n2 * p2 + i2 * f2;
            return d2 ? (t2[0] = h2 * (d2 = 1 / d2), t2[1] = (-c2 * n2 + i2 * u5) * d2, t2[2] = (a2 * n2 - i2 * o2) * d2, t2[3] = p2 * d2, t2[4] = (c2 * r2 - i2 * l2) * d2, t2[5] = (-a2 * r2 + i2 * s2) * d2, t2[6] = f2 * d2, t2[7] = (-u5 * r2 + n2 * l2) * d2, t2[8] = (o2 * r2 - n2 * s2) * d2, t2) : null;
          }, t.eA = function(t2, e2, r2) {
            return t2[0] = e2[0] / r2[0], t2[1] = e2[1] / r2[1], t2[2] = e2[2] / r2[2], t2;
          }, t.eB = $, t.eC = Ul, t.eD = B2, t.eE = function(t2, e2, r2, n2) {
            return t2[0] = e2, t2[1] = r2, t2[2] = n2, t2;
          }, t.eF = function([t2, e2, r2]) {
            const n2 = Math.hypot(t2, e2, r2), i2 = Math.atan2(t2, r2), s2 = 0.5 * Math.PI - Math.acos(-e2 / n2);
            return new $l(It(i2), It(s2));
          }, t.eG = X, t.eH = sg, t.eI = function(t2) {
            const e2 = t2.navigator ? t2.navigator.userAgent : null;
            return !!function(t3) {
              if (null == Wt) {
                const e3 = t3.navigator ? t3.navigator.userAgent : null;
                Wt = !!t3.safari || !(!e3 || !(/\b(iPad|iPhone|iPod)\b/.test(e3) || e3.match("Safari") && !e3.match("Chrome")));
              }
              return Wt;
            }(t2) && !(!e2 || !(e2.match("Version/15.4") || e2.match("Version/15.5") || e2.match(/CPU (OS|iPhone OS) (15_4|15_5) like Mac OS X/)));
          }, t.eJ = function(t2, e2) {
            ye = t2, ge = e2;
          }, t.eK = Sc, t.eL = Ic, t.eM = function(t2) {
            const e2 = [0, 0, 0], r2 = l(new Float64Array(16));
            return c(r2, t2.pixelMatrix, t2.globeMatrix), R(e2, e2, r2), new bt(e2[0], e2[1]);
          }, t.eN = function(t2, e2, r2 = false) {
            if (ao === no || ao === io || ao === so) throw new Error("setRTLTextPlugin cannot be called multiple times.");
            lo = pe.resolveURL(t2), ao = no, oo = e2, co(), r2 || fo();
          }, t.eO = po, t.eP = function() {
            rx().acquire(Kg);
          }, t.eQ = function() {
            const t2 = tx;
            t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Kg), tx = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, t.eR = Jg, t.eS = function(t2) {
            const e2 = _e();
            if (!e2) return;
            const r2 = e2.delete(me);
            t2 && r2.then(() => t2()).catch(t2);
          }, t.eT = Yg, t.eU = ob, t.eV = function(t2) {
            eb2 = pe.resolveURL(t2), sb || (sb = new Qg(rx(), new Qe())), sb.broadcast("setDracoUrl", eb2);
          }, t.eW = ab4, t.eX = function(t2) {
            nb = pe.resolveURL(t2), sb || (sb = new Qg(rx(), new Qe())), sb.broadcast("setMeshoptUrl", nb);
          }, t.eY = js, t.eZ = qc, t.e_ = pm, t.ea = as, t.eb = V, t.ec = ru, t.ed = class {
            constructor(t2, e2, r2, n2) {
              this.context = t2, this.format = n2, this.size = r2, this.texture = t2.gl.createTexture();
              const [i2, s2, o2] = this.size, { gl: a2 } = t2;
              a2.bindTexture(a2.TEXTURE_3D, this.texture), t2.pixelStoreUnpackFlipY.set(false), t2.pixelStoreUnpack.set(1), t2.pixelStoreUnpackPremultiplyAlpha.set(false), a2.texImage3D(a2.TEXTURE_3D, 0, this.format, i2, s2, o2, 0, Ly(this.format), Ry(this.format), e2.data);
            }
            bind(t2, e2) {
              const { context: r2 } = this, { gl: n2 } = r2;
              n2.bindTexture(n2.TEXTURE_3D, this.texture), t2 !== this.minFilter && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_MIN_FILTER, t2), this.minFilter = t2), e2 !== this.wrapS && (n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_3D, n2.TEXTURE_WRAP_T, e2), this.wrapS = e2);
            }
            destroy() {
              const { gl: t2 } = this.context;
              t2.deleteTexture(this.texture), this.texture = null;
            }
          }, t.ee = function(t2, e2) {
            if (t2 === e2) {
              var r2 = e2[1], n2 = e2[2], i2 = e2[3], s2 = e2[6], o2 = e2[7], a2 = e2[11];
              t2[1] = e2[4], t2[2] = e2[8], t2[3] = e2[12], t2[4] = r2, t2[6] = e2[9], t2[7] = e2[13], t2[8] = n2, t2[9] = s2, t2[11] = e2[14], t2[12] = i2, t2[13] = o2, t2[14] = a2;
            } else t2[0] = e2[0], t2[1] = e2[4], t2[2] = e2[8], t2[3] = e2[12], t2[4] = e2[1], t2[5] = e2[5], t2[6] = e2[9], t2[7] = e2[13], t2[8] = e2[2], t2[9] = e2[6], t2[10] = e2[10], t2[11] = e2[14], t2[12] = e2[3], t2[13] = e2[7], t2[14] = e2[11], t2[15] = e2[15];
            return t2;
          }, t.ef = ug, t.eg = b, t.eh = [1, 1, 1], t.ei = function(t2, e2, n2, i2) {
            var s2 = new r(4);
            return s2[0] = t2, s2[1] = e2, s2[2] = n2, s2[3] = i2, s2;
          }, t.ej = q, t.ek = function(t2, e2, r2, n2) {
            var i2 = e2[0], s2 = e2[1], o2 = e2[2], a2 = e2[3];
            return t2[0] = i2 + n2 * (r2[0] - i2), t2[1] = s2 + n2 * (r2[1] - s2), t2[2] = o2 + n2 * (r2[2] - o2), t2[3] = a2 + n2 * (r2[3] - a2), t2;
          }, t.el = Cg, t.em = zg, t.en = ga, t.eo = Ea, t.ep = function(t2, e2, n2, i2, s2, o2, a2, l2, u5, c2, h2, p2, f2, d2, m2, y2) {
            var g2 = new r(16);
            return g2[0] = t2, g2[1] = e2, g2[2] = n2, g2[3] = i2, g2[4] = s2, g2[5] = o2, g2[6] = a2, g2[7] = l2, g2[8] = u5, g2[9] = c2, g2[10] = h2, g2[11] = p2, g2[12] = f2, g2[13] = d2, g2[14] = m2, g2[15] = y2, g2;
          }, t.eq = Nl, t.er = ka, t.es = za, t.et = class {
            constructor() {
              this._updateTime = 0, this._sourceIds = [], this._activeRegions = [], this._prevRegions = [], this._globalClipBounds = { min: new bt(1 / 0, 1 / 0), max: new bt(-1 / 0, -1 / 0) };
            }
            clear() {
              this._activeRegions.length > 0 && ++this._updateTime, this._activeRegions = [], this._prevRegions = [];
            }
            get updateTime() {
              return this._updateTime;
            }
            getReplacementRegionsForTile(t2, e2 = false) {
              const r2 = Vp(new bt(0, 0), new bt(Tn, Tn), t2), n2 = [];
              if (e2 && !Tp(r2, this._globalClipBounds)) return n2;
              for (const e3 of this._activeRegions) {
                if (e3.hiddenByOverlap) continue;
                if (!Tp(r2, e3)) continue;
                const i2 = Cp(e3.min, e3.max, t2);
                n2.push({ min: i2.min, max: i2.max, sourceId: this._sourceIds[e3.priority], footprint: e3.footprint, footprintTileId: e3.tileId, order: e3.order, clipMask: e3.clipMask, clipScope: e3.clipScope });
              }
              return n2;
            }
            setSources(t2) {
              this._setSources(t2.map((t3) => ({ getSourceId: () => t3.cache.id, getFootprints: () => {
                const e2 = [];
                for (const r2 of t3.cache.getVisibleCoordinates()) {
                  const n2 = t3.cache.getTile(r2).buckets[t3.layer];
                  n2 && n2.updateFootprints(r2.toUnwrapped(), e2);
                }
                return e2;
              }, getOrder: () => t3.order, getClipMask: () => t3.clipMask, getClipScope: () => t3.clipScope })));
            }
            _addSource(t2) {
              const e2 = t2.getFootprints();
              if (0 === e2.length) return;
              const r2 = t2.getOrder(), n2 = t2.getClipMask(), i2 = t2.getClipScope();
              for (const t3 of e2) {
                if (!t3.footprint) continue;
                const e3 = Vp(t3.footprint.min, t3.footprint.max, t3.id);
                this._activeRegions.push({ min: e3.min, max: e3.max, hiddenByOverlap: false, priority: this._sourceIds.length, tileId: t3.id, footprint: t3.footprint, order: r2, clipMask: n2, clipScope: i2 });
              }
              this._sourceIds.push(t2.getSourceId());
            }
            _computeReplacement() {
              this._activeRegions.sort((t3, e2) => t3.priority - e2.priority || Ep(t3.min, e2.min) || Ep(t3.max, e2.max) || t3.order - e2.order || t3.clipMask - e2.clipMask || function(t4, e3) {
                const r2 = (t5, e4) => t5 + e4;
                return t4.length - e3.length || t4.reduce(r2, "").localeCompare(e3.reduce(r2, ""));
              }(t3.clipScope, e2.clipScope));
              let t2 = this._activeRegions.length !== this._prevRegions.length;
              if (!t2) {
                let e2 = 0;
                for (; !t2 && e2 !== this._activeRegions.length; ) {
                  const r2 = this._activeRegions[e2], n2 = this._prevRegions[e2];
                  t2 = r2.priority !== n2.priority || !Pp(r2, n2) || r2.order !== n2.order || r2.clipMask !== n2.clipMask || !_t(r2.clipScope, n2.clipScope), ++e2;
                }
              }
              if (t2) {
                ++this._updateTime;
                for (const t4 of this._activeRegions) t4.order !== zp && (this._globalClipBounds.min.x = Math.min(this._globalClipBounds.min.x, t4.min.x), this._globalClipBounds.min.y = Math.min(this._globalClipBounds.min.y, t4.min.y), this._globalClipBounds.max.x = Math.max(this._globalClipBounds.max.x, t4.max.x), this._globalClipBounds.max.y = Math.max(this._globalClipBounds.max.y, t4.max.y));
                const t3 = (t4) => {
                  const e2 = this._activeRegions;
                  if (t4 >= e2.length) return t4;
                  const r2 = e2[t4].priority;
                  for (; t4 < e2.length && e2[t4].priority === r2; ) ++t4;
                  return t4;
                };
                if (this._sourceIds.length > 1) {
                  let e2 = 0, r2 = t3(e2);
                  for (; e2 !== r2; ) {
                    let n2 = e2;
                    const i2 = e2;
                    for (; n2 !== r2; ) {
                      const t4 = this._activeRegions[n2];
                      t4.hiddenByOverlap = false;
                      for (let e3 = 0; e3 < i2; e3++) {
                        const r3 = this._activeRegions[e3];
                        if (!r3.hiddenByOverlap && t4.order === zp && Tp(t4, r3) && (t4.hiddenByOverlap = Fp(t4.footprint, t4.tileId, r3.footprint, r3.tileId), t4.hiddenByOverlap)) break;
                      }
                      ++n2;
                    }
                    e2 = r2, r2 = t3(e2);
                  }
                }
              }
            }
            _setSources(t2) {
              [this._prevRegions, this._activeRegions] = [this._activeRegions, []], this._sourceIds = [];
              for (let e2 = t2.length - 1; e2 >= 0; e2--) this._addSource(t2[e2]);
              this._computeReplacement();
            }
          }, t.eu = class {
            constructor(t2) {
              this._createGrid(t2), this._createPoles(t2);
            }
            destroy() {
              this._poleIndexBuffer.destroy(), this._gridBuffer.destroy(), this._gridIndexBuffer.destroy(), this._poleNorthVertexBuffer.destroy(), this._poleSouthVertexBuffer.destroy();
              for (const t2 of this._poleSegments) t2.destroy();
              for (const t2 of this._gridSegments) t2.withSkirts.destroy(), t2.withoutSkirts.destroy();
            }
            _fillGridMeshWithLods(t2, e2) {
              const r2 = new ea2(), n2 = new wa(), i2 = [], s2 = t2 + 1 + 2, o2 = e2[0] + 1, a2 = e2[0] + 1 + (1 + e2.length), l2 = (t3, e3, r3) => {
                let n3 = t3 === s2 - 1 ? t3 - 2 : 0 === t3 ? t3 : t3 - 1;
                return n3 += r3 ? 24575 : 0, [n3, e3];
              };
              for (let t3 = 0; t3 < s2; ++t3) r2.emplaceBack(...l2(t3, 0, true));
              for (let t3 = 0; t3 < o2; ++t3) for (let e3 = 0; e3 < s2; ++e3) r2.emplaceBack(...l2(e3, t3, (0 === e3 || e3 === s2 - 1) && true));
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const n3 = e2[t3];
                for (let t4 = 0; t4 < s2; ++t4) r2.emplaceBack(...l2(t4, n3, true));
              }
              for (let t3 = 0; t3 < e2.length; ++t3) {
                const o3 = n2.length, l3 = e2[t3] + 1 + 2, u5 = new wa();
                for (let r3 = 0; r3 < l3 - 1; r3++) {
                  const i3 = r3 === l3 - 2, o4 = i3 ? s2 * (a2 - e2.length + t3 - r3) : s2;
                  for (let t4 = 0; t4 < s2 - 1; t4++) {
                    const e3 = r3 * s2 + t4;
                    0 === r3 || i3 || 0 === t4 || t4 === s2 - 2 ? (u5.emplaceBack(e3 + 1, e3, e3 + o4), u5.emplaceBack(e3 + o4, e3 + o4 + 1, e3 + 1)) : (n2.emplaceBack(e3 + 1, e3, e3 + o4), n2.emplaceBack(e3 + o4, e3 + o4 + 1, e3 + 1));
                  }
                }
                const c2 = Ka.simpleSegment(0, o3, r2.length, n2.length - o3);
                for (let t4 = 0; t4 < u5.uint16.length; t4 += 3) n2.emplaceBack(u5.uint16[t4], u5.uint16[t4 + 1], u5.uint16[t4 + 2]);
                const h2 = Ka.simpleSegment(0, o3, r2.length, n2.length - o3);
                i2.push({ withoutSkirts: c2, withSkirts: h2 });
              }
              return { vertices: r2, indices: n2, segments: i2 };
            }
            _createGrid(t2) {
              const e2 = this._fillGridMeshWithLods(Dl, Fl);
              this._gridSegments = e2.segments, this._gridBuffer = t2.createVertexBuffer(e2.vertices, Wu.members), this._gridIndexBuffer = t2.createIndexBuffer(e2.indices, true);
            }
            _createPoles(t2) {
              const e2 = new wa();
              for (let t3 = 0; t3 <= Dl; t3++) e2.emplaceBack(0, t3 + 1, t3 + 2);
              this._poleIndexBuffer = t2.createIndexBuffer(e2, true);
              const r2 = new Ia(), n2 = new Ia(), i2 = new Ia(), s2 = new Ia();
              this._poleSegments = [];
              for (let t3 = 0, e3 = 0; t3 < Bl; t3++) {
                const o2 = 360 / (1 << t3);
                r2.emplaceBack(0, -Tl, 0, 0.5, 0), n2.emplaceBack(0, -Tl, 0, 0.5, 1), i2.emplaceBack(0, -Tl, 0, 0.5, 0.5), s2.emplaceBack(0, -Tl, 0, 0.5, 0.5);
                for (let t4 = 0; t4 <= Dl; t4++) {
                  let e4 = t4 / Dl, a2 = 0;
                  const l2 = or(0, o2, e4), [u5, c2, h2] = Ol(kc, Ec, l2, Tl);
                  r2.emplaceBack(u5, c2, h2, e4, a2), n2.emplaceBack(u5, c2, h2, e4, 1 - a2);
                  const p2 = Mt(l2);
                  e4 = 0.5 + 0.5 * Math.sin(p2), a2 = 0.5 + 0.5 * Math.cos(p2), i2.emplaceBack(u5, c2, h2, e4, a2), s2.emplaceBack(u5, c2, h2, e4, 1 - a2);
                }
                this._poleSegments.push(Ka.simpleSegment(e3, 0, 66, 64)), e3 += 66;
              }
              this._poleNorthVertexBuffer = t2.createVertexBuffer(r2, Xu, false), this._poleSouthVertexBuffer = t2.createVertexBuffer(n2, Xu, false), this._texturedPoleNorthVertexBuffer = t2.createVertexBuffer(i2, Xu, false), this._texturedPoleSouthVertexBuffer = t2.createVertexBuffer(s2, Xu, false);
            }
            getGridBuffers(t2, e2) {
              return [this._gridBuffer, this._gridIndexBuffer, e2 ? this._gridSegments[t2].withSkirts : this._gridSegments[t2].withoutSkirts];
            }
            getPoleBuffers(t2, e2) {
              return [e2 ? this._texturedPoleNorthVertexBuffer : this._poleNorthVertexBuffer, e2 ? this._texturedPoleSouthVertexBuffer : this._poleSouthVertexBuffer, this._poleIndexBuffer, this._poleSegments[t2]];
            }
          }, t.ev = zp, t.ew = kt, t.ex = function() {
            return !!document.fullscreenElement || !!document.webkitFullscreenElement;
          }, t.ey = Et, t.ez = nu, t.f = function(t2) {
            return 0 === t2.indexOf("mapbox:");
          }, t.f0 = Fb, t.f1 = Ff, t.f2 = jh, t.f3 = "hd_road_elevation", t.f4 = Kh, t.f5 = Ot, t.f6 = tp, t.f7 = am, t.f8 = sm, t.f9 = function(t2, e2, r2, n2, i2, s2, o2, a2 = 1, l2, u5) {
            t2.createArrays(), t2.tilePixelRatio = Tn / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
            const c2 = t2.layers[0].layout, h2 = t2.layers[0]._unevaluatedLayout._values, p2 = {};
            p2.scaleFactor = a2, p2.textSizeScaleRange = c2.get("text-size-scale-range"), p2.iconSizeScaleRange = c2.get("icon-size-scale-range");
            const [f2, d2] = p2.textSizeScaleRange, [m2, y2] = p2.iconSizeScaleRange;
            p2.textScaleFactor = Pt(p2.scaleFactor, f2, d2), p2.iconScaleFactor = Pt(p2.scaleFactor, m2, y2);
            const g2 = h2["text-size"], x2 = h2["icon-size"];
            if ("composite" === t2.textSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.textSizeData;
              p2.compositeTextSizes = [g2.possiblyEvaluate(new yo(e3), s2), g2.possiblyEvaluate(new yo(r3), s2)];
            }
            if ("composite" === t2.iconSizeData.kind) {
              const { minZoom: e3, maxZoom: r3 } = t2.iconSizeData;
              p2.compositeIconSizes = [x2.possiblyEvaluate(new yo(e3), s2), x2.possiblyEvaluate(new yo(r3), s2)];
            }
            p2.layoutTextSize = g2.possiblyEvaluate(new yo(o2 + 1), s2), p2.layoutIconSize = x2.possiblyEvaluate(new yo(o2 + 1), s2), p2.textMaxSize = g2.possiblyEvaluate(new yo(18), s2);
            const v3 = c2.get("symbol-placement"), b2 = "map" === c2.get("text-rotation-alignment") && "point" !== v3, _2 = c2.get("text-size");
            let w2 = false;
            const A2 = [];
            for (const o3 of t2.features) {
              const a3 = c2.get("text-font").evaluate(o3, {}, s2).join(","), f3 = _2.evaluate(o3, {}, s2) * p2.textScaleFactor, d3 = p2.layoutTextSize.evaluate(o3, {}, s2) * p2.textScaleFactor, m3 = p2.layoutIconSize.evaluate(o3, {}, s2) * p2.iconScaleFactor, y3 = { horizontal: {}, vertical: void 0 }, g3 = o3.text;
              let x3, M2 = [0, 0];
              if (g3) {
                const n3 = g3.toString(), u6 = c2.get("text-letter-spacing").evaluate(o3, {}, s2) * cd2, h3 = c2.get("text-line-height").evaluate(o3, {}, s2) * cd2, p3 = Ws(n3) ? u6 : 0, m4 = c2.get("text-anchor").evaluate(o3, {}, s2), x4 = c2.get("text-variable-anchor");
                if (!x4) {
                  const t3 = c2.get("text-radial-offset").evaluate(o3, {}, s2);
                  if (t3) M2 = Em(m4, [t3 * cd2, zm]);
                  else {
                    const t4 = c2.get("text-offset").evaluate(o3, {}, s2);
                    M2 = [t4[0] * cd2, t4[1] * cd2];
                  }
                }
                let _3 = b2 ? "center" : c2.get("text-justify").evaluate(o3, {}, s2);
                const w3 = "point" === v3, A3 = w3 ? c2.get("text-max-width").evaluate(o3, {}, s2) * cd2 : 1 / 0, I3 = (s3) => {
                  t2.allowVerticalPlacement && Zs(n3) && (y3.vertical = Pd(g3, e2, r2, i2, a3, A3, h3, m4, s3, p3, M2, zd.vertical, true, d3, f3, l2));
                };
                if (!b2 && x4) {
                  const t3 = "auto" === _3 ? x4.map((t4) => Fm(t4)) : [_3];
                  let n4 = false;
                  for (let s3 = 0; s3 < t3.length; s3++) {
                    const o4 = t3[s3];
                    if (!y3.horizontal[o4]) if (n4) y3.horizontal[o4] = y3.horizontal[0];
                    else {
                      const t4 = Pd(g3, e2, r2, i2, a3, A3, h3, "center", o4, p3, M2, zd.horizontal, false, d3, f3, l2);
                      t4 && (y3.horizontal[o4] = t4, n4 = 1 === t4.positionedLines.length);
                    }
                  }
                  I3("left");
                } else {
                  if ("auto" === _3 && (_3 = Fm(m4)), w3 || c2.get("text-writing-mode").indexOf("horizontal") >= 0 || !Zs(n3)) {
                    const t3 = Pd(g3, e2, r2, i2, a3, A3, h3, m4, _3, p3, M2, zd.horizontal, false, d3, f3, l2);
                    t3 && (y3.horizontal[_3] = t3);
                  }
                  I3(w3 ? "left" : _3);
                }
              }
              let I2, S2, z2, k2, E2, P2, T2, B3 = false;
              if (o3.icon && o3.icon.hasPrimary()) {
                const e3 = Bm(o3.icon, t2.iconSizeData, h2["icon-size"], s2, t2.zoom, o3, l2, p2.iconScaleFactor);
                I2 = e3.iconPrimary, z2 = e3.iconSecondary;
                const r3 = I2.toString();
                if (S2 = n2.get(r3), S2 && (E2 = c2.get("icon-offset").evaluate(o3, {}, s2), P2 = c2.get("icon-anchor").evaluate(o3, {}, s2), T2 = c2.get("icon-text-fit").evaluate(o3, {}, s2), x3 = Nd(i2.get(r3), z2 ? i2.get(z2.toString()) : void 0, E2, P2), B3 = S2.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = S2.sdf : t2.sdfIcons !== S2.sdf && $t("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (S2.pixelRatio !== t2.pixelRatio || 0 !== c2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true)), z2) {
                  const t3 = z2.toString();
                  k2 = n2.get(t3);
                }
              }
              w2 = w2 || !(!o3.icon || !o3.icon.hasSecondary());
              const V2 = jm(y3.horizontal) || y3.vertical;
              t2.iconsInText || (t2.iconsInText = !!V2 && V2.iconsInText);
              const C3 = d3 * p2.textScaleFactor / cd2, { defaultShapedIcon: D3, verticallyShapedIcon: F2 } = Lm(t2, x3, c2, o3, s2, y3, C3, E2, T2);
              "none" !== T2 && x3 && ($d(x3) || Gd(x3)) && (Pm(0, S2, I2, x3, D3, T2, u5, n2, i2), Pm(0, k2, z2, x3, D3, T2, u5, n2, i2), F2 && (Pm(0, S2, I2, x3, F2, T2, u5, n2, i2), Pm(0, k2, z2, x3, F2, T2, u5, n2, i2))), x3 = D3, A2.push({ feature: o3, shapedTextOrientations: y3, shapedText: V2, shapedIcon: x3, iconPrimary: I2, iconSecondary: z2, iconOffset: E2, iconAnchor: P2, verticallyShapedIcon: F2, layoutTextSize: d3, layoutIconSize: m3, textOffset: M2, isSDFIcon: B3, iconTextFit: T2 });
            }
            return { featureData: A2, sizes: p2, hasAnySecondaryIcon: w2, textAlongLine: b2, symbolPlacement: v3 };
          }, t.fa = lm, t.fb = function(t2, e2, r2, n2, i2, s2, o2, a2, l2, u5) {
            const { featureData: c2, hasAnySecondaryIcon: h2, sizes: p2, textAlongLine: f2, symbolPlacement: d2 } = e2;
            for (const e3 of c2) {
              const { shapedIcon: r3, verticallyShapedIcon: s3, feature: c3, shapedTextOrientations: m2, shapedText: y2, layoutTextSize: g2, textOffset: x2, isSDFIcon: v3, iconPrimary: b2, iconSecondary: _2, iconTextFit: w2, iconOffset: A2 } = e3;
              Vm(r3, u5.iconPositions, b2, _2), Vm(s3, u5.iconPositions, b2, _2), Cm(m2, u5.iconPositions), (y2 || r3) && Rm(t2, c3, m2, r3, s3, l2, p2, g2, 0, x2, v3, n2, i2, o2, a2, h2, w2, A2, f2, d2);
            }
            r2 && t2.generateCollisionDebugBuffers(s2, t2.collisionBoxArray, p2.textScaleFactor);
          }, t.fc = Nh, t.fd = av, t.fe = vt, t.ff = Uh, t.fg = bd2, t.fh = dt, t.fi = function(t2) {
            let e2 = 0;
            if (new Uint32Array(t2, 0, 1)[0] !== yb) {
              const r2 = new Uint32Array(t2, 0, 7), [, , n2, i2, s2, o2] = r2;
              e2 = r2.byteLength + i2 + s2 + o2 + s2, (n2 !== t2.byteLength || e2 >= t2.byteLength) && $t("Invalid b3dm header information.");
            }
            return wb(t2, e2);
          }, t.fj = function(t2, e2) {
            const r2 = Pb(t2);
            for (const t3 of r2) {
              for (const e3 of t3.meshes) Tb(e3);
              t3.lights && (t3.lightMeshIndex = t3.meshes.length, t3.meshes.push(Bb(t3.lights, e2)));
            }
            return r2;
          }, t.fk = Ng, t.fl = Xt, t.fm = Wg, t.fn = mo, t.fo = function(t2) {
            we(), null != ve && ve.then((e2) => {
              e2.keys().then((r2) => {
                for (let n2 = 0; n2 < r2.length - t2; n2++) e2.delete(r2[n2]).catch((t3) => $t(t3.message));
              }).catch((t3) => $t(t3.message));
            }).catch((t3) => $t(t3.message));
          }, t.g = function(t2, e2) {
            return Ce(Ct(t2, { method: "GET" }), e2);
          }, t.h = ne, t.i = function(t2) {
            return re.API_STYLE_REGEX.test(t2) && !ie(t2);
          }, t.j = function(t2) {
            return decodeURIComponent(atob(t2).split("").map((t3) => "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2)).join(""));
          }, t.k = function(t2) {
            return btoa(encodeURIComponent(t2).replace(/%([0-9A-F]{2})/g, (t3, e2) => String.fromCharCode(Number("0x" + e2))));
          }, t.l = Ct, t.m = Me, t.n = function(t2, e2) {
            return Ce(Ct(t2, { type: "json" }), e2);
          }, t.o = Ue, t.p = function(t2, e2) {
            return Ce(Ct(t2, { method: "POST" }), e2);
          }, t.q = pe, t.r = Hc, t.s = function(t2) {
            try {
              const e2 = self[t2];
              return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
            } catch (t3) {
              return false;
            }
          }, t.t = he, t.u = function() {
            return function t2(e2) {
              return e2 ? (e2 ^ Math.random() * (16 >> e2 / 4)).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
            }();
          }, t.v = function(t2) {
            return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
          }, t.w = $t, t.x = function() {
            return ex || (ex = new Jg()), ex;
          }, t.y = Wx, t.z = Ye;
        });
        define2(["./shared"], function(e) {
          function t(e2) {
            const t2 = e2 ? e2.url.toString() : void 0;
            return t2 ? performance.getEntriesByName(t2) : [];
          }
          function s(e2) {
            if ("number" == typeof e2 || "boolean" == typeof e2 || "string" == typeof e2 || null == e2) return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              let t3 = "[";
              for (const i2 of e2) t3 += `${s(i2)},`;
              return `${t3}]`;
            }
            let t2 = "{";
            for (const i2 of Object.keys(e2).sort()) t2 += `${i2}:${s(e2[i2])},`;
            return `${t2}}`;
          }
          function i(t2) {
            let i2 = "";
            for (const o2 of e.bu) ("model" !== t2.type || "minzoom" !== o2 && "maxzoom" !== o2) && (i2 += `/${s(t2[o2])}`);
            return i2;
          }
          class o {
            constructor(e2) {
              this.keyCache = {}, this._layers = {}, this._layerConfigs = {}, e2 && this.replace(e2);
            }
            replace(e2, t2) {
              this._layerConfigs = {}, this._layers = {}, this.update(e2, [], t2);
            }
            update(t2, o2, n2) {
              this._options = n2;
              for (const s2 of t2) this._layerConfigs[s2.id] = s2, (this._layers[s2.id] = e.dc(s2, this.scope, null, this._options)).compileFilter(n2), this.keyCache[s2.id] && delete this.keyCache[s2.id];
              for (const e2 of o2) delete this.keyCache[e2], delete this._layerConfigs[e2], delete this._layers[e2];
              this.familiesBySource = {};
              const r2 = function(e2, t3) {
                const o3 = {};
                for (let n4 = 0; n4 < e2.length; n4++) {
                  const r3 = e2[n4];
                  let a2 = t3 && t3[r3.id];
                  a2 || ("symbol" === r3.type ? a2 = r3.id : (a2 = i(r3), "line" === r3.type && r3.paint && function e3(t4) {
                    return "string" == typeof t4 && "line-progress" === t4 || (Array.isArray(t4) ? t4.some(e3) : !(!t4 || "object" != typeof t4) && Object.values(t4).some(e3));
                  }(r3.paint["line-width"]) && (a2 += `/${s(r3.paint["line-width"])}`))), t3 && (t3[r3.id] = a2);
                  let l2 = o3[a2];
                  l2 || (l2 = o3[a2] = []), l2.push(r3);
                }
                const n3 = [];
                for (const e3 in o3) n3.push(o3[e3]);
                return n3;
              }(Object.values(this._layerConfigs), this.keyCache);
              for (const e2 of r2) {
                const t3 = e2.map((e3) => this._layers[e3.id]), s2 = t3[0];
                if ("none" === s2.visibility) continue;
                const i2 = s2.source || "";
                let o3 = this.familiesBySource[i2];
                o3 || (o3 = this.familiesBySource[i2] = {});
                const n3 = s2.sourceLayer || "_geojsonTileLayer";
                let r3 = o3[n3];
                r3 || (r3 = o3[n3] = []), r3.push(t3);
              }
            }
          }
          const n = 1 * e.e_;
          class r {
            constructor(t2) {
              const s2 = {}, i2 = [];
              for (const e2 in t2) {
                const o3 = t2[e2], r3 = s2[e2] = {};
                for (const e3 in o3.glyphs) {
                  const t3 = o3.glyphs[+e3];
                  if (!t3 || 0 === t3.bitmap.width || 0 === t3.bitmap.height) continue;
                  const s3 = t3.metrics.localGlyph ? n : 1, a3 = { x: 0, y: 0, w: t3.bitmap.width + 2 * s3, h: t3.bitmap.height + 2 * s3 };
                  i2.push(a3), r3[e3] = a3;
                }
              }
              const { w: o2, h: r2 } = e.H(i2), a2 = new e.eZ({ width: o2 || 1, height: r2 || 1 });
              for (const i3 in t2) {
                const o3 = t2[i3];
                for (const t3 in o3.glyphs) {
                  const r3 = o3.glyphs[+t3];
                  if (!r3 || 0 === r3.bitmap.width || 0 === r3.bitmap.height) continue;
                  const l2 = s2[i3][t3], c2 = r3.metrics.localGlyph ? n : 1;
                  e.eZ.copy(r3.bitmap, a2, { x: 0, y: 0 }, { x: l2.x + c2, y: l2.y + c2 }, r3.bitmap);
                }
              }
              this.image = a2, this.positions = s2;
            }
          }
          e.eY(r, "GlyphAtlas");
          class a {
            constructor(t2) {
              this.tileID = new e.aM(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.lut = t2.lut, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.scope = t2.scope, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.request && t2.request.collectResourceTiming, this.promoteId = t2.promoteId, this.isSymbolTile = t2.isSymbolTile, this.tileTransform = e.aW(t2.tileID.canonical, t2.projection), this.projection = t2.projection, this.worldview = t2.worldview, this.localizableLayerIds = t2.localizableLayerIds, this.brightness = t2.brightness, this.extraShadowCaster = !!t2.extraShadowCaster, this.tessellationStep = t2.tessellationStep, this.scaleFactor = t2.scaleFactor;
            }
            parse(t2, s2, i2, o2, n2, a2) {
              this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.b0();
              const c2 = new e.e$(Object.keys(t2.layers).sort()), h2 = new e.f0(this.tileID, this.promoteId);
              h2.bucketLayerIDs = [];
              const u5 = {}, d2 = new e.f1(256, 256), f2 = { featureIndex: h2, iconDependencies: /* @__PURE__ */ new Map(), patternDependencies: /* @__PURE__ */ new Map(), glyphDependencies: {}, lineAtlas: d2, availableImages: i2, brightness: this.brightness, scaleFactor: this.scaleFactor, elevationFeatures: void 0 }, p2 = s2.familiesBySource[this.source];
              for (const s3 in p2) {
                const n3 = t2.layers[s3];
                if (!n3) continue;
                let r2 = false, a3 = false, d3 = false;
                for (const e2 of p2[s3]) "symbol" === e2[0].type ? r2 = true : a3 = true, e2[0].is3D() && "model" !== e2[0].type && (d3 = true);
                if (this.extraShadowCaster && !d3) continue;
                if (true === this.isSymbolTile && !r2) continue;
                if (false === this.isSymbolTile && !a3) continue;
                1 === n3.version && e.w(`Vector tile source "${this.source}" layer "${s3}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const g3 = c2.encode(s3), m3 = [];
                let y3 = false;
                for (let t3 = 0, i3 = 0; t3 < n3.length; t3++) {
                  const o3 = n3.feature(t3), r3 = h2.getId(o3, s3);
                  if (this.localizableLayerIds && this.localizableLayerIds.has(s3)) {
                    const e2 = o3.properties ? o3.properties.worldview : null;
                    if (this.worldview && "string" == typeof e2) if ("all" === e2) o3.properties.$localized = true;
                    else {
                      if (!e2.split(",").includes(this.worldview)) continue;
                      o3.properties.$localized = true, o3.properties.worldview = this.worldview;
                    }
                  }
                  !y3 && o3.properties && o3.properties.hasOwnProperty(e.f2) && (y3 = true), m3.push({ feature: o3, id: r3, index: i3, sourceLayerIndex: g3 }), i3++;
                }
                y3 && !f2.elevationFeatures && t2.layers.hasOwnProperty(e.f3) && (f2.elevationFeatures = e.f4.parseFrom(t2.layers[e.f3], this.canonical));
                for (const t3 of p2[s3]) {
                  const s4 = t3[0];
                  (!this.extraShadowCaster || s4.is3D() && "model" !== s4.type) && (void 0 !== this.isSymbolTile && "symbol" === s4.type !== this.isSymbolTile || s4.minzoom && this.zoom < Math.floor(s4.minzoom) || s4.maxzoom && this.zoom >= s4.maxzoom || "none" !== s4.visibility && (l(t3, this.zoom, f2.brightness, i2), (u5[s4.id] = s4.createBucket({ index: h2.bucketLayerIDs.length, layers: t3, zoom: this.zoom, lut: this.lut, canonical: this.canonical, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: g3, sourceID: this.source, projection: this.projection.spec, tessellationStep: this.tessellationStep, styleDefinedModelURLs: o2 })).populate(m3, f2, this.tileID.canonical, this.tileTransform), h2.bucketLayerIDs.push(t3.map((t4) => e.C(t4.id, t4.scope)))));
                }
              }
              let g2, m2, y2, w2, x2, b2;
              d2.trim();
              const v3 = { type: "maybePrepare", isSymbolTile: this.isSymbolTile, zoom: this.zoom }, I2 = () => {
                if (g2) return this.status = "done", a2(g2);
                if (this.extraShadowCaster) this.status = "done", a2(null, { buckets: Object.values(u5).filter((e2) => !e2.isEmpty()), featureIndex: h2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: f2.brightness, glyphMap: null, iconMap: null, glyphPositions: null });
                else if (m2 && y2 && w2) {
                  const t3 = new r(m2), s3 = /* @__PURE__ */ new Map();
                  for (const [t4, i3] of y2.entries()) {
                    const { imagePosition: o4 } = e.f7(t4, i3, e.f8);
                    s3.set(t4, o4);
                  }
                  const o3 = {};
                  for (const n3 in u5) {
                    const r2 = u5[n3];
                    r2 instanceof e.b1 && (l(r2.layers, this.zoom, f2.brightness, i2), o3[n3] = e.f9(r2, m2, t3.positions, y2, s3, this.tileID.canonical, this.tileZoom, this.scaleFactor, this.pixelRatio, x2));
                  }
                  const a3 = { iconsPending: true, patternsPending: true };
                  this.rasterizeIfNeeded(n2, y2, x2, () => {
                    a3.iconsPending = false, M2(o3, t3, a3);
                  }), this.rasterizeIfNeeded(n2, w2, b2, () => {
                    a3.patternsPending = false, M2(o3, t3, a3);
                  });
                }
              }, M2 = (t3, s3, o3, n3) => {
                if (o3.iconsPending || o3.patternsPending) return;
                const r2 = new e.fa(y2, w2, this.lut);
                for (const s4 in u5) {
                  const o4 = u5[s4];
                  if (s4 in t3) e.fb(o4, t3[s4], this.showCollisionBoxes, i2, this.tileID.canonical, this.tileZoom, this.projection, this.brightness, y2, r2);
                  else if (o4.hasPattern && (o4 instanceof e.b7 || o4 instanceof e.b8 || o4 instanceof e.dV)) {
                    l(o4.layers, this.zoom, f2.brightness, i2);
                    const e2 = Object.fromEntries(r2.patternPositions);
                    o4.addFeatures(f2, this.tileID.canonical, e2, i2, this.tileTransform, this.brightness);
                  }
                }
                this.status = "done", a2(null, { buckets: Object.values(u5).filter((e2) => !e2.isEmpty()), featureIndex: h2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: s3.image, lineAtlas: d2, imageAtlas: r2, brightness: f2.brightness });
              };
              if (!this.extraShadowCaster) {
                const t3 = e.f5(f2.glyphDependencies, (e2) => Object.keys(e2).map(Number));
                Object.keys(t3).length ? n2.send("getGlyphs", { uid: this.uid, stacks: t3, scope: this.scope }, (e2, t4) => {
                  g2 || (g2 = e2, m2 = t4, I2());
                }, void 0, false, v3) : m2 = {};
                const s3 = Array.from(f2.iconDependencies.keys()).map((t4) => e.I.parse(t4));
                s3.length ? n2.send("getImages", { images: s3, source: this.source, scope: this.scope, tileID: this.tileID, type: "icons" }, (e2, t4) => {
                  g2 || (g2 = e2, y2 = /* @__PURE__ */ new Map(), x2 = this.updateImageMapAndGetImageTaskQueue(y2, t4, f2.iconDependencies), I2());
                }, void 0, false, v3) : (y2 = /* @__PURE__ */ new Map(), x2 = /* @__PURE__ */ new Map());
                const i3 = Array.from(f2.patternDependencies.keys()).map((t4) => e.I.parse(t4));
                i3.length ? n2.send("getImages", { images: i3, source: this.source, scope: this.scope, tileID: this.tileID, type: "patterns" }, (e2, t4) => {
                  g2 || (g2 = e2, w2 = /* @__PURE__ */ new Map(), b2 = this.updateImageMapAndGetImageTaskQueue(w2, t4, f2.patternDependencies), I2());
                }, void 0, false, v3) : (w2 = /* @__PURE__ */ new Map(), b2 = /* @__PURE__ */ new Map());
              }
              if (f2.elevationFeatures && f2.elevationFeatures.length > 0) {
                const t3 = [];
                for (const s4 of Object.values(u5)) if (s4 instanceof e.b8) {
                  const e2 = s4.getUnevaluatedPortalGraph();
                  e2 && t3.push(e2);
                }
                const s3 = e.f6.evaluate(t3);
                for (const t4 of Object.values(u5)) t4 instanceof e.b8 && t4.setEvaluatedPortalGraph(s3);
              }
              I2();
            }
            rasterizeIfNeeded(e2, t2, s2, i2) {
              Array.from(t2.values()).some((e3) => e3.usvg) ? this.rasterize(e2, t2, s2, i2) : i2();
            }
            updateImageMapAndGetImageTaskQueue(e2, t2, s2) {
              const i2 = /* @__PURE__ */ new Map();
              for (const o2 of t2.keys()) {
                const n2 = s2.get(o2) || [];
                for (const s3 of n2) {
                  const o3 = s3.toString(), n3 = t2.get(s3.id.toString());
                  n3.usvg ? i2.has(o3) || (i2.set(o3, s3), e2.set(o3, Object.assign({}, n3))) : e2.set(o3, n3);
                }
              }
              return i2;
            }
            rasterize(e2, t2, s2, i2) {
              this.rasterizeTask = e2.send("rasterizeImages", { scope: this.scope, tasks: s2 }, (e3, s3) => {
                if (!e3) for (const [e4, i3] of s3.entries()) {
                  const s4 = Object.assign(t2.get(e4), { data: i3 });
                  t2.set(e4, s4);
                }
                i2();
              });
            }
            cancelRasterize() {
              this.rasterizeTask && this.rasterizeTask.cancel();
            }
          }
          function l(t2, s2, i2, o2) {
            const n2 = new e.aa(s2, { brightness: i2 });
            for (const e2 of t2) e2.recalculate(n2, o2);
          }
          class c extends e.E {
            constructor(t2, s2, i2, o2, n2, r2, a2) {
              super(), this.actor = t2, this.layerIndex = s2, this.availableImages = i2, this.availableModels = o2, this.loadVectorData = r2 || e.aJ, this.loading = {}, this.loaded = {}, this.deduped = new e.aI(t2.scheduler), this.isSpriteLoaded = n2, this.scheduler = t2.scheduler, this.brightness = a2;
            }
            loadTile(s2, i2) {
              const o2 = s2.uid, n2 = s2 && s2.request, r2 = n2 && n2.collectResourceTiming, l2 = this.loading[o2] = new a(s2);
              l2.abort = this.loadVectorData(s2, (a2, c2) => {
                const h2 = !this.loading[o2];
                if (delete this.loading[o2], l2.cancelRasterize(), h2 || a2 || !c2) return l2.status = "done", h2 || (this.loaded[o2] = l2), i2(a2);
                const u5 = c2.rawData, d2 = {};
                c2.expires && (d2.expires = c2.expires), c2.cacheControl && (d2.cacheControl = c2.cacheControl), l2.vectorTile = c2.vectorTile || new e.fc.VectorTile(new e.bq(u5));
                const f2 = () => {
                  l2.parse(l2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, (s3, o3) => {
                    if (s3 || !o3) return i2(s3);
                    const a3 = {};
                    if (r2) {
                      const e2 = t(n2);
                      e2.length > 0 && (a3.resourceTiming = JSON.parse(JSON.stringify(e2)));
                    }
                    i2(null, e.l({ rawTileData: u5.slice(0) }, o3, d2, a3));
                  });
                };
                this.isSpriteLoaded ? f2() : this.once("isSpriteLoaded", () => {
                  this.scheduler ? this.scheduler.add(f2, { type: "parseTile", isSymbolTile: s2.isSymbolTile, zoom: s2.tileZoom }) : f2();
                }), this.loaded = this.loaded || {}, this.loaded[o2] = l2;
              });
            }
            reloadTile(t2, s2) {
              const i2 = this.loaded, o2 = t2.uid;
              if (i2 && i2[o2]) {
                const n2 = i2[o2];
                n2.scaleFactor = t2.scaleFactor, n2.showCollisionBoxes = t2.showCollisionBoxes, n2.projection = t2.projection, n2.brightness = t2.brightness, n2.tileTransform = e.aW(t2.tileID.canonical, t2.projection), n2.extraShadowCaster = t2.extraShadowCaster, n2.lut = t2.lut;
                const r2 = (e2, t3) => {
                  const i3 = n2.reloadCallback;
                  i3 && (delete n2.reloadCallback, n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, i3)), s2(e2, t3);
                };
                "parsing" === n2.status ? n2.reloadCallback = r2 : "done" === n2.status && (n2.vectorTile ? n2.parse(n2.vectorTile, this.layerIndex, this.availableImages, this.availableModels, this.actor, r2) : r2());
              } else s2(null, void 0);
            }
            abortTile(e2, t2) {
              const s2 = e2.uid, i2 = this.loading[s2];
              i2 && (i2.abort && i2.abort(), delete this.loading[s2]), t2();
            }
            removeTile(e2, t2) {
              const s2 = this.loaded, i2 = e2.uid;
              s2 && s2[i2] && delete s2[i2], t2();
            }
          }
          class h {
            loadTile(t2, s2) {
              const { uid: i2, encoding: o2, rawImageData: n2, padding: r2 } = t2, a2 = ImageBitmap && n2 instanceof ImageBitmap ? this.getImageData(n2, r2) : n2;
              s2(null, new e.fd(i2, a2, o2, r2 < 1));
            }
            reloadTile(e2, t2) {
              t2(null, null);
            }
            abortTile(e2, t2) {
              t2();
            }
            removeTile(e2, t2) {
              t2();
            }
            getImageData(e2, t2) {
              this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(e2.width, e2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d", { willReadFrequently: true })), this.offscreenCanvas.width = e2.width, this.offscreenCanvas.height = e2.height, this.offscreenCanvasContext.drawImage(e2, 0, 0, e2.width, e2.height);
              const s2 = this.offscreenCanvasContext.getImageData(-t2, -t2, e2.width + 2 * t2, e2.height + 2 * t2);
              return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), s2;
            }
          }
          e.bp.setPbf(e.bq);
          class u4 {
            constructor(t2) {
              this._mrt = new e.bp(t2.partial ? 30 : 1 / 0), this._isHeaderLoaded = false, this.uid = t2.uid, this.tileID = t2.tileID, this.source = t2.source;
            }
            parse(t2, s2) {
              const i2 = this._mrt;
              this.status = "parsing", this._entireBuffer = t2;
              try {
                i2.parseHeader(t2), this._isHeaderLoaded = true;
                const o2 = [];
                for (const s3 in i2.layers) {
                  const n2 = i2.getLayer(s3), r2 = n2.getDataRange(n2.getBandList()), a2 = i2.createDecodingTask(r2), l2 = t2.slice(r2.firstByte, r2.lastByte + 1), c2 = e.bp.performDecoding(l2, a2).then((e2) => a2.complete(null, e2)).catch((e2) => a2.complete(e2, null));
                  o2.push(c2);
                }
                Promise.allSettled(o2).then(() => s2(null, i2)).catch((e2) => s2(e2));
              } catch (e2) {
                s2(e2);
              }
            }
          }
          class d {
            constructor(e2) {
              this.actor = e2, this.loading = {}, this.loaded = {};
            }
            loadTile(t2, s2) {
              const i2 = t2.uid, o2 = t2.request, n2 = this.loading[i2] = new u4(t2), { cancel: r2 } = e.br(o2, (e2, t3, o3, r3) => {
                const a2 = !this.loading[i2];
                if (delete this.loading[i2], a2 || e2 || !t3) return n2.status = "done", a2 || (this.loaded[i2] = n2), s2(e2);
                n2.parse(t3, (e3, t4) => {
                  if (e3 || !t4) return s2(e3);
                  s2(null, t4, o3, r3);
                }), this.loaded[i2] = n2;
              });
              n2.abort = r2;
            }
            reloadTile(e2, t2) {
              t2(null, void 0);
            }
            abortTile(e2, t2) {
              const s2 = e2.uid, i2 = this.loading[s2];
              i2 && (i2.abort && i2.abort(), delete this.loading[s2]), t2();
            }
            removeTile(e2, t2) {
              const s2 = e2.uid;
              this.loaded[s2] && delete this.loaded[s2], t2();
            }
            decodeRasterArray(t2, s2) {
              e.bp.performDecoding(t2.buffer, t2.task).then((e2) => s2(null, e2)).catch((e2) => s2(e2));
            }
          }
          const f = e.fc.VectorTileFeature.prototype.toGeoJSON;
          class p {
            constructor(t2) {
              this._feature = t2, this.extent = e.aj, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
            }
            loadGeometry() {
              if (1 === this._feature.type) {
                const t2 = [];
                for (const s2 of this._feature.geometry) t2.push([new e.P(s2[0], s2[1])]);
                return t2;
              }
              {
                const t2 = [];
                for (const s2 of this._feature.geometry) {
                  const i2 = [];
                  for (const t3 of s2) i2.push(new e.P(t3[0], t3[1]));
                  t2.push(i2);
                }
                return t2;
              }
            }
            toGeoJSON(e2, t2, s2) {
              return f.call(this, e2, t2, s2);
            }
          }
          class g {
            constructor(t2) {
              this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.aj, this.length = t2.length, this._features = t2;
            }
            feature(e2) {
              return new p(this._features[e2]);
            }
          }
          const m = 64 / 4096, y = 128;
          class w {
            constructor() {
              this.features = /* @__PURE__ */ new Map();
            }
            clear() {
              this.features.clear();
            }
            load(e2 = [], t2) {
              for (const s2 of e2) {
                const e3 = s2.id;
                if (null == e3) continue;
                let i2 = this.features.get(e3);
                i2 && this.updateCache(i2, t2), s2.geometry ? (i2 = b(s2), this.updateCache(i2, t2), this.features.set(e3, i2)) : this.features.delete(e3), this.updateCache(i2, t2);
              }
            }
            updateCache(e2, t2) {
              for (const { canonical: s2, uid: i2 } of Object.values(t2)) {
                const { z: o2, x: n2, y: r2 } = s2;
                x(e2, Math.pow(2, o2), n2, r2) && delete t2[i2];
              }
            }
            getTile(e2, t2, s2) {
              const i2 = Math.pow(2, e2), o2 = [];
              for (const e3 of this.features.values()) x(e3, i2, t2, s2) && o2.push(S(e3, i2, t2, s2));
              return { features: o2 };
            }
            getFeatures() {
              return [...this.features.values()];
            }
          }
          function x({ minX: e2, minY: t2, maxX: s2, maxY: i2 }, o2, n2, r2) {
            return e2 < (n2 + 1 + m) / o2 && t2 < (r2 + 1 + m) / o2 && s2 > (n2 - m) / o2 && i2 > (r2 - m) / o2;
          }
          function b(e2) {
            const { id: t2, geometry: s2, properties: i2 } = e2;
            if (!s2) return;
            if ("GeometryCollection" === s2.type) throw new Error("GeometryCollection not supported in dynamic mode.");
            const { type: o2, coordinates: n2 } = s2, r2 = { id: t2, type: 1, geometry: [], tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 }, a2 = r2.geometry;
            if ("Point" === o2) v2(n2, a2, r2);
            else if ("MultiPoint" === o2) for (const e3 of n2) v2(e3, a2, r2);
            else if ("LineString" === o2) r2.type = 2, I(n2, a2, r2);
            else if ("MultiLineString" === o2) r2.type = 2, M(n2, a2, r2);
            else if ("Polygon" === o2) r2.type = 3, M(n2, a2, r2, true);
            else {
              if ("MultiPolygon" !== o2) throw new Error("Input data is not a valid GeoJSON object.");
              r2.type = 3;
              for (const e3 of n2) M(e3, a2, r2, true);
            }
            return r2;
          }
          function v2([t2, s2], i2, o2) {
            const n2 = e.ay(t2);
            let r2 = e.aH(s2);
            r2 = r2 < 0 ? 0 : r2 > 1 ? 1 : r2, i2.push(n2, r2), o2.minX = Math.min(o2.minX, n2), o2.minY = Math.min(o2.minY, r2), o2.maxX = Math.max(o2.maxX, n2), o2.maxY = Math.max(o2.maxY, r2);
          }
          function I(e2, t2, s2, i2 = false, o2 = false) {
            const n2 = [];
            for (const t3 of e2) v2(t3, n2, s2);
            t2.push(n2), i2 && function(e3, t3) {
              let s3 = 0;
              for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
              if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
                const i3 = e3[t4], o3 = e3[t4 + 1];
                e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
              }
            }(n2, o2);
          }
          function M(e2, t2, s2, i2 = false) {
            for (let o2 = 0; o2 < e2.length; o2++) I(e2[o2], t2, s2, i2, 0 === o2);
          }
          function S(t2, s2, i2, o2) {
            const { id: n2, type: r2, geometry: a2, tags: l2 } = t2, c2 = [];
            if (1 === r2) !function(t3, s3, i3, o3, n3) {
              for (let r3 = 0; r3 < t3.length; r3 += 2) {
                const a3 = Math.round(e.aj * (t3[r3 + 0] * s3 - i3)), l3 = Math.round(e.aj * (t3[r3 + 1] * s3 - o3));
                n3.push([a3, l3]);
              }
            }(a2, s2, i2, o2, c2);
            else for (const e2 of a2) T(e2, s2, i2, o2, c2);
            return { id: n2, type: r2, geometry: c2, tags: l2 };
          }
          function T(t2, s2, i2, o2, n2) {
            const r2 = -y, a2 = e.aj + y;
            let l2;
            for (let c2 = 0; c2 < t2.length - 2; c2 += 2) {
              let h2 = Math.round(e.aj * (t2[c2 + 0] * s2 - i2)), u5 = Math.round(e.aj * (t2[c2 + 1] * s2 - o2)), d2 = Math.round(e.aj * (t2[c2 + 2] * s2 - i2)), f2 = Math.round(e.aj * (t2[c2 + 3] * s2 - o2));
              const p2 = d2 - h2, g2 = f2 - u5;
              h2 < r2 && d2 < r2 || (h2 < r2 ? (u5 += Math.round(g2 * ((r2 - h2) / p2)), h2 = r2) : d2 < r2 && (f2 = u5 + Math.round(g2 * ((r2 - h2) / p2)), d2 = r2), u5 < r2 && f2 < r2 || (u5 < r2 ? (h2 += Math.round(p2 * ((r2 - u5) / g2)), u5 = r2) : f2 < r2 && (d2 = h2 + Math.round(p2 * ((r2 - u5) / g2)), f2 = r2), h2 >= a2 && d2 >= a2 || (h2 >= a2 ? (u5 += Math.round(g2 * ((a2 - h2) / p2)), h2 = a2) : d2 >= a2 && (f2 = u5 + Math.round(g2 * ((a2 - h2) / p2)), d2 = a2), u5 >= a2 && f2 >= a2 || (u5 >= a2 ? (h2 += Math.round(p2 * ((a2 - u5) / g2)), u5 = a2) : f2 >= a2 && (d2 = h2 + Math.round(p2 * ((a2 - u5) / g2)), f2 = a2), l2 && h2 === l2[l2.length - 1][0] && u5 === l2[l2.length - 1][1] || (l2 = [[h2, u5]], n2.push(l2)), l2.push([d2, f2])))));
            }
          }
          var P, k, C, _ = { exports: {} }, L = function() {
            if (C) return _.exports;
            C = 1;
            var t2 = e.fg(), s2 = function() {
              if (k) return P;
              k = 1;
              var t3 = e.fe(), s3 = e.ff().VectorTileFeature;
              function i3(e2, t4) {
                this.options = t4 || {}, this.features = e2, this.length = e2.length;
              }
              function o3(e2, t4) {
                this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t4 || 4096;
              }
              return P = i3, i3.prototype.feature = function(e2) {
                return new o3(this.features[e2], this.options.extent);
              }, o3.prototype.loadGeometry = function() {
                var e2 = this.rawGeometry;
                this.geometry = [];
                for (var s4 = 0; s4 < e2.length; s4++) {
                  for (var i4 = e2[s4], o4 = [], n3 = 0; n3 < i4.length; n3++) o4.push(new t3(i4[n3][0], i4[n3][1]));
                  this.geometry.push(o4);
                }
                return this.geometry;
              }, o3.prototype.bbox = function() {
                this.geometry || this.loadGeometry();
                for (var e2 = this.geometry, t4 = 1 / 0, s4 = -1 / 0, i4 = 1 / 0, o4 = -1 / 0, n3 = 0; n3 < e2.length; n3++) for (var r3 = e2[n3], a3 = 0; a3 < r3.length; a3++) {
                  var l3 = r3[a3];
                  t4 = Math.min(t4, l3.x), s4 = Math.max(s4, l3.x), i4 = Math.min(i4, l3.y), o4 = Math.max(o4, l3.y);
                }
                return [t4, i4, s4, o4];
              }, o3.prototype.toGeoJSON = s3.prototype.toGeoJSON, P;
            }();
            function i2(e2) {
              var s3 = new t2();
              return function(e3, t3) {
                for (var s4 in e3.layers) t3.writeMessage(3, o2, e3.layers[s4]);
              }(e2, s3), s3.finish();
            }
            function o2(e2, t3) {
              var s3;
              t3.writeVarintField(15, e2.version || 1), t3.writeStringField(1, e2.name || ""), t3.writeVarintField(5, e2.extent || 4096);
              var i3 = { keys: [], values: [], keycache: {}, valuecache: {} };
              for (s3 = 0; s3 < e2.length; s3++) i3.feature = e2.feature(s3), t3.writeMessage(2, n2, i3);
              var o3 = i3.keys;
              for (s3 = 0; s3 < o3.length; s3++) t3.writeStringField(3, o3[s3]);
              var r3 = i3.values;
              for (s3 = 0; s3 < r3.length; s3++) t3.writeMessage(4, h2, r3[s3]);
            }
            function n2(e2, t3) {
              var s3 = e2.feature;
              void 0 !== s3.id && t3.writeVarintField(1, s3.id), t3.writeMessage(2, r2, e2), t3.writeVarintField(3, s3.type), t3.writeMessage(4, c2, s3);
            }
            function r2(e2, t3) {
              var s3 = e2.feature, i3 = e2.keys, o3 = e2.values, n3 = e2.keycache, r3 = e2.valuecache;
              for (var a3 in s3.properties) {
                var l3 = s3.properties[a3], c3 = n3[a3];
                if (null !== l3) {
                  void 0 === c3 && (i3.push(a3), n3[a3] = c3 = i3.length - 1), t3.writeVarint(c3);
                  var h3 = typeof l3;
                  "string" !== h3 && "boolean" !== h3 && "number" !== h3 && (l3 = JSON.stringify(l3));
                  var u5 = h3 + ":" + l3, d2 = r3[u5];
                  void 0 === d2 && (o3.push(l3), r3[u5] = d2 = o3.length - 1), t3.writeVarint(d2);
                }
              }
            }
            function a2(e2, t3) {
              return (t3 << 3) + (7 & e2);
            }
            function l2(e2) {
              return e2 << 1 ^ e2 >> 31;
            }
            function c2(e2, t3) {
              for (var s3 = e2.loadGeometry(), i3 = e2.type, o3 = 0, n3 = 0, r3 = s3.length, c3 = 0; c3 < r3; c3++) {
                var h3 = s3[c3], u5 = 1;
                1 === i3 && (u5 = h3.length), t3.writeVarint(a2(1, u5));
                for (var d2 = 3 === i3 ? h3.length - 1 : h3.length, f2 = 0; f2 < d2; f2++) {
                  1 === f2 && 1 !== i3 && t3.writeVarint(a2(2, d2 - 1));
                  var p2 = h3[f2].x - o3, g2 = h3[f2].y - n3;
                  t3.writeVarint(l2(p2)), t3.writeVarint(l2(g2)), o3 += p2, n3 += g2;
                }
                3 === i3 && t3.writeVarint(a2(7, 1));
              }
            }
            function h2(e2, t3) {
              var s3 = typeof e2;
              "string" === s3 ? t3.writeStringField(1, e2) : "boolean" === s3 ? t3.writeBooleanField(7, e2) : "number" === s3 && (e2 % 1 != 0 ? t3.writeDoubleField(3, e2) : e2 < 0 ? t3.writeSVarintField(6, e2) : t3.writeVarintField(5, e2));
            }
            return _.exports = i2, _.exports.fromVectorTileJs = i2, _.exports.fromGeojsonVt = function(e2, t3) {
              t3 = t3 || {};
              var o3 = {};
              for (var n3 in e2) o3[n3] = new s2(e2[n3].features, t3), o3[n3].name = n3, o3[n3].version = t3.version, o3[n3].extent = t3.extent;
              return i2({ layers: o3 });
            }, _.exports.GeoJSONWrapper = s2, _.exports;
          }(), j = e.fh(L);
          const z = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e2) => e2 }, D2 = Math.fround || (O = new Float32Array(1), (e2) => (O[0] = +e2, O[0]));
          var O;
          const F = 3, A = 5, Z = 6;
          class N {
            constructor(e2) {
              this.options = Object.assign(Object.create(z), e2), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e2) {
              const { log: t2, minZoom: s2, maxZoom: i2 } = this.options;
              t2 && console.time("total time");
              const o2 = `prepare ${e2.length} points`;
              t2 && console.time(o2), this.points = e2;
              const n2 = [];
              for (let t3 = 0; t3 < e2.length; t3++) {
                const s3 = e2[t3];
                if (!s3.geometry) continue;
                const [i3, o3] = s3.geometry.coordinates, r3 = D2(X(i3)), a2 = D2(Y(o3));
                n2.push(r3, a2, 1 / 0, t3, -1, 1), this.options.reduce && n2.push(0);
              }
              let r2 = this.trees[i2 + 1] = this._createTree(n2);
              t2 && console.timeEnd(o2);
              for (let e3 = i2; e3 >= s2; e3--) {
                const s3 = +Date.now();
                r2 = this.trees[e3] = this._createTree(this._cluster(r2, e3)), t2 && console.log("z%d: %d clusters in %dms", e3, r2.numItems, +Date.now() - s3);
              }
              return t2 && console.timeEnd("total time"), this;
            }
            getClusters(e2, t2) {
              let s2 = ((e2[0] + 180) % 360 + 360) % 360 - 180;
              const i2 = Math.max(-90, Math.min(90, e2[1]));
              let o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180;
              const n2 = Math.max(-90, Math.min(90, e2[3]));
              if (e2[2] - e2[0] >= 360) s2 = -180, o2 = 180;
              else if (s2 > o2) {
                const e3 = this.getClusters([s2, i2, 180, n2], t2), r3 = this.getClusters([-180, i2, o2, n2], t2);
                return e3.concat(r3);
              }
              const r2 = this.trees[this._limitZoom(t2)], a2 = r2.range(X(s2), Y(n2), X(o2), Y(i2)), l2 = r2.data, c2 = [];
              for (const e3 of a2) {
                const t3 = this.stride * e3;
                c2.push(l2[t3 + A] > 1 ? B2(l2, t3, this.clusterProps) : this.points[l2[t3 + F]]);
              }
              return c2;
            }
            getChildren(e2) {
              const t2 = this._getOriginId(e2), s2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[s2];
              if (!o2) throw new Error(i2);
              const n2 = o2.data;
              if (t2 * this.stride >= n2.length) throw new Error(i2);
              const r2 = this.options.radius / (this.options.extent * Math.pow(2, s2 - 1)), a2 = o2.within(n2[t2 * this.stride], n2[t2 * this.stride + 1], r2), l2 = [];
              for (const t3 of a2) {
                const s3 = t3 * this.stride;
                n2[s3 + 4] === e2 && l2.push(n2[s3 + A] > 1 ? B2(n2, s3, this.clusterProps) : this.points[n2[s3 + F]]);
              }
              if (0 === l2.length) throw new Error(i2);
              return l2;
            }
            getLeaves(e2, t2, s2) {
              const i2 = [];
              return this._appendLeaves(i2, e2, t2 = t2 || 10, s2 = s2 || 0, 0), i2;
            }
            getTile(e2, t2, s2) {
              const i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), { extent: n2, radius: r2 } = this.options, a2 = r2 / n2, l2 = (s2 - a2) / o2, c2 = (s2 + 1 + a2) / o2, h2 = { features: [] };
              return this._addTileFeatures(i2.range((t2 - a2) / o2, l2, (t2 + 1 + a2) / o2, c2), i2.data, t2, s2, o2, h2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / o2, l2, 1, c2), i2.data, o2, s2, o2, h2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, l2, a2 / o2, c2), i2.data, -1, s2, o2, h2), h2.features.length ? h2 : null;
            }
            getClusterExpansionZoom(e2) {
              let t2 = this._getOriginZoom(e2) - 1;
              for (; t2 <= this.options.maxZoom; ) {
                const s2 = this.getChildren(e2);
                if (t2++, 1 !== s2.length) break;
                e2 = s2[0].properties.cluster_id;
              }
              return t2;
            }
            _appendLeaves(e2, t2, s2, i2, o2) {
              const n2 = this.getChildren(t2);
              for (const t3 of n2) {
                const n3 = t3.properties;
                if (n3 && n3.cluster ? o2 + n3.point_count <= i2 ? o2 += n3.point_count : o2 = this._appendLeaves(e2, n3.cluster_id, s2, i2, o2) : o2 < i2 ? o2++ : e2.push(t3), e2.length === s2) break;
              }
              return o2;
            }
            _createTree(t2) {
              const s2 = new e.bW(t2.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e2 = 0; e2 < t2.length; e2 += this.stride) s2.add(t2[e2], t2[e2 + 1]);
              return s2.finish(), s2.data = t2, s2;
            }
            _addTileFeatures(e2, t2, s2, i2, o2, n2) {
              for (const r2 of e2) {
                const e3 = r2 * this.stride, a2 = t2[e3 + A] > 1;
                let l2, c2, h2;
                if (a2) l2 = E(t2, e3, this.clusterProps), c2 = t2[e3], h2 = t2[e3 + 1];
                else {
                  const s3 = this.points[t2[e3 + F]];
                  l2 = s3.properties;
                  const [i3, o3] = s3.geometry.coordinates;
                  c2 = X(i3), h2 = Y(o3);
                }
                const u5 = { type: 1, geometry: [[Math.round(this.options.extent * (c2 * o2 - s2)), Math.round(this.options.extent * (h2 * o2 - i2))]], tags: l2 };
                let d2;
                d2 = a2 || this.options.generateId ? t2[e3 + F] : this.points[t2[e3 + F]].id, void 0 !== d2 && (u5.id = d2), n2.features.push(u5);
              }
            }
            _limitZoom(e2) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e2), this.options.maxZoom + 1));
            }
            _cluster(e2, t2) {
              const { radius: s2, extent: i2, reduce: o2, minPoints: n2 } = this.options, r2 = s2 / (i2 * Math.pow(2, t2)), a2 = e2.data, l2 = [], c2 = this.stride;
              for (let s3 = 0; s3 < a2.length; s3 += c2) {
                if (a2[s3 + 2] <= t2) continue;
                a2[s3 + 2] = t2;
                const i3 = a2[s3], h2 = a2[s3 + 1], u5 = e2.within(a2[s3], a2[s3 + 1], r2), d2 = a2[s3 + A];
                let f2 = d2;
                for (const e3 of u5) {
                  const s4 = e3 * c2;
                  a2[s4 + 2] > t2 && (f2 += a2[s4 + A]);
                }
                if (f2 > d2 && f2 >= n2) {
                  let e3, n3 = i3 * d2, r3 = h2 * d2, p2 = -1;
                  const g2 = (s3 / c2 << 5) + (t2 + 1) + this.points.length;
                  for (const i4 of u5) {
                    const l3 = i4 * c2;
                    if (a2[l3 + 2] <= t2) continue;
                    a2[l3 + 2] = t2;
                    const h3 = a2[l3 + A];
                    n3 += a2[l3] * h3, r3 += a2[l3 + 1] * h3, a2[l3 + 4] = g2, o2 && (e3 || (e3 = this._map(a2, s3, true), p2 = this.clusterProps.length, this.clusterProps.push(e3)), o2(e3, this._map(a2, l3)));
                  }
                  a2[s3 + 4] = g2, l2.push(n3 / f2, r3 / f2, 1 / 0, g2, -1, f2), o2 && l2.push(p2);
                } else {
                  for (let e3 = 0; e3 < c2; e3++) l2.push(a2[s3 + e3]);
                  if (f2 > 1) for (const e3 of u5) {
                    const s4 = e3 * c2;
                    if (!(a2[s4 + 2] <= t2)) {
                      a2[s4 + 2] = t2;
                      for (let e4 = 0; e4 < c2; e4++) l2.push(a2[s4 + e4]);
                    }
                  }
                }
              }
              return l2;
            }
            _getOriginId(e2) {
              return e2 - this.points.length >> 5;
            }
            _getOriginZoom(e2) {
              return (e2 - this.points.length) % 32;
            }
            _map(e2, t2, s2) {
              if (e2[t2 + A] > 1) {
                const i3 = this.clusterProps[e2[t2 + Z]];
                return s2 ? Object.assign({}, i3) : i3;
              }
              const i2 = this.points[e2[t2 + F]].properties, o2 = this.options.map(i2);
              return s2 && o2 === i2 ? Object.assign({}, o2) : o2;
            }
          }
          function B2(e2, t2, s2) {
            return { type: "Feature", id: e2[t2 + F], properties: E(e2, t2, s2), geometry: { type: "Point", coordinates: [(i2 = e2[t2], 360 * (i2 - 0.5)), G(e2[t2 + 1])] } };
            var i2;
          }
          function E(e2, t2, s2) {
            const i2 = e2[t2 + A], o2 = i2 >= 1e4 ? `${Math.round(i2 / 1e3)}k` : i2 >= 1e3 ? Math.round(i2 / 100) / 10 + "k" : i2, n2 = e2[t2 + Z], r2 = -1 === n2 ? {} : Object.assign({}, s2[n2]);
            return Object.assign(r2, { cluster: true, cluster_id: e2[t2 + F], point_count: i2, point_count_abbreviated: o2 });
          }
          function X(e2) {
            return e2 / 360 + 0.5;
          }
          function Y(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
          }
          function G(e2) {
            const t2 = (180 - 360 * e2) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t2)) / Math.PI - 90;
          }
          function R(e2, t2, s2, i2) {
            let o2 = i2;
            const n2 = t2 + (s2 - t2 >> 1);
            let r2, a2 = s2 - t2;
            const l2 = e2[t2], c2 = e2[t2 + 1], h2 = e2[s2], u5 = e2[s2 + 1];
            for (let i3 = t2 + 3; i3 < s2; i3 += 3) {
              const t3 = J(e2[i3], e2[i3 + 1], l2, c2, h2, u5);
              if (t3 > o2) r2 = i3, o2 = t3;
              else if (t3 === o2) {
                const e3 = Math.abs(i3 - n2);
                e3 < a2 && (r2 = i3, a2 = e3);
              }
            }
            o2 > i2 && (r2 - t2 > 3 && R(e2, t2, r2, i2), e2[r2 + 2] = o2, s2 - r2 > 3 && R(e2, r2, s2, i2));
          }
          function J(e2, t2, s2, i2, o2, n2) {
            let r2 = o2 - s2, a2 = n2 - i2;
            if (0 !== r2 || 0 !== a2) {
              const l2 = ((e2 - s2) * r2 + (t2 - i2) * a2) / (r2 * r2 + a2 * a2);
              l2 > 1 ? (s2 = o2, i2 = n2) : l2 > 0 && (s2 += r2 * l2, i2 += a2 * l2);
            }
            return r2 = e2 - s2, a2 = t2 - i2, r2 * r2 + a2 * a2;
          }
          function V(e2, t2, s2, i2) {
            const o2 = { id: e2 ?? null, type: t2, geometry: s2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            if ("Point" === t2 || "MultiPoint" === t2 || "LineString" === t2) $(o2, s2);
            else if ("Polygon" === t2) $(o2, s2[0]);
            else if ("MultiLineString" === t2) for (const e3 of s2) $(o2, e3);
            else if ("MultiPolygon" === t2) for (const e3 of s2) $(o2, e3[0]);
            return o2;
          }
          function $(e2, t2) {
            for (let s2 = 0; s2 < t2.length; s2 += 3) e2.minX = Math.min(e2.minX, t2[s2]), e2.minY = Math.min(e2.minY, t2[s2 + 1]), e2.maxX = Math.max(e2.maxX, t2[s2]), e2.maxY = Math.max(e2.maxY, t2[s2 + 1]);
          }
          function W(e2, t2, s2, i2) {
            if (!t2.geometry) return;
            const o2 = t2.geometry.coordinates;
            if (o2 && 0 === o2.length) return;
            const n2 = t2.geometry.type, r2 = Math.pow(s2.tolerance / ((1 << s2.maxZoom) * s2.extent), 2);
            let a2 = [], l2 = t2.id;
            if (s2.promoteId ? l2 = t2.properties[s2.promoteId] : s2.generateId && (l2 = i2 || 0), "Point" === n2) q(o2, a2);
            else if ("MultiPoint" === n2) for (const e3 of o2) q(e3, a2);
            else if ("LineString" === n2) U(o2, a2, r2, false);
            else if ("MultiLineString" === n2) {
              if (s2.lineMetrics) {
                for (const s3 of o2) a2 = [], U(s3, a2, r2, false), e2.push(V(l2, "LineString", a2, t2.properties));
                return;
              }
              H(o2, a2, r2, false);
            } else if ("Polygon" === n2) H(o2, a2, r2, true);
            else {
              if ("MultiPolygon" !== n2) {
                if ("GeometryCollection" === n2) {
                  for (const o3 of t2.geometry.geometries) W(e2, { id: l2, geometry: o3, properties: t2.properties }, s2, i2);
                  return;
                }
                throw new Error("Input data is not a valid GeoJSON object.");
              }
              for (const e3 of o2) {
                const t3 = [];
                H(e3, t3, r2, true), a2.push(t3);
              }
            }
            e2.push(V(l2, n2, a2, t2.properties));
          }
          function q(e2, t2) {
            t2.push(Q(e2[0]), K(e2[1]), 0);
          }
          function U(e2, t2, s2, i2) {
            let o2, n2, r2 = 0;
            for (let s3 = 0; s3 < e2.length; s3++) {
              const a3 = Q(e2[s3][0]), l2 = K(e2[s3][1]);
              t2.push(a3, l2, 0), s3 > 0 && (r2 += i2 ? (o2 * l2 - a3 * n2) / 2 : Math.sqrt(Math.pow(a3 - o2, 2) + Math.pow(l2 - n2, 2))), o2 = a3, n2 = l2;
            }
            const a2 = t2.length - 3;
            t2[2] = 1, R(t2, 0, a2, s2), t2[a2 + 2] = 1, t2.size = Math.abs(r2), t2.start = 0, t2.end = t2.size;
          }
          function H(e2, t2, s2, i2) {
            for (let o2 = 0; o2 < e2.length; o2++) {
              const n2 = [];
              U(e2[o2], n2, s2, i2), t2.push(n2);
            }
          }
          function Q(e2) {
            return e2 / 360 + 0.5;
          }
          function K(e2) {
            const t2 = Math.sin(e2 * Math.PI / 180), s2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return s2 < 0 ? 0 : s2 > 1 ? 1 : s2;
          }
          function ee(e2, t2, s2, i2, o2, n2, r2, a2) {
            if (i2 /= t2, n2 >= (s2 /= t2) && r2 < i2) return e2;
            if (r2 < s2 || n2 >= i2) return null;
            const l2 = [];
            for (const t3 of e2) {
              const e3 = t3.geometry;
              let n3 = t3.type;
              const r3 = 0 === o2 ? t3.minX : t3.minY, c2 = 0 === o2 ? t3.maxX : t3.maxY;
              if (r3 >= s2 && c2 < i2) {
                l2.push(t3);
                continue;
              }
              if (c2 < s2 || r3 >= i2) continue;
              let h2 = [];
              if ("Point" === n3 || "MultiPoint" === n3) te(e3, h2, s2, i2, o2);
              else if ("LineString" === n3) se(e3, h2, s2, i2, o2, false, a2.lineMetrics);
              else if ("MultiLineString" === n3) oe(e3, h2, s2, i2, o2, false);
              else if ("Polygon" === n3) oe(e3, h2, s2, i2, o2, true);
              else if ("MultiPolygon" === n3) for (const t4 of e3) {
                const e4 = [];
                oe(t4, e4, s2, i2, o2, true), e4.length && h2.push(e4);
              }
              if (h2.length) {
                if (a2.lineMetrics && "LineString" === n3) {
                  for (const e4 of h2) l2.push(V(t3.id, n3, e4, t3.tags));
                  continue;
                }
                "LineString" !== n3 && "MultiLineString" !== n3 || (1 === h2.length ? (n3 = "LineString", h2 = h2[0]) : n3 = "MultiLineString"), "Point" !== n3 && "MultiPoint" !== n3 || (n3 = 3 === h2.length ? "Point" : "MultiPoint"), l2.push(V(t3.id, n3, h2, t3.tags));
              }
            }
            return l2.length ? l2 : null;
          }
          function te(e2, t2, s2, i2, o2) {
            for (let n2 = 0; n2 < e2.length; n2 += 3) {
              const r2 = e2[n2 + o2];
              r2 >= s2 && r2 <= i2 && ne(t2, e2[n2], e2[n2 + 1], e2[n2 + 2]);
            }
          }
          function se(e2, t2, s2, i2, o2, n2, r2) {
            let a2 = ie(e2);
            const l2 = 0 === o2 ? re : ae;
            let c2, h2, u5 = e2.start;
            for (let d3 = 0; d3 < e2.length - 3; d3 += 3) {
              const f3 = e2[d3], p3 = e2[d3 + 1], g3 = e2[d3 + 2], m2 = e2[d3 + 3], y2 = e2[d3 + 4], w2 = 0 === o2 ? f3 : p3, x2 = 0 === o2 ? m2 : y2;
              let b2 = false;
              r2 && (c2 = Math.sqrt(Math.pow(f3 - m2, 2) + Math.pow(p3 - y2, 2))), w2 < s2 ? x2 > s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), r2 && (a2.start = u5 + c2 * h2)) : w2 > i2 ? x2 < i2 && (h2 = l2(a2, f3, p3, m2, y2, i2), r2 && (a2.start = u5 + c2 * h2)) : ne(a2, f3, p3, g3), x2 < s2 && w2 >= s2 && (h2 = l2(a2, f3, p3, m2, y2, s2), b2 = true), x2 > i2 && w2 <= i2 && (h2 = l2(a2, f3, p3, m2, y2, i2), b2 = true), !n2 && b2 && (r2 && (a2.end = u5 + c2 * h2), t2.push(a2), a2 = ie(e2)), r2 && (u5 += c2);
            }
            let d2 = e2.length - 3;
            const f2 = e2[d2], p2 = e2[d2 + 1], g2 = 0 === o2 ? f2 : p2;
            g2 >= s2 && g2 <= i2 && ne(a2, f2, p2, e2[d2 + 2]), d2 = a2.length - 3, n2 && d2 >= 3 && (a2[d2] !== a2[0] || a2[d2 + 1] !== a2[1]) && ne(a2, a2[0], a2[1], a2[2]), a2.length && t2.push(a2);
          }
          function ie(e2) {
            const t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function oe(e2, t2, s2, i2, o2, n2) {
            for (const r2 of e2) se(r2, t2, s2, i2, o2, n2, false);
          }
          function ne(e2, t2, s2, i2) {
            e2.push(t2, s2, i2);
          }
          function re(e2, t2, s2, i2, o2, n2) {
            const r2 = (n2 - t2) / (i2 - t2);
            return ne(e2, n2, s2 + (o2 - s2) * r2, 1), r2;
          }
          function ae(e2, t2, s2, i2, o2, n2) {
            const r2 = (n2 - s2) / (o2 - s2);
            return ne(e2, t2 + (i2 - t2) * r2, n2, 1), r2;
          }
          function le(e2, t2) {
            const s2 = [];
            for (let i2 = 0; i2 < e2.length; i2++) {
              const o2 = e2[i2], n2 = o2.type;
              let r2;
              if ("Point" === n2 || "MultiPoint" === n2 || "LineString" === n2) r2 = ce2(o2.geometry, t2);
              else if ("MultiLineString" === n2 || "Polygon" === n2) {
                r2 = [];
                for (const e3 of o2.geometry) r2.push(ce2(e3, t2));
              } else if ("MultiPolygon" === n2) {
                r2 = [];
                for (const e3 of o2.geometry) {
                  const s3 = [];
                  for (const i3 of e3) s3.push(ce2(i3, t2));
                  r2.push(s3);
                }
              }
              s2.push(V(o2.id, n2, r2, o2.tags));
            }
            return s2;
          }
          function ce2(e2, t2) {
            const s2 = [];
            s2.size = e2.size, void 0 !== e2.start && (s2.start = e2.start, s2.end = e2.end);
            for (let i2 = 0; i2 < e2.length; i2 += 3) s2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
            return s2;
          }
          function he(e2, t2) {
            if (e2.transformed) return e2;
            const s2 = 1 << e2.z, i2 = e2.x, o2 = e2.y;
            for (const n2 of e2.features) {
              const e3 = n2.geometry, r2 = n2.type;
              if (n2.geometry = [], 1 === r2) for (let r3 = 0; r3 < e3.length; r3 += 2) n2.geometry.push(ue(e3[r3], e3[r3 + 1], t2, s2, i2, o2));
              else for (let r3 = 0; r3 < e3.length; r3++) {
                const a2 = [];
                for (let n3 = 0; n3 < e3[r3].length; n3 += 2) a2.push(ue(e3[r3][n3], e3[r3][n3 + 1], t2, s2, i2, o2));
                n2.geometry.push(a2);
              }
            }
            return e2.transformed = true, e2;
          }
          function ue(e2, t2, s2, i2, o2, n2) {
            return [Math.round(s2 * (e2 * i2 - o2)), Math.round(s2 * (t2 * i2 - n2))];
          }
          function de2(e2, t2, s2, i2, o2) {
            const n2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), r2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: e2.length, source: null, x: s2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 };
            for (const t3 of e2) fe(r2, t3, n2, o2);
            return r2;
          }
          function fe(e2, t2, s2, i2) {
            const o2 = t2.geometry, n2 = t2.type, r2 = [];
            if (e2.minX = Math.min(e2.minX, t2.minX), e2.minY = Math.min(e2.minY, t2.minY), e2.maxX = Math.max(e2.maxX, t2.maxX), e2.maxY = Math.max(e2.maxY, t2.maxY), "Point" === n2 || "MultiPoint" === n2) for (let t3 = 0; t3 < o2.length; t3 += 3) r2.push(o2[t3], o2[t3 + 1]), e2.numPoints++, e2.numSimplified++;
            else if ("LineString" === n2) pe(r2, o2, e2, s2, false, false);
            else if ("MultiLineString" === n2 || "Polygon" === n2) for (let t3 = 0; t3 < o2.length; t3++) pe(r2, o2[t3], e2, s2, "Polygon" === n2, 0 === t3);
            else if ("MultiPolygon" === n2) for (let t3 = 0; t3 < o2.length; t3++) {
              const i3 = o2[t3];
              for (let t4 = 0; t4 < i3.length; t4++) pe(r2, i3[t4], e2, s2, true, 0 === t4);
            }
            if (r2.length) {
              let s3 = t2.tags || null;
              if ("LineString" === n2 && i2.lineMetrics) {
                s3 = {};
                for (const e3 in t2.tags) s3[e3] = t2.tags[e3];
                s3.mapbox_clip_start = o2.start / o2.size, s3.mapbox_clip_end = o2.end / o2.size;
              }
              const a2 = { geometry: r2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: s3 };
              null !== t2.id && (a2.id = t2.id), e2.features.push(a2);
            }
          }
          function pe(e2, t2, s2, i2, o2, n2) {
            const r2 = i2 * i2;
            if (i2 > 0 && t2.size < (o2 ? r2 : i2)) return void (s2.numPoints += t2.length / 3);
            const a2 = [];
            for (let e3 = 0; e3 < t2.length; e3 += 3) (0 === i2 || t2[e3 + 2] > r2) && (s2.numSimplified++, a2.push(t2[e3], t2[e3 + 1])), s2.numPoints++;
            o2 && function(e3, t3) {
              let s3 = 0;
              for (let t4 = 0, i3 = e3.length, o3 = i3 - 2; t4 < i3; o3 = t4, t4 += 2) s3 += (e3[t4] - e3[o3]) * (e3[t4 + 1] + e3[o3 + 1]);
              if (s3 > 0 === t3) for (let t4 = 0, s4 = e3.length; t4 < s4 / 2; t4 += 2) {
                const i3 = e3[t4], o3 = e3[t4 + 1];
                e3[t4] = e3[s4 - 2 - t4], e3[t4 + 1] = e3[s4 - 1 - t4], e3[s4 - 2 - t4] = i3, e3[s4 - 1 - t4] = o3;
              }
            }(a2, n2), e2.push(a2);
          }
          const ge = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 };
          class me {
            constructor(e2, t2) {
              const s2 = (t2 = this.options = function(e3, t3) {
                for (const s3 in t3) e3[s3] = t3[s3];
                return e3;
              }(Object.create(ge), t2)).debug;
              if (s2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24) throw new Error("maxZoom should be in the 0-24 range");
              if (t2.promoteId && t2.generateId) throw new Error("promoteId and generateId cannot be used together.");
              let i2 = function(e3, t3) {
                const s3 = [];
                if ("FeatureCollection" === e3.type) for (let i3 = 0; i3 < e3.features.length; i3++) W(s3, e3.features[i3], t3, i3);
                else W(s3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
                return s3;
              }(e2, t2);
              this.tiles = {}, this.tileCoords = [], s2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), i2 = function(e3, t3) {
                const s3 = t3.buffer / t3.extent;
                let i3 = e3;
                const o2 = ee(e3, 1, -1 - s3, s3, 0, -1, 2, t3), n2 = ee(e3, 1, 1 - s3, 2 + s3, 0, -1, 2, t3);
                return (o2 || n2) && (i3 = ee(e3, 1, -s3, 1 + s3, 0, -1, 2, t3) || [], o2 && (i3 = le(o2, 1).concat(i3)), n2 && (i3 = i3.concat(le(n2, -1)))), i3;
              }(i2, t2), i2.length && this.splitTile(i2, 0, 0, 0), s2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
            }
            splitTile(e2, t2, s2, i2, o2, n2, r2) {
              const a2 = [e2, t2, s2, i2], l2 = this.options, c2 = l2.debug;
              for (; a2.length; ) {
                i2 = a2.pop(), s2 = a2.pop(), t2 = a2.pop(), e2 = a2.pop();
                const h2 = 1 << t2, u5 = ye(t2, s2, i2);
                let d2 = this.tiles[u5];
                if (!d2 && (c2 > 1 && console.time("creation"), d2 = this.tiles[u5] = de2(e2, t2, s2, i2, l2), this.tileCoords.push({ z: t2, x: s2, y: i2 }), c2)) {
                  c2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, s2, i2, d2.numFeatures, d2.numPoints, d2.numSimplified), console.timeEnd("creation"));
                  const e3 = `z${t2}`;
                  this.stats[e3] = (this.stats[e3] || 0) + 1, this.total++;
                }
                if (d2.source = e2, null == o2) {
                  if (t2 === l2.indexMaxZoom || d2.numPoints <= l2.indexMaxPoints) continue;
                } else {
                  if (t2 === l2.maxZoom || t2 === o2) continue;
                  if (null != o2) {
                    const e3 = o2 - t2;
                    if (s2 !== n2 >> e3 || i2 !== r2 >> e3) continue;
                  }
                }
                if (d2.source = null, 0 === e2.length) continue;
                c2 > 1 && console.time("clipping");
                const f2 = 0.5 * l2.buffer / l2.extent, p2 = 0.5 - f2, g2 = 0.5 + f2, m2 = 1 + f2;
                let y2 = null, w2 = null, x2 = null, b2 = null, v3 = ee(e2, h2, s2 - f2, s2 + g2, 0, d2.minX, d2.maxX, l2), I2 = ee(e2, h2, s2 + p2, s2 + m2, 0, d2.minX, d2.maxX, l2);
                e2 = null, v3 && (y2 = ee(v3, h2, i2 - f2, i2 + g2, 1, d2.minY, d2.maxY, l2), w2 = ee(v3, h2, i2 + p2, i2 + m2, 1, d2.minY, d2.maxY, l2), v3 = null), I2 && (x2 = ee(I2, h2, i2 - f2, i2 + g2, 1, d2.minY, d2.maxY, l2), b2 = ee(I2, h2, i2 + p2, i2 + m2, 1, d2.minY, d2.maxY, l2), I2 = null), c2 > 1 && console.timeEnd("clipping"), a2.push(y2 || [], t2 + 1, 2 * s2, 2 * i2), a2.push(w2 || [], t2 + 1, 2 * s2, 2 * i2 + 1), a2.push(x2 || [], t2 + 1, 2 * s2 + 1, 2 * i2), a2.push(b2 || [], t2 + 1, 2 * s2 + 1, 2 * i2 + 1);
              }
            }
            getTile(e2, t2, s2) {
              e2 = +e2, t2 = +t2, s2 = +s2;
              const i2 = this.options, { extent: o2, debug: n2 } = i2;
              if (e2 < 0 || e2 > 24) return null;
              const r2 = 1 << e2, a2 = ye(e2, t2 = t2 + r2 & r2 - 1, s2);
              if (this.tiles[a2]) return he(this.tiles[a2], o2);
              n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, s2);
              let l2, c2 = e2, h2 = t2, u5 = s2;
              for (; !l2 && c2 > 0; ) c2--, h2 >>= 1, u5 >>= 1, l2 = this.tiles[ye(c2, h2, u5)];
              return l2 && l2.source ? (n2 > 1 && (console.log("found parent tile z%d-%d-%d", c2, h2, u5), console.time("drilling down")), this.splitTile(l2.source, c2, h2, u5, e2, t2, s2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[a2] ? he(this.tiles[a2], o2) : null) : null;
            }
          }
          function ye(e2, t2, s2) {
            return 32 * ((1 << e2) * s2 + t2) + e2;
          }
          function we(e2, t2) {
            const s2 = e2.tileID.canonical;
            if (!this._geoJSONIndex) return void t2(null, null);
            const i2 = this._geoJSONIndex.getTile(s2.z, s2.x, s2.y);
            if (!i2) return void t2(null, null);
            const o2 = new g(i2.features);
            let n2 = j(o2);
            0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: o2, rawData: n2.buffer });
          }
          class xe extends c {
            constructor(e2, t2, s2, i2, o2, n2, r2) {
              super(e2, t2, s2, i2, o2, we, r2), n2 && (this.loadGeoJSON = n2), this._dynamicIndex = new w();
            }
            loadData(s2, i2) {
              const o2 = s2 && s2.request, n2 = o2 && o2.collectResourceTiming;
              this.loadGeoJSON(s2, (r2, a2) => {
                if (r2 || !a2) return i2(r2);
                if ("object" != typeof a2) return i2(new Error(`Input data given to '${s2.source}' is not a valid GeoJSON object.`));
                {
                  try {
                    if (s2.filter) {
                      const t2 = e.X(s2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === t2.result) throw new Error(t2.value.map((e2) => `${e2.key}: ${e2.message}`).join(", "));
                      a2.features = a2.features.filter((e2) => t2.value.evaluate({ zoom: 0 }, e2));
                    }
                    s2.dynamic ? ("Feature" === a2.type && (a2 = { type: "FeatureCollection", features: [a2] }), s2.append || (this._dynamicIndex.clear(), this.loaded = {}), this._dynamicIndex.load(a2.features, this.loaded), s2.cluster && (a2.features = this._dynamicIndex.getFeatures())) : this.loaded = {}, this._geoJSONIndex = s2.cluster ? new N(function({ superclusterOptions: t2, clusterProperties: s3 }) {
                      if (!s3 || !t2) return t2;
                      const i3 = {}, o3 = {}, n3 = { accumulated: null, zoom: 0 }, r4 = { properties: null }, a3 = Object.keys(s3);
                      for (const t3 of a3) {
                        const [n4, r5] = s3[t3], a4 = e.X(r5), l2 = e.X("string" == typeof n4 ? [n4, ["accumulated"], ["get", t3]] : n4);
                        i3[t3] = a4.value, o3[t3] = l2.value;
                      }
                      return t2.map = (e2) => {
                        r4.properties = e2;
                        const t3 = {};
                        for (const e3 of a3) t3[e3] = i3[e3].evaluate(n3, r4);
                        return t3;
                      }, t2.reduce = (e2, t3) => {
                        r4.properties = t3;
                        for (const t4 of a3) n3.accumulated = e2[t4], e2[t4] = o3[t4].evaluate(n3, r4);
                      }, t2;
                    }(s2)).load(a2.features) : s2.dynamic ? this._dynamicIndex : function(e2, t2) {
                      return new me(e2, t2);
                    }(a2, s2.geojsonVtOptions);
                  } catch (e2) {
                    return i2(e2);
                  }
                  const r3 = {};
                  if (n2) {
                    const e2 = t(o2);
                    e2 && (r3.resourceTiming = {}, r3.resourceTiming[s2.source] = JSON.parse(JSON.stringify(e2)));
                  }
                  i2(null, r3);
                }
              });
            }
            reloadTile(e2, t2) {
              const s2 = this.loaded;
              return s2 && s2[e2.uid] ? e2.partial ? t2(null, void 0) : super.reloadTile(e2, t2) : this.loadTile(e2, t2);
            }
            loadGeoJSON(t2, s2) {
              if (t2.request) e.n(t2.request, s2);
              else {
                if ("string" != typeof t2.data) return s2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                try {
                  return s2(null, JSON.parse(t2.data));
                } catch (e2) {
                  return s2(new Error(`Input data given to '${t2.source}' is not a valid GeoJSON object.`));
                }
              }
            }
            getClusterExpansionZoom(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterChildren(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t2(e3);
              }
            }
            getClusterLeaves(e2, t2) {
              try {
                t2(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t2(e3);
              }
            }
          }
          class be {
            constructor(t2, s2) {
              this.tileID = new e.aM(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.tileZoom = t2.tileZoom, this.uid = t2.uid, this.zoom = t2.zoom, this.canonical = t2.tileID.canonical, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.projection = t2.projection, this.brightness = s2;
            }
            parse(t2, s2, i2, o2) {
              this.status = "parsing";
              const n2 = new e.aM(i2.tileID.overscaledZ, i2.tileID.wrap, i2.tileID.canonical.z, i2.tileID.canonical.x, i2.tileID.canonical.y), r2 = [], a2 = s2.familiesBySource[i2.source], l2 = new e.f0(n2, i2.promoteId);
              l2.bucketLayerIDs = [], l2.is3DTile = true, e.fi(t2).then((t3) => {
                if (!t3) return o2(new Error("Could not parse tile"));
                const s3 = e.fj(t3, 1 / e.cT(i2.tileID.canonical)), c2 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("MAPBOX_mesh_features") || t3.json.asset.extras && t3.json.asset.extras.MAPBOX_mesh_features, h2 = t3.json.extensionsUsed && t3.json.extensionsUsed.includes("EXT_meshopt_compression"), u5 = new e.aa(this.zoom, { brightness: this.brightness });
                for (const t4 in a2) for (const i3 of a2[t4]) {
                  const t5 = i3[0];
                  l2.bucketLayerIDs.push(i3.map((t6) => e.C(t6.id, t6.scope))), t5.recalculate(u5, []);
                  const o3 = new e.fk(i3, s3, n2, c2, h2, this.brightness, l2);
                  c2 || (o3.needsUpload = true), r2.push(o3), o3.evaluate(t5);
                }
                this.status = "done", o2(null, { buckets: r2, featureIndex: l2, collisionBoxArray: null, glyphAtlasImage: null, lineAtlas: null, imageAtlas: null, brightness: null });
              }).catch((e2) => o2(new Error(e2.message)));
            }
          }
          class ve {
            constructor(e2, t2, s2, i2, o2, n2, r2) {
              this.actor = e2, this.layerIndex = t2, this.availableImages = s2, this.availableModels = i2, this.brightness = r2, this.loading = {}, this.loaded = {};
            }
            loadTile(t2, s2) {
              const i2 = t2.uid, o2 = this.loading[i2] = new be(t2, this.brightness);
              e.br(t2.request, (e2, n2) => {
                const r2 = !this.loading[i2];
                return delete this.loading[i2], r2 || e2 ? (o2.status = "done", r2 || (this.loaded[i2] = o2), s2(e2)) : n2 && 0 !== n2.byteLength ? void o2.parse(n2, this.layerIndex, t2, (e3, t3) => {
                  o2.status = "done", this.loaded = this.loaded || {}, this.loaded[i2] = o2, e3 || !t3 ? s2(e3) : s2(null, t3);
                }) : (o2.status = "done", this.loaded[i2] = o2, s2());
              });
            }
            reloadTile(e2, t2) {
              const s2 = this.loaded, i2 = e2.uid;
              if (s2 && s2[i2]) {
                const o2 = s2[i2];
                o2.projection = e2.projection, o2.brightness = e2.brightness;
                const n2 = (s3, i3) => {
                  o2.reloadCallback && (delete o2.reloadCallback, this.loadTile(e2, t2)), t2(s3, i3);
                };
                "parsing" === o2.status ? o2.reloadCallback = n2 : "done" === o2.status && this.loadTile(e2, t2);
              }
            }
            abortTile(e2, t2) {
              const s2 = e2.uid;
              this.loading[s2] && delete this.loading[s2], t2();
            }
            removeTile(e2, t2) {
              const s2 = this.loaded, i2 = e2.uid;
              s2 && s2[i2] && delete s2[i2], t2();
            }
          }
          class Ie {
            constructor(t2) {
              this.self = t2, this.actor = new e.fm(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.availableModels = {}, this.isSpriteLoaded = {}, this.imageRasterizer = new e.y(), this.projections = {}, this.defaultProjection = e.ce({ name: "mercator" }), this.workerSourceTypes = { vector: c, geojson: xe, "raster-dem": h, "raster-array": d, "batched-model": ve }, this.workerSources = {}, this.self.registerWorkerSource = (e2, t3) => {
                if (this.workerSourceTypes[e2]) throw new Error(`Worker source with name "${e2}" already registered.`);
                this.workerSourceTypes[e2] = t3;
              }, this.self.registerRTLTextPlugin = (t3) => {
                if (e.fn.isParsed()) throw new Error("RTL text plugin already registered.");
                e.fn.applyArabicShaping = t3.applyArabicShaping, e.fn.processBidirectionalText = t3.processBidirectionalText, e.fn.processStyledBidirectionalText = t3.processStyledBidirectionalText;
              };
            }
            clearCaches(e2, t2, s2) {
              delete this.layerIndexes[e2], delete this.availableImages[e2], delete this.availableModels[e2], delete this.workerSources[e2], s2();
            }
            checkIfReady(e2, t2, s2) {
              s2();
            }
            setReferrer(e2, t2) {
              this.referrer = t2;
            }
            spriteLoaded(t2, s2) {
              this.isSpriteLoaded[t2] || (this.isSpriteLoaded[t2] = {});
              const { scope: i2, isLoaded: o2 } = s2;
              if (this.isSpriteLoaded[t2][i2] = o2, this.workerSources[t2] && this.workerSources[t2][i2]) for (const s3 in this.workerSources[t2][i2]) {
                const n2 = this.workerSources[t2][i2][s3];
                for (const t3 in n2) {
                  const s4 = n2[t3];
                  s4 instanceof c && (s4.isSpriteLoaded = o2, s4.fire(new e.A("isSpriteLoaded")));
                }
              }
            }
            setImages(e2, t2, s2) {
              this.availableImages[e2] || (this.availableImages[e2] = {});
              const { scope: i2, images: o2 } = t2;
              if (this.availableImages[e2][i2] = o2, this.workerSources[e2] && this.workerSources[e2][i2]) {
                for (const t3 in this.workerSources[e2][i2]) {
                  const s3 = this.workerSources[e2][i2][t3];
                  for (const e3 in s3) s3[e3].availableImages = o2;
                }
                s2();
              } else s2();
            }
            setModels(e2, { scope: t2, models: s2 }, i2) {
              if (this.availableModels[e2] || (this.availableModels[e2] = {}), this.availableModels[e2][t2] = s2, this.workerSources[e2] && this.workerSources[e2][t2]) {
                for (const i3 in this.workerSources[e2][t2]) {
                  const o2 = this.workerSources[e2][t2][i3];
                  for (const e3 in o2) o2[e3].availableModels = s2;
                }
                i2();
              } else i2();
            }
            setProjection(t2, s2) {
              this.projections[t2] = e.ce(s2);
            }
            setBrightness(e2, t2, s2) {
              this.brightness = t2, s2();
            }
            setLayers(e2, t2, s2) {
              this.getLayerIndex(e2, t2.scope).replace(t2.layers, t2.options), s2();
            }
            updateLayers(e2, t2, s2) {
              this.getLayerIndex(e2, t2.scope).update(t2.layers, t2.removedIds, t2.options), s2();
            }
            loadTile(e2, t2, s2) {
              t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).loadTile(t2, s2);
            }
            decodeRasterArray(e2, t2, s2) {
              this.getWorkerSource(e2, t2.type, t2.source, t2.scope).decodeRasterArray(t2, s2);
            }
            reloadTile(e2, t2, s2) {
              t2.projection = this.projections[e2] || this.defaultProjection, this.getWorkerSource(e2, t2.type, t2.source, t2.scope).reloadTile(t2, s2);
            }
            abortTile(e2, t2, s2) {
              this.getWorkerSource(e2, t2.type, t2.source, t2.scope).abortTile(t2, s2);
            }
            removeTile(e2, t2, s2) {
              this.getWorkerSource(e2, t2.type, t2.source, t2.scope).removeTile(t2, s2);
            }
            removeSource(e2, t2, s2) {
              if (!(this.workerSources[e2] && this.workerSources[e2][t2.scope] && this.workerSources[e2][t2.scope][t2.type] && this.workerSources[e2][t2.scope][t2.type][t2.source])) return;
              const i2 = this.workerSources[e2][t2.scope][t2.type][t2.source];
              delete this.workerSources[e2][t2.scope][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, s2) : s2();
            }
            loadWorkerSource(e2, t2, s2) {
              try {
                this.self.importScripts(t2.url), s2();
              } catch (e3) {
                s2(e3.toString());
              }
            }
            syncRTLPluginState(t2, s2, i2) {
              try {
                e.fn.setState(s2);
                const t3 = e.fn.getPluginURL();
                if (e.fn.isLoaded() && !e.fn.isParsed() && null != t3) {
                  this.self.importScripts(t3);
                  const s3 = e.fn.isParsed();
                  i2(s3 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t3}`), s3);
                }
              } catch (e2) {
                i2(e2.toString());
              }
            }
            setDracoUrl(e2, t2) {
              this.dracoUrl = t2;
            }
            getAvailableImages(e2, t2) {
              this.availableImages[e2] || (this.availableImages[e2] = {});
              let s2 = this.availableImages[e2][t2];
              return s2 || (s2 = []), s2;
            }
            getAvailableModels(e2, t2) {
              this.availableModels[e2] || (this.availableModels[e2] = {});
              let s2 = this.availableModels[e2][t2];
              return s2 || (s2 = {}), s2;
            }
            getLayerIndex(e2, t2) {
              this.layerIndexes[e2] || (this.layerIndexes[e2] = {});
              let s2 = this.layerIndexes[e2][t2];
              return s2 || (s2 = this.layerIndexes[e2][t2] = new o(), s2.scope = t2), s2;
            }
            getWorkerSource(e2, t2, s2, i2) {
              const o2 = this.workerSources;
              return o2[e2] || (o2[e2] = {}), o2[e2][i2] || (o2[e2][i2] = {}), o2[e2][i2][t2] || (o2[e2][i2][t2] = {}), this.isSpriteLoaded[e2] || (this.isSpriteLoaded[e2] = {}), o2[e2][i2][t2][s2] || (o2[e2][i2][t2][s2] = new this.workerSourceTypes[t2]({ send: (t3, s3, i3, o3, n2, r2) => this.actor.send(t3, s3, i3, e2, n2, r2), scheduler: this.actor.scheduler }, this.getLayerIndex(e2, i2), this.getAvailableImages(e2, i2), this.getAvailableModels(e2, i2), this.isSpriteLoaded[e2][i2], void 0, this.brightness)), o2[e2][i2][t2][s2];
            }
            rasterizeImagesWorker(e2, t2, s2) {
              const i2 = /* @__PURE__ */ new Map();
              for (const [s3, { image: o2, imageVariant: n2 }] of t2.tasks.entries()) {
                const r2 = this.imageRasterizer.rasterize(n2, o2, t2.scope, e2);
                i2.set(s3, r2);
              }
              s2(void 0, i2);
            }
            removeRasterizedImages(e2, t2, s2) {
              this.imageRasterizer.removeImagesFromCacheByIds(t2.imageIds, t2.scope, e2), s2();
            }
            enforceCacheSizeLimit(t2, s2) {
              e.fo(s2);
            }
            getWorkerPerformanceMetrics(e2, t2, s2) {
              s2(void 0, void 0);
            }
          }
          return e.fl(self) && (self.worker = new Ie(self)), Ie;
        });
        define2(["./shared"], function(e) {
          var t = "3.12.0";
          const i = { create: "create", load: "load", fullLoad: "fullLoad" }, o = { mark(e2) {
            performance.mark(e2);
          }, measure(e2, t2, i2) {
            performance.measure(e2, t2, i2);
          } };
          function s(t2) {
            const i2 = t2.name.split("?")[0];
            return e.a(i2) && i2.includes("mapbox-gl.js") ? "javascript" : e.a(i2) && i2.includes("mapbox-gl.css") ? "css" : e.b(i2) ? "fontRange" : e.c(i2) ? "sprite" : e.i(i2) ? "style" : e.d(i2) ? "tilejson" : "other";
          }
          var r, n = {}, a = function() {
            if (r) return n;
            function e2(e3) {
              return !t2(e3);
            }
            function t2(t3) {
              return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window)) return false;
                var e3, t4, i3 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i3);
                try {
                  t4 = new Worker(o3), e3 = true;
                } catch (t5) {
                  e3 = false;
                }
                return t4 && t4.terminate(), URL.revokeObjectURL(o3), e3;
              }() ? function() {
                var e3 = document.createElement("canvas");
                e3.width = e3.height = 1;
                var t4 = e3.getContext("2d");
                if (!t4) return false;
                var i3 = t4.getImageData(0, 0, 1, 1);
                return i3 && i3.width === e3.width;
              }() ? (void 0 === i2[o2 = t3 && t3.failIfMajorPerformanceCaveat] && (i2[o2] = function(t4) {
                var i3, o3 = function(t5) {
                  var i4 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                  return o4.failIfMajorPerformanceCaveat = t5, i4.getContext("webgl2", o4);
                }(t4);
                if (!o3) return false;
                try {
                  i3 = o3.createShader(o3.VERTEX_SHADER);
                } catch (e3) {
                  return false;
                }
                return !(!i3 || o3.isContextLost()) && (o3.shaderSource(i3, "void main() {}"), o3.compileShader(i3), true === o3.getShaderParameter(i3, o3.COMPILE_STATUS));
              }(o2)), i2[o2] ? document.documentMode ? "insufficient ECMAScript 6 support" : void 0 : "insufficient WebGL2 support") : "insufficient Canvas/getImageData support" : "insufficient worker support";
              var o2;
            }
            r = 1, n.supported = e2, n.notSupportedReason = t2;
            var i2 = {};
            return e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true }, n;
          }();
          function l(e2, t2, i2) {
            const o2 = document.createElement(e2);
            return null != t2 && (o2.className = t2), i2 && i2.appendChild(o2), o2;
          }
          function c(e2, t2, i2) {
            const o2 = document.createElementNS("http://www.w3.org/2000/svg", e2);
            for (const e3 of Object.keys(t2)) o2.setAttributeNS(null, e3, String(t2[e3]));
            return i2 && i2.appendChild(o2), o2;
          }
          const h = "undefined" != typeof document ? document.documentElement && document.documentElement.style : null, d = h && void 0 !== h.userSelect ? "userSelect" : "WebkitUserSelect";
          let u4;
          function _() {
            h && d && (u4 = h[d], h[d] = "none");
          }
          function p() {
            h && d && (h[d] = u4);
          }
          function f(e2) {
            e2.preventDefault(), e2.stopPropagation(), window.removeEventListener("click", f, true);
          }
          function m() {
            window.addEventListener("click", f, true), window.setTimeout(() => {
              window.removeEventListener("click", f, true);
            }, 0);
          }
          function g(e2, t2) {
            const i2 = e2.getBoundingClientRect();
            return x(e2, i2, t2);
          }
          function v2(e2, t2) {
            const i2 = e2.getBoundingClientRect(), o2 = [];
            for (let s2 = 0; s2 < t2.length; s2++) o2.push(x(e2, i2, t2[s2]));
            return o2;
          }
          function y(e2) {
            return /firefox/i.test(navigator.userAgent) && /macintosh/i.test(navigator.userAgent) && 2 === e2.button && e2.ctrlKey ? 0 : e2.button;
          }
          function x(t2, i2, o2) {
            const s2 = t2.offsetWidth === i2.width ? 1 : t2.offsetWidth / i2.width;
            return new e.P((o2.clientX - i2.left) * s2, (o2.clientY - i2.top) * s2);
          }
          const b = "01", w = "NO_ACCESS_TOKEN";
          class T {
            constructor(e2, t2, i2) {
              this._transformRequestFn = e2, this._customAccessToken = t2, this._silenceAuthErrors = !!i2, this._createSkuToken();
            }
            _createSkuToken() {
              const e2 = function() {
                let e3 = "";
                for (let t2 = 0; t2 < 10; t2++) e3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
                return { token: ["1", b, e3].join(""), tokenExpiresAt: Date.now() + 432e5 };
              }();
              this._skuToken = e2.token, this._skuTokenExpiresAt = e2.tokenExpiresAt;
            }
            _isSkuTokenExpired() {
              return Date.now() > this._skuTokenExpiresAt;
            }
            transformRequest(e2, t2) {
              return this._transformRequestFn && this._transformRequestFn(e2, t2) || { url: e2 };
            }
            normalizeStyleURL(i2, o2) {
              if (!e.f(i2)) return i2;
              const s2 = S(i2);
              return s2.params.push(`sdk=js-${t}`), s2.path = `/styles/v1${s2.path}`, this._makeAPIURL(s2, this._customAccessToken || o2);
            }
            normalizeGlyphsURL(t2, i2) {
              if (!e.f(t2)) return t2;
              const o2 = S(t2);
              return o2.path = `/fonts/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
            }
            normalizeModelURL(t2, i2) {
              if (!e.f(t2)) return t2;
              const o2 = S(t2);
              return o2.path = `/models/v1${o2.path}`, this._makeAPIURL(o2, this._customAccessToken || i2);
            }
            normalizeSourceURL(t2, i2, o2, s2) {
              if (!e.f(t2)) return t2;
              const r2 = S(t2);
              return r2.path = `/v4/${r2.authority}.json`, r2.params.push("secure"), o2 && r2.params.push(`language=${o2}`), s2 && r2.params.push(`worldview=${s2}`), this._makeAPIURL(r2, this._customAccessToken || i2);
            }
            normalizeIconsetURL(t2, i2) {
              const o2 = S(t2);
              return e.f(t2) ? (o2.path = `/styles/v1${o2.path}/iconset.pbf`, this._makeAPIURL(o2, this._customAccessToken || i2)) : I(o2);
            }
            normalizeSpriteURL(t2, i2, o2, s2) {
              const r2 = S(t2);
              return e.f(t2) ? (r2.path = `/styles/v1${r2.path}/sprite${i2}${o2}`, this._makeAPIURL(r2, this._customAccessToken || s2)) : (r2.path += `${i2}${o2}`, I(r2));
            }
            normalizeTileURL(t2, i2, o2) {
              if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !e.f(t2)) return t2;
              const s2 = S(t2);
              s2.path = s2.path.replace(/(\.(png|jpg)\d*)(?=$)/, `${i2 || o2 && "raster" !== s2.authority && 512 === o2 ? "@2x" : ""}${e.m.supported ? ".webp" : "$1"}`), "raster" === s2.authority ? s2.path = `/${e.e.RASTER_URL_PREFIX}${s2.path}` : "rasterarrays" === s2.authority ? s2.path = `/${e.e.RASTERARRAYS_URL_PREFIX}${s2.path}` : "3dtiles" === s2.authority ? s2.path = `/${e.e.TILES3D_URL_PREFIX}${s2.path}` : (s2.path = s2.path.replace(/^.+\/v4\//, "/"), s2.path = `/${e.e.TILE_URL_VERSION}${s2.path}`);
              const r2 = this._customAccessToken || function(e2) {
                for (const t3 of e2) {
                  const e3 = t3.match(/^access_token=(.*)$/);
                  if (e3) return e3[1];
                }
                return null;
              }(s2.params) || e.e.ACCESS_TOKEN;
              return e.e.REQUIRE_ACCESS_TOKEN && r2 && this._skuToken && s2.params.push(`sku=${this._skuToken}`), this._makeAPIURL(s2, r2);
            }
            canonicalizeTileURL(t2, i2) {
              const o2 = S(t2);
              if (!o2.path.match(/^(\/v4\/|\/(raster|rasterarrays)\/v1\/)/) || !o2.path.match(/\.[\w]+$/)) return t2;
              let s2 = "mapbox://";
              o2.path.match(/^\/raster\/v1\//) ? s2 += `raster/${o2.path.replace(`/${e.e.RASTER_URL_PREFIX}/`, "")}` : o2.path.match(/^\/rasterarrays\/v1\//) ? s2 += `rasterarrays/${o2.path.replace(`/${e.e.RASTERARRAYS_URL_PREFIX}/`, "")}` : s2 += `tiles/${o2.path.replace(`/${e.e.TILE_URL_VERSION}/`, "")}`;
              let r2 = o2.params;
              return i2 && (r2 = r2.filter((e2) => !e2.match(/^access_token=/))), r2.length && (s2 += `?${r2.join("&")}`), s2;
            }
            canonicalizeTileset(t2, i2) {
              const o2 = !!i2 && e.f(i2), s2 = [];
              for (const i3 of t2.tiles || []) e.h(i3) ? s2.push(this.canonicalizeTileURL(i3, o2)) : s2.push(i3);
              return s2;
            }
            _makeAPIURL(t2, i2) {
              const o2 = "See https://docs.mapbox.com/api/overview/#access-tokens-and-token-scopes", s2 = S(e.e.API_URL);
              if (t2.protocol = s2.protocol, t2.authority = s2.authority, "http" === t2.protocol) {
                const e2 = t2.params.indexOf("secure");
                e2 >= 0 && t2.params.splice(e2, 1);
              }
              if ("/" !== s2.path && (t2.path = `${s2.path}${t2.path}`), !e.e.REQUIRE_ACCESS_TOKEN) return I(t2);
              if (i2 = i2 || e.e.ACCESS_TOKEN, !this._silenceAuthErrors) {
                if (!i2) throw new Error(`An API access token is required to use Mapbox GL. ${o2}`);
                if ("s" === i2[0]) throw new Error(`Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). ${o2}`);
              }
              return t2.params = t2.params.filter((e2) => -1 === e2.indexOf("access_token")), t2.params.push(`access_token=${i2 || ""}`), I(t2);
            }
          }
          const E = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function S(e2) {
            const t2 = e2.match(E);
            if (!t2) throw new Error("Unable to parse URL object");
            return { protocol: t2[1], authority: t2[2], path: t2[3] || "/", params: t2[4] ? t2[4].split("&") : [] };
          }
          function I(e2) {
            const t2 = e2.params.length ? `?${e2.params.join("&")}` : "";
            return `${e2.protocol}://${e2.authority}${e2.path}${t2}`;
          }
          const C = "mapbox.eventData";
          function R(t2) {
            if (!t2) return null;
            const i2 = t2.split(".");
            if (!i2 || 3 !== i2.length) return null;
            try {
              return JSON.parse(e.j(i2[1]));
            } catch (e2) {
              return null;
            }
          }
          class D2 {
            constructor(e2) {
              this.type = e2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
            }
            getStorageKey(t2) {
              const i2 = R(e.e.ACCESS_TOKEN);
              let o2 = "";
              return o2 = i2 && i2.u ? e.k(i2.u) : e.e.ACCESS_TOKEN || "", t2 ? `${C}.${t2}:${o2}` : `${C}:${o2}`;
            }
            fetchEventData() {
              const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid");
              if (t2) try {
                const e2 = localStorage.getItem(i2);
                e2 && (this.eventData = JSON.parse(e2));
                const t3 = localStorage.getItem(o2);
                t3 && (this.anonId = t3);
              } catch (t3) {
                e.w("Unable to read from LocalStorage");
              }
            }
            saveEventData() {
              const t2 = e.s("localStorage"), i2 = this.getStorageKey(), o2 = this.getStorageKey("uuid"), s2 = this.anonId;
              if (t2 && s2) try {
                localStorage.setItem(o2, s2), Object.keys(this.eventData).length >= 1 && localStorage.setItem(i2, JSON.stringify(this.eventData));
              } catch (t3) {
                e.w("Unable to write to LocalStorage");
              }
            }
            processRequests(e2) {
            }
            postEvent(t2, i2, o2, s2) {
              if (!e.e.EVENTS_URL) return;
              const r2 = S(e.e.EVENTS_URL);
              r2.params.push(`access_token=${s2 || e.e.ACCESS_TOKEN || ""}`);
              const n2 = { event: this.type, created: new Date(t2).toISOString() }, a2 = i2 ? e.l(n2, i2) : n2, l2 = { url: I(r2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([a2]) };
              this.pendingRequest = e.p(l2, (e2) => {
                this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(s2);
              });
            }
            queueRequest(e2, t2) {
              this.queue.push(e2), this.processRequests(t2);
            }
          }
          const A = new class extends D2 {
            constructor(e2) {
              super("appUserTurnstile"), this._customAccessToken = e2;
            }
            postTurnstileEvent(t2, i2) {
              e.e.EVENTS_URL && e.e.ACCESS_TOKEN && Array.isArray(t2) && t2.some((t3) => e.f(t3) || e.h(t3)) && this.queueRequest(Date.now(), i2);
            }
            processRequests(i2) {
              if (this.pendingRequest || 0 === this.queue.length) return;
              this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
              const o2 = R(e.e.ACCESS_TOKEN), s2 = o2 ? o2.u : e.e.ACCESS_TOKEN;
              let r2 = s2 !== this.eventData.tokenU;
              e.v(this.anonId) || (this.anonId = e.u(), r2 = true);
              const n2 = this.queue.shift();
              if (this.eventData.lastSuccess) {
                const e2 = new Date(this.eventData.lastSuccess), t2 = new Date(n2), i3 = (n2 - this.eventData.lastSuccess) / 864e5;
                r2 = r2 || i3 >= 1 || i3 < -1 || e2.getDate() !== t2.getDate();
              } else r2 = true;
              r2 ? this.postEvent(n2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, "enabled.telemetry": false, userId: this.anonId }, (e2) => {
                e2 || (this.eventData.lastSuccess = n2, this.eventData.tokenU = s2);
              }, i2) : this.processRequests();
            }
          }(), L = A.postTurnstileEvent.bind(A), P = new class extends D2 {
            constructor() {
              super("map.load"), this.success = {}, this.skuToken = "";
            }
            postMapLoadEvent(t2, i2, o2, s2) {
              this.skuToken = i2, this.errorCb = s2, e.e.EVENTS_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
            }
            processRequests(i2) {
              if (this.pendingRequest || 0 === this.queue.length) return;
              const { id: o2, timestamp: s2 } = this.queue.shift();
              o2 && this.success[o2] || (this.anonId || this.fetchEventData(), e.v(this.anonId) || (this.anonId = e.u()), this.postEvent(s2, { sdkIdentifier: "mapbox-gl-js", sdkVersion: t, skuId: b, skuToken: this.skuToken, userId: this.anonId }, (e2) => {
                e2 ? this.errorCb(e2) : o2 && (this.success[o2] = true);
              }, i2));
            }
            remove() {
              this.errorCb = null;
            }
          }(), z = P.postMapLoadEvent.bind(P), M = new class extends D2 {
            constructor() {
              super("style.load"), this.eventIdPerMapInstanceMap = /* @__PURE__ */ new Map(), this.mapInstanceIdMap = /* @__PURE__ */ new WeakMap();
            }
            getMapInstanceId(t2) {
              let i2 = this.mapInstanceIdMap.get(t2);
              return i2 || (i2 = e.u(), this.mapInstanceIdMap.set(t2, i2)), i2;
            }
            getEventId(e2) {
              const t2 = this.eventIdPerMapInstanceMap.get(e2) || 0;
              return this.eventIdPerMapInstanceMap.set(e2, t2 + 1), t2;
            }
            postStyleLoadEvent(t2, i2) {
              const { map: o2, style: s2, importedStyles: r2 } = i2;
              if (!e.e.EVENTS_URL || !t2 && !e.e.ACCESS_TOKEN) return;
              const n2 = this.getMapInstanceId(o2), a2 = { mapInstanceId: n2, eventId: this.getEventId(n2), style: s2 };
              r2.length && (a2.importedStyles = r2), this.queueRequest({ timestamp: Date.now(), payload: a2 }, t2);
            }
            processRequests(e2) {
              if (this.pendingRequest || 0 === this.queue.length) return;
              const { timestamp: t2, payload: i2 } = this.queue.shift();
              this.postEvent(t2, i2, () => {
              }, e2);
            }
          }(), O = M.postStyleLoadEvent.bind(M), F = new class extends D2 {
            constructor() {
              super("gljs.performance");
            }
            postPerformanceEvent(t2, i2) {
              e.e.EVENTS_URL && (t2 || e.e.ACCESS_TOKEN) && this.queueRequest({ timestamp: Date.now(), performanceData: i2 }, t2);
            }
            processRequests(o2) {
              if (this.pendingRequest || 0 === this.queue.length) return;
              const { timestamp: r2, performanceData: n2 } = this.queue.shift(), a2 = function(o3) {
                const r3 = performance.getEntriesByType("resource"), n3 = performance.getEntriesByType("mark"), a3 = function(e2) {
                  const t2 = {};
                  if (e2) {
                    for (const i2 in e2) if ("other" !== i2) for (const o4 of e2[i2]) {
                      const e3 = `${i2}ResolveRangeMin`, s2 = `${i2}ResolveRangeMax`, r4 = `${i2}RequestCount`, n4 = `${i2}RequestCachedCount`;
                      t2[e3] = Math.min(t2[e3] || 1 / 0, o4.startTime), t2[s2] = Math.max(t2[s2] || -1 / 0, o4.responseEnd);
                      const a4 = (e4) => {
                        void 0 === t2[e4] && (t2[e4] = 0), ++t2[e4];
                      };
                      void 0 !== o4.transferSize && 0 === o4.transferSize && a4(n4), a4(r4);
                    }
                  }
                  return t2;
                }(function(e2, t2) {
                  const i2 = {};
                  if (e2) for (const o4 of e2) {
                    const e3 = t2(o4);
                    void 0 === i2[e3] && (i2[e3] = []), i2[e3].push(o4);
                  }
                  return i2;
                }(r3, s)), l2 = window.devicePixelRatio, c2 = navigator.connection || navigator.mozConnection || navigator.webkitConnection, h2 = c2 ? c2.effectiveType : void 0, d2 = { counters: [], metadata: [], attributes: [] }, u5 = (e2, t2, i2) => {
                  null != i2 && e2.push({ name: t2, value: i2.toString() });
                };
                for (const e2 in a3) u5(d2.counters, e2, a3[e2]);
                if (o3.interactionRange[0] !== 1 / 0 && o3.interactionRange[1] !== -1 / 0 && (u5(d2.counters, "interactionRangeMin", o3.interactionRange[0]), u5(d2.counters, "interactionRangeMax", o3.interactionRange[1])), n3) for (const e2 of Object.keys(i)) {
                  const t2 = i[e2], o4 = n3.find((e3) => e3.name === t2);
                  o4 && u5(d2.counters, t2, o4.startTime);
                }
                return u5(d2.counters, "visibilityHidden", o3.visibilityHidden), u5(d2.attributes, "style", function(t2) {
                  if (t2) for (const i2 of t2) {
                    const t3 = i2.name.split("?")[0];
                    if (e.i(t3)) {
                      const e2 = t3.split("/").slice(-2);
                      if (2 === e2.length) return `mapbox://styles/${e2[0]}/${e2[1]}`;
                    }
                  }
                }(r3)), u5(d2.attributes, "terrainEnabled", o3.terrainEnabled ? "true" : "false"), u5(d2.attributes, "fogEnabled", o3.fogEnabled ? "true" : "false"), u5(d2.attributes, "projection", o3.projection), u5(d2.attributes, "zoom", o3.zoom), u5(d2.metadata, "devicePixelRatio", l2), u5(d2.metadata, "connectionEffectiveType", h2), u5(d2.metadata, "navigatorUserAgent", navigator.userAgent), u5(d2.metadata, "screenWidth", window.screen.width), u5(d2.metadata, "screenHeight", window.screen.height), u5(d2.metadata, "windowWidth", window.innerWidth), u5(d2.metadata, "windowHeight", window.innerHeight), u5(d2.metadata, "mapWidth", o3.width / l2), u5(d2.metadata, "mapHeight", o3.height / l2), u5(d2.metadata, "webglRenderer", o3.renderer), u5(d2.metadata, "webglVendor", o3.vendor), u5(d2.metadata, "sdkVersion", t), u5(d2.metadata, "sdkIdentifier", "mapbox-gl-js"), d2;
              }(n2);
              for (const e2 of a2.metadata) ;
              for (const e2 of a2.counters) ;
              for (const e2 of a2.attributes) ;
              this.postEvent(r2, a2, () => {
              }, o2);
            }
          }(), B2 = F.postPerformanceEvent.bind(F), k = new class extends D2 {
            constructor() {
              super("map.auth"), this.success = {}, this.skuToken = "";
            }
            getSession(t2, i2, o2, s2) {
              if (!e.e.API_URL || !e.e.SESSION_PATH) return;
              const r2 = S(e.e.API_URL + e.e.SESSION_PATH);
              r2.params.push(`sku=${i2 || ""}`), r2.params.push(`access_token=${s2 || e.e.ACCESS_TOKEN || ""}`);
              const n2 = { url: I(r2), headers: { "Content-Type": "text/plain" } };
              this.pendingRequest = e.g(n2, (e2) => {
                this.pendingRequest = null, o2(e2), this.saveEventData(), this.processRequests(s2);
              });
            }
            getSessionAPI(t2, i2, o2, s2) {
              this.skuToken = i2, this.errorCb = s2, e.e.SESSION_PATH && e.e.API_URL && (o2 || e.e.ACCESS_TOKEN ? this.queueRequest({ id: t2, timestamp: Date.now() }, o2) : this.errorCb(new Error(w)));
            }
            processRequests(e2) {
              if (this.pendingRequest || 0 === this.queue.length) return;
              const { id: t2, timestamp: i2 } = this.queue.shift();
              t2 && this.success[t2] || this.getSession(i2, this.skuToken, (e3) => {
                e3 ? this.errorCb(e3) : t2 && (this.success[t2] = true);
              }, e2);
            }
            remove() {
              this.errorCb = null;
            }
          }(), N = k.getSessionAPI.bind(k), U = /* @__PURE__ */ new Set();
          function j(e2, t2) {
            t2 ? U.add(e2) : U.delete(e2);
          }
          class V {
            constructor() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps = /* @__PURE__ */ new Set(), this._updatedImages = {};
            }
            isDirty() {
              return this._changed;
            }
            setDirty() {
              this._changed = true;
            }
            getUpdatedSourceCaches() {
              return this._updatedSourceCaches;
            }
            updateSourceCache(e2, t2) {
              this._updatedSourceCaches[e2] = t2, this.setDirty();
            }
            discardSourceCacheUpdate(e2) {
              delete this._updatedSourceCaches[e2];
            }
            updateLayer(e2) {
              const t2 = e2.scope;
              this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._updatedLayers[t2].add(e2.id), this.setDirty();
            }
            removeLayer(e2) {
              const t2 = e2.scope;
              this._removedLayers[t2] = this._removedLayers[t2] || {}, this._updatedLayers[t2] = this._updatedLayers[t2] || /* @__PURE__ */ new Set(), this._removedLayers[t2][e2.id] = e2, this._updatedLayers[t2].delete(e2.id), this._updatedPaintProps.delete(e2.fqid), this.setDirty();
            }
            getRemovedLayer(e2) {
              return this._removedLayers[e2.scope] ? this._removedLayers[e2.scope][e2.id] : null;
            }
            discardLayerRemoval(e2) {
              this._removedLayers[e2.scope] && delete this._removedLayers[e2.scope][e2.id];
            }
            getLayerUpdatesByScope() {
              const e2 = {};
              for (const t2 in this._updatedLayers) e2[t2] = e2[t2] || {}, e2[t2].updatedIds = Array.from(this._updatedLayers[t2].values());
              for (const t2 in this._removedLayers) e2[t2] = e2[t2] || {}, e2[t2].removedIds = Object.keys(this._removedLayers[t2]);
              return e2;
            }
            getUpdatedPaintProperties() {
              return this._updatedPaintProps;
            }
            updatePaintProperties(e2) {
              this._updatedPaintProps.add(e2.fqid), this.setDirty();
            }
            getUpdatedImages(e2) {
              return this._updatedImages[e2] ? Array.from(this._updatedImages[e2].values()) : [];
            }
            updateImage(t2, i2) {
              this._updatedImages[i2] = this._updatedImages[i2] || /* @__PURE__ */ new Set(), this._updatedImages[i2].add(e.I.toString(t2)), this.setDirty();
            }
            resetUpdatedImages(e2) {
              this._updatedImages[e2] && this._updatedImages[e2].clear();
            }
            reset() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSourceCaches = {}, this._updatedPaintProps.clear(), this._updatedImages = {};
            }
          }
          function G(e2) {
            const { userImage: t2 } = e2;
            return !!(t2 && t2.render && t2.render()) && (e2.data.replace(new Uint8Array(t2.data.buffer)), true);
          }
          class q extends e.E {
            constructor(t2) {
              super(), this.imageProviders = /* @__PURE__ */ new Map(), this.images = /* @__PURE__ */ new Map(), this.updatedImages = /* @__PURE__ */ new Map(), this.callbackDispatchedThisFrame = /* @__PURE__ */ new Map(), this.loaded = /* @__PURE__ */ new Map(), this.requestors = [], this.patterns = /* @__PURE__ */ new Map(), this.patternsInFlight = /* @__PURE__ */ new Set(), this.atlasImage = /* @__PURE__ */ new Map(), this.atlasTexture = /* @__PURE__ */ new Map(), this.dirty = true, this.spriteFormat = t2, "raster" !== t2 && e.t() && (this.imageRasterizerDispatcher = new e.D(e.x(), this, "Image Rasterizer Worker", 1));
            }
            addScope(t2) {
              this.loaded.set(t2, false), this.imageProviders.set(t2, /* @__PURE__ */ new Map()), this.images.set(t2, /* @__PURE__ */ new Map()), this.updatedImages.set(t2, /* @__PURE__ */ new Set()), this.callbackDispatchedThisFrame.set(t2, /* @__PURE__ */ new Set()), this.patterns.set(t2, /* @__PURE__ */ new Map()), this.atlasImage.set(t2, new e.r({ width: 1, height: 1 }));
            }
            removeScope(e2) {
              this.loaded.delete(e2), this.imageProviders.delete(e2), this.images.delete(e2), this.updatedImages.delete(e2), this.callbackDispatchedThisFrame.delete(e2), this.patterns.delete(e2), this.atlasImage.delete(e2);
              const t2 = this.atlasTexture.get(e2);
              t2 && (t2.destroy(), this.atlasTexture.delete(e2));
            }
            addImageProvider(e2, t2) {
              this.imageProviders.has(t2) || this.imageProviders.set(t2, /* @__PURE__ */ new Map()), this.imageProviders.get(t2).set(e2.id, e2);
            }
            removeImageProvider(e2, t2) {
              this.imageProviders.has(t2) && this.imageProviders.get(t2).delete(e2);
            }
            getPendingImageProviders() {
              const e2 = [];
              for (const t2 of this.imageProviders.values()) for (const i2 of t2.values()) i2.hasPendingRequests() && e2.push(i2);
              return e2;
            }
            get imageRasterizer() {
              return this._imageRasterizer || (this._imageRasterizer = new e.y()), this._imageRasterizer;
            }
            isLoaded() {
              for (const e2 of this.loaded.keys()) if (!this.loaded.get(e2)) return false;
              return true;
            }
            setLoaded(e2, t2) {
              if (this.loaded.get(t2) !== e2 && (this.loaded.set(t2, e2), e2)) {
                for (const { ids: e3, callback: i2 } of this.requestors) this._notify(e3, t2, i2);
                this.requestors = [];
              }
            }
            hasImage(e2, t2) {
              return !!this.getImage(e2, t2);
            }
            getImage(e2, t2) {
              return this.images.get(t2).get(e2.toString());
            }
            addImage(e2, t2, i2) {
              this._validate(e2, i2) && this.images.get(t2).set(e2.toString(), i2);
            }
            _validate(t2, i2) {
              let o2 = true;
              return this._validateStretch(i2.stretchX, i2.data && i2.data.width) || (this.fire(new e.z(new Error(`Image "${t2.name}" has invalid "stretchX" value`))), o2 = false), this._validateStretch(i2.stretchY, i2.data && i2.data.height) || (this.fire(new e.z(new Error(`Image "${t2.name}" has invalid "stretchY" value`))), o2 = false), this._validateContent(i2.content, i2) || (this.fire(new e.z(new Error(`Image "${t2.name}" has invalid "content" value`))), o2 = false), o2;
            }
            _validateStretch(e2, t2) {
              if (!e2) return true;
              let i2 = 0;
              for (const o2 of e2) {
                if (o2[0] < i2 || o2[1] < o2[0] || t2 < o2[1]) return false;
                i2 = o2[1];
              }
              return true;
            }
            _validateContent(e2, t2) {
              if (!e2) return true;
              if (4 !== e2.length) return false;
              if (!t2.usvg) {
                if (e2[0] < 0 || t2.data.width < e2[0]) return false;
                if (e2[1] < 0 || t2.data.height < e2[1]) return false;
                if (e2[2] < 0 || t2.data.width < e2[2]) return false;
                if (e2[3] < 0 || t2.data.height < e2[3]) return false;
              }
              return !(e2[2] < e2[0] || e2[3] < e2[1]);
            }
            updateImage(e2, t2, i2) {
              const o2 = this.images.get(t2).get(e2.toString());
              i2.version = o2.version + 1, this.images.get(t2).set(e2.toString(), i2), this.updatedImages.get(t2).add(e2), this.removeFromImageRasterizerCache(e2, t2);
            }
            clearUpdatedImages(e2) {
              this.updatedImages.get(e2).clear();
            }
            removeFromImageRasterizerCache(t2, i2) {
              "raster" !== this.spriteFormat && (e.t() ? this.imageRasterizerDispatcher.getActor().send("removeRasterizedImages", { imageIds: [t2], scope: i2 }) : this.imageRasterizer.removeImagesFromCacheByIds([t2], i2));
            }
            removeImage(e2, t2) {
              const i2 = this.images.get(t2), o2 = i2.get(e2.toString());
              i2.delete(e2.toString()), this.patterns.get(t2).delete(e2.toString()), this.removeFromImageRasterizerCache(e2, t2), o2.userImage && o2.userImage.onRemove && o2.userImage.onRemove();
            }
            listImages(t2) {
              return Array.from(this.images.get(t2).keys()).map((t3) => e.I.from(t3));
            }
            getImages(e2, t2, i2) {
              const o2 = [], s2 = [], r2 = this.imageProviders.get(t2);
              for (const i3 of e2) {
                if (!i3.iconsetId) {
                  o2.push(i3);
                  continue;
                }
                const e3 = r2.get(i3.iconsetId);
                e3 && (this.getImage(i3, t2) ? s2.push(i3) : e3.addPendingRequest(i3));
              }
              if (0 === o2.length) return void this._notify(s2, t2, i2);
              let n2 = true;
              const a2 = !!this.loaded.get(t2), l2 = this.images.get(t2);
              if (!a2) for (const e3 of o2) l2.has(e3.toString()) || (n2 = false);
              a2 || n2 ? this._notify(o2, t2, i2) : this.requestors.push({ ids: o2, scope: t2, callback: i2 });
            }
            rasterizeImages(e2, t2) {
              const i2 = /* @__PURE__ */ new Map(), { tasks: o2, scope: s2 } = e2;
              for (const [e3, t3] of o2.entries()) {
                const o3 = this.getImage(t3.id, s2);
                o3 && i2.set(e3, { image: o3, imageVariant: t3 });
              }
              this._rasterizeImages(s2, i2, t2);
            }
            _rasterizeImages(t2, i2, o2) {
              if (e.t()) this.imageRasterizerDispatcher.getActor().send("rasterizeImagesWorker", { tasks: i2, scope: t2 }, o2);
              else {
                const e2 = /* @__PURE__ */ new Map();
                for (const [o3, { image: s2, imageVariant: r2 }] of i2.entries()) e2.set(o3, this.imageRasterizer.rasterize(r2, s2, t2, 0));
                o2(void 0, e2);
              }
            }
            getUpdatedImages(e2) {
              return this.updatedImages.get(e2) || /* @__PURE__ */ new Set();
            }
            _notify(t2, i2, o2) {
              const s2 = this.images.get(i2), r2 = /* @__PURE__ */ new Map();
              for (const i3 of t2) {
                if (!s2.get(i3.toString())) {
                  if (i3.iconsetId) continue;
                  this.fire(new e.A("styleimagemissing", { id: i3.name }));
                }
                const t3 = s2.get(i3.toString());
                if (!t3) {
                  e.w(`Image "${i3.name}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
                  continue;
                }
                const o3 = { data: t3.usvg ? null : t3.data.clone(), pixelRatio: t3.pixelRatio, sdf: t3.sdf, usvg: t3.usvg, version: t3.version, stretchX: t3.stretchX, stretchY: t3.stretchY, content: t3.content, hasRenderCallback: Boolean(t3.userImage && t3.userImage.render) };
                t3.usvg && Object.assign(o3, { width: t3.icon.usvg_tree.width, height: t3.icon.usvg_tree.height }), r2.set(e.I.toString(i3), o3);
              }
              o2(null, r2);
            }
            getPixelSize(e2) {
              const { width: t2, height: i2 } = this.atlasImage.get(e2);
              return { width: t2, height: i2 };
            }
            getPattern(t2, i2, o2) {
              const s2 = t2.toString(), r2 = this.patterns.get(i2), n2 = r2.get(s2), a2 = this.getImage(t2, i2);
              if (!a2) return null;
              if (n2) {
                if (n2.position.version === a2.version) return n2.position;
                n2.position.version = a2.version;
              } else {
                if (a2.usvg && !a2.data) {
                  const r3 = this.getPatternInFlightId(s2, i2);
                  if (this.patternsInFlight.has(r3)) return null;
                  this.patternsInFlight.add(r3);
                  const n3 = new e.B(t2).scaleSelf(e.q.devicePixelRatio), l2 = /* @__PURE__ */ new Map([[n3.toString(), { image: a2, imageVariant: n3 }]]);
                  return this._rasterizeImages(i2, l2, (e2, t3) => this.storePatternImage(n3, i2, a2, o2, t3)), null;
                }
                this.storePattern(t2, i2, a2);
              }
              return this._updatePatternAtlas(i2, o2), r2.get(s2).position;
            }
            getPatternInFlightId(t2, i2) {
              return e.C(t2, i2);
            }
            hasPatternsInFlight() {
              return 0 !== this.patternsInFlight.size;
            }
            storePatternImage(e2, t2, i2, o2, s2) {
              const r2 = e2.toString(), n2 = s2 ? s2.get(r2) : void 0;
              n2 && (i2.data = n2, this.storePattern(e2.id, t2, i2), this._updatePatternAtlas(t2, o2), this.patternsInFlight.delete(this.getPatternInFlightId(e2.id.toString(), t2)));
            }
            storePattern(t2, i2, o2) {
              const s2 = { w: o2.data.width + 2 * e.F, h: o2.data.height + 2 * e.F, x: 0, y: 0 }, r2 = new e.G(s2, o2, e.F);
              this.patterns.get(i2).set(t2.toString(), { bin: s2, position: r2 });
            }
            bind(t2, i2) {
              const o2 = t2.gl;
              let s2 = this.atlasTexture.get(i2);
              s2 ? this.dirty && (s2.update(this.atlasImage.get(i2)), this.dirty = false) : (s2 = new e.T(t2, this.atlasImage.get(i2), o2.RGBA8), this.atlasTexture.set(i2, s2)), s2.bind(o2.LINEAR, o2.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas(t2, i2) {
              const o2 = this.patterns.get(t2), s2 = Array.from(o2.values()).map(({ bin: e2 }) => e2), { w: r2, h: n2 } = e.H(s2), a2 = this.atlasImage.get(t2);
              a2.resize({ width: r2 || 1, height: n2 || 1 });
              const l2 = this.images.get(t2);
              for (const [t3, { bin: s3, position: r3 }] of o2.entries()) {
                let o3 = r3.padding;
                const n3 = s3.x + o3, c2 = s3.y + o3, h2 = l2.get(t3).data, d2 = h2.width, u5 = h2.height;
                o3 = o3 > 1 ? o3 - 1 : o3, e.r.copy(h2, a2, { x: 0, y: 0 }, { x: n3, y: c2 }, { width: d2, height: u5 }, i2), e.r.copy(h2, a2, { x: 0, y: u5 - o3 }, { x: n3, y: c2 - o3 }, { width: d2, height: o3 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: n3, y: c2 + u5 }, { width: d2, height: o3 }, i2), e.r.copy(h2, a2, { x: d2 - o3, y: 0 }, { x: n3 - o3, y: c2 }, { width: o3, height: u5 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: n3 + d2, y: c2 }, { width: o3, height: u5 }, i2), e.r.copy(h2, a2, { x: d2 - o3, y: u5 - o3 }, { x: n3 - o3, y: c2 - o3 }, { width: o3, height: o3 }, i2), e.r.copy(h2, a2, { x: 0, y: u5 - o3 }, { x: n3 + d2, y: c2 - o3 }, { width: o3, height: o3 }, i2), e.r.copy(h2, a2, { x: 0, y: 0 }, { x: n3 + d2, y: c2 + u5 }, { width: o3, height: o3 }, i2), e.r.copy(h2, a2, { x: d2 - o3, y: 0 }, { x: n3 - o3, y: c2 + u5 }, { width: o3, height: o3 }, i2);
              }
              this.dirty = true;
            }
            beginFrame() {
              for (const e2 of this.images.keys()) this.callbackDispatchedThisFrame.set(e2, /* @__PURE__ */ new Set());
            }
            dispatchRenderCallbacks(e2, t2) {
              const i2 = this.images.get(t2);
              for (const o2 of e2) {
                if (this.callbackDispatchedThisFrame.get(t2).has(o2.toString())) continue;
                this.callbackDispatchedThisFrame.get(t2).add(o2.toString());
                const e3 = i2.get(o2.toString());
                G(e3) && this.updateImage(o2, t2, e3);
              }
            }
          }
          function Z(t2) {
            const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec || {}, r2 = t2.objectElementValidators || {}, n2 = t2.style, a2 = t2.styleSpec;
            let l2 = [];
            const c2 = e.K(o2);
            if ("object" !== c2) return [new e.V(i2, o2, `object expected, ${c2} found`)];
            for (const t3 in o2) {
              const c3 = t3.split(".")[0];
              let h2;
              r2[c3] ? h2 = r2[c3] : s2[c3] ? h2 = _e : r2["*"] ? h2 = r2["*"] : s2["*"] && (h2 = _e), h2 ? l2 = l2.concat(h2({ key: (i2 ? `${i2}.` : i2) + t3, value: o2[t3], valueSpec: s2[c3] || s2["*"], style: n2, styleSpec: a2, object: o2, objectKey: t3 }, o2)) : l2.push(new e.J(i2, o2[t3], `unknown property "${t3}"`));
            }
            for (const t3 in s2) r2[t3] || s2[t3].required && void 0 === s2[t3].default && void 0 === o2[t3] && l2.push(new e.V(i2, o2, `missing required property "${t3}"`));
            return l2;
          }
          function H(t2) {
            const i2 = t2.value, o2 = t2.valueSpec, s2 = t2.style, r2 = t2.styleSpec, n2 = t2.key, a2 = t2.arrayElementValidator || _e;
            if ("array" !== e.K(i2)) return [new e.V(n2, i2, `array expected, ${e.K(i2)} found`)];
            if (o2.length && i2.length !== o2.length) return [new e.V(n2, i2, `array length ${o2.length} expected, length ${i2.length} found`)];
            if (o2["min-length"] && i2.length < o2["min-length"]) return [new e.V(n2, i2, `array length at least ${o2["min-length"]} expected, length ${i2.length} found`)];
            let l2 = { type: o2.value, values: o2.values, minimum: o2.minimum, maximum: o2.maximum, function: void 0 };
            r2.$version < 7 && (l2.function = o2.function), "object" === e.K(o2.value) && (l2 = o2.value);
            let c2 = [];
            for (let e2 = 0; e2 < i2.length; e2++) c2 = c2.concat(a2({ array: i2, arrayIndex: e2, value: i2[e2], valueSpec: l2, style: s2, styleSpec: r2, key: `${n2}[${e2}]` }, true));
            return c2;
          }
          function W(t2) {
            const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec;
            let r2 = e.K(o2);
            if ("number" === r2 && o2 != o2 && (r2 = "NaN"), "number" !== r2) return [new e.V(i2, o2, `number expected, ${r2} found`)];
            if ("minimum" in s2) {
              let r3 = s2.minimum;
              if ("array" === e.K(s2.minimum) && (r3 = s2.minimum[t2.arrayIndex]), o2 < r3) return [new e.V(i2, o2, `${o2} is less than the minimum value ${r3}`)];
            }
            if ("maximum" in s2) {
              let r3 = s2.maximum;
              if ("array" === e.K(s2.maximum) && (r3 = s2.maximum[t2.arrayIndex]), o2 > r3) return [new e.V(i2, o2, `${o2} is greater than the maximum value ${r3}`)];
            }
            return [];
          }
          function $(t2) {
            const i2 = t2.valueSpec, o2 = e.M(t2.value.type);
            let s2, r2, n2, a2 = {};
            const l2 = "categorical" !== o2 && void 0 === t2.value.property, c2 = !l2, h2 = "array" === e.K(t2.value.stops) && "array" === e.K(t2.value.stops[0]) && "object" === e.K(t2.value.stops[0][0]), d2 = Z({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === o2) return [new e.V(t3.key, t3.value, 'identity function may not have a "stops" property')];
              let i3 = [];
              const s3 = t3.value;
              return i3 = i3.concat(H({ key: t3.key, value: s3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: u5 })), "array" === e.K(s3) && 0 === s3.length && i3.push(new e.V(t3.key, s3, "array must have at least one stop")), i3;
            }, default: function(e2) {
              return _e({ key: e2.key, value: e2.value, valueSpec: i2, style: e2.style, styleSpec: e2.styleSpec });
            } } });
            return "identity" === o2 && l2 && d2.push(new e.V(t2.key, t2.value, 'missing required property "property"')), "identity" === o2 || t2.value.stops || d2.push(new e.V(t2.key, t2.value, 'missing required property "stops"')), "exponential" === o2 && t2.valueSpec.expression && !e.N(t2.valueSpec) && d2.push(new e.V(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (c2 && !e.O(t2.valueSpec) ? d2.push(new e.V(t2.key, t2.value, "property functions not supported")) : l2 && !e.Q(t2.valueSpec) && d2.push(new e.V(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== o2 && !h2 || void 0 !== t2.value.property || d2.push(new e.V(t2.key, t2.value, '"property" property is required')), d2;
            function u5(t3) {
              let o3 = [];
              const s3 = t3.value, l3 = t3.key;
              if ("array" !== e.K(s3)) return [new e.V(l3, s3, `array expected, ${e.K(s3)} found`)];
              if (2 !== s3.length) return [new e.V(l3, s3, `array length 2 expected, length ${s3.length} found`)];
              if (h2) {
                if ("object" !== e.K(s3[0])) return [new e.V(l3, s3, `object expected, ${e.K(s3[0])} found`)];
                if (void 0 === s3[0].zoom) return [new e.V(l3, s3, "object stop key must have zoom")];
                if (void 0 === s3[0].value) return [new e.V(l3, s3, "object stop key must have value")];
                const i3 = e.M(s3[0].zoom);
                if ("number" != typeof i3) return [new e.V(l3, s3[0].zoom, "stop zoom values must be numbers")];
                if (n2 && n2 > i3) return [new e.V(l3, s3[0].zoom, "stop zoom values must appear in ascending order")];
                i3 !== n2 && (n2 = i3, r2 = void 0, a2 = {}), o3 = o3.concat(Z({ key: `${l3}[0]`, value: s3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: W, value: _2 } }));
              } else o3 = o3.concat(_2({ key: `${l3}[0]`, value: s3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, s3));
              return e.S(e.U(s3[1])) ? o3.concat([new e.V(`${l3}[1]`, s3[1], "expressions are not allowed in function stops.")]) : o3.concat(_e({ key: `${l3}[1]`, value: s3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function _2(t3, n3) {
              const l3 = e.K(t3.value), c3 = e.M(t3.value), h3 = null !== t3.value ? t3.value : n3;
              if (s2) {
                if (l3 !== s2) return [new e.V(t3.key, h3, `${l3} stop domain type must match previous stop domain type ${s2}`)];
              } else s2 = l3;
              if ("number" !== l3 && "string" !== l3 && "boolean" !== l3 && "number" != typeof c3 && "string" != typeof c3 && "boolean" != typeof c3) return [new e.V(t3.key, h3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== l3 && "categorical" !== o2) {
                let s3 = `number expected, ${l3} found`;
                return e.O(i2) && void 0 === o2 && (s3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new e.V(t3.key, h3, s3)];
              }
              return "categorical" !== o2 || "number" !== l3 || "number" == typeof c3 && isFinite(c3) && Math.floor(c3) === c3 ? "categorical" !== o2 && "number" === l3 && "number" == typeof c3 && "number" == typeof r2 && void 0 !== r2 && c3 < r2 ? [new e.V(t3.key, h3, "stop domain values must appear in ascending order")] : (r2 = c3, "categorical" === o2 && c3 in a2 ? [new e.V(t3.key, h3, "stop domain values must be unique")] : (a2[c3] = true, [])) : [new e.V(t3.key, h3, `integer expected, found ${String(c3)}`)];
            }
          }
          function X(t2) {
            const i2 = ("property" === t2.expressionContext ? e.W : e.X)(e.U(t2.value), t2.valueSpec);
            if ("error" === i2.result) return i2.value.map((i3) => new e.V(`${t2.key}${i3.key}`, t2.value, i3.message));
            const o2 = i2.value.expression || i2.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !o2.outputDefined()) return [new e.V(t2.key, t2.value, `Invalid data expression for "${t2.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !e.Y(o2)) return [new e.V(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext) return Y(o2, t2);
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!e.Z(o2, ["zoom", "feature-state"])) return [new e.V(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !e._(o2)) return [new e.V(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function Y(t2, i2) {
            const o2 = /* @__PURE__ */ new Set(["zoom", "feature-state", "pitch", "distance-from-center"]);
            if (i2.valueSpec && i2.valueSpec.expression) for (const e2 of i2.valueSpec.expression.parameters) o2.delete(e2);
            if (0 === o2.size) return [];
            const s2 = [];
            return t2 instanceof e.$ && o2.has(t2.name) ? [new e.V(i2.key, i2.value, `["${t2.name}"] expression is not supported in a filter for a ${i2.object.type} layer with id: ${i2.object.id}`)] : (t2.eachChild((e2) => {
              s2.push(...Y(e2, i2));
            }), s2);
          }
          function K(t2) {
            const i2 = t2.key, o2 = t2.value, s2 = t2.valueSpec, r2 = [];
            return Array.isArray(s2.values) ? -1 === s2.values.indexOf(e.M(o2)) && r2.push(new e.V(i2, o2, `expected one of [${s2.values.join(", ")}], ${JSON.stringify(o2)} found`)) : -1 === Object.keys(s2.values).indexOf(e.M(o2)) && r2.push(new e.V(i2, o2, `expected one of [${Object.keys(s2.values).join(", ")}], ${JSON.stringify(o2)} found`)), r2;
          }
          function J(t2) {
            return e.a1(e.U(t2.value)) ? X(e.L({}, t2, { expressionContext: "filter", valueSpec: t2.styleSpec[`filter_${t2.layerType || "fill"}`] })) : Q(t2);
          }
          function Q(t2) {
            const i2 = t2.value, o2 = t2.key;
            if ("array" !== e.K(i2)) return [new e.V(o2, i2, `array expected, ${e.K(i2)} found`)];
            const s2 = t2.styleSpec;
            let r2, n2 = [];
            if (i2.length < 1) return [new e.V(o2, i2, "filter array must have at least 1 element")];
            switch (n2 = n2.concat(K({ key: `${o2}[0]`, value: i2[0], valueSpec: s2.filter_operator, style: t2.style, styleSpec: t2.styleSpec })), e.M(i2[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                i2.length >= 2 && "$type" === e.M(i2[1]) && n2.push(new e.V(o2, i2, `"$type" cannot be use with operator "${i2[0]}"`));
              case "==":
              case "!=":
                3 !== i2.length && n2.push(new e.V(o2, i2, `filter array for operator "${i2[0]}" must have 3 elements`));
              case "in":
              case "!in":
                i2.length >= 2 && (r2 = e.K(i2[1]), "string" !== r2 && n2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${r2} found`)));
                for (let a2 = 2; a2 < i2.length; a2++) r2 = e.K(i2[a2]), "$type" === e.M(i2[1]) ? n2 = n2.concat(K({ key: `${o2}[${a2}]`, value: i2[a2], valueSpec: s2.geometry_type, style: t2.style, styleSpec: t2.styleSpec })) : "string" !== r2 && "number" !== r2 && "boolean" !== r2 && n2.push(new e.V(`${o2}[${a2}]`, i2[a2], `string, number, or boolean expected, ${r2} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let e2 = 1; e2 < i2.length; e2++) n2 = n2.concat(Q({ key: `${o2}[${e2}]`, value: i2[e2], style: t2.style, styleSpec: t2.styleSpec }));
                break;
              case "has":
              case "!has":
                r2 = e.K(i2[1]), 2 !== i2.length ? n2.push(new e.V(o2, i2, `filter array for "${i2[0]}" operator must have 2 elements`)) : "string" !== r2 && n2.push(new e.V(`${o2}[1]`, i2[1], `string expected, ${r2} found`));
            }
            return n2;
          }
          function ee(t2, i2) {
            const o2 = t2.key, s2 = t2.style, r2 = t2.layer, n2 = t2.styleSpec, a2 = t2.value, l2 = t2.objectKey, c2 = n2[`${i2}_${t2.layerType}`];
            if (!c2) return [];
            const h2 = l2.match(/^(.*)-use-theme$/);
            if ("paint" === i2 && h2 && c2[h2[1]]) return e.S(a2) ? [].concat(_e({ key: t2.key, value: a2, valueSpec: { type: "string", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, style: s2, styleSpec: n2, expressionContext: "property", propertyType: i2, propertyKey: l2 })) : _e({ key: o2, value: a2, valueSpec: { type: "string" }, style: s2, styleSpec: n2 });
            const d2 = l2.match(/^(.*)-transition$/);
            if ("paint" === i2 && d2 && c2[d2[1]] && c2[d2[1]].transition) return _e({ key: o2, value: a2, valueSpec: n2.transition, style: s2, styleSpec: n2 });
            const u5 = t2.valueSpec || c2[l2];
            if (!u5) return [new e.J(o2, a2, `unknown property "${l2}"`)];
            let _2;
            if ("string" === e.K(a2) && e.O(u5) && !u5.tokens && (_2 = /^{([^}]+)}$/.exec(a2))) {
              const t3 = `\`{ "type": "identity", "property": ${_2 ? JSON.stringify(_2[1]) : '"_"'} }\``;
              return [new e.V(o2, a2, `"${l2}" does not support interpolation syntax
Use an identity property function instead: ${t3}.`)];
            }
            const p2 = [];
            if ("symbol" === t2.layerType) "text-field" !== l2 || !s2 || s2.glyphs || s2.imports || p2.push(new e.V(o2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === l2 && e.a2(e.U(a2)) && "identity" === e.M(a2.type) && p2.push(new e.V(o2, a2, '"text-font" does not support identity functions'));
            else if ("model" === t2.layerType && "paint" === i2 && r2 && r2.layout && r2.layout.hasOwnProperty("model-id") && e.O(u5) && (e.a3(u5) || e.Q(u5))) {
              const t3 = e.W(e.U(a2), u5), i3 = t3.value.expression || t3.value._styleExpression.expression;
              i3 && !e.Z(i3, ["measure-light"]) && ("model-emissive-strength" === l2 && e._(i3) && e.Y(i3) || p2.push(new e.V(o2, a2, `${l2} does not support measure-light expressions when the model layer source is vector tile or GeoJSON.`)));
            }
            return p2.concat(_e({ key: t2.key, value: a2, valueSpec: u5, style: s2, styleSpec: n2, expressionContext: "property", propertyType: i2, propertyKey: l2 }));
          }
          function te(e2) {
            return ee(e2, "paint");
          }
          function ie(e2) {
            return ee(e2, "layout");
          }
          function oe(t2) {
            let i2 = [];
            const o2 = t2.value, s2 = t2.key, r2 = t2.style, n2 = t2.styleSpec;
            o2.type || o2.ref || i2.push(new e.V(s2, o2, 'either "type" or "ref" is required'));
            let a2 = e.M(o2.type);
            const l2 = e.M(o2.ref);
            if (o2.id) {
              const n3 = e.M(o2.id);
              for (let a3 = 0; a3 < t2.arrayIndex; a3++) {
                const t3 = r2.layers[a3];
                e.M(t3.id) === n3 && i2.push(new e.V(s2, o2.id, `duplicate layer id "${o2.id}", previously used at line ${t3.id.__line__}`));
              }
            }
            if ("ref" in o2) {
              let t3;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t4) => {
                t4 in o2 && i2.push(new e.V(s2, o2[t4], `"${t4}" is prohibited for ref layers`));
              }), r2.layers.forEach((i3) => {
                e.M(i3.id) === l2 && (t3 = i3);
              }), t3 ? t3.ref ? i2.push(new e.V(s2, o2.ref, "ref cannot reference another ref layer")) : a2 = e.M(t3.type) : "string" == typeof l2 && i2.push(new e.V(s2, o2.ref, `ref layer "${l2}" not found`));
            } else if ("background" !== a2 && "sky" !== a2 && "slot" !== a2) if (o2.source) {
              const t3 = r2.sources && r2.sources[o2.source], n3 = t3 && e.M(t3.type);
              t3 ? "vector" === n3 && "raster" === a2 ? i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a raster source`)) : "raster" === n3 && "raster" !== a2 ? i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a vector source`)) : "vector" !== n3 || o2["source-layer"] ? "raster-dem" === n3 && "hillshade" !== a2 ? i2.push(new e.V(s2, o2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "raster-array" !== n3 || ["raster", "raster-particle"].includes(a2) ? "line" === a2 && o2.paint && (o2.paint["line-gradient"] || o2.paint["line-trim-offset"]) && "geojson" === n3 && !t3.lineMetrics ? i2.push(new e.V(s2, o2, `layer "${o2.id}" specifies a line-gradient, which requires the GeoJSON source to have \`lineMetrics\` enabled.`)) : "raster-particle" === a2 && "raster-array" !== n3 && i2.push(new e.V(s2, o2.source, `layer "${o2.id}" requires a 'raster-array' source.`)) : i2.push(new e.V(s2, o2.source, "raster-array source can only be used with layer type 'raster'.")) : i2.push(new e.V(s2, o2, `layer "${o2.id}" must specify a "source-layer"`)) : i2.push(new e.V(s2, o2.source, `source "${o2.source}" not found`));
            } else i2.push(new e.V(s2, o2, 'missing required property "source"'));
            return i2 = i2.concat(Z({ key: s2, value: o2, valueSpec: n2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": () => [], type: () => _e({ key: `${s2}.type`, value: o2.type, valueSpec: n2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: o2, objectKey: "type" }), filter: (t3) => J(e.L({ layerType: a2 }, t3)), layout: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => ie(e.L({ layerType: a2 }, t4)) } }), paint: (t3) => Z({ layer: o2, key: t3.key, value: t3.value, valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": (t4) => te(e.L({ layerType: a2, layer: o2 }, t4)) } }) } })), i2;
          }
          function se(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = e.K(i2);
            return "string" !== s2 ? [new e.V(o2, i2, `string expected, ${s2} found`)] : [];
          }
          const re = { promoteId: function t2({ key: i2, value: o2 }) {
            if ("string" === e.K(o2)) return se({ key: i2, value: o2 });
            if (Array.isArray(o2)) {
              const t3 = [], s2 = e.U(o2), r2 = e.X(s2);
              return "error" === r2.result && r2.value.forEach((o3) => {
                t3.push(new e.V(`${i2}${o3.key}`, null, `${o3.message}`));
              }), e.Z(r2.value.expression, ["zoom", "heatmap-density", "line-progress", "raster-value", "sky-radial-progress", "accumulated", "is-supported-script", "pitch", "distance-from-center", "measure-light", "raster-particle-speed"]) || t3.push(new e.V(`${i2}`, null, "promoteId expression should be only feature dependent")), t3;
            }
            {
              const e2 = [];
              for (const s2 in o2) e2.push(...t2({ key: `${i2}.${s2}`, value: o2[s2] }));
              return e2;
            }
          } };
          function ne(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = t2.styleSpec, r2 = t2.style;
            if (!i2.type) return [new e.V(o2, i2, '"type" is required')];
            const n2 = e.M(i2.type);
            let a2 = [];
            switch (["vector", "raster", "raster-dem", "raster-array"].includes(n2) && (i2.url || i2.tiles || a2.push(new e.J(o2, i2, 'Either "url" or "tiles" is required.'))), n2) {
              case "vector":
              case "raster":
              case "raster-dem":
              case "raster-array":
                return a2 = a2.concat(Z({ key: o2, value: i2, valueSpec: s2[`source_${n2.replace("-", "_")}`], style: t2.style, styleSpec: s2, objectElementValidators: re })), a2;
              case "geojson":
                if (a2 = Z({ key: o2, value: i2, valueSpec: s2.source_geojson, style: r2, styleSpec: s2, objectElementValidators: re }), i2.cluster) for (const e2 in i2.clusterProperties) {
                  const [t3, s3] = i2.clusterProperties[e2], r3 = "string" == typeof t3 ? [t3, ["accumulated"], ["get", e2]] : t3;
                  a2.push(...X({ key: `${o2}.${e2}.map`, value: s3, expressionContext: "cluster-map" })), a2.push(...X({ key: `${o2}.${e2}.reduce`, value: r3, expressionContext: "cluster-reduce" }));
                }
                return a2;
              case "video":
                return Z({ key: o2, value: i2, valueSpec: s2.source_video, style: r2, styleSpec: s2 });
              case "image":
                return Z({ key: o2, value: i2, valueSpec: s2.source_image, style: r2, styleSpec: s2 });
              case "canvas":
                return [new e.V(o2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return K({ key: `${o2}.type`, value: i2.type, valueSpec: { values: ae(s2) }, style: r2, styleSpec: s2 });
            }
          }
          function ae(e2) {
            return e2.source.reduce((t2, i2) => {
              const o2 = e2[i2];
              return "enum" === o2.type.type && (t2 = t2.concat(Object.keys(o2.type.values))), t2;
            }, []);
          }
          function le(t2) {
            const i2 = t2.value, o2 = t2.styleSpec, s2 = o2.light, r2 = t2.style;
            let n2 = [];
            const a2 = e.K(i2);
            if (void 0 === i2) return n2;
            if ("object" !== a2) return n2 = n2.concat([new e.V("light", i2, `object expected, ${a2} found`)]), n2;
            for (const t3 in i2) {
              const a3 = t3.match(/^(.*)-transition$/), l2 = t3.match(/^(.*)-use-theme$/);
              n2 = n2.concat(l2 && s2[l2[1]] ? _e({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: r2, styleSpec: o2 }) : a3 && s2[a3[1]] && s2[a3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: o2.transition, style: r2, styleSpec: o2 }) : s2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: s2[t3], style: r2, styleSpec: o2 }) : [new e.V(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            return n2;
          }
          function ce2(t2) {
            const i2 = t2.value;
            let o2 = [];
            if (!i2) return o2;
            const s2 = e.K(i2);
            if ("object" !== s2) return o2 = o2.concat([new e.V("light-3d", i2, `object expected, ${s2} found`)]), o2;
            const r2 = t2.styleSpec, n2 = r2["light-3d"], a2 = t2.key, l2 = t2.style, c2 = t2.style.lights;
            for (const t3 of ["type", "id"]) if (!(t3 in i2)) return o2 = o2.concat([new e.V("light-3d", i2, `missing property ${t3} on light`)]), o2;
            if (i2.type && c2) for (let s3 = 0; s3 < t2.arrayIndex; s3++) {
              const t3 = e.M(i2.type), r3 = c2[s3];
              e.M(r3.type) === t3 && o2.push(new e.V(a2, i2.id, `duplicate light type "${i2.type}", previously defined at line ${r3.id.__line__}`));
            }
            const h2 = `properties_light_${i2.type}`;
            if (!(h2 in r2)) return o2 = o2.concat([new e.V("light-3d", i2, `Invalid light type ${i2.type}`)]), o2;
            const d2 = r2[h2];
            for (const s3 in i2) if ("properties" === s3) {
              const n3 = i2[s3], a3 = e.K(n3);
              if ("object" !== a3) return o2 = o2.concat([new e.V("properties", n3, `object expected, ${a3} found`)]), o2;
              for (const i3 in n3) o2 = o2.concat(d2[i3] ? _e({ key: i3, value: n3[i3], valueSpec: d2[i3], style: l2, styleSpec: r2 }) : [new e.J(t2.key, n3[i3], `unknown property "${i3}"`)]);
            } else {
              const t3 = s3.match(/^(.*)-transition$/), a3 = s3.match(/^(.*)-use-theme$/);
              o2 = o2.concat(a3 && n2[a3[1]] ? _e({ key: s3, value: i2[s3], valueSpec: { type: "string" }, style: l2, styleSpec: r2 }) : t3 && n2[t3[1]] && n2[t3[1]].transition ? _e({ key: s3, value: i2[s3], valueSpec: r2.transition, style: l2, styleSpec: r2 }) : n2[s3] ? _e({ key: s3, value: i2[s3], valueSpec: n2[s3], style: l2, styleSpec: r2 }) : [new e.J(s3, i2[s3], `unknown property "${s3}"`)]);
            }
            return o2;
          }
          function he(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = t2.style, r2 = t2.styleSpec, n2 = r2.terrain;
            let a2 = [];
            const l2 = e.K(i2);
            if (void 0 === i2) return a2;
            if ("null" === l2) return a2;
            if ("object" !== l2) return a2 = a2.concat([new e.V("terrain", i2, `object expected, ${l2} found`)]), a2;
            for (const t3 in i2) {
              const o3 = t3.match(/^(.*)-transition$/), l3 = t3.match(/^(.*)-use-theme$/);
              a2 = a2.concat(l3 && n2[l3[1]] ? _e({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: s2, styleSpec: r2 }) : o3 && n2[o3[1]] && n2[o3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: r2.transition, style: s2, styleSpec: r2 }) : n2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: n2[t3], style: s2, styleSpec: r2 }) : [new e.J(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            if (i2.source) {
              const t3 = s2.sources && s2.sources[i2.source], r3 = t3 && e.M(t3.type);
              t3 ? "raster-dem" !== r3 && a2.push(new e.V(o2, i2.source, `terrain cannot be used with a source of type ${String(r3)}, it only be used with a "raster-dem" source type`)) : a2.push(new e.V(o2, i2.source, `source "${i2.source}" not found`));
            } else a2.push(new e.V(o2, i2, 'terrain is missing required property "source"'));
            return a2;
          }
          function de2(t2) {
            const i2 = t2.value, o2 = t2.style, s2 = t2.styleSpec, r2 = s2.fog;
            let n2 = [];
            const a2 = e.K(i2);
            if (void 0 === i2) return n2;
            if ("object" !== a2) return n2 = n2.concat([new e.V("fog", i2, `object expected, ${a2} found`)]), n2;
            for (const t3 in i2) {
              const a3 = t3.match(/^(.*)-transition$/), l2 = t3.match(/^(.*)-use-theme$/);
              n2 = n2.concat(l2 && r2[l2[1]] ? _e({ key: t3, value: i2[t3], valueSpec: { type: "string" }, style: o2, styleSpec: s2 }) : a3 && r2[a3[1]] && r2[a3[1]].transition ? _e({ key: t3, value: i2[t3], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t3] ? _e({ key: t3, value: i2[t3], valueSpec: r2[t3], style: o2, styleSpec: s2 }) : [new e.J(t3, i2[t3], `unknown property "${t3}"`)]);
            }
            return n2;
          }
          const ue = { "*": () => [], array: H, boolean: function(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = e.K(i2);
            return "boolean" !== s2 ? [new e.V(o2, i2, `boolean expected, ${s2} found`)] : [];
          }, number: W, color: function(t2) {
            const i2 = t2.key, o2 = t2.value, s2 = e.K(o2);
            return "string" !== s2 ? [new e.V(i2, o2, `color expected, ${s2} found`)] : null === e.a0.parseCSSColor(o2) ? [new e.V(i2, o2, `color expected, "${o2}" found`)] : [];
          }, enum: K, filter: J, function: $, layer: oe, object: Z, source: ne, model: e.a4, light: le, "light-3d": ce2, terrain: he, fog: de2, string: se, formatted: function(e2) {
            return 0 === se(e2).length ? [] : X(e2);
          }, resolvedImage: function(e2) {
            return 0 === se(e2).length ? [] : X(e2);
          }, projection: function(t2) {
            const i2 = t2.value, o2 = t2.styleSpec, s2 = o2.projection, r2 = t2.style;
            let n2 = [];
            const a2 = e.K(i2);
            if ("object" === a2) for (const e2 in i2) n2 = n2.concat(_e({ key: e2, value: i2[e2], valueSpec: s2[e2], style: r2, styleSpec: o2 }));
            else "string" !== a2 && (n2 = n2.concat([new e.V("projection", i2, `object or string expected, ${a2} found`)]));
            return n2;
          }, import: function(t2) {
            const { value: i2, styleSpec: o2 } = t2, { data: s2, ...r2 } = i2;
            Object.defineProperty(r2, "__line__", { value: i2.__line__, enumerable: false });
            let n2 = Z(e.L({}, t2, { value: r2, valueSpec: o2.import }));
            return "" === e.M(r2.id) && n2.push(new e.V(`${t2.key}.id`, r2, "import id can't be an empty string")), s2 && (n2 = n2.concat(fe(s2, o2, { key: `${t2.key}.data` }))), n2;
          }, iconset: function(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = t2.styleSpec, r2 = t2.style;
            if (!i2.type) return [new e.V(o2, i2, '"type" is required')];
            const n2 = e.M(i2.type);
            let a2 = [];
            if (a2 = a2.concat(Z({ key: o2, value: i2, valueSpec: s2[`iconset_${n2}`], style: r2, styleSpec: s2 })), "source" === n2 && i2.source) {
              const t3 = r2.sources && r2.sources[i2.source], s3 = t3 && e.M(t3.type);
              t3 ? "raster-array" !== s3 && a2.push(new e.V(o2, i2.source, `iconset cannot be used with a source of type ${String(s3)}, it only be used with a "raster-array" source type`)) : a2.push(new e.V(o2, i2.source, `source "${i2.source}" not found`));
            }
            return a2;
          } };
          function _e(t2, i2 = false) {
            const o2 = t2.value, s2 = t2.valueSpec, r2 = t2.styleSpec;
            if (s2.expression && e.a2(e.M(o2))) return $(t2);
            if (s2.expression && e.S(e.U(o2))) return X(t2);
            if (s2.type && ue[s2.type]) {
              const o3 = ue[s2.type](t2);
              return true === i2 && o3.length > 0 && "array" === e.K(t2.value) ? X(t2) : o3;
            }
            return Z(e.L({}, t2, { valueSpec: s2.type ? r2[s2.type] : s2 }));
          }
          function pe(t2) {
            const i2 = t2.value, o2 = t2.key, s2 = se(t2);
            return s2.length || (-1 === i2.indexOf("{fontstack}") && s2.push(new e.V(o2, i2, '"glyphs" url must include a "{fontstack}" token')), -1 === i2.indexOf("{range}") && s2.push(new e.V(o2, i2, '"glyphs" url must include a "{range}" token'))), s2;
          }
          function fe(t2, i2 = e.a5, o2 = {}) {
            return _e({ key: o2.key || "", value: t2, valueSpec: i2.$root, styleSpec: i2, style: t2, objectElementValidators: { glyphs: pe, "*": () => [] } });
          }
          function me(t2, i2 = e.a5) {
            return De(fe(t2, i2));
          }
          const ge = (e2) => De(ne(e2)), ve = (e2) => De(le(e2)), ye = (e2) => De(ce2(e2)), xe = (e2) => De(he(e2)), be = (e2) => De(de2(e2)), we = (t2) => De(function(t3) {
            const i2 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r2 = s2.snow;
            let n2 = [];
            const a2 = e.K(i2);
            if (void 0 === i2) return n2;
            if ("object" !== a2) return n2 = n2.concat([new e.V("snow", i2, `object expected, ${a2} found`)]), n2;
            for (const t4 in i2) {
              const a3 = t4.match(/^(.*)-transition$/);
              n2 = n2.concat(a3 && r2[a3[1]] && r2[a3[1]].transition ? _e({ key: t4, value: i2[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t4] ? _e({ key: t4, value: i2[t4], valueSpec: r2[t4], style: o2, styleSpec: s2 }) : [new e.J(t4, i2[t4], `unknown property "${t4}"`)]);
            }
            return n2;
          }(t2)), Te = (t2) => De(function(t3) {
            const i2 = t3.value, o2 = t3.style, s2 = t3.styleSpec, r2 = s2.rain;
            let n2 = [];
            const a2 = e.K(i2);
            if (void 0 === i2) return n2;
            if ("object" !== a2) return n2 = n2.concat([new e.V("rain", i2, `object expected, ${a2} found`)]), n2;
            for (const t4 in i2) {
              const a3 = t4.match(/^(.*)-transition$/);
              n2 = n2.concat(a3 && r2[a3[1]] && r2[a3[1]].transition ? _e({ key: t4, value: i2[t4], valueSpec: s2.transition, style: o2, styleSpec: s2 }) : r2[t4] ? _e({ key: t4, value: i2[t4], valueSpec: r2[t4], style: o2, styleSpec: s2 }) : [new e.J(t4, i2[t4], `unknown property "${t4}"`)]);
            }
            return n2;
          }(t2)), Ee = (e2) => De(oe(e2)), Se = (e2) => De(J(e2)), Ie = (e2) => De(te(e2)), Ce = (e2) => De(ie(e2)), Re = (t2) => De(e.a4(t2));
          function De(e2) {
            return e2.slice().sort((e3, t2) => e3.line && t2.line ? e3.line - t2.line : 0);
          }
          function Ae(t2, i2) {
            let o2 = false;
            if (i2 && i2.length) for (const s2 of i2) s2 instanceof e.J ? e.w(s2.message) : (t2.fire(new e.z(new Error(s2.message))), o2 = true);
            return o2;
          }
          let Le;
          class Pe extends e.E {
            constructor(t2, i2 = "flat") {
              super(), this._transitionable = new e.a6(Le || (Le = new e.a7({ anchor: new e.a8(e.a5.light.anchor), position: new e.a9(e.a5.light.position), color: new e.a8(e.a5.light.color), intensity: new e.a8(e.a5.light.intensity) }))), this.setLight(t2, i2), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e2, t2, i2 = {}) {
              this._validate(ve, e2, i2) || (this._transitionable.setTransitionOrValue(e2), this.id = t2);
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && Ae(this, t2.call(me, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a5 })));
            }
          }
          let ze = class extends e.E {
            constructor(t2, i2, o2, s2) {
              super(), this.scope = o2, this._transitionable = new e.a6(new e.a7({ source: new e.a8(e.a5.terrain.source), exaggeration: new e.a8(e.a5.terrain.exaggeration) }), o2, s2), this._transitionable.setTransitionOrValue(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.drapeRenderMode = i2;
            }
            get() {
              return this._transitionable.serialize();
            }
            set(e2, t2) {
              this._transitionable.setTransitionOrValue(e2, t2);
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            getExaggeration(t2) {
              return this._transitioning.possiblyEvaluate(new e.aa(t2)).get("exaggeration");
            }
            getAttenuationRange() {
              if (!this.isZoomDependent()) return null;
              const t2 = this._transitionable._values.exaggeration;
              if (!t2) return null;
              const i2 = t2.value.expression;
              if (!i2) return null;
              let o2 = -1, s2 = -1, r2 = 1;
              for (const t3 of i2.zoomStops) r2 = i2.evaluate(new e.aa(t3)), r2 > 0.01 ? (o2 = t3, s2 = -1) : s2 = t3;
              return r2 < 0.01 && o2 > 0 && s2 > o2 ? [o2, s2] : null;
            }
            isZoomDependent() {
              const t2 = this._transitionable._values.exaggeration;
              return null != t2 && null != t2.value && null != t2.value.expression && t2.value.expression instanceof e.ab;
            }
          };
          const Me = 45, Oe = 65, Fe = 0.05;
          function Be(t2, i2, o2, s2) {
            const r2 = e.af(Me, Oe, o2), [n2, a2] = ke(t2, s2);
            let l2 = 1 - Math.min(1, Math.exp((i2 - n2) / (a2 - n2) * -6));
            return l2 *= l2 * l2, l2 = Math.min(1, 1.00747 * l2), l2 * r2 * t2.alpha;
          }
          function ke(e2, t2) {
            const i2 = 0.5 / Math.tan(0.5 * t2);
            return [e2.range[0] + i2, e2.range[1] + i2];
          }
          function Ne(t2, i2, o2, s2, r2) {
            const n2 = e.ad([], [i2, o2, s2], r2.mercatorFogMatrix);
            return Be(t2, e.ae(n2), r2.pitch, r2._fov);
          }
          function Ue(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = [[o2, s2, 0], [r2, s2, 0], [r2, n2, 0], [o2, n2, 0]];
            let c2 = Number.MAX_VALUE, h2 = -Number.MAX_VALUE;
            for (const t3 of l2) {
              const o3 = e.ad([], t3, i2), s3 = e.ae(o3);
              c2 = Math.min(c2, s3), h2 = Math.max(h2, s3);
            }
            return [Be(t2, c2, a2.pitch, a2._fov), Be(t2, h2, a2.pitch, a2._fov)];
          }
          class je extends e.E {
            constructor(t2, i2, o2, s2) {
              super();
              const r2 = new e.a7({ range: new e.a8(e.a5.fog.range), color: new e.a8(e.a5.fog.color), "color-use-theme": new e.a8({ type: "string", "property-type": "data-constant", default: "default" }), "high-color": new e.a8(e.a5.fog["high-color"]), "high-color-use-theme": new e.a8({ type: "string", "property-type": "data-constant", default: "default" }), "space-color": new e.a8(e.a5.fog["space-color"]), "space-color-use-theme": new e.a8({ type: "string", "property-type": "data-constant", default: "default" }), "horizon-blend": new e.a8(e.a5.fog["horizon-blend"]), "star-intensity": new e.a8(e.a5.fog["star-intensity"]), "vertical-range": new e.a8(e.a5.fog["vertical-range"]) });
              this._transitionable = new e.a6(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this._transform = i2, this.properties = new e.ag(r2), this.scope = o2;
            }
            get state() {
              const t2 = this._transform, i2 = "globe" === t2.projection.name, o2 = e.ah(t2.zoom), s2 = this.properties.get("range"), r2 = [0.5, 3];
              return { range: i2 ? [e.ai(r2[0], s2[0], o2), e.ai(r2[1], s2[1], o2)] : s2, horizonBlend: this.properties.get("horizon-blend"), alpha: this.properties.get("color").a };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2, i2, o2 = {}) {
              if (this._validate(be, t2, o2)) return;
              const s2 = e.l({}, t2);
              for (const t3 of Object.keys(e.a5.fog)) void 0 === s2[t3] && (s2[t3] = e.a5.fog[t3].default);
              this._options = s2, this._transitionable.setTransitionOrValue(this._options, i2);
            }
            getOpacity(t2) {
              if (!this._transform.projection.supportsFog) return 0;
              const i2 = this.properties && this.properties.get("color") || 1;
              return ("globe" === this._transform.projection.name ? 1 : e.af(Me, Oe, t2)) * i2.a;
            }
            getOpacityAtLatLng(t2, i2) {
              return this._transform.projection.supportsFog ? function(t3, i3, o2) {
                const s2 = e.ac.fromLngLat(i3), r2 = o2.elevation ? o2.elevation.getAtPointOrZero(s2) : 0;
                return Ne(t3, s2.x, s2.y, r2, o2);
              }(this.state, t2, i2) : 0;
            }
            getOpacityForTile(t2) {
              if (!this._transform.projection.supportsFog) return [1, 1];
              const i2 = this._transform.calculateFogTileMatrix(t2.toUnwrapped());
              return Ue(this.state, i2, 0, 0, e.aj, e.aj, this._transform);
            }
            getOpacityForBounds(e2, t2, i2, o2, s2) {
              return this._transform.projection.supportsFog ? Ue(this.state, e2, t2, i2, o2, s2, this._transform) : [1, 1];
            }
            getFovAdjustedRange(e2) {
              return this._transform.projection.supportsFog ? ke(this.state, e2) : [0, 1];
            }
            isVisibleOnFrustum(t2) {
              if (!this._transform.projection.supportsFog) return false;
              const i2 = [4, 5, 6, 7];
              for (const o2 of i2) {
                const i3 = t2.points[o2];
                let s2;
                if (i3[2] >= 0) s2 = i3;
                else {
                  const r2 = t2.points[o2 - 4];
                  s2 = e.ak(r2, i3, r2[2] / (r2[2] - i3[2]));
                }
                if (Ne(this.state, s2[0], s2[1], 0, this._transform) >= Fe) return true;
              }
              return false;
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && Ae(this, t2.call(me, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a5 })));
            }
          }
          let Ve, Ge, qe, Ze, He = class extends e.E {
            constructor(t2, i2, o2, s2) {
              super();
              const r2 = Ve || (Ve = new e.a7({ density: new e.a8(e.a5.snow.density), intensity: new e.a8(e.a5.snow.intensity), color: new e.a8(e.a5.snow.color), opacity: new e.a8(e.a5.snow.opacity), vignette: new e.a8(e.a5.snow.vignette), "vignette-color": new e.a8(e.a5.snow["vignette-color"]), "center-thinning": new e.a8(e.a5.snow["center-thinning"]), direction: new e.a8(e.a5.snow.direction), "flake-size": new e.a8(e.a5.snow["flake-size"]) }));
              this._transitionable = new e.a6(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ag(r2), this.scope = o2;
            }
            get state() {
              const t2 = this.properties.get("opacity"), i2 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e.al(o2[0]), r2 = -Math.max(e.al(o2[1]), 0.01), n2 = [Math.cos(s2) * Math.cos(r2), Math.sin(s2) * Math.cos(r2), Math.sin(r2)], a2 = this.properties.get("vignette"), l2 = this.properties.get("vignette-color");
              return l2.a = a2, { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e.am(i2.r, i2.g, i2.b, i2.a * t2), direction: n2, centerThinning: this.properties.get("center-thinning"), flakeSize: this.properties.get("flake-size"), vignetteColor: l2 };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2, i2, o2 = {}) {
              if (this._validate(we, t2, o2)) return;
              const s2 = e.l({}, t2);
              for (const t3 of Object.keys(e.a5.snow)) void 0 === s2[t3] && (s2[t3] = e.a5.snow[t3].default);
              this._options = s2, this._transitionable.setTransitionOrValue(this._options, i2);
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && Ae(this, t2.call(me, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a5 })));
            }
          }, We = class extends e.E {
            constructor(t2, i2, o2, s2) {
              super();
              const r2 = Ge || (Ge = new e.a7({ density: new e.a8(e.a5.rain.density), intensity: new e.a8(e.a5.rain.intensity), color: new e.a8(e.a5.rain.color), opacity: new e.a8(e.a5.rain.opacity), vignette: new e.a8(e.a5.rain.vignette), "vignette-color": new e.a8(e.a5.rain["vignette-color"]), "center-thinning": new e.a8(e.a5.rain["center-thinning"]), direction: new e.a8(e.a5.rain.direction), "droplet-size": new e.a8(e.a5.rain["droplet-size"]), "distortion-strength": new e.a8(e.a5.rain["distortion-strength"]) }));
              this._transitionable = new e.a6(r2, o2, new Map(s2)), this.set(t2, s2), this._transitioning = this._transitionable.untransitioned(), this.properties = new e.ag(r2), this.scope = o2;
            }
            get state() {
              const t2 = this.properties.get("opacity"), i2 = this.properties.get("color"), o2 = this.properties.get("direction"), s2 = e.al(o2[0]), r2 = -Math.max(e.al(o2[1]), 0.01), n2 = [Math.cos(s2) * Math.cos(r2), Math.sin(s2) * Math.cos(r2), Math.sin(r2)], a2 = this.properties.get("vignette-color");
              return a2.a = this.properties.get("vignette"), { density: this.properties.get("density"), intensity: this.properties.get("intensity"), color: new e.am(i2.r, i2.g, i2.b, i2.a * t2), direction: n2, centerThinning: this.properties.get("center-thinning"), dropletSize: this.properties.get("droplet-size"), distortionStrength: this.properties.get("distortion-strength"), vignetteColor: a2 };
            }
            get() {
              return this._transitionable.serialize();
            }
            set(t2, i2, o2 = {}) {
              if (this._validate(Te, t2, o2)) return;
              const s2 = e.l({}, t2);
              for (const t3 of Object.keys(e.a5.rain)) void 0 === s2[t3] && (s2[t3] = e.a5.rain[t3].default);
              this._options = s2, this._transitionable.setTransitionOrValue(this._options, i2);
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            _validate(t2, i2, o2) {
              return (!o2 || false !== o2.validate) && Ae(this, t2.call(me, e.l({ value: i2, style: { glyphs: true, sprite: true }, styleSpec: e.a5 })));
            }
          };
          class $e extends e.E {
            constructor(t2, i2, o2, s2) {
              super(), this.scope = o2, this._options = t2, this.properties = new e.ag(i2), this._transitionable = new e.a6(i2, o2, new Map(s2)), this._transitionable.setTransitionOrValue(t2.properties), this._transitioning = this._transitionable.untransitioned();
            }
            updateConfig(e2) {
              this._transitionable.setTransitionOrValue(this._options.properties, new Map(e2));
            }
            updateTransitions(e2) {
              this._transitioning = this._transitionable.transitioned(e2, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(e2) {
              this.properties = this._transitioning.possiblyEvaluate(e2);
            }
            get() {
              return this._options.properties = this._transitionable.serialize(), this._options;
            }
            set(e2, t2) {
              this._options = e2, this._transitionable.setTransitionOrValue(e2.properties, t2);
            }
            shadowsEnabled() {
              return !!this.properties && true === this.properties.get("cast-shadows");
            }
          }
          class Xe {
            constructor(e2, t2, i2, o2) {
              this.screenBounds = e2, this.cameraPoint = t2, this._screenRaycastCache = {}, this._cameraRaycastCache = {}, this.isAboveHorizon = i2, this.screenGeometry = this.bufferedScreenGeometry(0), this.screenGeometryMercator = this._bufferedScreenMercator(0, o2);
            }
            static createFromScreenPoints(t2, i2) {
              let o2, s2;
              if (t2 instanceof e.P || "number" == typeof t2[0]) {
                const r2 = e.P.convert(t2);
                o2 = [r2], s2 = i2.isPointAboveHorizon(r2);
              } else {
                const r2 = e.P.convert(t2[0]), n2 = e.P.convert(t2[1]), a2 = r2.add(n2)._div(2);
                o2 = [r2, n2], s2 = e.ao(r2, n2).every((e2) => i2.isPointAboveHorizon(e2)) && i2.isPointAboveHorizon(a2);
              }
              return new Xe(o2, i2.getCameraPoint(), s2, i2);
            }
            isPointQuery() {
              return 1 === this.screenBounds.length;
            }
            bufferedScreenGeometry(t2) {
              return e.ao(this.screenBounds[0], 1 === this.screenBounds.length ? this.screenBounds[0] : this.screenBounds[1], t2);
            }
            bufferedCameraGeometry(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s2 = e.ao(i2, o2, 0, false);
              return this.cameraPoint.y > o2.y && (this.cameraPoint.x > i2.x && this.cameraPoint.x < o2.x ? s2.splice(3, 0, this.cameraPoint) : this.cameraPoint.x >= o2.x ? s2[2] = this.cameraPoint : this.cameraPoint.x <= i2.x && (s2[3] = this.cameraPoint)), e.ap(s2, t2);
            }
            bufferedCameraGeometryGlobe(t2) {
              const i2 = this.screenBounds[0], o2 = 1 === this.screenBounds.length ? this.screenBounds[0].add(new e.P(1, 1)) : this.screenBounds[1], s2 = e.ao(i2, o2, t2), r2 = this.cameraPoint.clone();
              switch (3 * ((r2.y > i2.y) + (r2.y > o2.y)) + ((r2.x > i2.x) + (r2.x > o2.x))) {
                case 0:
                  s2[0] = r2, s2[4] = r2.clone();
                  break;
                case 1:
                  s2.splice(1, 0, r2);
                  break;
                case 2:
                  s2[1] = r2;
                  break;
                case 3:
                  s2.splice(4, 0, r2);
                  break;
                case 5:
                  s2.splice(2, 0, r2);
                  break;
                case 6:
                  s2[3] = r2;
                  break;
                case 7:
                  s2.splice(3, 0, r2);
                  break;
                case 8:
                  s2[2] = r2;
              }
              return s2;
            }
            containsTile(t2, i2, o2, s2 = 0) {
              const r2 = t2.queryPadding / i2._pixelsPerMercatorPixel + 1, n2 = o2 ? this._bufferedCameraMercator(r2, i2) : this._bufferedScreenMercator(r2, i2);
              let a2 = t2.tileID.wrap + (n2.unwrapped ? s2 : 0);
              const l2 = n2.polygon.map((i3) => e.aq(t2.tileTransform, i3, a2));
              if (!e.ar(l2, 0, 0, e.aj, e.aj)) return;
              a2 = t2.tileID.wrap + (this.screenGeometryMercator.unwrapped ? s2 : 0);
              const c2 = this.screenGeometryMercator.polygon.map((i3) => e.as(t2.tileTransform, i3, a2)), h2 = c2.map((t3) => new e.P(t3[0], t3[1])), d2 = i2.getFreeCameraOptions().position || new e.ac(0, 0, 0), u5 = e.as(t2.tileTransform, d2, a2), _2 = c2.map((t3) => {
                const i3 = e.at(t3, t3, u5);
                return e.au(i3, i3), new e.av(u5, i3);
              }), p2 = e.aw(t2, 1, i2.zoom) * i2._pixelsPerMercatorPixel;
              return { queryGeometry: this, tilespaceGeometry: h2, tilespaceRays: _2, bufferedTilespaceGeometry: l2, bufferedTilespaceBounds: (f2 = e.ax(l2), f2.min.x = e.aD(f2.min.x, 0, e.aj), f2.min.y = e.aD(f2.min.y, 0, e.aj), f2.max.x = e.aD(f2.max.x, 0, e.aj), f2.max.y = e.aD(f2.max.y, 0, e.aj), f2), tile: t2, tileID: t2.tileID, pixelToTileUnitsFactor: p2 };
              var f2;
            }
            _bufferedScreenMercator(e2, t2) {
              const i2 = Je(e2);
              if (this._screenRaycastCache[i2]) return this._screenRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedScreenGeometry(e2), t2) : { polygon: this.bufferedScreenGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._screenRaycastCache[i2] = o2, o2;
              }
            }
            _bufferedCameraMercator(e2, t2) {
              const i2 = Je(e2);
              if (this._cameraRaycastCache[i2]) return this._cameraRaycastCache[i2];
              {
                let o2;
                return o2 = "globe" === t2.projection.name ? this._projectAndResample(this.bufferedCameraGeometryGlobe(e2), t2) : { polygon: this.bufferedCameraGeometry(e2).map((e3) => t2.pointCoordinate3D(e3)), unwrapped: true }, this._cameraRaycastCache[i2] = o2, o2;
              }
            }
            _projectAndResample(t2, i2) {
              const o2 = function(t3, i3) {
                const o3 = e.az([], i3.pixelMatrix, i3.globeMatrix), s3 = [0, -e.aE, 0, 1], r2 = [0, e.aE, 0, 1], n2 = [0, 0, 0, 1];
                e.aA(s3, s3, o3), e.aA(r2, r2, o3), e.aA(n2, n2, o3);
                const a2 = new e.P(s3[0] / s3[3], s3[1] / s3[3]), l2 = new e.P(r2[0] / r2[3], r2[1] / r2[3]), c2 = e.aB(t3, a2) && s3[3] < n2[3], h2 = e.aB(t3, l2) && r2[3] < n2[3];
                if (!c2 && !h2) return null;
                const d2 = function(e2, t4, i4) {
                  for (let o4 = 1; o4 < e2.length; o4++) {
                    const s4 = Ke(t4.pointCoordinate3D(e2[o4 - 1]).x), r3 = Ke(t4.pointCoordinate3D(e2[o4]).x);
                    if (i4 < 0) {
                      if (s4 < r3) return { idx: o4, t: -s4 / (r3 - 1 - s4) };
                    } else if (r3 < s4) return { idx: o4, t: (1 - s4) / (r3 + 1 - s4) };
                  }
                  return null;
                }(t3, i3, c2 ? -1 : 1);
                if (!d2) return null;
                const { idx: u5, t: _2 } = d2;
                let p2 = u5 > 1 ? Ye(t3.slice(0, u5), i3) : [], f2 = u5 < t3.length ? Ye(t3.slice(u5), i3) : [];
                p2 = p2.map((t4) => new e.P(Ke(t4.x), t4.y)), f2 = f2.map((t4) => new e.P(Ke(t4.x), t4.y));
                const m2 = [...p2];
                0 === m2.length && m2.push(f2[f2.length - 1]);
                const g2 = e.ai(m2[m2.length - 1].y, (0 === f2.length ? p2[0] : f2[0]).y, _2);
                let v3;
                return v3 = c2 ? [new e.P(0, g2), new e.P(0, 0), new e.P(1, 0), new e.P(1, g2)] : [new e.P(1, g2), new e.P(1, 1), new e.P(0, 1), new e.P(0, g2)], m2.push(...v3), 0 === f2.length ? m2.push(p2[0]) : m2.push(...f2), { polygon: m2.map((t4) => new e.ac(t4.x, t4.y)), unwrapped: false };
              }(t2, i2);
              if (o2) return o2;
              const s2 = function(t3, i3) {
                let o3 = false, s3 = -1 / 0, r2 = 0;
                for (let e2 = 0; e2 < t3.length - 1; e2++) t3[e2].x > s3 && (s3 = t3[e2].x, r2 = e2);
                for (let e2 = 0; e2 < t3.length - 1; e2++) {
                  const i4 = (r2 + e2) % (t3.length - 1), s4 = t3[i4], n3 = t3[i4 + 1];
                  Math.abs(s4.x - n3.x) > 0.5 && (s4.x < n3.x ? (s4.x += 1, 0 === i4 && (t3[t3.length - 1].x += 1)) : (n3.x += 1, i4 + 1 === t3.length - 1 && (t3[0].x += 1)), o3 = true);
                }
                const n2 = e.ay(i3.center.lng);
                return o3 && n2 < Math.abs(n2 - 1) && t3.forEach((e2) => {
                  e2.x -= 1;
                }), { polygon: t3, unwrapped: o3 };
              }(Ye(t2, i2).map((t3) => new e.P(Ke(t3.x), t3.y)), i2);
              return { polygon: s2.polygon.map((t3) => new e.ac(t3.x, t3.y)), unwrapped: s2.unwrapped };
            }
          }
          function Ye(t2, i2) {
            return e.aC(t2, (e2) => {
              const t3 = i2.pointCoordinate3D(e2);
              e2.x = t3.x, e2.y = t3.y;
            }, 1 / 256);
          }
          function Ke(e2) {
            return e2 < 0 ? 1 + e2 % 1 : e2 % 1;
          }
          function Je(e2) {
            return 100 * e2 | 0;
          }
          function Qe(t2, i2, o2, s2, r2) {
            const n2 = function(o3, s3) {
              if (o3) return r2(o3);
              if (s3) {
                if (t2.url && s3.tiles && t2.tiles && delete t2.tiles, s3.variants) {
                  if (!Array.isArray(s3.variants)) return r2(new Error("variants must be an array"));
                  for (const t3 of s3.variants) {
                    if (null == t3 || "object" != typeof t3 || t3.constructor !== Object) return r2(new Error("variant must be an object"));
                    if (!Array.isArray(t3.capabilities)) return r2(new Error("capabilities must be an array"));
                    if (1 === t3.capabilities.length && "meshopt" === t3.capabilities[0]) {
                      s3 = e.l(s3, t3);
                      break;
                    }
                  }
                }
                const o4 = e.aF(e.l({}, s3, t2), ["tilejson", "tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "extra_bounds", "scheme", "tileSize", "encoding", "vector_layers", "raster_layers", "worldview_options", "worldview_default", "worldview"]);
                o4.tiles = i2.canonicalizeTileset(o4, t2.url), r2(null, o4);
              }
            }, a2 = function(e2, t3, i3) {
              if (!e2) return null;
              if (!t3 && !i3) return e2;
              i3 = i3 || e2.worldview_default;
              const o3 = Object.values(e2.language || {});
              if (0 === o3.length) return null;
              const s3 = Object.values(e2.worldview || {});
              if (0 === s3.length) return null;
              const r3 = o3.every((e3) => e3 === t3), n3 = s3.every((e3) => e3 === i3);
              return r3 && n3 ? e2 : t3 in (e2.language_options || {}) || i3 in (e2.worldview_options || {}) ? null : e2.language_options && e2.worldview_options ? e2 : null;
            }(t2.data, o2, s2);
            return a2 ? e.q.frame(() => n2(null, a2)) : t2.url ? e.n(i2.transformRequest(i2.normalizeSourceURL(t2.url, null, o2, s2), e.R.Source), n2) : e.q.frame(() => {
              const { data: e2, ...i3 } = t2;
              n2(null, i3);
            });
          }
          function et(t2, i2) {
            const o2 = Math.pow(2, i2.z), s2 = Math.floor(e.ay(t2.getWest()) * o2), r2 = Math.floor(e.aH(t2.getNorth()) * o2), n2 = Math.ceil(e.ay(t2.getEast()) * o2), a2 = Math.ceil(e.aH(t2.getSouth()) * o2);
            return i2.x >= s2 && i2.x < n2 && i2.y >= r2 && i2.y < a2;
          }
          class tt {
            constructor(t2, i2, o2) {
              this.bounds = t2 ? e.aG.convert(this.validateBounds(t2)) : null, this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
            }
            validateBounds(e2) {
              return Array.isArray(e2) && 4 === e2.length ? [Math.max(-180, e2[0]), Math.max(-90, e2[1]), Math.min(180, e2[2]), Math.min(90, e2[3])] : [-180, -90, 180, 90];
            }
            addExtraBounds(t2) {
              if (t2) {
                this.extraBounds || (this.extraBounds = []);
                for (const i2 of t2) this.extraBounds.push(e.aG.convert(this.validateBounds(i2)));
              }
            }
            contains(e2) {
              if (e2.z > this.maxzoom || e2.z < this.minzoom) return false;
              if (this.bounds && !et(this.bounds, e2)) return false;
              if (!this.extraBounds) return true;
              for (const t2 of this.extraBounds) if (et(t2, e2)) return true;
              return false;
            }
            static fromTileJSON(e2) {
              if (!e2.bounds && !e2.extra_bounds) return null;
              const t2 = new tt(e2.bounds, e2.minzoom, e2.maxzoom);
              return t2.addExtraBounds(e2.extra_bounds), t2;
            }
          }
          class it extends e.E {
            constructor(t2, i2, o2, s2) {
              if (super(), this.id = t2, this.dispatcher = o2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, e.l(this, e.aF(i2, ["url", "scheme", "tileSize", "promoteId"])), this._options = e.l({ type: "vector" }, i2), this._collectResourceTiming = !!i2.collectResourceTiming, 512 !== this.tileSize) throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(s2), this._tileWorkers = {}, this._deduped = new e.aI();
            }
            load(t2) {
              this._loaded = false, this.fire(new e.A("dataloading", { dataType: "source" }));
              const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
              this._tileJSONRequest = Qe(this._options, this.map._requestManager, i2, o2, (s2, r2) => {
                if (this._tileJSONRequest = null, this._loaded = true, s2) i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.z(s2));
                else if (r2) {
                  if (e.l(this, r2), this.hasWorldviews = !!r2.worldview_options, r2.worldview_default && (this.worldviewDefault = r2.worldview_default), r2.vector_layers) {
                    this.vectorLayers = r2.vector_layers, this.vectorLayerIds = [], this.localizableLayerIds = /* @__PURE__ */ new Set();
                    for (const e2 of r2.vector_layers) this.vectorLayerIds.push(e2.id), r2.worldview && r2.worldview[e2.source] && this.localizableLayerIds.add(e2.id);
                  }
                  this.tileBounds = tt.fromTileJSON(r2), L(r2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.A("data", { dataType: "source", sourceDataType: "content" }));
                }
                t2 && t2(s2);
              });
            }
            loaded() {
              return this._loaded;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest();
              const t2 = e.C(this.id, this.scope);
              this.load(() => this.map.style.clearSource(t2));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove(e2) {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.l({}, this._options);
            }
            loadTile(t2, i2) {
              const o2 = t2.tileID.canonical.url(this.tiles, this.scheme), s2 = this.map._requestManager.normalizeTileURL(o2), r2 = this.map._requestManager.transformRequest(s2, e.R.Tile), n2 = this.map.style ? this.map.style.getLut(this.scope) : null, a2 = n2 ? { image: n2.image.clone() } : null, l2 = { request: r2, data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, lut: a2, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, pixelRatio: e.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster, tessellationStep: this.map._tessellationStep, scaleFactor: this.map.getScaleFactor() };
              if (this.hasWorldviews && e.f(o2) && (l2.worldview = this.map.getWorldview() || this.worldviewDefault, l2.localizableLayerIds = this.localizableLayerIds), l2.request.collectResourceTiming = this._collectResourceTiming, t2.actor && "expired" !== t2.state) "loading" === t2.state ? t2.reloadCallback = i2 : t2.request = t2.actor.send("reloadTile", l2, c2.bind(this));
              else if (t2.actor = this._tileWorkers[s2] = this._tileWorkers[s2] || this.dispatcher.getActor(), this.dispatcher.ready) t2.request = t2.actor.send("loadTile", l2, c2.bind(this), void 0, true);
              else {
                const i3 = e.aJ.call({ deduped: this._deduped }, l2, (e2, i4) => {
                  e2 || !i4 ? c2.call(this, e2) : (l2.data = { cacheControl: i4.cacheControl, expires: i4.expires, rawData: i4.rawData.slice(0) }, t2.actor && t2.actor.send("loadTile", l2, c2.bind(this), void 0, true));
                }, true);
                t2.request = { cancel: i3 };
              }
              function c2(o3, s3) {
                return delete t2.request, t2.aborted ? i2(null) : o3 && 404 !== o3.status ? i2(o3) : (s3 && s3.resourceTiming && (t2.resourceTiming = s3.resourceTiming), this.map._refreshExpiredTiles && s3 && t2.setExpiryData(s3), t2.loadVectorData(s3, this.map.painter), e.aK(this.dispatcher), i2(null), void (t2.reloadCallback && (this.loadTile(t2, t2.reloadCallback), t2.reloadCallback = null)));
              }
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope });
            }
            unloadTile(e2, t2) {
              e2.actor && e2.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
            }
            hasTransition() {
              return false;
            }
            afterUpdate() {
              this._tileWorkers = {};
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          class ot extends e.E {
            constructor(t2, i2, o2, s2) {
              super(), this.id = t2, this.dispatcher = o2, this.setEventedParent(s2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = e.l({ type: "raster" }, i2), e.l(this, e.aF(i2, ["url", "scheme", "tileSize"]));
            }
            load(t2) {
              this._loaded = false, this.fire(new e.A("dataloading", { dataType: "source" })), this._tileJSONRequest = Qe(this._options, this.map._requestManager, null, null, (i2, o2) => {
                this._tileJSONRequest = null, this._loaded = true, i2 ? this.fire(new e.z(i2)) : o2 && (e.l(this, o2), o2.raster_layers && (this.rasterLayers = o2.raster_layers, this.rasterLayerIds = this.rasterLayers.map((e2) => e2.id)), this.tileBounds = tt.fromTileJSON(o2), L(o2.tiles), this.fire(new e.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.A("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(i2);
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest();
              const t2 = e.C(this.id, this.scope);
              this.load(() => this.map.style.clearSource(t2));
            }
            setTiles(e2) {
              return this._options.tiles = e2, this.reload(), this;
            }
            setUrl(e2) {
              return this.url = e2, this._options.url = e2, this.reload(), this;
            }
            onRemove(e2) {
              this.cancelTileJSONRequest();
            }
            serialize() {
              return e.l({}, this._options);
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(t2, i2) {
              const o2 = e.q.devicePixelRatio >= 2, s2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), o2, this.tileSize);
              t2.request = e.o(this.map._requestManager.transformRequest(s2, e.R.Tile), (o3, s3, r2, n2) => (delete t2.request, t2.aborted ? (t2.state = "unloaded", i2(null)) : o3 ? (t2.state = "errored", i2(o3)) : s3 ? (this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: r2, expires: n2 }), t2.setTexture(s3, this.map.painter), t2.state = "loaded", e.aK(this.dispatcher), void i2(null)) : i2(null)));
            }
            abortTile(e2, t2) {
              e2.request && (e2.request.cancel(), delete e2.request), t2 && t2();
            }
            unloadTile(t2, i2) {
              t2.texture && t2.texture instanceof e.T ? (t2.destroy(true), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), i2 && i2();
            }
            hasTransition() {
              return false;
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
          }
          class st extends ot {
            constructor(t2, i2, o2, s2) {
              super(t2, i2, o2, s2), this.type = "raster-array", this.maxzoom = 22, this.partial = true, this._options = e.l({ type: "raster-array" }, i2);
            }
            triggerRepaint(e2) {
              const t2 = this.map.painter._terrain, i2 = this.map.style.getSourceCache(this.id);
              t2 && t2.enabled && i2 && t2._clearRenderCacheForTile(i2.id, e2.tileID), this.map.triggerRepaint();
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize), s2 = this.map._requestManager.transformRequest(o2, e.R.Tile), r2 = { request: s2, uid: t2.uid, tileID: t2.tileID, type: this.type, source: this.id, scope: this.scope, partial: this.partial };
              t2.source = this.id, t2.scope = this.scope, t2.requestParams = s2, t2.actor || (t2.actor = this.dispatcher.getActor());
              const n2 = (e2, o3, s3, r3) => {
                if (delete t2.request, t2.aborted) return t2.state = "unloaded", i2(null);
                if (e2) {
                  if ("AbortError" === e2.name) return;
                  return t2.state = "errored", i2(e2);
                }
                if (this.map._refreshExpiredTiles && o3 && t2.setExpiryData({ cacheControl: s3, expires: r3 }), this.partial) t2.state = "empty";
                else {
                  if (!o3) return i2(null);
                  t2.state = "loaded", t2._isHeaderLoaded = true, t2._mrt = o3;
                }
                i2(null);
              };
              t2.request = this.partial ? t2.fetchHeader(void 0, n2.bind(this)) : t2.actor.send("loadTile", r2, n2.bind(this), void 0, true);
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.actor && e2.actor.send("abortTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope });
            }
            unloadTile(t2, i2) {
              const o2 = t2.texture;
              o2 && o2 instanceof e.T ? (t2.destroy(true), this.map.painter.saveTileTexture(o2)) : (t2.destroy(), t2.flushQueues(), t2._isHeaderLoaded = false, delete t2._mrt, delete t2.textureDescriptor), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), delete t2.request, delete t2.requestParams, delete t2.neighboringTiles, t2.state = "unloaded";
            }
            prepareTile(t2, i2, o2) {
              t2._isHeaderLoaded && ("empty" !== t2.state && (t2.state = "reloading"), t2.fetchBand(i2, o2, (i3, o3) => {
                if (i3) return t2.state = "errored", this.fire(new e.z(i3)), void this.triggerRepaint(t2);
                o3 && (t2._isHeaderLoaded = true, t2.setTexture(o3, this.map.painter), t2.state = "loaded", this.triggerRepaint(t2));
              }));
            }
            getInitialBand(e2) {
              if (!this.rasterLayers) return 0;
              const t2 = this.rasterLayers.find(({ id: t3 }) => t3 === e2), i2 = t2 && t2.fields, o2 = i2 && i2.bands && i2.bands;
              return o2 ? o2[0] : 0;
            }
            getTextureDescriptor(t2, i2, o2) {
              if (!t2) return;
              const s2 = i2.sourceLayer || this.rasterLayerIds && this.rasterLayerIds[0];
              if (!s2) return;
              let r2 = null;
              i2 instanceof e.aN ? r2 = i2.paint.get("raster-array-band") : i2 instanceof e.aO && (r2 = i2.paint.get("raster-particle-array-band"));
              const n2 = r2 || this.getInitialBand(s2);
              if (null != n2) if (t2.textureDescriptor) {
                if (!t2.updateNeeded(s2, n2) || o2) return Object.assign({}, t2.textureDescriptor, { texture: t2.texture });
              } else this.prepareTile(t2, s2, n2);
            }
            getImages(t2, i2) {
              const o2 = /* @__PURE__ */ new Map();
              for (const s2 of t2) for (const t3 of i2) {
                const [i3, r2] = t3.split("/"), n2 = s2.getLayer(i3);
                if (!n2) continue;
                if (!n2.hasBand(r2) || !n2.hasDataForBand(r2)) continue;
                const { bytes: a2, tileSize: l2, buffer: c2 } = n2.getBandView(r2), h2 = l2 + 2 * c2, d2 = { data: new e.r({ width: h2, height: h2 }, a2), pixelRatio: 2, sdf: false, usvg: false, version: 0 };
                o2.set(t3, d2);
              }
              return o2;
            }
          }
          const rt = { vector: it, raster: ot, "raster-dem": class extends ot {
            constructor(t2, i2, o2, s2) {
              super(t2, i2, o2, s2), this.type = "raster-dem", this.maxzoom = 22, this._options = e.l({ type: "raster-dem" }, i2), this.encoding = i2.encoding || "mapbox";
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme), false, this.tileSize);
              function s2(e2, o3) {
                e2 && (t2.state = "errored", i2(e2)), o3 && (t2.dem = o3, t2.dem.onDeserialize(), t2.needsHillshadePrepare = true, t2.needsDEMTextureUpload = true, t2.state = "loaded", i2(null));
              }
              t2.request = e.o(this.map._requestManager.transformRequest(o2, e.R.Tile), function(o3, r2, n2, a2) {
                if (delete t2.request, t2.aborted) t2.state = "unloaded", i2(null);
                else if (o3) t2.state = "errored", i2(o3);
                else if (r2) {
                  this.map._refreshExpiredTiles && t2.setExpiryData({ cacheControl: n2, expires: a2 });
                  const i3 = ImageBitmap && r2 instanceof ImageBitmap && e.t(), o4 = 1 - (r2.width - e.aL(r2.width)) / 2;
                  o4 < 1 || t2.neighboringTiles || (t2.neighboringTiles = this._getNeighboringTiles(t2.tileID));
                  const l2 = i3 ? r2 : e.q.getImageData(r2, o4), c2 = { uid: t2.uid, tileID: t2.tileID, source: this.id, type: this.type, scope: this.scope, rawImageData: l2, encoding: this.encoding, padding: o4 };
                  t2.actor && "expired" !== t2.state || (t2.actor = this.dispatcher.getActor(), t2.actor.send("loadTile", c2, s2.bind(this), void 0, true));
                }
              }.bind(this));
            }
            _getNeighboringTiles(t2) {
              const i2 = t2.canonical, o2 = Math.pow(2, i2.z), s2 = (i2.x - 1 + o2) % o2, r2 = 0 === i2.x ? t2.wrap - 1 : t2.wrap, n2 = (i2.x + 1 + o2) % o2, a2 = i2.x + 1 === o2 ? t2.wrap + 1 : t2.wrap, l2 = {};
              return l2[new e.aM(t2.overscaledZ, r2, i2.z, s2, i2.y).key] = { backfilled: false }, l2[new e.aM(t2.overscaledZ, a2, i2.z, n2, i2.y).key] = { backfilled: false }, i2.y > 0 && (l2[new e.aM(t2.overscaledZ, r2, i2.z, s2, i2.y - 1).key] = { backfilled: false }, l2[new e.aM(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y - 1).key] = { backfilled: false }, l2[new e.aM(t2.overscaledZ, a2, i2.z, n2, i2.y - 1).key] = { backfilled: false }), i2.y + 1 < o2 && (l2[new e.aM(t2.overscaledZ, r2, i2.z, s2, i2.y + 1).key] = { backfilled: false }, l2[new e.aM(t2.overscaledZ, t2.wrap, i2.z, i2.x, i2.y + 1).key] = { backfilled: false }, l2[new e.aM(t2.overscaledZ, a2, i2.z, n2, i2.y + 1).key] = { backfilled: false }), l2;
            }
          }, "raster-array": st, geojson: class extends e.E {
            constructor(t2, i2, o2, s2) {
              super(), this.id = t2, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._loaded = false, this.actor = o2.getActor(), this.setEventedParent(s2), this._data = i2.data, this._options = e.l({}, i2), this._collectResourceTiming = i2.collectResourceTiming, void 0 !== i2.maxzoom && (this.maxzoom = i2.maxzoom), void 0 !== i2.minzoom && (this.minzoom = i2.minzoom), i2.type && (this.type = i2.type), i2.attribution && (this.attribution = i2.attribution), this.promoteId = i2.promoteId;
              const r2 = e.aj / this.tileSize;
              this.workerOptions = e.l({ source: this.id, scope: this.scope, cluster: i2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i2.buffer ? i2.buffer : 128) * r2, tolerance: (void 0 !== i2.tolerance ? i2.tolerance : 0.375) * r2, extent: e.aj, maxZoom: this.maxzoom, lineMetrics: i2.lineMetrics || false, generateId: i2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i2.clusterMaxZoom ? i2.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i2.clusterMinPoints || 2), extent: e.aj, radius: (void 0 !== i2.clusterRadius ? i2.clusterRadius : 50) * r2, log: false, generateId: i2.generateId || false }, clusterProperties: i2.clusterProperties, filter: i2.filter, dynamic: i2.dynamic }, i2.workerOptions);
            }
            onAdd(e2) {
              this.map = e2, this.setData(this._data);
            }
            setData(e2) {
              return this._data = e2, this._updateWorkerData(), this;
            }
            updateData(t2) {
              if (!this._options.dynamic) return this.fire(new e.z(new Error("Can't call updateData on a GeoJSON source with dynamic set to false.")));
              if ("string" != typeof t2 && ("Feature" === t2.type && (t2 = { type: "FeatureCollection", features: [t2] }), "FeatureCollection" !== t2.type)) return this.fire(new e.z(new Error("Data to update should be a feature or a feature collection.")));
              if (this._coalesce && "string" != typeof t2 && "string" != typeof this._data && "FeatureCollection" === this._data.type) {
                const e2 = /* @__PURE__ */ new Map();
                for (const t3 of this._data.features) e2.set(t3.id, t3);
                for (const i2 of t2.features) e2.set(i2.id, i2);
                this._data.features = [...e2.values()];
              } else this._data = t2;
              return this._updateWorkerData(true), this;
            }
            getClusterExpansionZoom(e2, t2) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
            }
            getClusterChildren(e2, t2) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: e2, source: this.id, scope: this.scope }, t2), this;
            }
            getClusterLeaves(e2, t2, i2, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, scope: this.scope, clusterId: e2, limit: t2, offset: i2 }, o2), this;
            }
            _updateWorkerData(t2 = false) {
              if (this._pendingLoad) return void (this._coalesce = true);
              this.fire(new e.A("dataloading", { dataType: "source" })), this._loaded = false;
              const i2 = e.l({ append: t2 }, this.workerOptions);
              i2.scope = this.scope;
              const o2 = this._data;
              "string" == typeof o2 ? (i2.request = this.map._requestManager.transformRequest(e.q.resolveURL(o2), e.R.Source), i2.request.collectResourceTiming = this._collectResourceTiming) : i2.data = JSON.stringify(o2), this._pendingLoad = this.actor.send(`${this.type}.loadData`, i2, (i3, o3) => {
                if (this._loaded = true, this._pendingLoad = null, i3) this.fire(new e.z(i3));
                else {
                  const i4 = { dataType: "source", sourceDataType: this._metadataFired ? "content" : "metadata" };
                  this._collectResourceTiming && o3 && o3.resourceTiming && o3.resourceTiming[this.id] && (i4.resourceTiming = o3.resourceTiming[this.id]), t2 && (this._partialReload = true), this.fire(new e.A("data", i4)), this._partialReload = false, this._metadataFired = true;
                }
                this._coalesce && (this._updateWorkerData(t2), this._coalesce = false);
              });
            }
            loaded() {
              return this._loaded;
            }
            reload() {
              const t2 = e.C(this.id, this.scope);
              this.map.style.clearSource(t2), this._updateWorkerData();
            }
            loadTile(t2, i2) {
              const o2 = t2.actor ? "reloadTile" : "loadTile";
              t2.actor = this.actor;
              const s2 = this.map.style ? this.map.style.getLut(this.scope) : null, r2 = s2 ? { image: s2.image.clone() } : null, n2 = this._partialReload, a2 = { type: this.type, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, lut: r2, scope: this.scope, pixelRatio: e.q.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId, brightness: this.map.style && this.map.style.getBrightness() || 0, extraShadowCaster: t2.isExtraShadowCaster, scaleFactor: this.map.getScaleFactor(), partial: n2 };
              t2.request = this.actor.send(o2, a2, (e2, s3) => n2 && !s3 ? (t2.state = "loaded", i2(null)) : (delete t2.request, t2.destroy(), t2.aborted ? i2(null) : e2 ? i2(e2) : (t2.loadVectorData(s3, this.map.painter, "reloadTile" === o2), i2(null))), void 0, "loadTile" === o2);
            }
            abortTile(e2) {
              e2.request && (e2.request.cancel(), delete e2.request), e2.aborted = true;
            }
            unloadTile(e2, t2) {
              this.actor.send("removeTile", { uid: e2.uid, type: this.type, source: this.id, scope: this.scope }), e2.destroy();
            }
            onRemove(e2) {
              this._pendingLoad && this._pendingLoad.cancel();
            }
            serialize() {
              return e.l({}, this._options, { type: this.type, data: this._data });
            }
            hasTransition() {
              return false;
            }
          }, video: class extends e.aP {
            constructor(e2, t2, i2, o2) {
              super(e2, t2, i2, o2), this.roundZoom = true, this.type = "video", this.options = t2;
            }
            load() {
              this._loaded = false;
              const t2 = this.options;
              this.urls = [];
              for (const i2 of t2.urls) this.urls.push(this.map._requestManager.transformRequest(i2, e.R.Source).url);
              e.aQ(this.urls, (t3, i2) => {
                this._loaded = true, t3 ? this.fire(new e.z(t3)) : i2 && (this.video = i2, this.video.loop = true, this.video.setAttribute("playsinline", ""), this.video.addEventListener("playing", () => {
                  this.map.triggerRepaint();
                }), this.map && this.video.play(), this._finishLoading());
              });
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(t2) {
              if (this.video) {
                const i2 = this.video.seekable;
                t2 < i2.start(0) || t2 > i2.end(0) ? this.fire(new e.z(new e.V(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i2.start(0)} and ${i2.end(0)}-second mark.`))) : this.video.currentTime = t2;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(e2) {
              this.map || (this.map = e2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            prepare() {
              if (0 === Object.keys(this.tiles).length || this.video.readyState < 2) return;
              const t2 = this.map.painter.context, i2 = t2.gl;
              this.texture ? this.video.paused || (this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), i2.texSubImage2D(i2.TEXTURE_2D, 0, 0, 0, i2.RGBA, i2.UNSIGNED_BYTE, this.video)) : (this.texture = new e.T(t2, this.video, i2.RGBA8), this.texture.bind(i2.LINEAR, i2.CLAMP_TO_EDGE), this.width = this.video.videoWidth, this.height = this.video.videoHeight), this._prepareData(t2);
            }
            serialize() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }, image: e.aP, model: class extends e.E {
            constructor(e2, t2, i2, o2) {
              super(), this.id = e2, this.type = "model", this.models = [], this._loaded = false, this._options = t2;
            }
            load() {
              const t2 = [];
              for (const i2 in this._options.models) {
                const o2 = this._options.models[i2], s2 = e.aS(this.map._requestManager.transformRequest(o2.uri, e.R.Model).url).then((t3) => {
                  if (!t3) return;
                  const s3 = e.aT(t3), r2 = new e.aU(i2, o2.position, o2.orientation, s3);
                  r2.computeBoundsAndApplyParent(), this.models.push(r2);
                }).catch((t3) => {
                  this.fire(new e.z(new Error(`Could not load model ${i2} from ${o2.uri}: ${t3.message}`)));
                });
                t2.push(s2);
              }
              Promise.allSettled(t2).then(() => {
                this._loaded = true, this.fire(new e.A("data", { dataType: "source", sourceDataType: "metadata" }));
              }).catch((t3) => {
                this._loaded = true, this.fire(new e.z(new Error(`Could not load models: ${t3.message}`)));
              });
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            hasTransition() {
              return false;
            }
            loaded() {
              return this._loaded;
            }
            getModels() {
              return this.models;
            }
            loadTile(e2, t2) {
            }
            serialize() {
              return this._options;
            }
          }, "batched-model": class extends e.E {
            constructor(e2, t2, i2, o2) {
              super(), this.type = "batched-model", this.id = e2, this.tileSize = 512, this._options = t2, this.tiles = this._options.tiles, this.maxzoom = t2.maxzoom || 19, this.minzoom = t2.minzoom || 0, this.roundZoom = true, this.usedInConflation = true, this.dispatcher = i2, this.reparseOverscaled = false, this.scheme = "xyz", this._loaded = false, this.setEventedParent(o2);
            }
            onAdd(e2) {
              this.map = e2, this.load();
            }
            reload() {
              this.cancelTileJSONRequest();
              const t2 = e.C(this.id, this.scope);
              this.load(() => this.map.style.clearSource(t2));
            }
            cancelTileJSONRequest() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            load(t2) {
              this._loaded = false, this.fire(new e.A("dataloading", { dataType: "source" }));
              const i2 = Array.isArray(this.map._language) ? this.map._language.join() : this.map._language, o2 = this.map.getWorldview();
              this._tileJSONRequest = Qe(this._options, this.map._requestManager, i2, o2, (s2, r2) => {
                this._tileJSONRequest = null, this._loaded = true, s2 ? (i2 && console.warn(`Ensure that your requested language string is a valid BCP-47 code or list of codes. Found: ${i2}`), o2 && 2 !== o2.length && console.warn(`Requested worldview strings must be a valid ISO alpha-2 code. Found: ${o2}`), this.fire(new e.z(s2))) : r2 && (e.l(this, r2), r2.bounds && (this.tileBounds = new tt(r2.bounds, this.minzoom, this.maxzoom)), L(r2.tiles, this.map._requestManager._customAccessToken), this.fire(new e.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.A("data", { dataType: "source", sourceDataType: "content" }))), t2 && t2(s2);
              });
            }
            hasTransition() {
              return false;
            }
            hasTile(e2) {
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loaded() {
              return this._loaded;
            }
            loadTile(t2, i2) {
              const o2 = this.map._requestManager.normalizeTileURL(t2.tileID.canonical.url(this.tiles, this.scheme)), s2 = { request: this.map._requestManager.transformRequest(o2, e.R.Tile), data: void 0, uid: t2.uid, tileID: t2.tileID, tileZoom: t2.tileZoom, zoom: t2.tileID.overscaledZ, tileSize: this.tileSize * t2.tileID.overscaleFactor(), type: this.type, source: this.id, scope: this.scope, showCollisionBoxes: this.map.showCollisionBoxes, isSymbolTile: t2.isSymbolTile, brightness: this.map.style && this.map.style.getBrightness() || 0, pixelRatio: e.q.devicePixelRatio, promoteId: this.promoteId };
              if (t2.actor && "expired" !== t2.state) if ("loading" === t2.state) t2.reloadCallback = i2;
              else {
                if (t2.buckets) {
                  const e2 = Object.values(t2.buckets);
                  for (const t3 of e2) t3.dirty = true;
                  return void (t2.state = "loaded");
                }
                t2.request = t2.actor.send("reloadTile", s2, r2.bind(this));
              }
              else t2.actor = this.dispatcher.getActor(), t2.request = t2.actor.send("loadTile", s2, r2.bind(this), void 0, true);
              function r2(e2, o3) {
                return t2.aborted ? i2(null) : e2 && 404 !== e2.status ? i2(e2) : (this.map._refreshExpiredTiles && o3 && t2.setExpiryData(o3), t2.loadModelData(o3, this.map.painter), t2.state = "loaded", void i2(null));
              }
            }
            serialize() {
              return e.l({}, this._options);
            }
          }, canvas: class extends e.aP {
            constructor(t2, i2, o2, s2) {
              super(t2, i2, o2, s2), i2.coordinates ? Array.isArray(i2.coordinates) && 4 === i2.coordinates.length && !i2.coordinates.some((e2) => !Array.isArray(e2) || 2 !== e2.length || e2.some((e3) => "number" != typeof e3)) || this.fire(new e.z(new e.V(`sources.${t2}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new e.z(new e.V(`sources.${t2}`, null, 'missing required property "coordinates"'))), i2.animate && "boolean" != typeof i2.animate && this.fire(new e.z(new e.V(`sources.${t2}`, null, 'optional "animate" property must be a boolean value'))), i2.canvas ? "string" == typeof i2.canvas || i2.canvas instanceof HTMLCanvasElement || this.fire(new e.z(new e.V(`sources.${t2}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new e.z(new e.V(`sources.${t2}`, null, 'missing required property "canvas"'))), this.options = i2, this.animate = void 0 === i2.animate || i2.animate;
            }
            load() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new e.z(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(e2) {
              this.map = e2, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove(e2) {
              this.pause();
            }
            prepare() {
              let t2 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, t2 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, t2 = true), this._hasInvalidDimensions()) return;
              if (0 === Object.keys(this.tiles).length) return;
              const i2 = this.map.painter.context;
              this.texture ? !t2 && !this._playing || this.texture instanceof e.aR || this.texture.update(this.canvas, { premultiply: true }) : this.texture = new e.T(i2, this.canvas, i2.gl.RGBA8, { premultiply: true }), this._prepareData(i2);
            }
            serialize() {
              return { type: "canvas", coordinates: this.coordinates };
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const e2 of [this.canvas.width, this.canvas.height]) if (isNaN(e2) || e2 <= 0) return true;
              return false;
            }
          }, custom: class extends e.E {
            constructor(t2, i2, o2, s2) {
              super(), this.id = t2, this.type = "custom", this._dataType = "raster", this._dispatcher = o2, this._implementation = i2, this.setEventedParent(s2), this.scheme = "xyz", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this._loaded = false, this.roundZoom = true, this._implementation || this.fire(new e.z(new Error(`Missing implementation for ${this.id} custom source`))), this._implementation.loadTile || this.fire(new e.z(new Error(`Missing loadTile implementation for ${this.id} custom source`))), this._implementation.bounds && (this.tileBounds = new tt(this._implementation.bounds, this.minzoom, this.maxzoom)), i2.update = this._update.bind(this), i2.clearTiles = this._clearTiles.bind(this), i2.coveringTiles = this._coveringTiles.bind(this), e.l(this, e.aF(i2, ["dataType", "scheme", "minzoom", "maxzoom", "tileSize", "attribution", "minTileCacheSize", "maxTileCacheSize"]));
            }
            serialize() {
              return e.aF(this, ["type", "scheme", "minzoom", "maxzoom", "tileSize", "attribution"]);
            }
            load() {
              this._loaded = true, this.fire(new e.A("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new e.A("data", { dataType: "source", sourceDataType: "content" }));
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t2) {
              this.map = t2, this._loaded = false, this.fire(new e.A("dataloading", { dataType: "source" })), this._implementation.onAdd && this._implementation.onAdd(t2), this.load();
            }
            onRemove(e2) {
              this._implementation.onRemove && this._implementation.onRemove(e2);
            }
            hasTile(e2) {
              if (this._implementation.hasTile) {
                const { x: t2, y: i2, z: o2 } = e2.canonical;
                return this._implementation.hasTile({ x: t2, y: i2, z: o2 });
              }
              return !this.tileBounds || this.tileBounds.contains(e2.canonical);
            }
            loadTile(e2, t2) {
              const { x: i2, y: o2, z: s2 } = e2.tileID.canonical, r2 = new AbortController();
              e2.request = Promise.resolve(this._implementation.loadTile({ x: i2, y: o2, z: s2 }, { signal: r2.signal })).then(function(i3) {
                return delete e2.request, e2.aborted ? (e2.state = "unloaded", t2(null)) : void 0 === i3 ? (e2.state = "errored", t2(null)) : null === i3 ? (this.loadTileData(e2, { width: this.tileSize, height: this.tileSize, data: null }), e2.state = "loaded", t2(null)) : function(e3) {
                  return e3 instanceof ImageData || e3 instanceof HTMLCanvasElement || e3 instanceof ImageBitmap || e3 instanceof HTMLImageElement;
                }(i3) ? (this.loadTileData(e2, i3), e2.state = "loaded", void t2(null)) : (e2.state = "errored", t2(new Error(`Can't infer data type for ${this.id}, only raster data supported at the moment`)));
              }.bind(this)).catch((i3) => {
                "AbortError" !== i3.name && (e2.state = "errored", t2(i3));
              }), e2.request.cancel = () => r2.abort();
            }
            loadTileData(e2, t2) {
              e2.setTexture(t2, this.map.painter);
            }
            unloadTile(t2, i2) {
              if (t2.texture && t2.texture instanceof e.T ? (t2.destroy(true), t2.texture && t2.texture instanceof e.T && this.map.painter.saveTileTexture(t2.texture)) : t2.destroy(), this._implementation.unloadTile) {
                const { x: e2, y: i3, z: o2 } = t2.tileID.canonical;
                this._implementation.unloadTile({ x: e2, y: i3, z: o2 });
              }
              i2 && i2();
            }
            abortTile(e2, t2) {
              e2.request && e2.request.cancel && (e2.request.cancel(), delete e2.request), t2 && t2();
            }
            hasTransition() {
              return false;
            }
            _coveringTiles() {
              return this.map.transform.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, roundZoom: this.roundZoom }).map((e2) => ({ x: e2.canonical.x, y: e2.canonical.y, z: e2.canonical.z }));
            }
            _clearTiles() {
              const t2 = e.C(this.id, this.scope);
              this.map.style.clearSource(t2);
            }
            _update() {
              this.fire(new e.A("data", { dataType: "source", sourceDataType: "content" }));
            }
          } }, nt = function(t2, i2, o2, s2) {
            const r2 = new rt[i2.type](t2, i2, o2, s2);
            if (r2.id !== t2) throw new Error(`Expected Source id to be ${t2} instead of ${r2.id}`);
            return e.aV(["load", "abort", "unload", "serialize", "prepare"], r2), r2;
          };
          function at(e2, t2, i2 = "") {
            return `${i2}:${t2.id || ""}:${t2.layer.id}:${function(e3) {
              if ("layerId" in e3) return `layer:${e3.layerId}`;
              {
                const { featuresetId: t3, importId: i3 } = e3;
                return `featureset:${t3}${i3 ? `:import:${i3}` : ""}`;
              }
            }(e2.target)}`;
          }
          function lt(e2, t2, i2, o2 = "") {
            if (e2.uniqueFeatureID) {
              const s2 = at(e2, t2, o2);
              if (i2.has(s2)) return true;
              i2.add(s2);
            }
            return false;
          }
          function ct(e2, t2, i2, o2, s2 = false) {
            const r2 = t2.sourceCache.transform, n2 = t2.sourceCache.tilesIn(e2, t2.has3DLayers, s2);
            n2.sort(ut);
            const a2 = [];
            for (const e3 of n2) {
              const n3 = e3.tile.queryRenderedFeatures(t2, e3, i2, o2, r2, s2);
              Object.keys(n3).length && a2.push({ wrappedTileID: e3.tile.tileID.wrapped().key, queryResults: n3 });
            }
            return 0 === a2.length ? {} : function(e3) {
              const t3 = {}, i3 = {};
              for (const o3 of e3) {
                const e4 = o3.queryResults, s3 = o3.wrappedTileID, r3 = i3[s3] = i3[s3] || {};
                for (const i4 in e4) {
                  const o4 = e4[i4], s4 = r3[i4] = r3[i4] || {}, n3 = t3[i4] = t3[i4] || [];
                  for (const e5 of o4) s4[e5.featureIndex] || (s4[e5.featureIndex] = true, n3.push(e5));
                }
              }
              return t3;
            }(a2);
          }
          function ht(e2, t2, i2, o2, s2) {
            const r2 = {}, n2 = o2.queryRenderedSymbols(e2), a2 = [];
            for (const e3 of Object.keys(n2).map(Number)) a2.push(s2[e3]);
            a2.sort(ut);
            for (const e3 of a2) {
              const o3 = e3.featureIndex.lookupSymbolFeatures(n2[e3.bucketInstanceId], e3.bucketIndex, e3.sourceLayerIndex, t2, i2);
              for (const t3 in o3) {
                const i3 = r2[t3] = r2[t3] || [], s3 = o3[t3];
                s3.sort((t4, i4) => {
                  const o4 = e3.featureSortOrder;
                  if (o4) {
                    const e4 = o4.indexOf(t4.featureIndex);
                    return o4.indexOf(i4.featureIndex) - e4;
                  }
                  return i4.featureIndex - t4.featureIndex;
                });
                for (const e4 of s3) i3.push(e4);
              }
            }
            return r2;
          }
          function dt(e2, t2) {
            const i2 = e2.getRenderableIds().map((t3) => e2.getTileByID(t3)), o2 = [], s2 = {};
            for (let e3 = 0; e3 < i2.length; e3++) {
              const r2 = i2[e3], n2 = r2.tileID.canonical.key;
              s2[n2] || (s2[n2] = true, r2.querySourceFeatures(o2, t2));
            }
            return o2;
          }
          function ut(e2, t2) {
            const i2 = e2.tileID, o2 = t2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          function _t(e2, t2) {
            const i2 = {};
            if (!t2) return i2;
            for (const o2 of e2) {
              const e3 = o2.layerIds.map((e4) => t2.getLayer(e4)).filter(Boolean);
              if (0 !== e3.length) {
                o2.layers = e3, o2.stateDependentLayerIds && (o2.stateDependentLayers = o2.stateDependentLayerIds.map((t3) => e3.filter((e4) => e4.id === t3)[0]));
                for (const t3 of e3) i2[t3.fqid] = o2;
              }
            }
            return i2;
          }
          const pt = 32, ft = 33, mt = new Uint16Array(8184);
          for (let e2 = 0; e2 < 2046; e2++) {
            let t2 = e2 + 2, i2 = 0, o2 = 0, s2 = 0, r2 = 0, n2 = 0, a2 = 0;
            for (1 & t2 ? s2 = r2 = n2 = pt : i2 = o2 = a2 = pt; (t2 >>= 1) > 1; ) {
              const e3 = i2 + s2 >> 1, l3 = o2 + r2 >> 1;
              1 & t2 ? (s2 = i2, r2 = o2, i2 = n2, o2 = a2) : (i2 = s2, o2 = r2, s2 = n2, r2 = a2), n2 = e3, a2 = l3;
            }
            const l2 = 4 * e2;
            mt[l2 + 0] = i2, mt[l2 + 1] = o2, mt[l2 + 2] = s2, mt[l2 + 3] = r2;
          }
          const gt = new Uint16Array(2178), vt = new Uint8Array(1089), yt = new Uint16Array(1089);
          function xt(e2) {
            return 0 === e2 ? -0.03125 : 32 === e2 ? 0.03125 : 0;
          }
          const bt = (() => ({ type: 2, extent: e.aj, loadGeometry: () => [[new e.P(0, 0), new e.P(e.aj + 1, 0), new e.P(e.aj + 1, e.aj + 1), new e.P(0, e.aj + 1), new e.P(0, 0)]] }))();
          class wt {
            constructor(t2, i2, o2, s2, r2) {
              this.tileID = t2, this.uid = e.a$(), this.uses = 0, this.tileSize = i2, this.tileZoom = o2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.isRaster = r2, s2 && s2.style && (this._lastUpdatedBrightness = s2.style.getBrightness()), this.expiredRequestCount = 0, this.state = "loading", s2 && s2.transform && (this.projection = s2.transform.projection);
            }
            registerFadeDuration(t2) {
              const i2 = t2 + this.timeAdded;
              i2 < e.q.now() || this.fadeEndTime && i2 < this.fadeEndTime || (this.fadeEndTime = i2);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            get tileTransform() {
              return this._tileTransform || (this._tileTransform = e.aW(this.tileID.canonical, this.projection)), this._tileTransform;
            }
            loadVectorData(t2, i2, o2) {
              if (this.unloadVectorData(), this.state = "loaded", t2) {
                t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = _t(t2.buckets, i2.style), this.hasSymbolBuckets = false;
                for (const t3 in this.buckets) {
                  const i3 = this.buckets[t3];
                  if (i3 instanceof e.b1) {
                    if (this.hasSymbolBuckets = true, !o2) break;
                    i3.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets) for (const t3 in this.buckets) {
                  const i3 = this.buckets[t3];
                  if (i3 instanceof e.b1 && i3.hasRTLText) {
                    this.hasRTLText = true, e.b2();
                    break;
                  }
                }
                this.queryPadding = 0;
                for (const e2 in this.buckets) {
                  const t3 = this.buckets[e2], o3 = i2.style.getOwnLayer(e2);
                  if (!o3) continue;
                  const s2 = o3.queryRadius(t3);
                  this.queryPadding = Math.max(this.queryPadding, s2);
                }
                t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage), t2.lineAtlas && (this.lineAtlas = t2.lineAtlas), this._lastUpdatedBrightness = t2.brightness;
              } else this.collisionBoxArray = new e.b0();
            }
            unloadVectorData() {
              if (this.hasData()) {
                for (const e2 in this.buckets) this.buckets[e2].destroy();
                this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.lineAtlasTexture && this.lineAtlasTexture.destroy(), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), this.latestFeatureIndex = null, this.state = "unloaded";
              }
            }
            loadModelData(e2, t2, i2) {
              e2 && (e2.resourceTiming && (this.resourceTiming = e2.resourceTiming), this.buckets = Object.assign({}, this.buckets, _t(e2.buckets, t2.style)), e2.featureIndex && (this.latestFeatureIndex = e2.featureIndex));
            }
            getBucket(e2) {
              return this.buckets[e2.fqid];
            }
            upload(t2) {
              for (const e2 in this.buckets) {
                const i3 = this.buckets[e2];
                i3.uploadPending() && i3.upload(t2);
              }
              const i2 = t2.gl, o2 = this.imageAtlas;
              o2 && !o2.uploaded && (this.imageAtlasTexture = new e.T(t2, o2.image, i2.RGBA8, { useMipmap: !!o2.patternPositions.size }), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new e.T(t2, this.glyphAtlasImage, i2.R8), this.glyphAtlasImage = null), this.lineAtlas && !this.lineAtlas.uploaded && (this.lineAtlasTexture = new e.T(t2, this.lineAtlas.image, i2.R8), this.lineAtlas.uploaded = true);
            }
            prepare(e2, t2, i2) {
              if (this.imageAtlas && this.imageAtlasTexture && this.imageAtlas.patchUpdatedImages(e2, this.imageAtlasTexture, i2), !t2 || !this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData) return;
              const o2 = t2.style.getBrightness();
              (this._lastUpdatedBrightness || o2) && (this._lastUpdatedBrightness && o2 && Math.abs(this._lastUpdatedBrightness - o2) < 1e-3 || (this.updateBuckets(t2, this._lastUpdatedBrightness !== o2), this._lastUpdatedBrightness = o2));
            }
            queryRenderedFeatures(t2, i2, o2, s2, r2, n2) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData && !this.latestFeatureIndex.is3DTile) return {};
              const a2 = function(t3, i3) {
                const o3 = e.bn([], [0.5 * t3.width, 0.5 * -t3.height, 1]);
                return e.bo(o3, o3, [1, -1, 0]), e.az(o3, o3, t3.calculateProjMatrix(i3.toUnwrapped())), Float32Array.from(o3);
              }(r2, this.tileID);
              return this.latestFeatureIndex.query(t2, { tilespaceGeometry: i2, pixelPosMatrix: a2, transform: s2, availableImages: o2, tileTransform: this.tileTransform });
            }
            querySourceFeatures(t2, i2) {
              const o2 = this.latestFeatureIndex;
              if (!o2 || !o2.rawTileData) return;
              const s2 = o2.loadVTLayers(), r2 = i2 ? i2.sourceLayer : "", n2 = s2._geojsonTileLayer || s2[r2];
              if (!n2) return;
              const a2 = e.b3(i2 && i2.filter), { z: l2, x: c2, y: h2 } = this.tileID.canonical, d2 = { z: l2, x: c2, y: h2 };
              for (let i3 = 0; i3 < n2.length; i3++) {
                const s3 = n2.feature(i3);
                if (a2.needGeometry) {
                  const t3 = e.b4(s3, true);
                  if (!a2.filter(new e.aa(this.tileID.overscaledZ), t3, this.tileID.canonical)) continue;
                } else if (!a2.filter(new e.aa(this.tileID.overscaledZ), s3)) continue;
                const u5 = o2.getId(s3, r2), _2 = new e.b5(s3, l2, c2, h2, u5);
                _2.tile = d2, t2.push(_2);
              }
            }
            loaded() {
              return "loaded" === this.state || "errored" === this.state;
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return !!this.imageAtlas && !!this.imageAtlas.patternPositions.size;
            }
            setExpiryData(t2) {
              const i2 = this.expirationTime;
              if (t2.cacheControl) {
                const i3 = e.b6(t2.cacheControl);
                i3["max-age"] && (this.expirationTime = Date.now() + 1e3 * i3["max-age"]);
              } else t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
              if (this.expirationTime) {
                const e2 = Date.now();
                let t3 = false;
                if (this.expirationTime > e2) t3 = false;
                else if (i2) if (this.expirationTime < i2) t3 = true;
                else {
                  const o2 = this.expirationTime - i2;
                  o2 ? this.expirationTime = e2 + Math.max(o2, 3e4) : t3 = true;
                }
                else t3 = true;
                t3 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime) return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            refreshFeatureState(e2) {
              this.latestFeatureIndex && (this.latestFeatureIndex.rawTileData || this.latestFeatureIndex.is3DTile) && e2 && this.updateBuckets(e2);
            }
            updateBuckets(t2, i2) {
              if (!this.latestFeatureIndex) return;
              if (!t2.style) return;
              const o2 = this.latestFeatureIndex.loadVTLayers(), s2 = t2.style.listImages(), r2 = t2.style.getBrightness();
              for (const n2 in this.buckets) {
                if (!t2.style.hasLayer(n2)) continue;
                const a2 = this.buckets[n2], l2 = a2.layers[0], c2 = l2.sourceLayer || "_geojsonTileLayer", h2 = o2[c2], d2 = t2.style.getLayerSourceCache(l2);
                let u5 = {};
                d2 && (u5 = d2._state.getState(c2, void 0));
                const _2 = this.imageAtlas ? Object.fromEntries(this.imageAtlas.patternPositions) : {}, p2 = Object.keys(u5).length > 0 && !i2;
                p2 && !a2.stateDependentLayers.length && !i2 || a2.update(u5, h2, s2, _2, p2 ? a2.stateDependentLayers : a2.layers, i2, r2), (a2 instanceof e.b7 || a2 instanceof e.b8) && t2._terrain && t2._terrain.enabled && d2 && a2.uploadPending() && t2._terrain._clearRenderCacheForTile(d2.id, this.tileID);
                const f2 = t2 && t2.style && t2.style.getOwnLayer(n2);
                f2 && (this.queryPadding = Math.max(this.queryPadding, f2.queryRadius(a2)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < e.q.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(t2) {
              this.symbolFadeHoldUntil = e.q.now() + t2;
            }
            setTexture(t2, i2) {
              const o2 = i2.context, s2 = o2.gl;
              this.texture = this.texture || i2.getTileTexture(t2.width), this.texture && this.texture instanceof e.T ? this.texture.update(t2) : (this.texture = new e.T(o2, t2, s2.RGBA8, { useMipmap: true }), this.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE));
            }
            setDependencies(e2, t2) {
              const i2 = {};
              for (const e3 of t2) i2[e3] = true;
              this.dependencies[e2] = i2;
            }
            hasDependency(e2, t2) {
              for (const i2 of e2) {
                const e3 = this.dependencies[i2];
                if (e3) {
                  for (const i3 of t2) if (e3[i3]) return true;
                }
              }
              return false;
            }
            clearQueryDebugViz() {
            }
            _makeDebugTileBoundsBuffers(t2, i2) {
              if (!i2 || "mercator" === i2.name || this._tileDebugBuffer) return;
              const o2 = e.b9(bt, this.tileID.canonical, this.tileTransform)[0], s2 = new e.ba(), r2 = new e.bb();
              for (let e2 = 0; e2 < o2.length; e2++) {
                const { x: t3, y: i3 } = o2[e2];
                s2.emplaceBack(t3, i3), r2.emplaceBack(e2);
              }
              r2.emplaceBack(0), this._tileDebugIndexBuffer = t2.createIndexBuffer(r2), this._tileDebugBuffer = t2.createVertexBuffer(s2, e.bc.members), this._tileDebugSegments = e.bd.simpleSegment(0, 0, s2.length, r2.length);
            }
            _makeTileBoundsBuffers(t2, i2) {
              if (this._tileBoundsBuffer || !i2 || "mercator" === i2.name) return;
              const o2 = e.b9(bt, this.tileID.canonical, this.tileTransform)[0];
              let s2, r2;
              if (this.isRaster) {
                const t3 = function(t4, i3) {
                  const o3 = e.aW(t4, i3), s3 = Math.pow(2, t4.z);
                  for (let r4 = 0; r4 < ft; r4++) for (let n3 = 0; n3 < ft; n3++) {
                    const a3 = e.aX((t4.x + (n3 + xt(n3)) / pt) / s3), l3 = e.aY((t4.y + (r4 + xt(r4)) / pt) / s3), c3 = i3.project(a3, l3), h2 = r4 * ft + n3;
                    gt[2 * h2 + 0] = Math.round((c3.x * o3.scale - o3.x) * e.aj), gt[2 * h2 + 1] = Math.round((c3.y * o3.scale - o3.y) * e.aj);
                  }
                  vt.fill(0), yt.fill(0);
                  for (let e2 = 2045; e2 >= 0; e2--) {
                    const t5 = 4 * e2, i4 = mt[t5 + 0], o4 = mt[t5 + 1], s4 = mt[t5 + 2], r4 = mt[t5 + 3], n3 = i4 + s4 >> 1, a3 = o4 + r4 >> 1, l3 = n3 + a3 - o4, c3 = a3 + i4 - n3, h2 = o4 * ft + i4, d2 = r4 * ft + s4, u5 = a3 * ft + n3, _2 = Math.hypot((gt[2 * h2 + 0] + gt[2 * d2 + 0]) / 2 - gt[2 * u5 + 0], (gt[2 * h2 + 1] + gt[2 * d2 + 1]) / 2 - gt[2 * u5 + 1]) >= 16;
                    vt[u5] = vt[u5] || (_2 ? 1 : 0), e2 < 1022 && (vt[u5] = vt[u5] || vt[(o4 + c3 >> 1) * ft + (i4 + l3 >> 1)] || vt[(r4 + c3 >> 1) * ft + (s4 + l3 >> 1)]);
                  }
                  const r3 = new e.aZ(), n2 = new e.a_();
                  let a2 = 0;
                  function l2(t5, i4) {
                    const o4 = i4 * ft + t5;
                    return 0 === yt[o4] && (r3.emplaceBack(gt[2 * o4 + 0], gt[2 * o4 + 1], t5 * e.aj / pt, i4 * e.aj / pt), yt[o4] = ++a2), yt[o4] - 1;
                  }
                  function c2(e2, t5, i4, o4, s4, r4) {
                    const a3 = e2 + i4 >> 1, h2 = t5 + o4 >> 1;
                    if (Math.abs(e2 - s4) + Math.abs(t5 - r4) > 1 && vt[h2 * ft + a3]) c2(s4, r4, e2, t5, a3, h2), c2(i4, o4, s4, r4, a3, h2);
                    else {
                      const a4 = l2(e2, t5), c3 = l2(i4, o4), h3 = l2(s4, r4);
                      n2.emplaceBack(a4, c3, h3);
                    }
                  }
                  return c2(0, 0, pt, pt, pt, 0), c2(pt, pt, 0, 0, 0, pt), { vertices: r3, indices: n2 };
                }(this.tileID.canonical, i2);
                s2 = t3.vertices, r2 = t3.indices;
              } else {
                s2 = new e.aZ(), r2 = new e.a_();
                for (const { x: e2, y: t4 } of o2) s2.emplaceBack(e2, t4, 0, 0);
                const t3 = e.be(s2.int16.subarray(0, 4 * s2.length), void 0, 4);
                for (let e2 = 0; e2 < t3.length; e2 += 3) r2.emplaceBack(t3[e2], t3[e2 + 1], t3[e2 + 2]);
              }
              this._tileBoundsBuffer = t2.createVertexBuffer(s2, e.bf.members), this._tileBoundsIndexBuffer = t2.createIndexBuffer(r2), this._tileBoundsSegments = e.bd.simpleSegment(0, 0, s2.length, r2.length);
            }
            _makeGlobeTileDebugBuffers(t2, i2) {
              const o2 = i2.projection;
              if (!o2 || "globe" !== o2.name || i2.freezeTileCoverage) return;
              const s2 = this.tileID.canonical, r2 = e.bg(s2, i2), n2 = e.bh(r2), a2 = e.ah(i2.zoom);
              let l2;
              a2 > 0 && (l2 = e.bi(new Float64Array(16), i2.globeMatrix)), this._makeGlobeTileDebugBorderBuffer(t2, s2, i2, n2, l2, a2), this._makeGlobeTileDebugTextBuffer(t2, s2, i2, n2, l2, a2);
            }
            _globePoint(t2, i2, o2, s2, r2, n2, a2) {
              let l2 = e.bj(t2, i2, o2);
              if (n2) {
                const r3 = 1 << o2.z, c2 = e.ay(s2.center.lng), h2 = e.aH(s2.center.lat), d2 = (o2.x + 0.5) / r3 - c2;
                let u5 = 0;
                d2 > 0.5 ? u5 = -1 : d2 < -0.5 && (u5 = 1);
                let _2 = (t2 / e.aj + o2.x) / r3 + u5, p2 = (i2 / e.aj + o2.y) / r3;
                _2 = (_2 - c2) * s2._pixelsPerMercatorPixel + c2, p2 = (p2 - h2) * s2._pixelsPerMercatorPixel + h2;
                const f2 = [_2 * s2.worldSize, p2 * s2.worldSize, 0];
                e.ad(f2, f2, n2), l2 = e.bk(l2, f2, a2);
              }
              return e.ad(l2, l2, r2);
            }
            _makeGlobeTileDebugBorderBuffer(t2, i2, o2, s2, r2, n2) {
              const a2 = new e.ba(), l2 = new e.bb(), c2 = new e.bl(), h2 = (e2, t3, h3, d3, u5) => {
                const _2 = (h3 - e2) / (u5 - 1), p2 = (d3 - t3) / (u5 - 1), f2 = a2.length;
                for (let h4 = 0; h4 < u5; h4++) {
                  const d4 = e2 + h4 * _2, u6 = t3 + h4 * p2;
                  a2.emplaceBack(d4, u6);
                  const m2 = this._globePoint(d4, u6, i2, o2, s2, r2, n2);
                  c2.emplaceBack(m2[0], m2[1], m2[2]), l2.emplaceBack(f2 + h4);
                }
              }, d2 = e.aj;
              h2(0, 0, d2, 0, 16), h2(d2, 0, d2, d2, 16), h2(d2, d2, 0, d2, 16), h2(0, d2, 0, 0, 16), this._tileDebugIndexBuffer = t2.createIndexBuffer(l2), this._tileDebugBuffer = t2.createVertexBuffer(a2, e.bc.members), this._globeTileDebugBorderBuffer = t2.createVertexBuffer(c2, e.bm.members), this._tileDebugSegments = e.bd.simpleSegment(0, 0, a2.length, l2.length);
            }
            _makeGlobeTileDebugTextBuffer(t2, i2, o2, s2, r2, n2) {
              const a2 = e.aj / 4, l2 = new e.ba(), c2 = new e.a_(), h2 = new e.bl(), d2 = 25;
              c2.reserve(32), l2.reserve(d2), h2.reserve(d2);
              const u5 = (e2, t3) => d2 * e2 + t3;
              for (let e2 = 0; e2 < d2; e2++) {
                const t3 = e2 * a2;
                for (let e3 = 0; e3 < d2; e3++) {
                  const c3 = e3 * a2;
                  l2.emplaceBack(c3, t3);
                  const d3 = this._globePoint(c3, t3, i2, o2, s2, r2, n2);
                  h2.emplaceBack(d3[0], d3[1], d3[2]);
                }
              }
              for (let e2 = 0; e2 < 4; e2++) for (let t3 = 0; t3 < 4; t3++) {
                const i3 = u5(e2, t3), o3 = u5(e2, t3 + 1), s3 = u5(e2 + 1, t3), r3 = u5(e2 + 1, t3 + 1);
                c2.emplaceBack(i3, o3, s3), c2.emplaceBack(s3, o3, r3);
              }
              this._tileDebugTextIndexBuffer = t2.createIndexBuffer(c2), this._tileDebugTextBuffer = t2.createVertexBuffer(l2, e.bc.members), this._globeTileDebugTextBuffer = t2.createVertexBuffer(h2, e.bm.members), this._tileDebugTextSegments = e.bd.simpleSegment(0, 0, d2, 32);
            }
            destroy(t2 = false) {
              for (const e2 in this.buckets) this.buckets[e2].destroy();
              this.buckets = {}, this.imageAtlas && (this.imageAtlas = null), this.lineAtlas && (this.lineAtlas = null), this.imageAtlasTexture && (this.imageAtlasTexture.destroy(), delete this.imageAtlasTexture), this.glyphAtlasTexture && (this.glyphAtlasTexture.destroy(), delete this.glyphAtlasTexture), this.lineAtlasTexture && (this.lineAtlasTexture.destroy(), delete this.lineAtlasTexture), this._tileBoundsBuffer && (this._tileBoundsBuffer.destroy(), this._tileBoundsIndexBuffer.destroy(), this._tileBoundsSegments.destroy(), this._tileBoundsBuffer = null), this._tileDebugBuffer && (this._tileDebugBuffer.destroy(), this._tileDebugSegments.destroy(), this._tileDebugBuffer = null), this._tileDebugIndexBuffer && (this._tileDebugIndexBuffer.destroy(), this._tileDebugIndexBuffer = null), this._globeTileDebugBorderBuffer && (this._globeTileDebugBorderBuffer.destroy(), this._globeTileDebugBorderBuffer = null), this._tileDebugTextBuffer && (this._tileDebugTextBuffer.destroy(), this._tileDebugTextSegments.destroy(), this._tileDebugTextIndexBuffer.destroy(), this._tileDebugTextBuffer = null), this._globeTileDebugTextBuffer && (this._globeTileDebugTextBuffer.destroy(), this._globeTileDebugTextBuffer = null), !t2 && this.texture && this.texture instanceof e.T && (this.texture.destroy(), delete this.texture), this.hillshadeFBO && (this.hillshadeFBO.destroy(), delete this.hillshadeFBO), this.dem && delete this.dem, this.neighboringTiles && delete this.neighboringTiles, this.demTexture && (this.demTexture.destroy(), delete this.demTexture), this.rasterParticleState && (this.rasterParticleState.destroy(), delete this.rasterParticleState), this.latestFeatureIndex = null, this.state = "unloaded";
            }
          }
          e.bp.setPbf(e.bq);
          class Tt extends wt {
            constructor(e2, t2, i2, o2, s2) {
              super(e2, t2, i2, o2, s2), this._workQueue = [], this._fetchQueue = [], this._isHeaderLoaded = false;
            }
            getLayers() {
              return this._mrt ? Object.values(this._mrt.layers) : [];
            }
            getLayer(e2) {
              return this._mrt && this._mrt.getLayer(e2);
            }
            setTexture(t2, i2) {
              const o2 = i2.context, s2 = o2.gl;
              this.texture = this.texture || i2.getTileTexture(t2.width), this.texture && this.texture instanceof e.T ? this.texture.update(t2, { premultiply: false }) : this.texture = new e.T(o2, t2, s2.RGBA8, { premultiply: false });
            }
            flushQueues() {
              for (; this._workQueue.length; ) this._workQueue.pop()();
              for (; this._fetchQueue.length; ) this._fetchQueue.pop()();
            }
            fetchHeader(t2 = 16384, i2) {
              const o2 = this._mrt = new e.bp(30), s2 = Object.assign({}, this.requestParams, { headers: { Range: "bytes=0-" + (t2 - 1) } });
              return this.entireBuffer = null, this.request = e.br(s2, (e2, s3, r2, n2) => {
                if (e2) i2(e2);
                else try {
                  const e3 = o2.getHeaderLength(s3);
                  if (e3 > t2) return void (this.request = this.fetchHeader(e3, i2));
                  o2.parseHeader(s3), this._isHeaderLoaded = true;
                  let a2 = 0;
                  for (const e4 of Object.values(o2.layers)) a2 = Math.max(a2, e4.dataIndex[e4.dataIndex.length - 1].lastByte);
                  s3.byteLength >= a2 && (this.entireBuffer = s3), i2(null, this.entireBuffer || s3, r2, n2);
                } catch (e3) {
                  i2(e3);
                }
              }), this.request;
            }
            fetchBand(t2, i2, o2) {
              const s2 = this._mrt;
              if (!this._isHeaderLoaded || !s2) return void o2(new Error("Tile header is not ready"));
              const r2 = this.actor;
              if (!r2) return void o2(new Error("Can't fetch tile band without an actor"));
              let n2;
              const a2 = (e2, s3) => {
                n2.complete(e2, s3), e2 ? o2(e2) : (this.updateTextureDescriptor(t2, i2), o2(null, this.textureDescriptor && this.textureDescriptor.img));
              }, l2 = (e2, t3) => {
                if (e2) return o2(e2);
                const i3 = r2.send("decodeRasterArray", { type: "raster-array", source: this.source, scope: this.scope, tileID: this.tileID, uid: this.uid, buffer: t3, task: n2 }, a2, void 0, true);
                this._workQueue.push(() => {
                  i3 && i3.cancel(), n2.cancel();
                });
              }, c2 = s2.getLayer(t2);
              if (!c2) return void o2(new Error(`Unknown sourceLayer "${t2}"`));
              if (c2.hasDataForBand(i2)) return this.updateTextureDescriptor(t2, i2), void o2(null, this.textureDescriptor ? this.textureDescriptor.img : null);
              const h2 = c2.getDataRange([i2]);
              if (n2 = s2.createDecodingTask(h2), !n2 || n2.tasks.length) if (this.flushQueues(), this.entireBuffer) l2(null, this.entireBuffer.slice(h2.firstByte, h2.lastByte + 1));
              else {
                const t3 = Object.assign({}, this.requestParams, { headers: { Range: `bytes=${h2.firstByte}-${h2.lastByte}` } }), i3 = e.br(t3, l2);
                this._fetchQueue.push(() => {
                  i3.cancel(), n2.cancel();
                });
              }
              else o2(null);
            }
            updateNeeded(e2, t2) {
              return (!this.textureDescriptor || this.textureDescriptor.band !== t2 || this.textureDescriptor.layer !== e2) && "errored" !== this.state;
            }
            updateTextureDescriptor(t2, i2) {
              if (!this._mrt) return;
              const o2 = this._mrt.getLayer(t2);
              if (!o2 || !o2.hasBand(i2) || !o2.hasDataForBand(i2)) return;
              const { bytes: s2, tileSize: r2, buffer: n2, offset: a2, scale: l2 } = o2.getBandView(i2), c2 = r2 + 2 * n2, h2 = new e.r({ width: c2, height: c2 }, s2), d2 = this.texture;
              d2 && d2 instanceof e.T && d2.update(h2, { premultiply: false }), this.textureDescriptor = { layer: t2, band: i2, img: h2, buffer: n2, offset: a2, tileSize: r2, format: o2.pixelFormat, mix: [l2, 256 * l2, 65536 * l2, 16777216 * l2] };
            }
          }
          class Et {
            constructor(e2, t2) {
              this.max = e2, this.onRemove = t2, this.reset();
            }
            reset() {
              for (const e2 in this.data) for (const t2 of this.data[e2]) t2.timeout && clearTimeout(t2.timeout), this.onRemove(t2.value);
              return this.data = {}, this.order = [], this;
            }
            add(e2, t2, i2) {
              const o2 = e2.wrapped().key;
              void 0 === this.data[o2] && (this.data[o2] = []);
              const s2 = { value: t2, timeout: void 0 };
              if (void 0 !== i2 && (s2.timeout = setTimeout(() => {
                this.remove(e2, s2);
              }, i2)), this.data[o2].push(s2), this.order.push(o2), this.order.length > this.max) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            has(e2) {
              return e2.wrapped().key in this.data;
            }
            getAndRemove(e2) {
              return this.has(e2) ? this._getAndRemoveByKey(e2.wrapped().key) : null;
            }
            _getAndRemoveByKey(e2) {
              const t2 = this.data[e2].shift();
              return t2.timeout && clearTimeout(t2.timeout), 0 === this.data[e2].length && delete this.data[e2], this.order.splice(this.order.indexOf(e2), 1), t2.value;
            }
            getByKey(e2) {
              const t2 = this.data[e2];
              return t2 ? t2[0].value : null;
            }
            get(e2) {
              return this.has(e2) ? this.data[e2.wrapped().key][0].value : null;
            }
            remove(e2, t2) {
              if (!this.has(e2)) return this;
              const i2 = e2.wrapped().key, o2 = void 0 === t2 ? 0 : this.data[i2].indexOf(t2), s2 = this.data[i2][o2];
              return this.data[i2].splice(o2, 1), s2.timeout && clearTimeout(s2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(s2.value), this.order.splice(this.order.indexOf(i2), 1), this;
            }
            setMaxSize(e2) {
              for (this.max = e2; this.order.length > this.max; ) {
                const e3 = this._getAndRemoveByKey(this.order[0]);
                e3 && this.onRemove(e3);
              }
              return this;
            }
            filter(e2) {
              const t2 = [];
              for (const i2 in this.data) for (const o2 of this.data[i2]) e2(o2.value) || t2.push(o2);
              for (const e3 of t2) this.remove(e3.value.tileID, e3);
            }
          }
          class St {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(t2, i2, o2) {
              const s2 = String(i2);
              if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][s2] = this.stateChanges[t2][s2] || {}, e.l(this.stateChanges[t2][s2], o2), null === this.deletedStates[t2]) {
                this.deletedStates[t2] = {};
                for (const e2 in this.state[t2]) e2 !== s2 && (this.deletedStates[t2][e2] = null);
              } else if (this.deletedStates[t2] && null === this.deletedStates[t2][s2]) {
                this.deletedStates[t2][s2] = {};
                for (const e2 in this.state[t2][s2]) o2[e2] || (this.deletedStates[t2][s2][e2] = null);
              } else for (const e2 in o2) this.deletedStates[t2] && this.deletedStates[t2][s2] && null === this.deletedStates[t2][s2][e2] && delete this.deletedStates[t2][s2][e2];
            }
            removeFeatureState(e2, t2, i2) {
              if (null === this.deletedStates[e2]) return;
              const o2 = String(t2);
              if (this.deletedStates[e2] = this.deletedStates[e2] || {}, i2 && void 0 !== t2) null !== this.deletedStates[e2][o2] && (this.deletedStates[e2][o2] = this.deletedStates[e2][o2] || {}, this.deletedStates[e2][o2][i2] = null);
              else if (void 0 !== t2) if (this.stateChanges[e2] && this.stateChanges[e2][o2]) for (i2 in this.deletedStates[e2][o2] = {}, this.stateChanges[e2][o2]) this.deletedStates[e2][o2][i2] = null;
              else this.deletedStates[e2][o2] = null;
              else this.deletedStates[e2] = null;
            }
            getState(t2, i2) {
              const o2 = this.state[t2] || {}, s2 = this.stateChanges[t2] || {}, r2 = this.deletedStates[t2];
              if (null === r2) return {};
              if (void 0 !== i2) {
                const t3 = String(i2), n3 = e.l({}, o2[t3], s2[t3]);
                if (r2) {
                  const e2 = r2[i2];
                  if (null === e2) return {};
                  for (const t4 in e2) delete n3[t4];
                }
                return n3;
              }
              const n2 = e.l({}, o2, s2);
              if (r2) for (const e2 in r2) delete n2[e2];
              return n2;
            }
            initializeTileState(e2, t2) {
              e2.refreshFeatureState(t2);
            }
            coalesceChanges(t2, i2) {
              const o2 = {};
              for (const t3 in this.stateChanges) {
                this.state[t3] = this.state[t3] || {};
                const i3 = {};
                for (const o3 in this.stateChanges[t3]) this.state[t3][o3] || (this.state[t3][o3] = {}), e.l(this.state[t3][o3], this.stateChanges[t3][o3]), i3[o3] = this.state[t3][o3];
                o2[t3] = i3;
              }
              for (const t3 in this.deletedStates) {
                this.state[t3] = this.state[t3] || {};
                const i3 = {};
                if (null === this.deletedStates[t3]) for (const e2 in this.state[t3]) i3[e2] = {}, this.state[t3][e2] = {};
                else for (const e2 in this.deletedStates[t3]) {
                  if (null === this.deletedStates[t3][e2]) this.state[t3][e2] = {};
                  else if (this.state[t3][e2]) for (const i4 of Object.keys(this.deletedStates[t3][e2])) delete this.state[t3][e2][i4];
                  i3[e2] = this.state[t3][e2];
                }
                o2[t3] = o2[t3] || {}, e.l(o2[t3], i3);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(o2).length) for (const e2 in t2) t2[e2].refreshFeatureState(i2);
            }
          }
          class It extends e.E {
            constructor(e2, t2, i2) {
              super(), this.id = e2, this._onlySymbols = i2, t2.on("data", (e3) => {
                "source" === e3.dataType && "metadata" === e3.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === e3.dataType && "content" === e3.sourceDataType && (this.reload(), this.transform && this.update(this.transform));
              }), t2.on("error", () => {
                this._sourceErrored = true;
              }), this._source = t2, this._tiles = {}, this._cache = new Et(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._loadedParentTiles = {}, this.castsShadows = false, this.tileCoverLift = 0, this._coveredTiles = {}, this._shadowCasterTiles = {}, this._state = new St(), this._isRaster = "raster" === this._source.type || "raster-dem" === this._source.type || "raster-array" === this._source.type || "custom" === this._source.type && "raster" === this._source._dataType;
            }
            onAdd(e2) {
              this.map = e2, this._minTileCacheSize = void 0 === this._minTileCacheSize && e2 ? e2._minTileCacheSize : this._minTileCacheSize, this._maxTileCacheSize = void 0 === this._maxTileCacheSize && e2 ? e2._maxTileCacheSize : this._maxTileCacheSize;
            }
            loaded() {
              if (this._sourceErrored) return true;
              if (!this._sourceLoaded) return false;
              if (!this._source.loaded()) return false;
              for (const e2 in this._tiles) if (!this._tiles[e2].loaded()) return false;
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused) return;
              const e2 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, e2 && this.reload(), this.transform && this.update(this.transform);
            }
            _loadTile(e2, t2) {
              return e2.isSymbolTile = this._onlySymbols, e2.isExtraShadowCaster = this._shadowCasterTiles[e2.tileID.key], this._source.loadTile(e2, t2);
            }
            _unloadTile(e2) {
              if (this._source.unloadTile) return this._source.unloadTile(e2);
            }
            _abortTile(e2) {
              if (this._source.abortTile) return this._source.abortTile(e2);
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(e2) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const t2 in this._tiles) {
                const i2 = this._tiles[t2];
                i2.upload(e2), i2.prepare(this.map.style.imageManager, this.map ? this.map.painter : null, this._source.scope);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((e2) => e2.tileID).sort(Ct).map((e2) => e2.key);
            }
            getRenderableIds(t2, i2) {
              const o2 = [];
              for (const e2 in this._tiles) this._isIdRenderable(+e2, t2, i2) && o2.push(this._tiles[e2]);
              return t2 ? o2.sort((t3, i3) => {
                const o3 = t3.tileID, s2 = i3.tileID, r2 = new e.P(o3.canonical.x, o3.canonical.y)._rotate(this.transform.angle), n2 = new e.P(s2.canonical.x, s2.canonical.y)._rotate(this.transform.angle);
                return o3.overscaledZ - s2.overscaledZ || n2.y - r2.y || n2.x - r2.x;
              }).map((e2) => e2.tileID.key) : o2.map((e2) => e2.tileID).sort(Ct).map((e2) => e2.key);
            }
            hasRenderableParent(e2) {
              const t2 = this.findLoadedParent(e2, 0);
              return !!t2 && this._isIdRenderable(t2.tileID.key);
            }
            _isIdRenderable(e2, t2, i2) {
              return this._tiles[e2] && this._tiles[e2].hasData() && !this._coveredTiles[e2] && (t2 || !this._tiles[e2].holdingForFade()) && (i2 || !this._shadowCasterTiles[e2]);
            }
            reload() {
              if (this._paused) this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const e2 in this._tiles) "errored" !== this._tiles[e2].state && this._reloadTile(+e2, "reloading");
              }
            }
            _reloadTile(e2, t2) {
              const i2 = this._tiles[e2];
              i2 && ("loading" !== i2.state && (i2.state = t2), this._loadTile(i2, this._tileLoaded.bind(this, i2, e2, t2)));
            }
            _tileLoaded(t2, i2, o2, s2) {
              if (s2) if (t2.state = "errored", 404 !== s2.status) this._source.fire(new e.z(s2, { tile: t2 }));
              else {
                if (this._source.fire(new e.A("data", { dataType: "source", sourceDataType: "error", sourceId: this._source.id, tile: t2 })), !(t2.tileID.key in this._loadedParentTiles)) return;
                if ("raster-dem" === this._source.type && this.usedForTerrain && this.map.painter.terrain) {
                  const e2 = this.map.painter.terrain;
                  this.update(this.transform, e2.getScaledDemTileSize(), true), e2.resetTileLookupCache(this.id);
                } else this.update(this.transform);
              }
              else t2.timeAdded = e.q.now(), "expired" === o2 && (t2.refreshedUponExpiration = true), this._setTileReloadTimer(i2, t2), "raster-dem" === this._source.type && t2.dem && this._backfillDEM(t2), this._state.initializeTileState(t2, this.map ? this.map.painter : null), this._source.fire(new e.A("data", { dataType: "source", tile: t2, coord: t2.tileID, sourceCacheId: this.id }));
            }
            _backfillDEM(e2) {
              const t2 = this.getRenderableIds();
              for (let o2 = 0; o2 < t2.length; o2++) {
                const s2 = t2[o2];
                if (e2.neighboringTiles && e2.neighboringTiles[s2]) {
                  const t3 = this.getTileByID(s2);
                  i2(e2, t3), i2(t3, e2);
                }
              }
              function i2(e3, t3) {
                if (!e3.dem || e3.dem.borderReady) return;
                e3.needsHillshadePrepare = true, e3.needsDEMTextureUpload = true;
                let i3 = t3.tileID.canonical.x - e3.tileID.canonical.x;
                const o2 = t3.tileID.canonical.y - e3.tileID.canonical.y, s2 = Math.pow(2, e3.tileID.canonical.z), r2 = t3.tileID.key;
                0 === i3 && 0 === o2 || Math.abs(o2) > 1 || (Math.abs(i3) > 1 && (1 === Math.abs(i3 + s2) ? i3 += s2 : 1 === Math.abs(i3 - s2) && (i3 -= s2)), t3.dem && e3.dem && (e3.dem.backfillBorder(t3.dem, i3, o2), e3.neighboringTiles && e3.neighboringTiles[r2] && (e3.neighboringTiles[r2].backfilled = true)));
              }
            }
            getTile(e2) {
              return this.getTileByID(e2.key);
            }
            getTileByID(e2) {
              return this._tiles[e2];
            }
            _retainLoadedChildren(e2, t2, i2, o2) {
              for (const s2 in this._tiles) {
                let r2 = this._tiles[s2];
                if (o2[s2] || !r2.hasData() || r2.tileID.overscaledZ <= t2 || r2.tileID.overscaledZ > i2) continue;
                let n2 = r2.tileID;
                for (; r2 && r2.tileID.overscaledZ > t2 + 1; ) {
                  const e3 = r2.tileID.scaledTo(r2.tileID.overscaledZ - 1);
                  r2 = this._tiles[e3.key], r2 && r2.hasData() && (n2 = e3);
                }
                let a2 = n2;
                for (; a2.overscaledZ > t2; ) if (a2 = a2.scaledTo(a2.overscaledZ - 1), e2[a2.key]) {
                  o2[n2.key] = n2;
                  break;
                }
              }
            }
            findLoadedParent(e2, t2) {
              if (e2.key in this._loadedParentTiles) {
                const i2 = this._loadedParentTiles[e2.key];
                return i2 && i2.tileID.overscaledZ >= t2 ? i2 : null;
              }
              for (let i2 = e2.overscaledZ - 1; i2 >= t2; i2--) {
                const t3 = e2.scaledTo(i2), o2 = this._getLoadedTile(t3);
                if (o2) return o2;
              }
            }
            _getLoadedTile(e2) {
              const t2 = this._tiles[e2.key];
              return t2 && t2.hasData() ? t2 : this._cache.getByKey(this._source.reparseOverscaled ? e2.wrapped().key : e2.canonical.key);
            }
            updateCacheSize(e2, t2) {
              t2 = t2 || this._source.tileSize;
              const i2 = Math.ceil(e2.width / t2) + 1, o2 = Math.ceil(e2.height / t2) + 1, s2 = Math.floor(i2 * o2 * 5), r2 = "number" == typeof this._minTileCacheSize ? Math.max(this._minTileCacheSize, s2) : s2, n2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, r2) : r2;
              this._cache.setMaxSize(n2);
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - (void 0 === this._prevLng ? e2 : this._prevLng)) / 360);
              if (this._prevLng = e2, t2) {
                const e3 = {};
                for (const i2 in this._tiles) {
                  const o2 = this._tiles[i2];
                  o2.tileID = o2.tileID.unwrapTo(o2.tileID.wrap + t2), e3[o2.tileID.key] = o2;
                }
                this._tiles = e3;
                for (const e4 in this._timers) clearTimeout(this._timers[e4]), delete this._timers[e4];
                for (const e4 in this._tiles) this._setTileReloadTimer(+e4, this._tiles[e4]);
              }
            }
            update(t2, i2, o2, s2, r2) {
              if (this.transform = t2, !this._sourceLoaded || this._paused || this.transform.freezeTileCoverage) return;
              if (this.usedForTerrain && !o2) return;
              this.updateCacheSize(t2, i2), "globe" !== this.transform.projection.name && this.handleWrapJump(this.transform.center.lng), this._shadowCasterTiles = {}, this._coveredTiles = {};
              const n2 = "batched-model" === this._source.type;
              let a2, l2 = this._source.maxzoom;
              const c2 = this.map && this.map.painter ? this.map.painter._terrain : null;
              if (c2 && c2.sourceCache === this && c2.attenuationRange()) {
                const e2 = c2.attenuationRange()[0], t3 = Math.floor(e2) - Math.log2(c2.getDemUpscale());
                l2 > t3 && (l2 = t3);
              }
              if (this.used || this.usedForTerrain) {
                if (this._source.tileID) a2 = t2.getVisibleUnwrappedCoordinates(this._source.tileID).map((t3) => new e.aM(t3.canonical.z, t3.wrap, t3.canonical.z, t3.canonical.x, t3.canonical.y));
                else if (0 !== this.tileCoverLift) {
                  const s3 = t2.clone();
                  s3.tileCoverLift = this.tileCoverLift, a2 = s3.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l2, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n2 }), this._source.minzoom <= 1 && "globe" === t2.projection.name && (a2.push(new e.aM(1, 0, 1, 0, 0)), a2.push(new e.aM(1, 0, 1, 1, 0)), a2.push(new e.aM(1, 0, 1, 0, 1)), a2.push(new e.aM(1, 0, 1, 1, 1)));
                } else if (a2 = t2.coveringTiles({ tileSize: i2 || this._source.tileSize, minzoom: this._source.minzoom, maxzoom: l2, roundZoom: this._source.roundZoom && !o2, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain, calculateQuadrantVisibility: n2 }), this._source.hasTile) {
                  const e2 = this._source.hasTile.bind(this._source);
                  a2 = a2.filter((t3) => e2(t3));
                }
              } else a2 = [];
              if (a2.length > 0 && "globe" !== this.transform.projection.name && !this.usedForTerrain && !Rt(this._source.type)) {
                const e2 = t2.coveringZoomLevel({ tileSize: i2 || this._source.tileSize, roundZoom: this._source.roundZoom && !o2 }), l3 = Math.min(e2, this._source.maxzoom);
                if (n2) {
                  const e3 = t2.extendTileCover(a2, l3);
                  for (const t3 of e3) a2.push(t3);
                } else if (r2) {
                  const e3 = t2.extendTileCover(a2, l3, this.transform._camera.forward());
                  for (const t3 of e3) a2.push(t3);
                } else if (this.castsShadows && s2) {
                  const e3 = t2.extendTileCover(a2, l3, s2);
                  for (const t3 of e3) this._shadowCasterTiles[t3.key] = true, a2.push(t3);
                }
              }
              const h2 = this._updateRetainedTiles(a2);
              if (Rt(this._source.type) && 0 !== a2.length) {
                const t3 = {}, i3 = {}, o3 = Object.keys(h2);
                for (const s4 of o3) {
                  const o4 = h2[s4], r3 = this._tiles[s4];
                  if (!r3 || r3.fadeEndTime && r3.fadeEndTime <= e.q.now()) continue;
                  const n3 = this.findLoadedParent(o4, Math.max(o4.overscaledZ - It.maxOverzooming, this._source.minzoom));
                  n3 && (this._addTile(n3.tileID), t3[n3.tileID.key] = n3.tileID), i3[s4] = o4;
                }
                const s3 = a2[a2.length - 1].overscaledZ;
                for (const e2 in this._tiles) {
                  const t4 = this._tiles[e2];
                  if (h2[e2] || !t4.hasData()) continue;
                  let o4 = t4.tileID;
                  for (; o4.overscaledZ > s3; ) {
                    o4 = o4.scaledTo(o4.overscaledZ - 1);
                    const s4 = this._tiles[o4.key];
                    if (s4 && s4.hasData() && i3[o4.key]) {
                      h2[e2] = t4.tileID;
                      break;
                    }
                  }
                }
                for (const e2 in t3) h2[e2] || (this._coveredTiles[e2] = true, h2[e2] = t3[e2]);
              }
              for (const e2 in h2) this._tiles[e2].clearFadeHold();
              const d2 = e.bs(this._tiles, h2);
              for (const e2 of d2) {
                const t3 = this._tiles[e2];
                t3.hasSymbolBuckets && !t3.holdingForFade() ? t3.setHoldDuration(this.map._fadeDuration) : t3.hasSymbolBuckets && !t3.symbolFadeFinished() || this._removeTile(+e2);
              }
              this._updateLoadedParentTileCache(), this._onlySymbols && this._source.afterUpdate && this._source.afterUpdate();
            }
            releaseSymbolFadeTiles() {
              for (const e2 in this._tiles) this._tiles[e2].holdingForFade() && this._removeTile(+e2);
            }
            _updateRetainedTiles(e2) {
              const t2 = {};
              if (0 === e2.length) return t2;
              const i2 = {}, o2 = e2.reduce((e3, t3) => Math.min(e3, t3.overscaledZ), 1 / 0), s2 = e2[0].overscaledZ, r2 = Math.max(s2 - It.maxOverzooming, this._source.minzoom), n2 = Math.max(s2 + It.maxUnderzooming, this._source.minzoom), a2 = {};
              for (const i3 of e2) {
                const e3 = this._addTile(i3);
                t2[i3.key] = i3, e3.hasData() || o2 < this._source.maxzoom && (a2[i3.key] = i3);
              }
              this._retainLoadedChildren(a2, o2, n2, t2);
              for (const o3 of e2) {
                let e3 = this._tiles[o3.key];
                if (e3.hasData()) continue;
                if (o3.canonical.z >= this._source.maxzoom) {
                  const e4 = o3.children(this._source.maxzoom)[0], i3 = this.getTile(e4);
                  if (i3 && i3.hasData()) {
                    t2[e4.key] = e4;
                    continue;
                  }
                } else {
                  const e4 = o3.children(this._source.maxzoom);
                  if (t2[e4[0].key] && t2[e4[1].key] && t2[e4[2].key] && t2[e4[3].key]) continue;
                }
                let s3 = e3.wasRequested();
                for (let n3 = o3.overscaledZ - 1; n3 >= r2; --n3) {
                  const r3 = o3.scaledTo(n3);
                  if (i2[r3.key]) break;
                  if (i2[r3.key] = true, e3 = this.getTile(r3), !e3 && s3 && (e3 = this._addTile(r3)), e3 && (t2[r3.key] = r3, s3 = e3.wasRequested(), e3.hasData())) break;
                }
              }
              return t2;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const e2 in this._tiles) {
                const t2 = [];
                let i2, o2 = this._tiles[e2].tileID;
                for (; o2.overscaledZ > 0; ) {
                  if (o2.key in this._loadedParentTiles) {
                    i2 = this._loadedParentTiles[o2.key];
                    break;
                  }
                  t2.push(o2.key);
                  const e3 = o2.scaledTo(o2.overscaledZ - 1);
                  if (i2 = this._getLoadedTile(e3), i2) break;
                  o2 = e3;
                }
                for (const e3 of t2) this._loadedParentTiles[e3] = i2;
              }
            }
            _addTile(t2) {
              let i2 = this._tiles[t2.key];
              if (i2) return true !== i2.isExtraShadowCaster || !!this._shadowCasterTiles[t2.key] || this._reloadTile(t2.key, "reloading"), i2;
              i2 = this._cache.getAndRemove(t2), i2 && (this._setTileReloadTimer(t2.key, i2), i2.tileID = t2, this._state.initializeTileState(i2, this.map ? this.map.painter : null), this._cacheTimers[t2.key] && (clearTimeout(this._cacheTimers[t2.key]), delete this._cacheTimers[t2.key], this._setTileReloadTimer(t2.key, i2)));
              const o2 = Boolean(i2);
              if (!o2) {
                const e2 = this.map ? this.map.painter : null, o3 = this._source.tileSize * t2.overscaleFactor();
                i2 = "raster-array" === this._source.type ? new Tt(t2, o3, this.transform.tileZoom, e2, this._isRaster) : new wt(t2, o3, this.transform.tileZoom, e2, this._isRaster), this._loadTile(i2, this._tileLoaded.bind(this, i2, t2.key, i2.state));
              }
              return i2.uses++, this._tiles[t2.key] = i2, o2 || this._source.fire(new e.A("dataloading", { tile: i2, coord: i2.tileID, dataType: "source" })), i2;
            }
            _setTileReloadTimer(e2, t2) {
              e2 in this._timers && (clearTimeout(this._timers[e2]), delete this._timers[e2]);
              const i2 = t2.getExpiryTimeout();
              i2 && (this._timers[e2] = setTimeout(() => {
                this._reloadTile(e2, "expired"), delete this._timers[e2];
              }, i2));
            }
            _removeTile(e2) {
              const t2 = this._tiles[e2];
              t2 && (t2.uses--, delete this._tiles[e2], this._timers[e2] && (clearTimeout(this._timers[e2]), delete this._timers[e2]), t2.uses > 0 || (t2.hasData() && "reloading" !== t2.state || "empty" === t2.state ? this._cache.add(t2.tileID, t2, t2.getExpiryTimeout()) : (t2.aborted = true, this._abortTile(t2), this._unloadTile(t2))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const e2 in this._tiles) this._removeTile(+e2);
              this._source._clear && this._source._clear(), this._cache.reset(), this.map && this.usedForTerrain && this.map.painter.terrain && this.map.painter.terrain.resetTileLookupCache(this.id);
            }
            tilesIn(t2, i2, o2) {
              const s2 = [], r2 = this.transform;
              if (!r2) return s2;
              const n2 = "globe" === r2.projection.name, a2 = e.ay(r2.center.lng);
              for (const l2 in this._tiles) {
                const c2 = this._tiles[l2];
                if (o2 && c2.clearQueryDebugViz(), c2.holdingForFade()) continue;
                let h2;
                if (n2) {
                  const t3 = c2.tileID.canonical;
                  if (0 === t3.z) {
                    const i3 = [Math.abs(e.aD(a2, ...Dt(t3, -1)) - a2), Math.abs(e.aD(a2, ...Dt(t3, 1)) - a2)];
                    h2 = [0, 2 * i3.indexOf(Math.min(...i3)) - 1];
                  } else {
                    const i3 = [Math.abs(e.aD(a2, ...Dt(t3, -1)) - a2), Math.abs(e.aD(a2, ...Dt(t3, 0)) - a2), Math.abs(e.aD(a2, ...Dt(t3, 1)) - a2)];
                    h2 = [i3.indexOf(Math.min(...i3)) - 1];
                  }
                } else h2 = [0];
                for (const e2 of h2) {
                  const o3 = t2.containsTile(c2, r2, i2, e2);
                  o3 && s2.push(o3);
                }
              }
              return s2;
            }
            getShadowCasterCoordinates() {
              return this._getRenderableCoordinates(false, true);
            }
            getVisibleCoordinates(e2) {
              return this._getRenderableCoordinates(e2);
            }
            _getRenderableCoordinates(e2, t2) {
              const i2 = this.getRenderableIds(e2, t2).map((e3) => this._tiles[e3].tileID), o2 = "globe" === this.transform.projection.name;
              for (const e3 of i2) e3.projMatrix = this.transform.calculateProjMatrix(e3.toUnwrapped()), e3.expandedProjMatrix = o2 ? this.transform.calculateProjMatrix(e3.toUnwrapped(), false, true) : e3.projMatrix;
              return i2;
            }
            sortCoordinatesByDistance(e2) {
              const t2 = e2.slice(), i2 = this.transform._camera.position, o2 = this.transform._camera.forward(), s2 = {};
              for (const e3 of t2) {
                const t3 = 1 / (1 << e3.canonical.z);
                s2[e3.key] = ((e3.canonical.x + 0.5) * t3 + e3.wrap - i2[0]) * o2[0] + ((e3.canonical.y + 0.5) * t3 - i2[1]) * o2[1] - i2[2] * o2[2];
              }
              return t2.sort((e3, t3) => s2[e3.key] - s2[t3.key]), t2;
            }
            hasTransition() {
              if (this._source.hasTransition()) return true;
              if (Rt(this._source.type)) for (const t2 in this._tiles) {
                const i2 = this._tiles[t2];
                if (void 0 !== i2.fadeEndTime && i2.fadeEndTime >= e.q.now()) return true;
              }
              return false;
            }
            setFeatureState(e2, t2, i2) {
              this._state.updateState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            removeFeatureState(e2, t2, i2) {
              this._state.removeFeatureState(e2 = e2 || "_geojsonTileLayer", t2, i2);
            }
            getFeatureState(e2, t2) {
              return this._state.getState(e2 = e2 || "_geojsonTileLayer", t2);
            }
            setDependencies(e2, t2, i2) {
              const o2 = this._tiles[e2];
              o2 && o2.setDependencies(t2, i2);
            }
            reloadTilesForDependencies(e2, t2) {
              for (const i2 in this._tiles) this._tiles[i2].hasDependency(e2, t2) && this._reloadTile(+i2, "reloading");
              this._cache.filter((i2) => !i2.hasDependency(e2, t2));
            }
            _preloadTiles(t2, i2) {
              if (!this._sourceLoaded) {
                const e2 = () => {
                  this._sourceLoaded && (this._source.off("data", e2), this._preloadTiles(t2, i2));
                };
                return void this._source.on("data", e2);
              }
              const o2 = /* @__PURE__ */ new Map(), s2 = Array.isArray(t2) ? t2 : [t2], r2 = this.map.painter.terrain, n2 = this.usedForTerrain && r2 ? r2.getScaledDemTileSize() : this._source.tileSize;
              for (const e2 of s2) {
                const t3 = e2.coveringTiles({ tileSize: n2, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom && !this.usedForTerrain, reparseOverscaled: this._source.reparseOverscaled, isTerrainDEM: this.usedForTerrain });
                for (const e3 of t3) o2.set(e3.key, e3);
                this.usedForTerrain && e2.updateElevation(false);
              }
              const a2 = Array.from(o2.values());
              e.bt(a2, (e2, t3) => {
                const i3 = new wt(e2, this._source.tileSize * e2.overscaleFactor(), this.transform.tileZoom, this.map.painter, this._isRaster);
                this._loadTile(i3, (e3) => {
                  "raster-dem" === this._source.type && i3.dem && this._backfillDEM(i3), t3(e3, i3);
                });
              }, i2);
            }
          }
          function Ct(e2, t2) {
            const i2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0), o2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0);
            return e2.overscaledZ - t2.overscaledZ || o2 - i2 || t2.canonical.y - e2.canonical.y || t2.canonical.x - e2.canonical.x;
          }
          function Rt(e2) {
            return "raster" === e2 || "image" === e2 || "video" === e2 || "custom" === e2;
          }
          function Dt(e2, t2) {
            const i2 = 1 << e2.z;
            return [e2.x / i2 + t2, (e2.x + 1) / i2 + t2];
          }
          It.maxOverzooming = 10, It.maxUnderzooming = 3;
          class At {
            constructor(e2) {
              this.style = e2, this.layersGotHidden = false, this.layers = [];
            }
            processLayersChanged() {
              this.layers = [];
              const e2 = false, t2 = false;
              for (const i2 in this.style._mergedLayers) {
                const o2 = this.style._mergedLayers[i2];
                if ("fill-extrusion" === o2.type) this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
                else if ("model" === o2.type) {
                  const i3 = this.style.getLayerSource(o2);
                  i3 && "batched-model" === i3.type && this.layers.push({ layer: o2, visible: e2, visibilityChanged: t2 });
                }
              }
            }
            onNewFrame(e2) {
              this.layersGotHidden = false;
              for (const t2 of this.layers) {
                const i2 = t2.layer;
                let o2 = false;
                "fill-extrusion" === i2.type ? o2 = !i2.isHidden(e2) && i2.paint.get("fill-extrusion-opacity") > 0 : "model" === i2.type && (o2 = !i2.isHidden(e2) && i2.paint.get("model-opacity").constantOr(1) > 0), this.layersGotHidden = this.layersGotHidden || !o2 && t2.visible, t2.visible = o2;
              }
            }
            updateZOffset(e2, t2) {
              this.currentBuildingBuckets = [];
              for (const e3 of this.layers) {
                const i3 = e3.layer, o2 = this.style.getLayerSourceCache(i3);
                let s2 = 1;
                "fill-extrusion" === i3.type && (s2 = e3.visible ? i3.paint.get("fill-extrusion-vertical-scale") : 0);
                let r2 = o2 ? o2.getTile(t2) : null;
                if (!r2 && o2 && t2.canonical.z > o2.getSource().minzoom) {
                  let e4 = t2.scaledTo(Math.min(o2.getSource().maxzoom, t2.overscaledZ - 1));
                  for (; e4.overscaledZ >= o2.getSource().minzoom && (r2 = o2.getTile(e4), !r2 && 0 !== e4.overscaledZ); ) e4 = e4.scaledTo(e4.overscaledZ - 1);
                }
                this.currentBuildingBuckets.push({ bucket: r2 ? r2.getBucket(i3) : null, tileID: r2 ? r2.tileID : t2, verticalScale: s2 });
              }
              e2.hasAnyZOffset = false;
              let i2 = false;
              for (let o2 = 0; o2 < e2.symbolInstances.length; o2++) {
                const s2 = e2.symbolInstances.get(o2), r2 = s2.zOffset, n2 = this._getHeightAtTileOffset(t2, s2.tileAnchorX, s2.tileAnchorY);
                s2.zOffset = n2 !== Number.NEGATIVE_INFINITY ? n2 : r2, i2 || r2 === s2.zOffset || (i2 = true), e2.hasAnyZOffset || 0 === s2.zOffset || (e2.hasAnyZOffset = true);
              }
              i2 && (e2.zOffsetBuffersNeedUpload = true, e2.zOffsetSortDirty = true);
            }
            _mapCoordToOverlappingTile(t2, i2, o2, s2) {
              let r2 = i2, n2 = o2;
              if (t2.canonical.z !== s2.canonical.z) {
                const a2 = s2.canonical, l2 = 1 / (1 << t2.canonical.z - a2.z);
                r2 = (i2 + t2.canonical.x * e.aj) * l2 - a2.x * e.aj | 0, n2 = (o2 + t2.canonical.y * e.aj) * l2 - a2.y * e.aj | 0;
              }
              return { tileX: r2, tileY: n2 };
            }
            _getHeightAtTileOffset(e2, t2, i2) {
              let o2, s2;
              for (let r2 = 0; r2 < this.layers.length; ++r2) {
                if ("fill-extrusion" !== this.layers[r2].layer.type) continue;
                const { bucket: n2, tileID: a2, verticalScale: l2 } = this.currentBuildingBuckets[r2];
                if (!n2) continue;
                const { tileX: c2, tileY: h2 } = this._mapCoordToOverlappingTile(e2, t2, i2, a2), d2 = n2.getHeightAtTileCoord(c2, h2);
                d2 && void 0 !== d2.height && (d2.hidden ? o2 = d2.height : s2 = Math.max(d2.height * l2, s2 || 0));
              }
              if (void 0 !== s2) return s2;
              for (let s3 = 0; s3 < this.layers.length; ++s3) {
                const r2 = this.layers[s3];
                if ("model" !== r2.layer.type || !r2.visible) continue;
                const { bucket: n2, tileID: a2 } = this.currentBuildingBuckets[s3];
                if (!n2) continue;
                const { tileX: l2, tileY: c2 } = this._mapCoordToOverlappingTile(e2, t2, i2, a2), h2 = n2.getHeightAtTileCoord(l2, c2);
                if (h2 && !h2.hidden) return void 0 === h2.height && void 0 !== o2 ? Math.min(h2.maxHeight, o2) * h2.verticalScale : h2.height ? h2.height * h2.verticalScale : Number.NEGATIVE_INFINITY;
              }
              return this.layersGotHidden ? 0 : Number.NEGATIVE_INFINITY;
            }
          }
          function Lt(t2, i2) {
            const o2 = {};
            for (const e2 in t2) "ref" !== e2 && (o2[e2] = t2[e2]);
            return e.bu.forEach((e2) => {
              e2 in i2 && (o2[e2] = i2[e2]);
            }), o2;
          }
          function Pt(e2) {
            e2 = e2.slice();
            const t2 = /* @__PURE__ */ Object.create(null);
            for (let i2 = 0; i2 < e2.length; i2++) t2[e2[i2].id] = e2[i2];
            for (let i2 = 0; i2 < e2.length; i2++) "ref" in e2[i2] && (e2[i2] = Lt(e2[i2], t2[e2[i2].ref]));
            return e2;
          }
          const zt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setSlot: "setSlot", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight", setTerrain: "setTerrain", setFog: "setFog", setSnow: "setSnow", setRain: "setRain", setCamera: "setCamera", setLights: "setLights", setProjection: "setProjection", addImport: "addImport", removeImport: "removeImport", updateImport: "updateImport", addIconset: "addIconset", removeIconset: "removeIconset" };
          function Mt(e2, t2, i2) {
            i2.push({ command: zt.addSource, args: [e2, t2[e2]] });
          }
          function Ot(e2, t2, i2) {
            t2.push({ command: zt.removeSource, args: [e2] }), i2[e2] = true;
          }
          function Ft(e2, t2, i2, o2) {
            Ot(e2, i2, o2), Mt(e2, t2, i2);
          }
          function Bt(t2, i2, o2) {
            let s2;
            for (s2 in t2[o2]) if (t2[o2].hasOwnProperty(s2) && "data" !== s2 && !e.bv(t2[o2][s2], i2[o2][s2])) return false;
            for (s2 in i2[o2]) if (i2[o2].hasOwnProperty(s2) && "data" !== s2 && !e.bv(t2[o2][s2], i2[o2][s2])) return false;
            return true;
          }
          function kt(t2, i2, o2, s2, r2, n2) {
            let a2;
            for (a2 in i2 = i2 || {}, t2 = t2 || {}) t2.hasOwnProperty(a2) && (e.bv(t2[a2], i2[a2]) || o2.push({ command: n2, args: [s2, a2, i2[a2], r2] }));
            for (a2 in i2) i2.hasOwnProperty(a2) && !t2.hasOwnProperty(a2) && (e.bv(t2[a2], i2[a2]) || o2.push({ command: n2, args: [s2, a2, i2[a2], r2] }));
          }
          function Nt(e2) {
            return e2.id;
          }
          function Ut(e2, t2) {
            return e2[t2.id] = t2, e2;
          }
          class jt {
            constructor(e2, t2) {
              this.reset(e2, t2);
            }
            reset(e2, t2) {
              this.points = e2 || [], this._distances = [0];
              for (let e3 = 1; e3 < this.points.length; e3++) this._distances[e3] = this._distances[e3 - 1] + this.points[e3].dist(this.points[e3 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(t2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(t2) {
              if (1 === this.points.length) return this.points[0];
              t2 = e.aD(t2, 0, 1);
              let i2 = 1, o2 = this._distances[i2];
              const s2 = t2 * this.paddedLength + this.padding;
              for (; o2 < s2 && i2 < this._distances.length; ) o2 = this._distances[++i2];
              const r2 = i2 - 1, n2 = this._distances[r2], a2 = o2 - n2, l2 = a2 > 0 ? (s2 - n2) / a2 : 0;
              return this.points[r2].mult(1 - l2).add(this.points[i2].mult(l2));
            }
          }
          class Vt {
            constructor(e2, t2, i2) {
              const o2 = this.boxCells = [], s2 = this.circleCells = [];
              this.xCellCount = Math.ceil(e2 / i2), this.yCellCount = Math.ceil(t2 / i2);
              for (let e3 = 0; e3 < this.xCellCount * this.yCellCount; e3++) o2.push([]), s2.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = e2, this.height = t2, this.xScale = this.xCellCount / e2, this.yScale = this.yCellCount / t2, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(e2, t2, i2, o2, s2) {
              this._forEachCell(t2, i2, o2, s2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(e2), this.bboxes.push(t2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(s2);
            }
            insertCircle(e2, t2, i2, o2) {
              this._forEachCell(t2 - o2, i2 - o2, t2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(e2), this.circles.push(t2), this.circles.push(i2), this.circles.push(o2);
            }
            _insertBoxCell(e2, t2, i2, o2, s2, r2) {
              this.boxCells[s2].push(r2);
            }
            _insertCircleCell(e2, t2, i2, o2, s2, r2) {
              this.circleCells[s2].push(r2);
            }
            _query(e2, t2, i2, o2, s2, r2) {
              if (i2 < 0 || e2 > this.width || o2 < 0 || t2 > this.height) return !s2 && [];
              const n2 = [];
              if (e2 <= 0 && t2 <= 0 && this.width <= i2 && this.height <= o2) {
                if (s2) return true;
                for (let e3 = 0; e3 < this.boxKeys.length; e3++) n2.push({ key: this.boxKeys[e3], x1: this.bboxes[4 * e3], y1: this.bboxes[4 * e3 + 1], x2: this.bboxes[4 * e3 + 2], y2: this.bboxes[4 * e3 + 3] });
                for (let e3 = 0; e3 < this.circleKeys.length; e3++) {
                  const t3 = this.circles[3 * e3], i3 = this.circles[3 * e3 + 1], o3 = this.circles[3 * e3 + 2];
                  n2.push({ key: this.circleKeys[e3], x1: t3 - o3, y1: i3 - o3, x2: t3 + o3, y2: i3 + o3 });
                }
                return r2 ? n2.filter(r2) : n2;
              }
              return this._forEachCell(e2, t2, i2, o2, this._queryCell, n2, { hitTest: s2, seenUids: { box: {}, circle: {} } }, r2), s2 ? n2.length > 0 : n2;
            }
            _queryCircle(e2, t2, i2, o2, s2) {
              const r2 = e2 - i2, n2 = e2 + i2, a2 = t2 - i2, l2 = t2 + i2;
              if (n2 < 0 || r2 > this.width || l2 < 0 || a2 > this.height) return !o2 && [];
              const c2 = [];
              return this._forEachCell(r2, a2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: e2, y: t2, radius: i2 }, seenUids: { box: {}, circle: {} } }, s2), o2 ? c2.length > 0 : c2;
            }
            query(e2, t2, i2, o2, s2) {
              return this._query(e2, t2, i2, o2, false, s2);
            }
            hitTest(e2, t2, i2, o2, s2) {
              return this._query(e2, t2, i2, o2, true, s2);
            }
            hitTestCircle(e2, t2, i2, o2) {
              return this._queryCircle(e2, t2, i2, true, o2);
            }
            _queryCell(e2, t2, i2, o2, s2, r2, n2, a2) {
              const l2 = n2.seenUids, c2 = this.boxCells[s2];
              if (null !== c2) {
                const s3 = this.bboxes;
                for (const h3 of c2) if (!l2.box[h3]) {
                  l2.box[h3] = true;
                  const c3 = 4 * h3;
                  if (e2 <= s3[c3 + 2] && t2 <= s3[c3 + 3] && i2 >= s3[c3 + 0] && o2 >= s3[c3 + 1] && (!a2 || a2(this.boxKeys[h3]))) {
                    if (n2.hitTest) return r2.push(true), true;
                    r2.push({ key: this.boxKeys[h3], x1: s3[c3], y1: s3[c3 + 1], x2: s3[c3 + 2], y2: s3[c3 + 3] });
                  }
                }
              }
              const h2 = this.circleCells[s2];
              if (null !== h2) {
                const s3 = this.circles;
                for (const c3 of h2) if (!l2.circle[c3]) {
                  l2.circle[c3] = true;
                  const h3 = 3 * c3;
                  if (this._circleAndRectCollide(s3[h3], s3[h3 + 1], s3[h3 + 2], e2, t2, i2, o2) && (!a2 || a2(this.circleKeys[c3]))) {
                    if (n2.hitTest) return r2.push(true), true;
                    {
                      const e3 = s3[h3], t3 = s3[h3 + 1], i3 = s3[h3 + 2];
                      r2.push({ key: this.circleKeys[c3], x1: e3 - i3, y1: t3 - i3, x2: e3 + i3, y2: t3 + i3 });
                    }
                  }
                }
              }
            }
            _queryCellCircle(e2, t2, i2, o2, s2, r2, n2, a2) {
              const l2 = n2.circle, c2 = n2.seenUids, h2 = this.boxCells[s2];
              if (null !== h2) {
                const e3 = this.bboxes;
                for (const t3 of h2) if (!c2.box[t3]) {
                  c2.box[t3] = true;
                  const i3 = 4 * t3;
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, e3[i3 + 0], e3[i3 + 1], e3[i3 + 2], e3[i3 + 3]) && (!a2 || a2(this.boxKeys[t3]))) return r2.push(true), true;
                }
              }
              const d2 = this.circleCells[s2];
              if (null !== d2) {
                const e3 = this.circles;
                for (const t3 of d2) if (!c2.circle[t3]) {
                  c2.circle[t3] = true;
                  const i3 = 3 * t3;
                  if (this._circlesCollide(e3[i3], e3[i3 + 1], e3[i3 + 2], l2.x, l2.y, l2.radius) && (!a2 || a2(this.circleKeys[t3]))) return r2.push(true), true;
                }
              }
            }
            _forEachCell(e2, t2, i2, o2, s2, r2, n2, a2) {
              const l2 = this._convertToXCellCoord(e2), c2 = this._convertToYCellCoord(t2), h2 = this._convertToXCellCoord(i2), d2 = this._convertToYCellCoord(o2);
              for (let u5 = l2; u5 <= h2; u5++) for (let l3 = c2; l3 <= d2; l3++) if (s2.call(this, e2, t2, i2, o2, this.xCellCount * l3 + u5, r2, n2, a2)) return;
            }
            _convertToXCellCoord(e2) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e2 * this.xScale)));
            }
            _convertToYCellCoord(e2) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e2 * this.yScale)));
            }
            _circlesCollide(e2, t2, i2, o2, s2, r2) {
              const n2 = o2 - e2, a2 = s2 - t2, l2 = i2 + r2;
              return l2 * l2 > n2 * n2 + a2 * a2;
            }
            _circleAndRectCollide(e2, t2, i2, o2, s2, r2, n2) {
              const a2 = (r2 - o2) / 2, l2 = Math.abs(e2 - (o2 + a2));
              if (l2 > a2 + i2) return false;
              const c2 = (n2 - s2) / 2, h2 = Math.abs(t2 - (s2 + c2));
              if (h2 > c2 + i2) return false;
              if (l2 <= a2 || h2 <= c2) return true;
              const d2 = l2 - a2, u5 = h2 - c2;
              return d2 * d2 + u5 * u5 <= i2 * i2;
            }
          }
          const Gt = { unknown: 0, flipRequired: 1, flipNotRequired: 2 }, qt = Math.tan(85 * Math.PI / 180);
          function Zt(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = e.bz();
            if (o2) if ("globe" === n2.name) {
              const t3 = e.bA(r2, i2);
              e.az(l2, l2, t3);
            } else {
              const t3 = e.bB([], a2);
              l2[0] = t3[0], l2[1] = t3[1], l2[4] = t3[2], l2[5] = t3[3], s2 || e.by(l2, l2, r2.angle);
            }
            else e.az(l2, r2.labelPlaneMatrix, t2);
            return l2;
          }
          function Ht(e2, t2, i2, o2, s2, r2, n2) {
            const a2 = Zt(e2, t2, i2, o2, s2, r2, n2);
            return "globe" === r2.name && i2 || (a2[2] = a2[6] = a2[10] = a2[14] = 0), a2;
          }
          function Wt(t2, i2, o2, s2, r2, n2, a2) {
            if (o2) {
              if ("globe" === n2.name) {
                const l2 = Zt(t2, i2, o2, s2, r2, n2, a2);
                return e.bi(l2, l2), e.az(l2, t2, l2), l2;
              }
              {
                const i3 = e.bw(t2), o3 = e.bx([]);
                return o3[0] = a2[0], o3[1] = a2[1], o3[4] = a2[2], o3[5] = a2[3], e.az(i3, i3, o3), s2 || e.by(i3, i3, -r2.angle), i3;
              }
            }
            return r2.glCoordMatrix;
          }
          function $t(t2, i2, o2, s2) {
            const r2 = [t2, i2, o2, 1];
            o2 ? e.aA(r2, r2, s2) : ri(r2, r2, s2);
            const n2 = r2[3];
            return r2[0] /= n2, r2[1] /= n2, r2[2] /= n2, r2;
          }
          function Xt(e2, t2) {
            return Math.min(0.5 + e2 / t2 * 0.5, 1.5);
          }
          function Yt(e2, t2) {
            const i2 = e2[0] / e2[3], o2 = e2[1] / e2[3];
            return i2 >= -t2[0] && i2 <= t2[0] && o2 >= -t2[1] && o2 <= t2[1];
          }
          function Kt(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
            const d2 = o2.transform, u5 = s2 ? t2.textSizeData : t2.iconSizeData, _2 = e.bH(u5, o2.transform.zoom), p2 = "globe" === d2.projection.name, f2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], m2 = s2 ? t2.text.dynamicLayoutVertexArray : t2.icon.dynamicLayoutVertexArray;
            m2.clear();
            let g2 = null;
            p2 && (g2 = s2 ? t2.text.globeExtVertexArray : t2.icon.globeExtVertexArray);
            const v3 = t2.lineVertexArray, y2 = s2 ? t2.text.placedSymbolArray : t2.icon.placedSymbolArray, x2 = o2.transform.width / o2.transform.height;
            let b2, w2 = false;
            for (let s3 = 0; s3 < y2.length; s3++) {
              const p3 = y2.get(s3), { numGlyphs: T2, writingMode: E2 } = p3;
              if (E2 !== e.bI.vertical || w2 || b2 === e.bI.horizontal || (w2 = true), b2 = E2, (p3.hidden || E2 === e.bI.vertical) && !w2) {
                si(T2, m2);
                continue;
              }
              w2 = false;
              const S2 = new e.P(p3.tileAnchorX, p3.tileAnchorY);
              let { x: I2, y: C3, z: R2 } = d2.projection.projectTilePoint(S2.x, S2.y, h2.canonical);
              if (c2) {
                const [e2, t3, i3] = c2(S2);
                I2 += e2, C3 += t3, R2 += i3;
              }
              const D3 = [I2, C3, R2, 1];
              if (e.aA(D3, D3, i2), !Yt(D3, f2)) {
                si(T2, m2);
                continue;
              }
              const A2 = D3[3], L2 = Xt(o2.transform.getCameraToCenterDistance(d2.projection), A2), P2 = e.bJ(u5, _2, p3), z2 = a2 ? P2 / L2 : P2 * L2, M2 = $t(I2, C3, R2, r2);
              if (M2[3] <= 0) {
                si(T2, m2);
                continue;
              }
              let O2 = {};
              const F2 = e.al(t2.layers[0].layout.get("text-max-angle")), B3 = Math.cos(F2), k2 = a2 ? null : c2, N2 = ei(p3, z2, false, l2, i2, r2, n2, t2.glyphOffsetArray, v3, m2, g2, M2, S2, O2, x2, k2, d2.projection, h2, a2, B3);
              w2 = N2.useVertical, k2 && N2.needsFlipping && (O2 = {}), (N2.notEnoughRoom || w2 || N2.needsFlipping && ei(p3, z2, true, l2, i2, r2, n2, t2.glyphOffsetArray, v3, m2, g2, M2, S2, O2, x2, k2, d2.projection, h2, a2, B3).notEnoughRoom) && si(T2, m2);
            }
            s2 ? (t2.text.dynamicLayoutVertexBuffer.updateData(m2), g2 && t2.text.globeExtVertexBuffer && t2.text.globeExtVertexBuffer.updateData(g2)) : (t2.icon.dynamicLayoutVertexBuffer.updateData(m2), g2 && t2.icon.globeExtVertexBuffer && t2.icon.globeExtVertexBuffer.updateData(g2));
          }
          function Jt(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2) {
            const { lineStartIndex: g2, glyphStartIndex: v3, segment: y2 } = a2, x2 = v3 + a2.numGlyphs, b2 = g2 + a2.lineLength, w2 = t2.getoffsetX(v3), T2 = t2.getoffsetX(x2 - 1), E2 = oi(e2 * w2, i2, o2, s2, r2, n2, y2, g2, b2, l2, c2, h2, d2, u5, true, _2, p2, f2, m2);
            if (!E2) return null;
            const S2 = oi(e2 * T2, i2, o2, s2, r2, n2, y2, g2, b2, l2, c2, h2, d2, u5, true, _2, p2, f2, m2);
            return S2 ? { first: E2, last: S2 } : null;
          }
          function Qt(t2, i2, o2, s2) {
            return t2 === e.bI.horizontal && Math.abs(s2) > Math.abs(o2) ? { useVertical: true } : t2 === e.bI.vertical ? s2 > 0 ? { needsFlipping: true } : null : i2 !== Gt.unknown && function(e2, t3) {
              return 0 === e2 || Math.abs(t3 / e2) > qt;
            }(o2, s2) ? i2 === Gt.flipRequired ? { needsFlipping: true } : null : o2 < 0 ? { needsFlipping: true } : null;
          }
          function ei(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3, y2, x2) {
            const b2 = i2 / 24, w2 = t2.lineOffsetX * b2, T2 = t2.lineOffsetY * b2, { lineStartIndex: E2, glyphStartIndex: S2, numGlyphs: I2, segment: C3, writingMode: R2, flipState: D3 } = t2, A2 = E2 + t2.lineLength, L2 = (t3) => {
              if (d2) {
                const [i4, o4, s4] = t3.up, r3 = h2.length;
                e.bK(d2, r3 + 0, i4, o4, s4), e.bK(d2, r3 + 1, i4, o4, s4), e.bK(d2, r3 + 2, i4, o4, s4), e.bK(d2, r3 + 3, i4, o4, s4);
              }
              const [i3, o3, s3] = t3.point;
              e.bL(h2, i3, o3, s3, t3.angle);
            };
            if (I2 > 1) {
              const e2 = Jt(b2, l2, w2, T2, o2, u5, _2, t2, c2, n2, p2, m2, false, g2, v3, y2, x2);
              if (!e2) return { notEnoughRoom: true };
              if (s2 && !o2) {
                let [i3, o3, s3] = e2.first.point, [r3, n3, l3] = e2.last.point;
                [i3, o3] = $t(i3, o3, s3, a2), [r3, n3] = $t(r3, n3, l3, a2);
                const c3 = Qt(R2, D3, (r3 - i3) * f2, n3 - o3);
                if (t2.flipState = c3 && c3.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, c3) return c3;
              }
              L2(e2.first);
              for (let e3 = S2 + 1; e3 < S2 + I2 - 1; e3++) {
                const t3 = oi(b2 * l2.getoffsetX(e3), w2, T2, o2, u5, _2, C3, E2, A2, c2, n2, p2, m2, false, false, g2, v3, y2, x2);
                if (!t3) return h2.length -= 4 * (e3 - S2), { notEnoughRoom: true };
                L2(t3);
              }
              L2(e2.last);
            } else {
              if (s2 && !o2) {
                const i4 = $t(_2.x, _2.y, 0, r2), o3 = E2 + C3 + 1, s3 = new e.P(c2.getx(o3), c2.gety(o3)), n3 = $t(s3.x, s3.y, 0, r2), a3 = n3[3] > 0 ? n3 : ii(_2, s3, i4, 1, r2, void 0, g2, v3.canonical), l3 = Qt(R2, D3, (a3[0] - i4[0]) * f2, a3[1] - i4[1]);
                if (t2.flipState = l3 && l3.needsFlipping ? Gt.flipRequired : Gt.flipNotRequired, l3) return l3;
              }
              const i3 = oi(b2 * l2.getoffsetX(S2), w2, T2, o2, u5, _2, C3, E2, A2, c2, n2, p2, m2, false, false, g2, v3, y2, x2);
              if (!i3) return { notEnoughRoom: true };
              L2(i3);
            }
            return {};
          }
          function ti(e2, t2, i2, o2, s2) {
            const { x: r2, y: n2, z: a2 } = o2.projectTilePoint(e2.x, e2.y, t2);
            if (!s2) return $t(r2, n2, a2, i2);
            const [l2, c2, h2] = s2(e2);
            return $t(r2 + l2, n2 + c2, a2 + h2, i2);
          }
          function ii(t2, i2, o2, s2, r2, n2, a2, l2) {
            const c2 = ti(t2.sub(i2)._unit()._add(t2), l2, r2, a2, n2);
            return e.at(c2, o2, c2), e.au(c2, c2), e.bF(c2, o2, c2, s2);
          }
          function oi(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3, y2) {
            const x2 = s2 ? t2 - i2 : t2 + i2;
            let b2 = x2 > 0 ? 1 : -1, w2 = 0;
            s2 && (b2 *= -1, w2 = Math.PI), b2 < 0 && (w2 += Math.PI);
            let T2 = l2 + a2 + (b2 > 0 ? 0 : 1) | 0, E2 = r2, S2 = r2, I2 = 0, C3 = 0;
            const R2 = Math.abs(x2), D3 = [], A2 = [];
            let L2 = n2, P2 = L2, z2 = e.bC([]);
            const M2 = () => ii(P2, L2, S2, R2 - I2 + 1, d2, _2, m2, g2.canonical);
            for (; I2 + C3 <= R2; ) {
              if (T2 += b2, T2 < l2 || T2 >= c2) return null;
              if (S2 = E2, P2 = L2, D3.push(S2), p2 && A2.push(P2), L2 = new e.P(h2.getx(T2), h2.gety(T2)), E2 = u5[T2], !E2) {
                const e2 = ti(L2, g2.canonical, d2, m2, _2);
                E2 = e2[3] > 0 ? u5[T2] = e2 : M2();
              }
              I2 += C3;
              const t3 = e.at([], E2, S2), i3 = e.bD(S2, E2);
              if (o2 && i3 > 0 && C3 > 0 && e.bE(z2, t3) / (C3 * i3) < y2) return null;
              C3 = i3, z2 = t3;
            }
            f2 && _2 && (u5[T2] && (E2 = M2(), C3 = e.bD(S2, E2), z2 = e.at([], E2, S2)), u5[T2] = E2);
            const O2 = (R2 - I2) / C3, F2 = L2.sub(P2)._mult(O2)._add(P2), B3 = e.bF([], S2, z2, O2);
            let k2 = [0, 0, 1], N2 = z2[0], U2 = z2[1];
            if (v3 && (k2 = m2.upVector(g2.canonical, F2.x, F2.y), 0 !== k2[0] || 0 !== k2[1] || 1 !== k2[2])) {
              const t3 = [k2[2], 0, -k2[0]], i3 = e.bG([], k2, t3);
              e.au(t3, t3), e.au(i3, i3), N2 = e.bE(z2, t3), U2 = e.bE(z2, i3);
            }
            if (o2) {
              const t3 = e.bG([], k2, z2);
              e.au(t3, t3), e.bF(B3, B3, t3, o2 * b2);
            }
            const j2 = w2 + Math.atan2(U2, N2);
            return D3.push(B3), p2 && A2.push(F2), { point: B3, angle: j2, path: D3, tilePath: A2, up: k2 };
          }
          function si(e2, t2) {
            const i2 = t2.length, o2 = i2 + 4 * e2;
            t2.resize(o2), t2.float32.fill(-1 / 0, 4 * i2, 4 * o2);
          }
          function ri(e2, t2, i2) {
            const o2 = t2[0], s2 = t2[1];
            return e2[0] = i2[0] * o2 + i2[4] * s2 + i2[12], e2[1] = i2[1] * o2 + i2[5] * s2 + i2[13], e2[3] = i2[3] * o2 + i2[7] * s2 + i2[15], e2;
          }
          const ni = 100;
          class ai {
            constructor(e2, t2, i2 = new Vt(e2.width + 200, e2.height + 200, 25), o2 = new Vt(e2.width + 200, e2.height + 200, 25)) {
              this.transform = e2, this.grid = i2, this.ignoredGrid = o2, this.pitchfactor = Math.cos(e2._pitch) * e2.cameraToCenterDistance, this.screenRightBoundary = e2.width + ni, this.screenBottomBoundary = e2.height + ni, this.gridRightBoundary = e2.width + 200, this.gridBottomBoundary = e2.height + 200, this.fogState = t2;
            }
            placeCollisionBox(e2, t2, i2, o2, s2, r2, n2, a2) {
              let l2 = i2.projectedAnchorX, c2 = i2.projectedAnchorY, h2 = i2.projectedAnchorZ;
              const d2 = i2.elevation, u5 = i2.tileID, _2 = e2.getProjection();
              if (d2 && u5) {
                const [e3, t3, o3] = _2.upVector(u5.canonical, i2.tileAnchorX, i2.tileAnchorY), s3 = _2.upVectorScale(u5.canonical, this.transform.center.lat, this.transform.worldSize).metersToTile;
                l2 += e3 * d2 * s3, c2 += t3 * d2 * s3, h2 += o3 * d2 * s3;
              }
              const p2 = this.projectAndGetPerspectiveRatio(n2, l2, c2, h2, i2.tileID, "globe" === _2.name || !!d2 || this.transform.pitch > 0, _2), f2 = r2 * p2.perspectiveRatio, m2 = (i2.x1 * t2 + o2.x - i2.padding) * f2 + p2.point.x, g2 = (i2.y1 * t2 + o2.y - i2.padding) * f2 + p2.point.y, v3 = (i2.x2 * t2 + o2.x + i2.padding) * f2 + p2.point.x, y2 = (i2.y2 * t2 + o2.y + i2.padding) * f2 + p2.point.y, x2 = p2.perspectiveRatio <= 0.55 || p2.occluded;
              return !this.isInsideGrid(m2, g2, v3, y2) || !s2 && this.grid.hitTest(m2, g2, v3, y2, a2) || x2 ? { box: [], offscreen: false, occluded: p2.occluded } : { box: [m2, g2, v3, y2], offscreen: this.isOffscreen(m2, g2, v3, y2), occluded: false };
            }
            placeCollisionCircles(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2) {
              const m2 = [], g2 = this.transform.elevation, v3 = t2.getProjection(), y2 = g2 ? g2.getAtTileOffsetFunc(f2, this.transform.center.lat, this.transform.worldSize, v3) : null, x2 = new e.P(o2.tileAnchorX, o2.tileAnchorY);
              let { x: b2, y: w2, z: T2 } = v3.projectTilePoint(x2.x, x2.y, f2.canonical);
              if (y2) {
                const [e2, t3, i3] = y2(x2);
                b2 += e2, w2 += t3, T2 += i3;
              }
              const E2 = "globe" === v3.name, S2 = this.projectAndGetPerspectiveRatio(a2, b2, w2, T2, f2, E2 || !!g2 || this.transform.pitch > 0, v3), { perspectiveRatio: I2 } = S2, C3 = (d2 ? n2 / I2 : n2 * I2) / e.bO, R2 = $t(b2, w2, T2, l2), D3 = o2.lineOffsetX * C3, A2 = o2.lineOffsetY * C3, L2 = e.al(t2.layers[0].layout.get("text-max-angle")), P2 = Math.cos(L2), z2 = S2.signedDistanceFromCamera > 0 ? Jt(C3, r2, D3, A2, false, R2, x2, o2, s2, l2, {}, g2 && !d2 ? y2 : null, d2 && !!g2, v3, f2, d2, P2) : null;
              let M2 = false, O2 = false, F2 = true;
              if (z2 && !S2.occluded) {
                const t3 = 0.5 * _2 * I2 + p2, o3 = new e.P(-100, -100), s3 = new e.P(this.screenRightBoundary, this.screenBottomBoundary), r3 = new jt(), { first: n3, last: a3 } = z2, l3 = n3.path.length;
                let d3 = [];
                for (let e2 = l3 - 1; e2 >= 1; e2--) d3.push(n3.path[e2]);
                for (let e2 = 1; e2 < a3.path.length; e2++) d3.push(a3.path[e2]);
                const f3 = 2.5 * t3;
                c2 && (d3 = d3.map(([e2, t4, i3], o4) => (y2 && !E2 && (i3 = y2(o4 < l3 - 1 ? n3.tilePath[l3 - 1 - o4] : a3.tilePath[o4 - l3 + 2])[2]), $t(e2, t4, i3, c2))), d3.some((e2) => e2[3] <= 0) && (d3 = []));
                let g3 = [];
                if (d3.length > 0) {
                  let t4 = 1 / 0, i3 = -1 / 0, r4 = 1 / 0, n4 = -1 / 0;
                  for (const e2 of d3) t4 = Math.min(t4, e2[0]), r4 = Math.min(r4, e2[1]), i3 = Math.max(i3, e2[0]), n4 = Math.max(n4, e2[1]);
                  i3 >= o3.x && t4 <= s3.x && n4 >= o3.y && r4 <= s3.y && (g3 = [d3.map((t5) => new e.P(t5[0], t5[1]))], (t4 < o3.x || i3 > s3.x || r4 < o3.y || n4 > s3.y) && (g3 = e.bM(g3, o3.x, o3.y, s3.x, s3.y)));
                }
                for (const e2 of g3) {
                  r3.reset(e2, 0.25 * t3);
                  let o4 = 0;
                  o4 = r3.length <= 0.5 * t3 ? 1 : Math.ceil(r3.paddedLength / f3) + 1;
                  for (let e3 = 0; e3 < o4; e3++) {
                    const s4 = e3 / Math.max(o4 - 1, 1), n4 = r3.lerp(s4), a4 = n4.x + ni, l4 = n4.y + ni;
                    m2.push(a4, l4, t3, 0);
                    const c3 = a4 - t3, d4 = l4 - t3, _3 = a4 + t3, p3 = l4 + t3;
                    if (F2 = F2 && this.isOffscreen(c3, d4, _3, p3), O2 = O2 || this.isInsideGrid(c3, d4, _3, p3), !i2 && this.grid.hitTestCircle(a4, l4, t3, u5) && (M2 = true, !h2)) return { circles: [], offscreen: false, collisionDetected: M2, occluded: false };
                  }
                }
              }
              return { circles: !h2 && M2 || !O2 ? [] : m2, offscreen: F2, collisionDetected: M2, occluded: S2.occluded };
            }
            queryRenderedSymbols(t2) {
              if (0 === t2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength()) return {};
              const i2 = [];
              let o2 = 1 / 0, s2 = 1 / 0, r2 = -1 / 0, n2 = -1 / 0;
              for (const a3 of t2) {
                const t3 = new e.P(a3.x + ni, a3.y + ni);
                o2 = Math.min(o2, t3.x), s2 = Math.min(s2, t3.y), r2 = Math.max(r2, t3.x), n2 = Math.max(n2, t3.y), i2.push(t3);
              }
              const a2 = this.grid.query(o2, s2, r2, n2).concat(this.ignoredGrid.query(o2, s2, r2, n2)), l2 = {}, c2 = {};
              for (const t3 of a2) {
                const o3 = t3.key;
                if (void 0 === l2[o3.bucketInstanceId] && (l2[o3.bucketInstanceId] = {}), l2[o3.bucketInstanceId][o3.featureIndex]) continue;
                const s3 = [new e.P(t3.x1, t3.y1), new e.P(t3.x2, t3.y1), new e.P(t3.x2, t3.y2), new e.P(t3.x1, t3.y2)];
                e.bN(i2, s3) && (l2[o3.bucketInstanceId][o3.featureIndex] = true, void 0 === c2[o3.bucketInstanceId] && (c2[o3.bucketInstanceId] = []), c2[o3.bucketInstanceId].push(o3.featureIndex));
              }
              return c2;
            }
            insertCollisionBox(e2, t2, i2, o2, s2) {
              (t2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: s2 }, e2[0], e2[1], e2[2], e2[3]);
            }
            insertCollisionCircles(e2, t2, i2, o2, s2) {
              const r2 = t2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: s2 };
              for (let t3 = 0; t3 < e2.length; t3 += 4) r2.insertCircle(n2, e2[t3], e2[t3 + 1], e2[t3 + 2]);
            }
            projectAndGetPerspectiveRatio(t2, i2, o2, s2, r2, n2, a2) {
              const l2 = [i2, o2, s2, 1];
              let c2 = false;
              if (s2 || this.transform.pitch > 0) {
                if (e.aA(l2, l2, t2), this.fogState && r2 && "globe" !== a2.name) {
                  const t3 = function(t4, i3, o3, s3, r3, n3) {
                    const a3 = n3.calculateFogTileMatrix(r3), l3 = [i3, o3, s3];
                    return e.ad(l3, l3, a3), Be(t4, e.ae(l3), n3.pitch, n3._fov);
                  }(this.fogState, i2, o2, s2, r2.toUnwrapped(), this.transform);
                  c2 = t3 > 0.9;
                }
              } else ri(l2, l2, t2);
              const h2 = l2[3];
              return { point: new e.P((l2[0] / h2 + 1) / 2 * this.transform.width + ni, (-l2[1] / h2 + 1) / 2 * this.transform.height + ni), perspectiveRatio: Math.min(0.5 + this.transform.getCameraToCenterDistance(a2) / h2 * 0.5, 1.5), signedDistanceFromCamera: h2, occluded: n2 && l2[2] > h2 || c2 };
            }
            isOffscreen(e2, t2, i2, o2) {
              return i2 < ni || e2 >= this.screenRightBoundary || o2 < ni || t2 > this.screenBottomBoundary;
            }
            isInsideGrid(e2, t2, i2, o2) {
              return i2 >= 0 && e2 < this.gridRightBoundary && o2 >= 0 && t2 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const t2 = e.bx([]);
              return e.bo(t2, t2, [-100, -100, 0]), t2;
            }
          }
          function li(t2, i2, o2) {
            const s2 = i2.createTileMatrix(t2, t2.worldSize, o2.toUnwrapped());
            return e.az(new Float32Array(16), t2.projMatrix, s2);
          }
          function ci(e2, t2, i2) {
            if (t2.projection.name === i2.projection.name) return e2.projMatrix;
            const o2 = i2.clone();
            return o2.setProjection(t2.projection), li(o2, t2.getProjection(), e2);
          }
          function hi(e2, t2, i2) {
            return t2.name === i2.projection.name ? e2.projMatrix : li(i2, t2, e2);
          }
          class di {
            constructor(e2, t2, i2, o2) {
              this.opacity = e2 ? Math.max(0, Math.min(1, e2.opacity + (e2.placed ? t2 : -t2))) : o2 && i2 ? 1 : 0, this.placed = i2;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class ui {
            constructor(e2, t2, i2, o2, s2, r2 = false) {
              this.text = new di(e2 ? e2.text : null, t2, i2, s2), this.icon = new di(e2 ? e2.icon : null, t2, o2, s2), this.clipped = r2;
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class _i {
            constructor(e2, t2, i2, o2 = false) {
              this.text = e2, this.icon = t2, this.skipFade = i2, this.clipped = o2;
            }
          }
          class pi {
            constructor() {
              this.invProjMatrix = e.bz(), this.viewportMatrix = e.bz(), this.circles = [];
            }
          }
          class fi {
            constructor(e2, t2, i2, o2, s2) {
              this.bucketInstanceId = e2, this.featureIndex = t2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = s2;
            }
          }
          class mi {
            constructor(e2) {
              this.crossSourceCollisions = e2, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(e2) {
              if (this.crossSourceCollisions) return { ID: 0, predicate: null };
              if (!this.collisionGroups[e2]) {
                const t2 = ++this.maxGroupID;
                this.collisionGroups[e2] = { ID: t2, predicate: (e3) => e3.collisionGroupID === t2 };
              }
              return this.collisionGroups[e2];
            }
          }
          function gi(t2, i2, o2, s2, r2) {
            const { horizontalAlign: n2, verticalAlign: a2 } = e.bV(t2), l2 = -(n2 - 0.5) * i2, c2 = -(a2 - 0.5) * o2, h2 = e.bU(t2, s2);
            return new e.P(l2 + h2[0] * r2, c2 + h2[1] * r2);
          }
          function vi(t2, i2, o2, s2, r2) {
            const n2 = new e.P(t2, i2);
            return o2 && n2._rotate(s2 ? r2 : -r2), n2;
          }
          class yi {
            constructor(e2, t2, i2, o2, s2, r2) {
              this.transform = e2.clone(), this.projection = e2.projection.name, this.collisionIndex = new ai(this.transform, s2), this.buildingIndex = r2, this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = t2, this.retainedQueryData = {}, this.collisionGroups = new mi(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(t2, i2, o2, s2, r2 = 1) {
              const n2 = o2.getBucket(i2), a2 = o2.latestFeatureIndex;
              if (!n2 || !a2 || i2.fqid !== n2.layerIds[0]) return;
              const l2 = n2.layers[0].layout, c2 = n2.layers[0].paint, h2 = o2.collisionBoxArray, d2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u5 = o2.tileSize / e.aj, _2 = o2.tileID.toUnwrapped();
              this.transform.setProjection(n2.projection);
              const p2 = (f2 = o2.tileID, m2 = n2.getProjection(), g2 = this.transform, m2.name === this.projection ? g2.calculateProjMatrix(f2.toUnwrapped()) : li(g2, m2, f2));
              var f2, m2, g2;
              const v3 = "map" === l2.get("text-pitch-alignment"), y2 = "map" === l2.get("text-rotation-alignment");
              i2.compileFilter(i2.options);
              const x2 = i2.dynamicFilter(), b2 = i2.dynamicFilterNeedsFeature(), w2 = this.transform.calculatePixelsToTileUnitsMatrix(o2), T2 = Ht(p2, o2.tileID.canonical, v3, y2, this.transform, n2.getProjection(), w2);
              let E2 = null;
              if (v3) {
                const t3 = Wt(p2, o2.tileID.canonical, v3, y2, this.transform, n2.getProjection(), w2);
                E2 = e.az([], this.transform.labelPlaneMatrix, t3);
              }
              let S2 = null;
              x2 && o2.latestFeatureIndex && (S2 = { unwrappedTileID: _2, dynamicFilter: x2, dynamicFilterNeedsFeature: b2 }), this.retainedQueryData[n2.bucketInstanceId] = new fi(n2.bucketInstanceId, a2, n2.sourceLayerIndex, n2.index, o2.tileID);
              const [I2, C3] = n2.layers[0].layout.get("text-size-scale-range"), R2 = e.aD(r2, I2, C3), [D3, A2] = l2.get("icon-size-scale-range"), L2 = e.aD(r2, D3, A2), P2 = { bucket: n2, layout: l2, paint: c2, posMatrix: p2, textLabelPlaneMatrix: T2, labelToScreenMatrix: E2, clippingData: S2, scale: d2, textPixelRatio: u5, holdingForFade: o2.holdingForFade(), collisionBoxArray: h2, partiallyEvaluatedTextSize: e.bH(n2.textSizeData, this.transform.zoom, R2), partiallyEvaluatedIconSize: e.bH(n2.iconSizeData, this.transform.zoom, L2), collisionGroup: this.collisionGroups.get(n2.sourceID), latestFeatureIndex: o2.latestFeatureIndex };
              if (s2) for (const e2 of n2.sortKeyRanges) {
                const { sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3 } = e2;
                t2.push({ sortKey: i3, symbolInstanceStart: o3, symbolInstanceEnd: s3, parameters: P2 });
              }
              else t2.push({ symbolInstanceStart: 0, symbolInstanceEnd: n2.symbolInstances.length, parameters: P2 });
            }
            attemptAnchorPlacement(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2) {
              const { textOffset0: v3, textOffset1: y2, crossTileID: x2 } = d2, b2 = [v3, y2], w2 = gi(e2, i2, o2, b2, s2), T2 = this.collisionIndex.placeCollisionBox(_2, s2, t2, vi(w2.x, w2.y, r2, n2, this.transform.angle), h2, a2, l2, c2.predicate);
              if (f2) {
                const e3 = _2.getSymbolInstanceIconSize(g2, this.transform.zoom, d2.placedIconSymbolIndex);
                if (0 === this.collisionIndex.placeCollisionBox(_2, e3, f2, vi(w2.x, w2.y, r2, n2, this.transform.angle), h2, a2, l2, c2.predicate).box.length) return;
              }
              if (T2.box.length > 0) {
                let t3;
                return this.prevPlacement && this.prevPlacement.variableOffsets[x2] && this.prevPlacement.placements[x2] && this.prevPlacement.placements[x2].text && (t3 = this.prevPlacement.variableOffsets[x2].anchor), this.variableOffsets[x2] = { textOffset: b2, width: i2, height: o2, anchor: e2, textScale: s2, prevAnchor: t3 }, this.markUsedJustification(_2, e2, d2, p2), _2.allowVerticalPlacement && (this.markUsedOrientation(_2, p2, d2), this.placedOrientations[x2] = p2), { shift: w2, placedGlyphBoxes: T2 };
              }
            }
            placeLayerBucketPart(t2, i2, o2, s2, r2 = 1) {
              const { bucket: n2, layout: a2, paint: l2, posMatrix: c2, textLabelPlaneMatrix: h2, labelToScreenMatrix: d2, clippingData: u5, textPixelRatio: _2, holdingForFade: p2, collisionBoxArray: f2, partiallyEvaluatedTextSize: m2, partiallyEvaluatedIconSize: g2, collisionGroup: v3, latestFeatureIndex: y2 } = t2.parameters, x2 = a2.get("text-optional"), b2 = a2.get("icon-optional"), w2 = a2.get("text-allow-overlap"), T2 = a2.get("icon-allow-overlap"), E2 = "map" === a2.get("text-rotation-alignment"), S2 = "map" === a2.get("text-pitch-alignment"), I2 = l2.get("symbol-z-offset"), C3 = "sea" === a2.get("symbol-elevation-reference"), [R2, D3] = a2.get("text-size-scale-range"), [A2, L2] = a2.get("icon-size-scale-range"), P2 = e.aD(r2, R2, D3), z2 = e.aD(r2, A2, L2);
              this.transform.setProjection(n2.projection);
              let M2 = w2 && (T2 || !n2.hasIconData() || b2), O2 = T2 && (w2 || !n2.hasTextData() || x2);
              const F2 = !I2.isConstant();
              !n2.collisionArrays && f2 && n2.deserializeCollisionBoxes(f2), o2 && s2 && n2.updateCollisionDebugBuffers(this.transform.zoom, f2, P2, z2);
              const B3 = (t3, s3, l3) => {
                const { crossTileID: f3, numVerticalGlyphVertices: R3 } = t3;
                let D4 = null;
                if (u5 && u5.dynamicFilterNeedsFeature || F2) {
                  const e2 = this.retainedQueryData[n2.bucketInstanceId];
                  D4 = y2.loadFeature({ featureIndex: t3.featureIndex, bucketIndex: e2.bucketIndex, sourceLayerIndex: e2.sourceLayerIndex, layoutVertexArrayOffset: 0 });
                }
                if (u5 && !(0, u5.dynamicFilter)({ zoom: this.transform.zoom, pitch: this.transform.pitch }, D4, this.retainedQueryData[n2.bucketInstanceId].tileID.canonical, new e.P(t3.tileAnchorX, t3.tileAnchorY), this.transform.calculateDistanceTileData(u5.unwrappedTileID))) return this.placements[f3] = new _i(false, false, false, true), void i2.add(f3);
                const A3 = I2.evaluate(D4, {});
                if (i2.has(f3)) return;
                if (p2) return void (this.placements[f3] = new _i(false, false, false));
                let L3 = false, P3 = false, z3 = true, B4 = false, k2 = false, N2 = null, U2 = { box: null, offscreen: null, occluded: null }, j2 = { box: null, offscreen: null, occluded: null }, V2 = null, G2 = null, q2 = null, Z2 = 0, H2 = 0, W2 = 0;
                l3.textFeatureIndex ? Z2 = l3.textFeatureIndex : t3.useRuntimeCollisionCircles && (Z2 = t3.featureIndex), l3.verticalTextFeatureIndex && (H2 = l3.verticalTextFeatureIndex);
                const $2 = (e2) => {
                  e2.tileID = this.retainedQueryData[n2.bucketInstanceId].tileID;
                  const i3 = this.transform.elevation;
                  e2.elevation = C3 ? A3 : A3 + (i3 ? i3.getAtTileOffset(e2.tileID, e2.tileAnchorX, e2.tileAnchorY) : 0), e2.elevation += t3.zOffset;
                }, X2 = l3.textBox;
                if (X2) {
                  $2(X2);
                  const i3 = (i4) => {
                    let o4 = e.bI.horizontal;
                    if (n2.allowVerticalPlacement && !i4 && this.prevPlacement) {
                      const e2 = this.prevPlacement.placedOrientations[f3];
                      e2 && (this.placedOrientations[f3] = e2, o4 = e2, this.markUsedOrientation(n2, o4, t3));
                    }
                    return o4;
                  }, o3 = (t4, i4) => {
                    if (n2.allowVerticalPlacement && R3 > 0 && l3.verticalTextBox) {
                      for (const o4 of n2.writingModes) if (o4 === e.bI.vertical ? (U2 = i4(), j2 = U2) : U2 = t4(), U2 && U2.box && U2.box.length) break;
                    } else U2 = t4();
                  };
                  if (a2.get("text-variable-anchor")) {
                    let r3 = a2.get("text-variable-anchor");
                    if (this.prevPlacement && this.prevPlacement.variableOffsets[f3]) {
                      const e2 = this.prevPlacement.variableOffsets[f3];
                      r3.indexOf(e2.anchor) > 0 && (r3 = r3.filter((t4) => t4 !== e2.anchor), r3.unshift(e2.anchor));
                    }
                    const h3 = (e2, i4, o4) => {
                      const a3 = n2.getSymbolInstanceTextSize(m2, t3, this.transform.zoom, s3), l4 = (e2.x2 - e2.x1) * a3 + 2 * e2.padding, h4 = (e2.y2 - e2.y1) * a3 + 2 * e2.padding, d4 = t3.hasIconTextFit && !T2 ? i4 : null;
                      d4 && $2(d4);
                      let u6 = { box: [], offscreen: false, occluded: false };
                      const p3 = w2 ? 2 * r3.length : r3.length;
                      for (let i5 = 0; i5 < p3; ++i5) {
                        const p4 = this.attemptAnchorPlacement(r3[i5 % r3.length], e2, l4, h4, a3, E2, S2, _2, c2, v3, i5 >= r3.length, t3, s3, n2, o4, d4, m2, g2);
                        if (p4 && (u6 = p4.placedGlyphBoxes, u6 && u6.box && u6.box.length)) {
                          L3 = true, N2 = p4.shift;
                          break;
                        }
                      }
                      return u6;
                    };
                    o3(() => h3(X2, l3.iconBox, e.bI.horizontal), () => {
                      const t4 = l3.verticalTextBox;
                      return t4 && $2(t4), n2.allowVerticalPlacement && !(U2 && U2.box && U2.box.length) && R3 > 0 && t4 ? h3(t4, l3.verticalIconBox, e.bI.vertical) : { box: null, offscreen: null, occluded: null };
                    }), U2 && (L3 = U2.box, z3 = U2.offscreen, B4 = U2.occluded);
                    const d3 = i3(!(!U2 || !U2.box));
                    if (!L3 && this.prevPlacement) {
                      const e2 = this.prevPlacement.variableOffsets[f3];
                      e2 && (this.variableOffsets[f3] = e2, this.markUsedJustification(n2, e2.anchor, t3, d3));
                    }
                  } else {
                    const a3 = (i4, o4) => {
                      const a4 = n2.getSymbolInstanceTextSize(m2, t3, this.transform.zoom, s3, r2), l4 = this.collisionIndex.placeCollisionBox(n2, a4, i4, new e.P(0, 0), w2, _2, c2, v3.predicate);
                      return l4 && l4.box && l4.box.length && (this.markUsedOrientation(n2, o4, t3), this.placedOrientations[f3] = o4), l4;
                    };
                    o3(() => a3(X2, e.bI.horizontal), () => {
                      const t4 = l3.verticalTextBox;
                      return n2.allowVerticalPlacement && R3 > 0 && t4 ? ($2(t4), a3(t4, e.bI.vertical)) : { box: null, offscreen: null, occluded: null };
                    }), i3(!!(U2 && U2.box && U2.box.length));
                  }
                }
                if (V2 = U2, L3 = V2 && V2.box && V2.box.length > 0, z3 = V2 && V2.offscreen, B4 = V2 && V2.occluded, t3.useRuntimeCollisionCircles) {
                  const i3 = n2.text.placedSymbolArray.get(t3.centerJustifiedTextSymbolIndex >= 0 ? t3.centerJustifiedTextSymbolIndex : t3.verticalPlacedTextSymbolIndex), s4 = e.bJ(n2.textSizeData, m2, i3), r3 = a2.get("text-padding");
                  G2 = this.collisionIndex.placeCollisionCircles(n2, w2, i3, n2.lineVertexArray, n2.glyphOffsetArray, s4, c2, h2, d2, o2, S2, v3.predicate, t3.collisionCircleDiameter * s4 / e.bO, r3, this.retainedQueryData[n2.bucketInstanceId].tileID), L3 = w2 || G2.circles.length > 0 && !G2.collisionDetected, z3 = z3 && G2.offscreen, B4 = G2.occluded;
                }
                if (l3.iconFeatureIndex && (W2 = l3.iconFeatureIndex), l3.iconBox) {
                  const i3 = (i4) => {
                    $2(i4);
                    const o3 = t3.hasIconTextFit && N2 ? vi(N2.x, N2.y, E2, S2, this.transform.angle) : new e.P(0, 0), s4 = n2.getSymbolInstanceIconSize(g2, this.transform.zoom, t3.placedIconSymbolIndex);
                    return this.collisionIndex.placeCollisionBox(n2, s4, i4, o3, T2, _2, c2, v3.predicate);
                  };
                  j2 && j2.box && j2.box.length && l3.verticalIconBox ? (q2 = i3(l3.verticalIconBox), P3 = q2.box.length > 0) : (q2 = i3(l3.iconBox), P3 = q2.box.length > 0), z3 = z3 && q2.offscreen, k2 = q2.occluded;
                }
                const Y2 = x2 || 0 === t3.numHorizontalGlyphVertices && 0 === R3, K2 = b2 || 0 === t3.numIconVertices;
                if (Y2 || K2 ? K2 ? Y2 || (P3 = P3 && L3) : L3 = P3 && L3 : P3 = L3 = P3 && L3, L3 && V2 && V2.box && this.collisionIndex.insertCollisionBox(V2.box, a2.get("text-ignore-placement"), n2.bucketInstanceId, j2 && j2.box && H2 ? H2 : Z2, v3.ID), P3 && q2 && this.collisionIndex.insertCollisionBox(q2.box, a2.get("icon-ignore-placement"), n2.bucketInstanceId, W2, v3.ID), G2 && (L3 && this.collisionIndex.insertCollisionCircles(G2.circles, a2.get("text-ignore-placement"), n2.bucketInstanceId, Z2, v3.ID), o2)) {
                  const e2 = n2.bucketInstanceId;
                  let t4 = this.collisionCircleArrays[e2];
                  void 0 === t4 && (t4 = this.collisionCircleArrays[e2] = new pi());
                  for (let e3 = 0; e3 < G2.circles.length; e3 += 4) t4.circles.push(G2.circles[e3 + 0]), t4.circles.push(G2.circles[e3 + 1]), t4.circles.push(G2.circles[e3 + 2]), t4.circles.push(G2.collisionDetected ? 1 : 0);
                }
                const J2 = "globe" !== n2.projection.name;
                M2 = M2 && (J2 || !B4), O2 = O2 && (J2 || !k2), this.placements[f3] = new _i(L3 || M2, P3 || O2, z3 || n2.justReloaded), i2.add(f3);
              };
              if ("offset" === n2.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(n2, this.retainedQueryData[n2.bucketInstanceId].tileID), "road" === n2.elevationType && n2.updateRoadElevation(), n2.updateZOffset(), n2.sortFeaturesByY) {
                const t3 = n2.getSortedSymbolIndexes(this.transform.angle);
                for (let e2 = t3.length - 1; e2 >= 0; --e2) {
                  const i3 = t3[e2];
                  B3(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
                }
                n2.hasAnyZOffset && e.w(`${n2.layerIds[0]} layer symbol-z-elevate: symbols are not sorted by elevation if symbol-z-order is evaluated to viewport-y`);
              } else if (n2.hasAnyZOffset) {
                const e2 = n2.getSortedIndexesByZOffset();
                for (let t3 = 0; t3 < e2.length; ++t3) {
                  const i3 = e2[t3];
                  B3(n2.symbolInstances.get(i3), i3, n2.collisionArrays[i3]);
                }
              } else for (let e2 = t2.symbolInstanceStart; e2 < t2.symbolInstanceEnd; e2++) B3(n2.symbolInstances.get(e2), e2, n2.collisionArrays[e2]);
              if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
                const t3 = this.collisionCircleArrays[n2.bucketInstanceId];
                e.bi(t3.invProjMatrix, c2), t3.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              n2.justReloaded = false;
            }
            markUsedJustification(t2, i2, o2, s2) {
              const { leftJustifiedTextSymbolIndex: r2, centerJustifiedTextSymbolIndex: n2, rightJustifiedTextSymbolIndex: a2, verticalPlacedTextSymbolIndex: l2, crossTileID: c2 } = o2, h2 = e.bT(i2), d2 = s2 === e.bI.vertical ? l2 : "left" === h2 ? r2 : "center" === h2 ? n2 : "right" === h2 ? a2 : -1;
              r2 >= 0 && (t2.text.placedSymbolArray.get(r2).crossTileID = d2 >= 0 && r2 !== d2 ? 0 : c2), n2 >= 0 && (t2.text.placedSymbolArray.get(n2).crossTileID = d2 >= 0 && n2 !== d2 ? 0 : c2), a2 >= 0 && (t2.text.placedSymbolArray.get(a2).crossTileID = d2 >= 0 && a2 !== d2 ? 0 : c2), l2 >= 0 && (t2.text.placedSymbolArray.get(l2).crossTileID = d2 >= 0 && l2 !== d2 ? 0 : c2);
            }
            markUsedOrientation(t2, i2, o2) {
              const s2 = i2 === e.bI.horizontal || i2 === e.bI.horizontalOnly ? i2 : 0, r2 = i2 === e.bI.vertical ? i2 : 0, { leftJustifiedTextSymbolIndex: n2, centerJustifiedTextSymbolIndex: a2, rightJustifiedTextSymbolIndex: l2, verticalPlacedTextSymbolIndex: c2 } = o2, h2 = t2.text.placedSymbolArray;
              n2 >= 0 && (h2.get(n2).placedOrientation = s2), a2 >= 0 && (h2.get(a2).placedOrientation = s2), l2 >= 0 && (h2.get(l2).placedOrientation = s2), c2 >= 0 && (h2.get(c2).placedOrientation = r2);
            }
            commit(e2) {
              this.commitTime = e2, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const t2 = this.prevPlacement;
              let i2 = false;
              this.prevZoomAdjustment = t2 ? t2.zoomAdjustment(this.transform.zoom) : 0;
              const o2 = t2 ? t2.symbolFadeChange(e2) : 1, s2 = t2 ? t2.opacities : {}, r2 = t2 ? t2.variableOffsets : {}, n2 = t2 ? t2.placedOrientations : {};
              for (const e3 in this.placements) {
                const t3 = this.placements[e3], r3 = s2[e3];
                r3 ? (this.opacities[e3] = new ui(r3, o2, t3.text, t3.icon, null, t3.clipped), i2 = i2 || t3.text !== r3.text.placed || t3.icon !== r3.icon.placed) : (this.opacities[e3] = new ui(null, o2, t3.text, t3.icon, t3.skipFade, t3.clipped), i2 = i2 || t3.text || t3.icon);
              }
              for (const e3 in s2) {
                const t3 = s2[e3];
                if (!this.opacities[e3]) {
                  const s3 = new ui(t3, o2, false, false);
                  s3.isHidden() || (this.opacities[e3] = s3, i2 = i2 || t3.text.placed || t3.icon.placed);
                }
              }
              for (const e3 in r2) this.variableOffsets[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.variableOffsets[e3] = r2[e3]);
              for (const e3 in n2) this.placedOrientations[e3] || !this.opacities[e3] || this.opacities[e3].isHidden() || (this.placedOrientations[e3] = n2[e3]);
              i2 ? this.lastPlacementChangeTime = e2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = t2 ? t2.lastPlacementChangeTime : e2);
            }
            updateLayerOpacities(e2, t2, i2, o2) {
              const s2 = /* @__PURE__ */ new Set();
              for (const r2 of t2) {
                const t3 = r2.getBucket(e2);
                t3 && r2.latestFeatureIndex && e2.fqid === t3.layerIds[0] && (this.updateBucketOpacities(t3, s2, r2, r2.collisionBoxArray, i2, o2, r2.tileID, e2.scope), "offset" === t3.elevationType && this.buildingIndex && this.buildingIndex.updateZOffset(t3, r2.tileID), "road" === t3.elevationType && t3.updateRoadElevation(), t3.updateZOffset());
              }
            }
            updateBucketOpacities(t2, i2, o2, s2, r2, n2, a2, l2) {
              t2.hasTextData() && t2.text.opacityVertexArray.clear(), t2.hasIconData() && t2.icon.opacityVertexArray.clear(), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexArray.clear(), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexArray.clear();
              const c2 = t2.layers[0].layout, h2 = t2.layers[0].paint, d2 = !!t2.layers[0].dynamicFilter(), u5 = new ui(null, 0, false, false, true), _2 = c2.get("text-allow-overlap"), p2 = c2.get("icon-allow-overlap"), f2 = c2.get("text-variable-anchor"), m2 = "map" === c2.get("text-rotation-alignment"), g2 = "map" === c2.get("text-pitch-alignment"), v3 = h2.get("symbol-z-offset"), y2 = "sea" === c2.get("symbol-elevation-reference"), x2 = !v3.isConstant(), b2 = new ui(null, 0, _2 && (p2 || !t2.hasIconData() || c2.get("icon-optional")), p2 && (_2 || !t2.hasTextData() || c2.get("text-optional")), true);
              !t2.collisionArrays && s2 && (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) && t2.deserializeCollisionBoxes(s2);
              const w2 = (e2, t3, i3) => {
                for (let o3 = 0; o3 < t3 / 4; o3++) e2.opacityVertexArray.emplaceBack(i3);
              };
              let T2 = 0;
              n2 && t2.updateReplacement(a2, n2);
              for (let s3 = 0; s3 < t2.symbolInstances.length; s3++) {
                const c3 = t2.symbolInstances.get(s3), { numHorizontalGlyphVertices: h3, numVerticalGlyphVertices: _3, crossTileID: p3, numIconVertices: E2, tileAnchorX: S2, tileAnchorY: I2 } = c3;
                let C3 = null;
                const R2 = this.retainedQueryData[t2.bucketInstanceId];
                x2 && c3 && R2 && (C3 = o2.latestFeatureIndex.loadFeature({ featureIndex: c3.featureIndex, bucketIndex: R2.bucketIndex, sourceLayerIndex: R2.sourceLayerIndex, layoutVertexArrayOffset: 0 }));
                const D3 = v3.evaluate(C3, {}), A2 = i2.has(p3);
                let L2 = this.opacities[p3];
                A2 ? L2 = u5 : L2 || (L2 = b2, this.opacities[p3] = L2), i2.add(p3);
                const P2 = h3 > 0 || _3 > 0, z2 = E2 > 0, M2 = this.placedOrientations[p3], O2 = M2 === e.bI.vertical, F2 = M2 === e.bI.horizontal || M2 === e.bI.horizontalOnly;
                !P2 && !z2 || L2.isHidden() || T2++;
                let B3 = false;
                if ((P2 || z2) && n2) for (const i3 of t2.activeReplacements) {
                  if (e.bP(i3, r2, e.bQ.Symbol, l2)) continue;
                  if (i3.min.x > S2 || S2 > i3.max.x || i3.min.y > I2 || I2 > i3.max.y) continue;
                  const t3 = e.bR(S2, I2, a2.canonical, i3.footprintTileId.canonical);
                  if (B3 = e.bS(t3, i3.footprint), B3) break;
                }
                if (P2) {
                  const e2 = B3 ? Di : Ri(L2.text);
                  w2(t2.text, h3, O2 ? Di : e2), w2(t2.text, _3, F2 ? Di : e2);
                  const i3 = L2.text.isHidden(), { leftJustifiedTextSymbolIndex: o3, centerJustifiedTextSymbolIndex: s4, rightJustifiedTextSymbolIndex: r3, verticalPlacedTextSymbolIndex: n3 } = c3, a3 = t2.text.placedSymbolArray, l3 = i3 || O2 ? 1 : 0;
                  o3 >= 0 && (a3.get(o3).hidden = l3), s4 >= 0 && (a3.get(s4).hidden = l3), r3 >= 0 && (a3.get(r3).hidden = l3), n3 >= 0 && (a3.get(n3).hidden = i3 || F2 ? 1 : 0);
                  const d3 = this.variableOffsets[p3];
                  d3 && this.markUsedJustification(t2, d3.anchor, c3, M2);
                  const u6 = this.placedOrientations[p3];
                  u6 && (this.markUsedJustification(t2, "left", c3, u6), this.markUsedOrientation(t2, u6, c3));
                }
                if (z2) {
                  const e2 = B3 ? Di : Ri(L2.icon), { placedIconSymbolIndex: i3, verticalPlacedIconSymbolIndex: o3 } = c3, s4 = t2.icon.placedSymbolArray, r3 = L2.icon.isHidden() ? 1 : 0;
                  i3 >= 0 && (w2(t2.icon, E2, O2 ? Di : e2), s4.get(i3).hidden = r3), o3 >= 0 && (w2(t2.icon, c3.numVerticalIconVertices, F2 ? Di : e2), s4.get(o3).hidden = r3);
                }
                if (t2.hasIconCollisionBoxData() || t2.hasTextCollisionBoxData()) {
                  const i3 = t2.collisionArrays[s3];
                  if (i3) {
                    let o3 = new e.P(0, 0), s4 = true;
                    if (i3.textBox || i3.verticalTextBox) {
                      if (f2) {
                        const e2 = this.variableOffsets[p3];
                        e2 ? (o3 = gi(e2.anchor, e2.width, e2.height, e2.textOffset, e2.textScale), m2 && o3._rotate(g2 ? this.transform.angle : -this.transform.angle)) : s4 = false;
                      }
                      d2 && (s4 = !L2.clipped), i3.textBox && xi(t2.textCollisionBox.collisionVertexArray, L2.text.placed, !s4 || O2, D3, y2, o3.x, o3.y), i3.verticalTextBox && xi(t2.textCollisionBox.collisionVertexArray, L2.text.placed, !s4 || F2, D3, y2, o3.x, o3.y);
                    }
                    const r3 = s4 && Boolean(!F2 && i3.verticalIconBox);
                    i3.iconBox && xi(t2.iconCollisionBox.collisionVertexArray, L2.icon.placed, r3, D3, y2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0), i3.verticalIconBox && xi(t2.iconCollisionBox.collisionVertexArray, L2.icon.placed, !r3, D3, y2, c3.hasIconTextFit ? o3.x : 0, c3.hasIconTextFit ? o3.y : 0);
                  }
                }
              }
              if (t2.fullyClipped = 0 === T2, t2.sortFeatures(this.transform.angle), this.retainedQueryData[t2.bucketInstanceId] && (this.retainedQueryData[t2.bucketInstanceId].featureSortOrder = t2.featureSortOrder), t2.hasTextData() && t2.text.opacityVertexBuffer && t2.text.opacityVertexBuffer.updateData(t2.text.opacityVertexArray), t2.hasIconData() && t2.icon.opacityVertexBuffer && t2.icon.opacityVertexBuffer.updateData(t2.icon.opacityVertexArray), t2.hasIconCollisionBoxData() && t2.iconCollisionBox.collisionVertexBuffer && t2.iconCollisionBox.collisionVertexBuffer.updateData(t2.iconCollisionBox.collisionVertexArray), t2.hasTextCollisionBoxData() && t2.textCollisionBox.collisionVertexBuffer && t2.textCollisionBox.collisionVertexBuffer.updateData(t2.textCollisionBox.collisionVertexArray), t2.bucketInstanceId in this.collisionCircleArrays) {
                const e2 = this.collisionCircleArrays[t2.bucketInstanceId];
                t2.placementInvProjMatrix = e2.invProjMatrix, t2.placementViewportMatrix = e2.viewportMatrix, t2.collisionCircleArray = e2.circles, delete this.collisionCircleArrays[t2.bucketInstanceId];
              }
            }
            symbolFadeChange(e2) {
              return 0 === this.fadeDuration ? 1 : (e2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(e2) {
              return Math.max(0, (this.transform.zoom - e2) / 1.5);
            }
            hasTransitions(e2) {
              return this.stale || e2 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(e2, t2) {
              const i2 = this.zoomAtLastRecencyCheck === t2 ? 1 - this.zoomAdjustment(t2) : 1;
              return this.zoomAtLastRecencyCheck = t2, this.commitTime + this.fadeDuration * i2 > e2;
            }
            setStale() {
              this.stale = true;
            }
          }
          function xi(e2, t2, i2, o2, s2, r2, n2) {
            e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0), e2.emplaceBack(t2 ? 1 : 0, i2 ? 1 : 0, r2 || 0, n2 || 0, o2, s2 ? 1 : 0);
          }
          const bi = Math.pow(2, 25), wi = Math.pow(2, 24), Ti = Math.pow(2, 17), Ei = Math.pow(2, 16), Si = Math.pow(2, 9), Ii = Math.pow(2, 8), Ci = Math.pow(2, 1);
          function Ri(e2) {
            if (0 === e2.opacity && !e2.placed) return 0;
            if (1 === e2.opacity && e2.placed) return 4294967295;
            const t2 = e2.placed ? 1 : 0, i2 = Math.floor(127 * e2.opacity);
            return i2 * bi + t2 * wi + i2 * Ti + t2 * Ei + i2 * Si + t2 * Ii + i2 * Ci + t2;
          }
          const Di = 0;
          class Ai {
            constructor(e2) {
              this._sortAcrossTiles = "viewport-y" !== e2.layout.get("symbol-z-order") && void 0 !== e2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = /* @__PURE__ */ new Set(), this._bucketParts = [];
            }
            continuePlacement(e2, t2, i2, o2, s2, r2) {
              const n2 = this._bucketParts;
              for (; this._currentTileIndex < e2.length; ) if (t2.getBucketParts(n2, o2, e2[this._currentTileIndex], this._sortAcrossTiles, r2), this._currentTileIndex++, s2()) return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, n2.sort((e3, t3) => e3.sortKey - t3.sortKey)); this._currentPartIndex < n2.length; ) {
                const e3 = n2[this._currentPartIndex];
                if (t2.placeLayerBucketPart(e3, this._seenCrossTileIDs, i2, 0 === e3.symbolInstanceStart, r2), this._currentPartIndex++, s2()) return true;
              }
              return false;
            }
          }
          class Li {
            constructor(e2, t2, i2, o2, s2, r2, n2, a2, l2) {
              this.placement = new yi(e2, s2, r2, n2, a2, l2), this._currentPlacementIndex = t2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(t2, i2, o2, s2, r2) {
              const n2 = e.q.now(), a2 = () => {
                const t3 = e.q.now() - n2;
                return !this._forceFullPlacement && t3 > 2;
              };
              for (; this._currentPlacementIndex >= 0; ) {
                const n3 = i2[t2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === n3.type && (!n3.minzoom || n3.minzoom <= l2) && (!n3.maxzoom || n3.maxzoom > l2)) {
                  const t3 = n3, i3 = t3.layout.get("symbol-z-elevate"), l3 = void 0 !== t3.layout.get("symbol-sort-key").constantOr(1), c2 = t3.layout.get("symbol-z-order"), h2 = "viewport-y" === c2 || "auto" === c2 && !("viewport-y" !== c2 && l3), d2 = t3.layout.get("text-allow-overlap") || t3.layout.get("icon-allow-overlap") || t3.layout.get("text-ignore-placement") || t3.layout.get("icon-ignore-placement"), u5 = h2 && d2, _2 = this._inProgressLayer = this._inProgressLayer || new Ai(t3), p2 = e.C(n3.source, n3.scope);
                  if (_2.continuePlacement(i3 || u5 ? s2[p2] : o2[p2], this.placement, this._showCollisionBoxes, n3, a2, r2)) return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(e2) {
              return this.placement.commit(e2), this.placement;
            }
          }
          const Pi = 512 / e.aj / 2;
          class zi {
            constructor(t2, i2, o2) {
              this.tileID = t2, this.bucketInstanceId = o2, this.index = new e.bW(i2.length, 16, Int32Array), this.keys = [], this.crossTileIDs = [];
              const s2 = t2.canonical.x * e.aj, r2 = t2.canonical.y * e.aj;
              for (let e2 = 0; e2 < i2.length; e2++) {
                const { key: t3, crossTileID: o3, tileAnchorX: n2, tileAnchorY: a2 } = i2.get(e2), l2 = Math.floor((s2 + n2) * Pi), c2 = Math.floor((r2 + a2) * Pi);
                this.index.add(l2, c2), this.keys.push(t3), this.crossTileIDs.push(o3);
              }
              this.index.finish();
            }
            findMatches(t2, i2, o2) {
              const s2 = this.tileID.canonical.z < i2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i2.canonical.z), r2 = Pi / Math.pow(2, i2.canonical.z - this.tileID.canonical.z), n2 = i2.canonical.x * e.aj, a2 = i2.canonical.y * e.aj;
              for (let e2 = 0; e2 < t2.length; e2++) {
                const i3 = t2.get(e2);
                if (i3.crossTileID) continue;
                const { key: l2, tileAnchorX: c2, tileAnchorY: h2 } = i3, d2 = Math.floor((n2 + c2) * r2), u5 = Math.floor((a2 + h2) * r2), _2 = this.index.range(d2 - s2, u5 - s2, d2 + s2, u5 + s2).sort((e3, t3) => e3 - t3);
                for (const e3 of _2) {
                  const t3 = this.crossTileIDs[e3];
                  if (this.keys[e3] === l2 && !o2.has(t3)) {
                    o2.add(t3), i3.crossTileID = t3;
                    break;
                  }
                }
              }
            }
          }
          class Mi {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Oi {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(e2) {
              const t2 = Math.round((e2 - this.lng) / 360);
              if (0 !== t2) for (const e3 in this.indexes) {
                const i2 = this.indexes[e3], o2 = {};
                for (const e4 in i2) {
                  const s2 = i2[e4];
                  s2.tileID = s2.tileID.unwrapTo(s2.tileID.wrap + t2), o2[s2.tileID.key] = s2;
                }
                this.indexes[e3] = o2;
              }
              this.lng = e2;
            }
            addBucket(e2, t2, i2) {
              if (this.indexes[e2.overscaledZ] && this.indexes[e2.overscaledZ][e2.key]) {
                if (this.indexes[e2.overscaledZ][e2.key].bucketInstanceId === t2.bucketInstanceId) return false;
                this.removeBucketCrossTileIDs(e2.overscaledZ, this.indexes[e2.overscaledZ][e2.key]);
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) t2.symbolInstances.get(e3).crossTileID = 0;
              this.usedCrossTileIDs[e2.overscaledZ] || (this.usedCrossTileIDs[e2.overscaledZ] = /* @__PURE__ */ new Set());
              const o2 = this.usedCrossTileIDs[e2.overscaledZ];
              for (const i3 in this.indexes) {
                const s2 = this.indexes[i3];
                if (Number(i3) > e2.overscaledZ) for (const i4 in s2) {
                  const r2 = s2[i4];
                  r2.tileID.isChildOf(e2) && r2.findMatches(t2.symbolInstances, e2, o2);
                }
                else {
                  const r2 = s2[e2.scaledTo(Number(i3)).key];
                  r2 && r2.findMatches(t2.symbolInstances, e2, o2);
                }
              }
              for (let e3 = 0; e3 < t2.symbolInstances.length; e3++) {
                const s2 = t2.symbolInstances.get(e3);
                s2.crossTileID || (s2.crossTileID = i2.generate(), o2.add(s2.crossTileID));
              }
              return void 0 === this.indexes[e2.overscaledZ] && (this.indexes[e2.overscaledZ] = {}), this.indexes[e2.overscaledZ][e2.key] = new zi(e2, t2.symbolInstances, t2.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(e2, t2) {
              for (const i2 of t2.crossTileIDs) this.usedCrossTileIDs[e2].delete(i2);
            }
            removeStaleBuckets(e2) {
              let t2 = false;
              for (const i2 in this.indexes) {
                const o2 = this.indexes[i2];
                for (const s2 in o2) e2[o2[s2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[s2]), delete o2[s2], t2 = true);
              }
              return t2;
            }
          }
          class Fi {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Mi(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(e2, t2, i2, o2) {
              let s2 = this.layerIndexes[e2.fqid];
              void 0 === s2 && (s2 = this.layerIndexes[e2.fqid] = new Oi());
              let r2 = false;
              const n2 = {};
              "globe" !== o2.name && s2.handleWrapJump(i2);
              for (const i3 of t2) {
                const t3 = i3.getBucket(e2);
                t3 && e2.fqid === t3.layerIds[0] && (t3.bucketInstanceId || (t3.bucketInstanceId = ++this.maxBucketInstanceId), s2.addBucket(i3.tileID, t3, this.crossTileIDs) && (r2 = true), n2[t3.bucketInstanceId] = true);
              }
              return s2.removeStaleBuckets(n2) && (r2 = true), r2;
            }
            pruneUnusedLayers(e2) {
              const t2 = {};
              e2.forEach((e3) => {
                t2[e3] = true;
              });
              for (const e3 in this.layerIndexes) t2[e3] || delete this.layerIndexes[e3];
            }
          }
          const Bi = 771;
          class ki {
            constructor(e2, t2, i2, o2) {
              this.blendFunction = e2, this.blendColor = t2, this.mask = i2, this.blendEquation = o2;
            }
          }
          ki.Replace = [1, 0, 1, 0], ki.disabled = new ki(ki.Replace, e.am.transparent, [false, false, false, false]), ki.unblended = new ki(ki.Replace, e.am.transparent, [true, true, true, true]), ki.alphaBlended = new ki([1, Bi, 1, Bi], e.am.transparent, [true, true, true, true]), ki.alphaBlendedNonPremultiplied = new ki([770, Bi, 770, Bi], e.am.transparent, [true, true, true, true]), ki.multiply = new ki([774, 0, 774, 0], e.am.transparent, [true, true, true, true]);
          class Ni {
            constructor(e2, t2, i2) {
              this.func = e2, this.mask = t2, this.range = i2;
            }
          }
          Ni.ReadOnly = false, Ni.ReadWrite = true, Ni.disabled = new Ni(519, Ni.ReadOnly, [0, 1]);
          const Ui = 7680;
          class ji {
            constructor(e2, t2, i2, o2, s2, r2) {
              this.test = e2, this.ref = t2, this.mask = i2, this.fail = o2, this.depthFail = s2, this.pass = r2;
            }
          }
          ji.disabled = new ji({ func: 519, mask: 0 }, 0, 0, Ui, Ui, Ui);
          const Vi = 1029, Gi = 2305;
          class qi {
            constructor(e2, t2, i2) {
              this.enable = e2, this.mode = t2, this.frontFace = i2;
            }
          }
          function Zi(t2, i2) {
            const o2 = e.c1(t2, 3);
            e.c3(t2, i2), e.c7(t2, 3, o2);
          }
          function Hi(t2, i2) {
            const o2 = e.bY([]);
            return e.bZ(o2, o2, -i2), e.b_(o2, o2, -t2), o2;
          }
          function Wi(t2, i2) {
            const o2 = [t2[0], t2[1], 0], s2 = [i2[0], i2[1], 0];
            if (e.ae(o2) >= 1e-15) {
              const t3 = e.au([], o2);
              e.b$(s2, t3, e.bE(s2, t3)), i2[0] = s2[0], i2[1] = s2[1];
            }
            const r2 = e.bG([], i2, t2);
            if (e.c0(r2) < 1e-15) return null;
            const n2 = Math.atan2(-r2[1], r2[0]);
            return Hi(Math.atan2(Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]), -t2[2]), n2);
          }
          qi.disabled = new qi(false, Vi, Gi), qi.backCCW = new qi(true, Vi, Gi), qi.backCW = new qi(true, Vi, 2304), qi.frontCW = new qi(true, 1028, 2304), qi.frontCCW = new qi(true, 1028, Gi);
          class $i {
            constructor(e2, t2) {
              this.position = e2, this.orientation = t2;
            }
            get position() {
              return this._position;
            }
            set position(t2) {
              if (t2) {
                const i2 = t2 instanceof e.ac ? t2 : new e.ac(t2[0], t2[1], t2[2]);
                this._renderWorldCopies && (i2.x = e.bX(i2.x, 0, 1)), this._position = i2;
              } else this._position = null;
            }
            lookAtPoint(t2, i2) {
              if (this.orientation = null, !this.position) return;
              const o2 = this.position, s2 = this._elevation ? this._elevation.getAtPointOrZero(e.ac.fromLngLat(t2)) : 0, r2 = e.ac.fromLngLat(t2, s2), n2 = [r2.x - o2.x, r2.y - o2.y, r2.z - o2.z];
              i2 || (i2 = [0, 0, 1]), i2[2] = Math.abs(i2[2]), this.orientation = Wi(n2, i2);
            }
            setPitchBearing(t2, i2) {
              this.orientation = Hi(e.al(t2), e.al(-i2));
            }
          }
          class Xi {
            constructor(t2, i2) {
              this._transform = e.bx([]), this.orientation = i2, this.position = t2;
            }
            get mercatorPosition() {
              const t2 = this.position;
              return new e.ac(t2[0], t2[1], t2[2]);
            }
            get position() {
              const t2 = e.c1(this._transform, 3);
              return [t2[0], t2[1], t2[2]];
            }
            set position(t2) {
              var i2;
              t2 && e.c7(this._transform, 3, [(i2 = t2)[0], i2[1], i2[2], 1]);
            }
            get orientation() {
              return this._orientation;
            }
            set orientation(t2) {
              this._orientation = t2 || e.bY([]), t2 && Zi(this._transform, this._orientation);
            }
            getPitchBearing() {
              const e2 = this.forward(), t2 = this.right();
              return { bearing: Math.atan2(-t2[1], t2[0]), pitch: Math.atan2(Math.sqrt(e2[0] * e2[0] + e2[1] * e2[1]), -e2[2]) };
            }
            setPitchBearing(e2, t2) {
              this._orientation = Hi(e2, t2), Zi(this._transform, this._orientation);
            }
            forward() {
              const t2 = e.c1(this._transform, 2);
              return [-t2[0], -t2[1], -t2[2]];
            }
            up() {
              const t2 = e.c1(this._transform, 1);
              return [-t2[0], -t2[1], -t2[2]];
            }
            right() {
              const t2 = e.c1(this._transform, 0);
              return [t2[0], t2[1], t2[2]];
            }
            getCameraToWorld(t2, i2) {
              const o2 = new Float64Array(16);
              return e.bi(o2, this.getWorldToCamera(t2, i2)), o2;
            }
            getCameraToWorldMercator() {
              return this._transform;
            }
            getWorldToCameraPosition(t2, i2, o2) {
              const s2 = this.position;
              e.b$(s2, s2, -t2);
              const r2 = new Float64Array(16);
              return e.bn(r2, [o2, o2, o2]), e.bo(r2, r2, s2), r2[10] *= i2, r2;
            }
            getWorldToCamera(t2, i2) {
              const o2 = new Float64Array(16), s2 = new Float64Array(4), r2 = this.position;
              return e.c2(s2, this._orientation), e.b$(r2, r2, -t2), e.c3(o2, s2), e.bo(o2, o2, r2), o2[1] *= -1, o2[5] *= -1, o2[9] *= -1, o2[13] *= -1, o2[8] *= i2, o2[9] *= i2, o2[10] *= i2, o2[11] *= i2, o2;
            }
            getCameraToClipPerspective(t2, i2, o2, s2) {
              const r2 = new Float64Array(16);
              return e.c4(r2, t2, i2, o2, s2), r2;
            }
            getCameraToClipOrthographic(t2, i2, o2, s2, r2, n2) {
              const a2 = new Float64Array(16);
              return e.c5(a2, t2, i2, o2, s2, r2, n2), a2;
            }
            getDistanceToElevation(t2, i2 = false) {
              const o2 = 0 === t2 ? 0 : e.c6(t2, i2 ? e.aY(this.position[1]) : this.position[1]), s2 = this.forward();
              return (o2 - this.position[2]) / s2[2];
            }
            clone() {
              return new Xi([...this.position], [...this.orientation]);
            }
          }
          const Yi = { BaseColor: 5, MetallicRoughness: 6, Normal: 7, Occlusion: 8, Emission: 9, LUT: 10, ShadowMap0: 11 };
          class Ki {
            constructor(e2 = 0, t2 = 0, i2 = 0, o2 = 0) {
              if (isNaN(e2) || e2 < 0 || isNaN(t2) || t2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0) throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = e2, this.bottom = t2, this.left = i2, this.right = o2;
            }
            interpolate(t2, i2, o2) {
              return null != i2.top && null != t2.top && (this.top = e.ai(t2.top, i2.top, o2)), null != i2.bottom && null != t2.bottom && (this.bottom = e.ai(t2.bottom, i2.bottom, o2)), null != i2.left && null != t2.left && (this.left = e.ai(t2.left, i2.left, o2)), null != i2.right && null != t2.right && (this.right = e.ai(t2.right, i2.right, o2)), this;
            }
            getCenter(t2, i2) {
              const o2 = e.aD((this.left + t2 - this.right) / 2, 0, t2), s2 = e.aD((this.top + i2 - this.bottom) / 2, 0, i2);
              return new e.P(o2, s2);
            }
            equals(e2) {
              return this.top === e2.top && this.bottom === e2.bottom && this.left === e2.left && this.right === e2.right;
            }
            clone() {
              return new Ki(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          const Ji = 15;
          class Qi {
            constructor(t2, i2, o2, s2, r2, n2, a2) {
              this.tileSize = 512, this._renderWorldCopies = void 0 === r2 || r2, this._minZoom = t2 || 0, this._maxZoom = i2 || 22, this._minPitch = o2 ?? 0, this._maxPitch = s2 ?? 60, this.setProjection(n2), this.setMaxBounds(a2), this.width = 0, this.height = 0, this._center = new e.cd(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._nearZ = 0, this._farZ = 0, this._unmodified = true, this._edgeInsets = new Ki(), this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._fogTileMatrixCache = {}, this._expandedProjMatrixCache = {}, this._distanceTileDataCache = {}, this._camera = new Xi(), this._centerAltitude = 0, this._averageElevation = 0, this.cameraElevationReference = "ground", this._pixelsPerMercatorPixel = 1, this.globeRadius = 0, this.globeCenterInViewSpace = [0, 0, 0], this._tileCoverLift = 0, this.freezeTileCoverage = false, this._horizonShift = 0.1, this._orthographicProjectionAtLowPitch = false, this._allowWorldUnderZoom = false;
            }
            clone() {
              const e2 = new Qi(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies, this.getProjection(), this.maxBounds);
              return e2._elevation = this._elevation, e2._centerAltitude = this._centerAltitude, e2._centerAltitudeValidForExaggeration = this._centerAltitudeValidForExaggeration, e2.tileSize = this.tileSize, e2.mercatorFromTransition = this.mercatorFromTransition, e2.width = this.width, e2.height = this.height, e2.cameraElevationReference = this.cameraElevationReference, e2._center = this._center, e2._setZoom(this.zoom), e2._seaLevelZoom = this._seaLevelZoom, e2.angle = this.angle, e2._fov = this._fov, e2._pitch = this._pitch, e2._nearZ = this._nearZ, e2._farZ = this._farZ, e2._averageElevation = this._averageElevation, e2._orthographicProjectionAtLowPitch = this._orthographicProjectionAtLowPitch, e2._unmodified = this._unmodified, e2._edgeInsets = this._edgeInsets.clone(), e2._camera = this._camera.clone(), e2._calcMatrices(), e2.freezeTileCoverage = this.freezeTileCoverage, e2.frustumCorners = this.frustumCorners, e2._allowWorldUnderZoom = this._allowWorldUnderZoom, e2;
            }
            get isOrthographic() {
              return "globe" !== this.projection.name && this._orthographicProjectionAtLowPitch && this.pitch < Ji;
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(e2) {
              this._elevation !== e2 && (this._elevation = e2, this._updateCameraOnTerrain(), this._calcMatrices());
            }
            get depthOcclusionForSymbolsAndCircles() {
              return "globe" !== this.projection.name && !this.isOrthographic;
            }
            updateElevation(e2, t2 = false) {
              const i2 = this._elevation && this._elevation.exaggeration() !== this._centerAltitudeValidForExaggeration;
              (null == this._seaLevelZoom || i2) && this._updateCameraOnTerrain(), (e2 || i2) && this._constrainCamera(t2), this._calcMatrices();
            }
            getProjection() {
              return e.aF(this.projection, ["name", "center", "parallels"]);
            }
            setProjection(t2) {
              this.projectionOptions = t2 || { name: "mercator" };
              const i2 = this.projection ? this.getProjection() : void 0;
              this.projection = e.ce(this.projectionOptions);
              const o2 = this.getProjection(), s2 = !e.bv(i2, o2);
              return s2 && this._calcMatrices(), this.mercatorFromTransition = false, s2;
            }
            setOrthographicProjectionAtLowPitch(e2) {
              return this._orthographicProjectionAtLowPitch !== e2 && (this._orthographicProjectionAtLowPitch = e2, this._calcMatrices(), true);
            }
            setMercatorFromTransition() {
              const t2 = this.projection.name;
              this.mercatorFromTransition = true, this.projectionOptions = { name: "mercator" }, this.projection = e.ce({ name: "mercator" });
              const i2 = t2 !== this.projection.name;
              return i2 && this._calcMatrices(), i2;
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(e2) {
              this._minZoom !== e2 && (this._minZoom = e2, this.zoom = Math.max(this.zoom, e2));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(e2) {
              this._maxZoom !== e2 && (this._maxZoom = e2, this.zoom = Math.min(this.zoom, e2));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(e2) {
              this._minPitch !== e2 && (this._minPitch = e2, this.pitch = Math.max(this.pitch, e2));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(e2) {
              this._maxPitch !== e2 && (this._maxPitch = e2, this.pitch = Math.min(this.pitch, e2));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies && true === this.projection.supportsWorldCopies;
            }
            set renderWorldCopies(e2) {
              void 0 === e2 ? e2 = true : null === e2 && (e2 = false), this._renderWorldCopies = e2;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get cameraWorldSizeForFog() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get cameraWorldSize() {
              const e2 = Math.max(this._camera.getDistanceToElevation(this._averageElevation, true), Number.EPSILON);
              return this._worldSizeFromZoom(this._zoomFromMercatorZ(e2));
            }
            get pixelsPerMeter() {
              return this.projection.pixelsPerMeter(this.center.lat, this.worldSize);
            }
            get cameraPixelsPerMeter() {
              return e.c6(1, this.center.lat) * this.cameraWorldSizeForFog;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new e.P(this.width, this.height);
            }
            get bearing() {
              return e.bX(this.rotation, -180, 180);
            }
            set bearing(e2) {
              this.rotation = e2;
            }
            get rotation() {
              return -this.angle / Math.PI * 180;
            }
            set rotation(t2) {
              const i2 = -t2 * Math.PI / 180;
              this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = e.cf(), e.cg(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(t2) {
              const i2 = e.aD(t2, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
            }
            get aspect() {
              return this.width / this.height;
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t2) {
              t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = e.al(t2), this._calcMatrices());
            }
            get fovX() {
              return this._fov;
            }
            get fovY() {
              const e2 = 1 / Math.tan(0.5 * this.fovX);
              return 2 * Math.atan(1 / this.aspect / e2);
            }
            get averageElevation() {
              return this._averageElevation;
            }
            set averageElevation(e2) {
              this._averageElevation = e2, this._calcFogMatrices(), this._distanceTileDataCache = {};
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(e2) {
              const t2 = Math.min(Math.max(e2, this.minZoom), this.maxZoom);
              this._zoom !== t2 && (this._unmodified = false, this._setZoom(t2), this._updateSeaLevelZoom(), this._constrain(), this._calcMatrices());
            }
            _setZoom(e2) {
              this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom;
            }
            get tileCoverLift() {
              return this._tileCoverLift;
            }
            set tileCoverLift(e2) {
              this._tileCoverLift !== e2 && (this._tileCoverLift = e2);
            }
            _updateCameraOnTerrain() {
              const e2 = this.elevation ? this.elevation.getAtPoint(this.locationCoordinate(this.center), Number.NEGATIVE_INFINITY) : Number.NEGATIVE_INFINITY, t2 = this.elevation && e2 === Number.NEGATIVE_INFINITY && this.elevation.visibleDemTiles.length > 0 && this.elevation.exaggeration() > 0 && this._centerAltitudeValidForExaggeration;
              if (!this._elevation || e2 === Number.NEGATIVE_INFINITY && (!t2 || !this._centerAltitude)) return this._centerAltitude = 0, this._seaLevelZoom = null, void (this._centerAltitudeValidForExaggeration = void 0);
              const i2 = this._elevation;
              t2 || this._centerAltitude && this._centerAltitudeValidForExaggeration && i2.exaggeration() && this._centerAltitudeValidForExaggeration !== i2.exaggeration() ? (this._centerAltitude = this._centerAltitude / this._centerAltitudeValidForExaggeration * i2.exaggeration(), this._centerAltitudeValidForExaggeration = i2.exaggeration()) : (this._centerAltitude = e2 || 0, this._centerAltitudeValidForExaggeration = i2.exaggeration()), this._updateSeaLevelZoom();
            }
            _updateSeaLevelZoom() {
              void 0 !== this._centerAltitudeValidForExaggeration && (this._seaLevelZoom = this._zoomFromMercatorZ((this.pixelsPerMeter * this._centerAltitude + this.cameraToCenterDistance) / this.worldSize));
            }
            sampleAverageElevation() {
              if (!this._elevation) return 0;
              const t2 = this._elevation, i2 = [[0.5, 0.2], [0.3, 0.5], [0.5, 0.5], [0.7, 0.5], [0.5, 0.8]], o2 = this.horizonLineFromTop();
              let s2 = 0, r2 = 0;
              for (let n2 = 0; n2 < i2.length; n2++) {
                const a2 = new e.P(i2[n2][0] * this.width, o2 + i2[n2][1] * (this.height - o2)), l2 = t2.pointCoordinate(a2);
                if (!l2) continue;
                const c2 = 1 / Math.hypot(l2[0] - this._camera.position[0], l2[1] - this._camera.position[1]);
                s2 += l2[3] * c2, r2 += c2;
              }
              return 0 === r2 ? NaN : s2 / r2;
            }
            get center() {
              return this._center;
            }
            set center(e2) {
              e2.lat === this._center.lat && e2.lng === this._center.lng || (this._unmodified = false, this._center = e2, this._terrainEnabled() && ("ground" === this.cameraElevationReference ? this._updateCameraOnTerrain() : this._updateZoomFromElevation()), this._constrain(), this._calcMatrices());
            }
            _updateZoomFromElevation() {
              if (null == this._seaLevelZoom || !this._elevation) return;
              const e2 = this._seaLevelZoom, t2 = this._elevation.getAtPointOrZero(this.locationCoordinate(this.center)), i2 = this.pixelsPerMeter / this.worldSize * t2, o2 = this._mercatorZfromZoom(e2), s2 = this._mercatorZfromZoom(this._maxZoom), r2 = Math.max(o2 - i2, s2);
              this._setZoom(this._zoomFromMercatorZ(r2));
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(e2) {
              this._edgeInsets.equals(e2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, e2, 1), this._calcMatrices());
            }
            computeZoomRelativeTo(t2) {
              const i2 = this.rayIntersectionCoordinate(this.pointRayIntersection(this.centerPoint, t2.toAltitude()));
              let o2;
              o2 = t2.z < this._camera.position[2] ? [i2.x, i2.y, i2.z] : [t2.x, t2.y, t2.z];
              const s2 = e.ae(e.at([], this._camera.position, o2));
              return e.aD(this._zoomFromMercatorZ(s2), this._minZoom, this._maxZoom);
            }
            setFreeCameraOptions(t2) {
              if (!this.height) return;
              if (!t2.position && !t2.orientation) return;
              this._updateCameraState();
              let i2 = false;
              if (t2.orientation && !e.ch(t2.orientation, this._camera.orientation) && (i2 = this._setCameraOrientation(t2.orientation)), t2.position) {
                const o2 = [t2.position.x, t2.position.y, t2.position.z];
                e.ci(o2, this._camera.position) || (this._setCameraPosition(o2), i2 = true);
              }
              i2 && (this._updateStateFromCamera(), this.recenterOnTerrain());
            }
            getFreeCameraOptions() {
              this._updateCameraState();
              const t2 = this._camera.position, i2 = new $i();
              return i2.position = new e.ac(t2[0], t2[1], t2[2]), i2.orientation = this._camera.orientation, i2._elevation = this.elevation, i2._renderWorldCopies = this.renderWorldCopies, i2;
            }
            _setCameraOrientation(t2) {
              if (!e.cj(t2)) return false;
              e.ck(t2, t2);
              const i2 = e.cl([], [0, 0, -1], t2), o2 = e.cl([], [0, -1, 0], t2);
              if (o2[2] < 0) return false;
              const s2 = Wi(i2, o2);
              return !!s2 && (this._camera.orientation = s2, true);
            }
            _setCameraPosition(t2) {
              const i2 = this.zoomScale(this.minZoom) * this.tileSize, o2 = this.zoomScale(this.maxZoom) * this.tileSize, s2 = this.cameraToCenterDistance;
              t2[2] = e.aD(t2[2], s2 / o2, s2 / i2), this._camera.position = t2;
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            get fovAboveCenter() {
              return this._fov * (0.5 + this.centerOffset.y / this.height);
            }
            isPaddingEqual(e2) {
              return this._edgeInsets.equals(e2);
            }
            interpolatePadding(e2, t2, i2) {
              this._unmodified = false, this._edgeInsets.interpolate(e2, t2, i2), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(e2) {
              const t2 = (e2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / e2.tileSize));
              return Math.max(0, t2);
            }
            getVisibleUnwrappedCoordinates(t2) {
              const i2 = [new e.cm(0, t2)];
              if (this.renderWorldCopies) {
                const o2 = this.pointCoordinate(new e.P(0, 0)), s2 = this.pointCoordinate(new e.P(this.width, 0)), r2 = this.pointCoordinate(new e.P(this.width, this.height)), n2 = this.pointCoordinate(new e.P(0, this.height)), a2 = Math.floor(Math.min(o2.x, s2.x, r2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, s2.x, r2.x, n2.x)), c2 = 1;
                for (let o3 = a2 - c2; o3 <= l2 + c2; o3++) 0 !== o3 && i2.push(new e.cm(o3, t2));
              }
              return i2;
            }
            isLODDisabled(e2) {
              return (!e2 || this.pitch <= 60) && this._edgeInsets.top <= this._edgeInsets.bottom && !this._elevation && !this.projection.isReprojectedInTileSpace;
            }
            extendTileCover(t2, i2, o2) {
              let s2 = [];
              const r2 = null != o2, n2 = !r2;
              if (n2 && this.zoom < i2) return s2;
              if (r2 && 0 === o2[0] && 0 === o2[1]) return s2;
              const a2 = /* @__PURE__ */ new Set(), l2 = (t3, i3, o3, r3, n3) => {
                const l3 = e.cK(i3, t3, o3, r3, n3);
                a2.has(l3) || (s2.push(new e.aM(t3, i3, o3, r3, n3)), a2.add(l3));
              };
              for (let e2 = 0; e2 < t2.length; e2++) {
                const s3 = t2[e2];
                if (n2 && s3.canonical.z !== i2) continue;
                const a3 = s3.canonical, c3 = s3.overscaledZ, h2 = s3.wrap, d2 = 1 << a3.z, u5 = a3.x + 1 < d2, _2 = a3.x > 0, p2 = a3.y + 1 < d2, f2 = a3.y > 0, m2 = s3.wrap - (_2 ? 0 : 1), g2 = s3.wrap + (u5 ? 0 : 1), v3 = _2 ? a3.x - 1 : d2 - 1, y2 = u5 ? a3.x + 1 : 0;
                if (r2) o2[0] < 0 ? (l2(c3, g2, a3.z, y2, a3.y), o2[1] < 0 && p2 && (l2(c3, h2, a3.z, a3.x, a3.y + 1), l2(c3, g2, a3.z, y2, a3.y + 1)), o2[1] > 0 && f2 && (l2(c3, h2, a3.z, a3.x, a3.y - 1), l2(c3, g2, a3.z, y2, a3.y - 1))) : o2[0] > 0 ? (l2(c3, m2, a3.z, v3, a3.y), o2[1] < 0 && p2 && (l2(c3, h2, a3.z, a3.x, a3.y + 1), l2(c3, m2, a3.z, v3, a3.y + 1)), o2[1] > 0 && f2 && (l2(c3, h2, a3.z, a3.x, a3.y - 1), l2(c3, m2, a3.z, v3, a3.y - 1))) : o2[1] < 0 && p2 ? l2(c3, h2, a3.z, a3.x, a3.y + 1) : f2 && l2(c3, h2, a3.z, a3.x, a3.y - 1);
                else {
                  const e3 = s3.visibleQuadrants;
                  1 & e3 && (l2(c3, m2, a3.z, v3, a3.y), f2 && (l2(c3, h2, a3.z, a3.x, a3.y - 1), l2(c3, m2, a3.z, v3, a3.y - 1))), 2 & e3 && (l2(c3, g2, a3.z, y2, a3.y), f2 && (l2(c3, h2, a3.z, a3.x, a3.y - 1), l2(c3, g2, a3.z, y2, a3.y - 1))), 4 & e3 && (l2(c3, m2, a3.z, v3, a3.y), p2 && (l2(c3, h2, a3.z, a3.x, a3.y + 1), l2(c3, m2, a3.z, v3, a3.y + 1))), 8 & e3 && (l2(c3, g2, a3.z, y2, a3.y), p2 && (l2(c3, h2, a3.z, a3.x, a3.y + 1), l2(c3, g2, a3.z, y2, a3.y + 1)));
                }
              }
              const c2 = [];
              for (const e2 of s2) s2.some((t3) => e2.isChildOf(t3)) || c2.push(e2);
              if (s2 = c2.filter((e2) => !t2.some((t3) => !!(e2.overscaledZ < i2 && t3.isChildOf(e2)) || e2.equals(t3) || e2.isChildOf(t3))), n2) {
                const e2 = 1 << i2, t3 = "globe" === this.projection.name ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), o3 = [e2 * t3.x, e2 * t3.y], r3 = 4, n3 = r3 * r3;
                s2 = s2.filter((e3) => {
                  const t4 = e3.canonical.x + 0.5 - o3[0], i3 = e3.canonical.y + 0.5 - o3[1];
                  return t4 * t4 + i3 * i3 < n3;
                });
              }
              return s2;
            }
            coveringTiles(t2) {
              let i2 = this.coveringZoomLevel(t2);
              const o2 = i2, s2 = this.elevation && this.elevation.exaggeration(), r2 = s2 && !t2.isTerrainDEM, n2 = "mercator" === this.projection.name;
              if (void 0 !== t2.minzoom && i2 < t2.minzoom) return [];
              void 0 !== t2.maxzoom && i2 > t2.maxzoom && (i2 = t2.maxzoom);
              const a2 = this.locationCoordinate(this.center), l2 = this.center.lat, c2 = 1 << i2, h2 = [c2 * a2.x, c2 * a2.y, 0], d2 = "globe" === this.projection.name, u5 = !d2, _2 = e.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2, u5), p2 = d2 ? this._camera.mercatorPosition : this.pointCoordinate(this.getCameraPoint()), f2 = c2 * e.c6(1, this.center.lat), m2 = this._camera.position[2] / e.c6(1, this.center.lat), g2 = [c2 * p2.x, c2 * p2.y, m2 * (u5 ? 1 : f2)], v3 = d2 || s2, y2 = this.cameraToCenterDistance / t2.tileSize * (t2.roundZoom ? 1 : 0.502), x2 = this.isLODDisabled(true) ? i2 : 0;
              let b2;
              if (this._elevation && t2.isTerrainDEM) b2 = 1e4 * this._elevation.exaggeration();
              else if (this._elevation) {
                const e2 = this._elevation.getMinMaxForVisibleTiles();
                b2 = e2 ? e2.max : this._centerAltitude;
              } else b2 = this._centerAltitude;
              const w2 = t2.isTerrainDEM ? -b2 : this._elevation ? this._elevation.getMinElevationBelowMSL() : 0, T2 = this.projection.isReprojectedInTileSpace ? e.co(this) : 1, E2 = (t3) => {
                const i3 = 1 / 4e4, o3 = new e.ac(t3.x + i3, t3.y, t3.z), s3 = new e.ac(t3.x, t3.y + i3, t3.z), r3 = t3.toLngLat(), n3 = o3.toLngLat(), a3 = s3.toLngLat(), l3 = this.locationCoordinate(r3), c3 = this.locationCoordinate(n3), h3 = this.locationCoordinate(a3), d3 = Math.hypot(c3.x - l3.x, c3.y - l3.y), u6 = Math.hypot(h3.x - l3.x, h3.y - l3.y);
                return Math.sqrt(d3 * u6) * T2 / i3;
              }, S2 = (t3) => {
                const i3 = b2, o3 = w2;
                return { aabb: e.cr(this, c2, 0, 0, 0, t3, o3, i3, this.projection), zoom: 0, x: 0, y: 0, minZ: o3, maxZ: i3, wrap: t3, fullyVisible: false };
              }, I2 = [];
              let C3 = [];
              const R2 = i2, D3 = t2.reparseOverscaled ? o2 : i2, A2 = (m2 - this._centerAltitude) * f2, L2 = (e2) => {
                if (!this._elevation || !e2.tileID || !n2) return;
                const t3 = this._elevation.getMinMaxForTile(e2.tileID), i3 = e2.aabb;
                t3 ? (i3.min[2] = t3.min, i3.max[2] = t3.max, i3.center[2] = (i3.min[2] + i3.max[2]) / 2) : (e2.shouldSplit = z2(e2), e2.shouldSplit || (i3.min[2] = i3.max[2] = i3.center[2] = this._centerAltitude));
              }, P2 = (e2, t3) => {
                if (0.707 * t3 < e2) return 1;
                const i3 = t3 / e2;
                return i3 / (1.4144271570014144 + (Math.pow(1.1, i3 - 1.4144271570014144 + 1) - 1) / (1.1 - 1) - 1);
              }, z2 = (t3) => {
                if (t3.zoom < x2) return true;
                if (t3.zoom === R2) return false;
                if (null != t3.shouldSplit) return t3.shouldSplit;
                const i3 = t3.aabb.distanceX(g2), s3 = t3.aabb.distanceY(g2);
                let a3 = A2, c3 = 1;
                if (d2) {
                  a3 = t3.aabb.distanceZ(g2);
                  const i4 = Math.pow(2, t3.zoom), o3 = e.aY((t3.y + 1) / i4), s4 = e.aY(t3.y / i4), r3 = Math.min(Math.max(l2, o3), s4), n3 = e.cP(r3) / e.cP(l2);
                  if (c3 = r3 === l2 ? 1 / Math.max(1, this._mercatorScaleRatio - 0.3) : Math.min(1, n3 / this._mercatorScaleRatio), this.zoom <= e.cL && t3.zoom === R2 - 1 && n3 >= 0.9) return true;
                } else if (r2 && (a3 = t3.aabb.distanceZ(g2) * f2), this.projection.isReprojectedInTileSpace && o2 <= 5) {
                  const i4 = Math.pow(2, t3.zoom), o3 = E2(new e.ac((t3.x + 0.5) / i4, (t3.y + 0.5) / i4));
                  c3 = o3 > 0.85 ? 1 : o3;
                }
                if (!n2) {
                  const e2 = Math.sqrt(i3 * i3 + s3 * s3 + a3 * a3);
                  let o3 = (1 << R2 - t3.zoom) * y2 * c3;
                  return o3 *= P2(Math.max(a3, A2), e2), e2 < o3;
                }
                let u6 = Number.MAX_VALUE, _3 = 0;
                const p3 = t3.aabb.getCorners(), m3 = [];
                for (const t4 of p3) {
                  e.at(m3, t4, g2), d2 || (r2 ? m3[2] *= f2 : m3[2] = A2);
                  const i4 = e.bE(m3, this._camera.forward());
                  i4 < u6 && (u6 = i4, _3 = Math.abs(m3[2]));
                }
                let v4 = (1 << R2 - t3.zoom) * y2 * c3;
                if (v4 *= P2(Math.max(_3, A2), u6), u6 < v4) return true;
                const b3 = t3.aabb.closestPoint(h2);
                return b3[0] === h2[0] && b3[1] === h2[1];
              };
              if (this.renderWorldCopies) for (let e2 = 1; e2 <= 3; e2++) I2.push(S2(-e2)), I2.push(S2(e2));
              for (I2.push(S2(0)); I2.length > 0; ) {
                const o3 = I2.pop(), s3 = o3.x, a3 = o3.y;
                let l3 = o3.fullyVisible;
                const u6 = () => "globe" === this.projection.name && (0 === o3.y || o3.y === (1 << o3.zoom) - 1);
                if (!l3) {
                  let t3 = v3 ? o3.aabb.intersects(_2) : o3.aabb.intersectsFlat(_2);
                  if (0 === t3 && u6()) {
                    const i3 = new e.cp(o3.zoom, s3, a3);
                    t3 = e.cq(this, c2, i3, true).intersects(_2);
                  }
                  if (0 === t3) continue;
                  l3 = 2 === t3;
                }
                if (o3.zoom !== R2 && z2(o3)) for (let t3 = 0; t3 < 4; t3++) {
                  const i3 = (s3 << 1) + t3 % 2, h3 = (a3 << 1) + (t3 >> 1), u7 = { aabb: n2 ? o3.aabb.quadrant(t3) : e.cr(this, c2, o3.zoom + 1, i3, h3, o3.wrap, o3.minZ, o3.maxZ, this.projection), zoom: o3.zoom + 1, x: i3, y: h3, wrap: o3.wrap, fullyVisible: l3, tileID: void 0, shouldSplit: void 0, minZ: o3.minZ, maxZ: o3.maxZ };
                  r2 && !d2 && (u7.tileID = new e.aM(o3.zoom + 1 === R2 ? D3 : o3.zoom + 1, o3.wrap, o3.zoom + 1, i3, h3), L2(u7)), I2.push(u7);
                }
                else {
                  const r3 = o3.zoom === R2 ? D3 : o3.zoom;
                  if (t2.minzoom && t2.minzoom > r3) continue;
                  let n3 = 0;
                  if (!l3) {
                    let i3 = v3 ? o3.aabb.intersectsPrecise(_2) : o3.aabb.intersectsPreciseFlat(_2);
                    if (0 === i3 && u6()) {
                      const t3 = new e.cp(o3.zoom, s3, a3);
                      i3 = e.cq(this, c2, t3, true).intersectsPrecise(_2);
                    }
                    if (0 === i3) continue;
                    if (t2.calculateQuadrantVisibility) if (_2.containsPoint(o3.aabb.center)) n3 = 15;
                    else for (let e2 = 0; e2 < 4; e2++) 0 !== o3.aabb.quadrant(e2).intersects(_2) && (n3 |= 1 << e2);
                  }
                  const d3 = h2[0] - (0.5 + s3 + (o3.wrap << o3.zoom)) * (1 << i2 - o3.zoom), p3 = h2[1] - 0.5 - a3, f3 = o3.tileID ? o3.tileID : new e.aM(r3, o3.wrap, o3.zoom, s3, a3);
                  t2.calculateQuadrantVisibility && (f3.visibleQuadrants = n3), C3.push({ tileID: f3, distanceSq: d3 * d3 + p3 * p3 });
                }
              }
              if (this.fogCullDistSq) {
                const i3 = this.fogCullDistSq, o3 = this.horizonLineFromTop();
                C3 = C3.filter((s3) => {
                  const r3 = [0, 0, 0, 1], n3 = [e.aj, e.aj, 0, 1], a3 = this.calculateFogTileMatrix(s3.tileID.toUnwrapped());
                  e.aA(r3, r3, a3), e.aA(n3, n3, a3);
                  const l3 = e.cs([], r3, n3), c3 = e.ct([], r3, n3), h3 = e.cM(l3, c3);
                  if (0 === h3) return true;
                  let d3 = false;
                  const u6 = this._elevation;
                  if (u6 && h3 > i3 && 0 !== o3) {
                    const i4 = this.calculateProjMatrix(s3.tileID.toUnwrapped());
                    let r4;
                    t2.isTerrainDEM || (r4 = u6.getMinMaxForTile(s3.tileID)), r4 || (r4 = { min: w2, max: b2 });
                    const n4 = e.cu(this.rotation), a4 = [n4[0] * e.aj, n4[1] * e.aj, r4.max];
                    e.ad(a4, a4, i4), d3 = (1 - a4[1]) * this.height * 0.5 < o3;
                  }
                  return h3 < i3 || d3;
                });
              }
              return C3.sort((e2, t3) => e2.distanceSq - t3.distanceSq).map((e2) => e2.tileID);
            }
            resize(e2, t2) {
              this.width = e2, this.height = t2, this.pixelsToGLUnits = [2 / e2, -2 / t2], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(e2) {
              return Math.pow(2, e2);
            }
            scaleZoom(e2) {
              return Math.log(e2) / Math.LN2;
            }
            project(t2) {
              const i2 = e.aD(t2.lat, -e.cv, e.cv), o2 = this.projection.project(t2.lng, i2);
              return new e.P(o2.x * this.worldSize, o2.y * this.worldSize);
            }
            unproject(e2) {
              return this.projection.unproject(e2.x / this.worldSize, e2.y / this.worldSize);
            }
            get point() {
              return this.project(this.center);
            }
            get pointMerc() {
              return this.point._div(this.worldSize);
            }
            get pixelsPerMeterRatio() {
              return this.pixelsPerMeter / e.c6(1, this.center.lat) / this.worldSize;
            }
            setLocationAtPoint(t2, i2) {
              let o2, s2;
              const r2 = this.centerPoint;
              if ("globe" === this.projection.name) {
                const e2 = this.worldSize;
                o2 = (i2.x - r2.x) / e2, s2 = (i2.y - r2.y) / e2;
              } else {
                const e2 = this.pointCoordinate(i2), t3 = this.pointCoordinate(r2);
                o2 = e2.x - t3.x, s2 = e2.y - t3.y;
              }
              const n2 = this.locationCoordinate(t2);
              this.setLocation(new e.ac(n2.x - o2, n2.y - s2));
            }
            setLocation(e2) {
              this.center = this.coordinateLocation(e2), this.projection.wrap && (this.center = this.center.wrap());
            }
            locationPoint(e2, t2) {
              return this.projection.locationPoint(this, e2, t2);
            }
            locationPoint3D(e2, t2) {
              return this.projection.locationPoint(this, e2, t2, true);
            }
            pointLocation(e2) {
              return this.coordinateLocation(this.pointCoordinate(e2));
            }
            pointLocation3D(e2, t2) {
              return this.coordinateLocation(this.pointCoordinate3D(e2, t2));
            }
            locationCoordinate(t2, i2) {
              const o2 = i2 ? e.c6(i2, t2.lat) : void 0, s2 = this.projection.project(t2.lng, t2.lat);
              return new e.ac(s2.x, s2.y, o2);
            }
            coordinateLocation(e2) {
              return this.projection.unproject(e2.x, e2.y);
            }
            pointRayIntersection(t2, i2) {
              const o2 = null != i2 ? i2 : this._centerAltitude, s2 = [t2.x, t2.y, 0, 1], r2 = [t2.x, t2.y, 1, 1];
              e.aA(s2, s2, this.pixelMatrixInverse), e.aA(r2, r2, this.pixelMatrixInverse);
              const n2 = r2[3];
              e.cw(s2, s2, 1 / s2[3]), e.cw(r2, r2, 1 / n2);
              const a2 = s2[2], l2 = r2[2];
              return { p0: s2, p1: r2, t: a2 === l2 ? 0 : (o2 - a2) / (l2 - a2) };
            }
            screenPointToMercatorRay(t2) {
              const i2 = [t2.x, t2.y, 0, 1], o2 = [t2.x, t2.y, 1, 1];
              return e.aA(i2, i2, this.pixelMatrixInverse), e.aA(o2, o2, this.pixelMatrixInverse), e.cw(i2, i2, 1 / i2[3]), e.cw(o2, o2, 1 / o2[3]), i2[2] = e.c6(i2[2], this._center.lat) * this.worldSize, o2[2] = e.c6(o2[2], this._center.lat) * this.worldSize, e.cw(i2, i2, 1 / this.worldSize), e.cw(o2, o2, 1 / this.worldSize), new e.av([i2[0], i2[1], i2[2]], e.au([], e.at([], o2, i2)));
            }
            rayIntersectionCoordinate(t2) {
              const { p0: i2, p1: o2, t: s2 } = t2, r2 = e.c6(i2[2], this._center.lat), n2 = e.c6(o2[2], this._center.lat);
              return new e.ac(e.ai(i2[0], o2[0], s2) / this.worldSize, e.ai(i2[1], o2[1], s2) / this.worldSize, e.ai(r2, n2, s2));
            }
            pointCoordinate(e2, t2 = this._centerAltitude) {
              return this.projection.pointCoordinate(this, e2.x, e2.y, t2);
            }
            pointCoordinate3D(t2, i2) {
              if (!this.elevation) return this.pointCoordinate(t2, i2);
              let o2 = this.projection.pointCoordinate3D(this, t2.x, t2.y);
              if (o2) return new e.ac(o2[0], o2[1], o2[2]);
              let s2 = 0, r2 = this.horizonLineFromTop();
              if (t2.y > r2) return this.pointCoordinate(t2, i2);
              const n2 = 0.02 * r2, a2 = t2.clone();
              for (let t3 = 0; t3 < 10 && r2 - s2 > n2; t3++) {
                a2.y = e.ai(s2, r2, 0.66);
                const t4 = this.projection.pointCoordinate3D(this, a2.x, a2.y);
                t4 ? (r2 = a2.y, o2 = t4) : s2 = a2.y;
              }
              return o2 ? new e.ac(o2[0], o2[1], o2[2]) : this.pointCoordinate(t2);
            }
            isPointAboveHorizon(e2) {
              return this.projection.isPointAboveHorizon(this, e2);
            }
            isPointOnSurface(t2) {
              if (t2.y < 0 || t2.y > this.height || t2.x < 0 || t2.x > this.width) return false;
              if (this.elevation || this.zoom >= e.cx) return !this.isPointAboveHorizon(t2);
              const i2 = this.pointCoordinate(t2);
              return i2.y >= 0 && i2.y <= 1;
            }
            _coordinatePoint(t2, i2) {
              const o2 = i2 && this.elevation ? this.elevation.getAtPointOrZero(t2, this._centerAltitude) : this._centerAltitude, s2 = [t2.x * this.worldSize, t2.y * this.worldSize, o2 + t2.toAltitude(), 1];
              return e.aA(s2, s2, this.pixelMatrix), s2[3] > 0 ? new e.P(s2[0] / s2[3], s2[1] / s2[3]) : new e.P(Number.MAX_VALUE, Number.MAX_VALUE);
            }
            _getBoundsNonRectangular() {
              const { top: t2, left: i2 } = this._edgeInsets, o2 = this.height - this._edgeInsets.bottom, s2 = this.width - this._edgeInsets.right, r2 = this.pointLocation3D(new e.P(i2, t2)), n2 = this.pointLocation3D(new e.P(s2, t2)), a2 = this.pointLocation3D(new e.P(s2, o2)), l2 = this.pointLocation3D(new e.P(i2, o2));
              let c2 = Math.min(r2.lng, n2.lng, a2.lng, l2.lng), h2 = Math.max(r2.lng, n2.lng, a2.lng, l2.lng), d2 = Math.min(r2.lat, n2.lat, a2.lat, l2.lat), u5 = Math.max(r2.lat, n2.lat, a2.lat, l2.lat);
              const _2 = Math.pow(2, -this.zoom) / 16 * 270, p2 = "globe" === this.projection.name ? 1 : 4, f2 = (t3, i3, o3, s3, r3) => {
                const n3 = (t3 + o3) / 2, a3 = (i3 + s3) / 2, l3 = new e.P(n3, a3), { lng: m2, lat: g2 } = this.pointLocation3D(l3), v3 = Math.max(0, c2 - m2, d2 - g2, m2 - h2, g2 - u5);
                c2 = Math.min(c2, m2), h2 = Math.max(h2, m2), d2 = Math.min(d2, g2), u5 = Math.max(u5, g2), (r3 < p2 || v3 > _2) && (f2(t3, i3, n3, a3, r3 + 1), f2(n3, a3, o3, s3, r3 + 1));
              };
              if (f2(i2, t2, s2, t2, 1), f2(s2, t2, s2, o2, 1), f2(s2, o2, i2, o2, 1), f2(i2, o2, i2, t2, 1), "globe" === this.projection.name) {
                const [t3, i3] = e.cy(this);
                t3 ? (u5 = 90, h2 = 180, c2 = -180) : i3 && (d2 = -90, h2 = 180, c2 = -180);
              }
              return new e.aG(new e.cd(c2, d2), new e.cd(h2, u5));
            }
            _getBoundsRectangular(t2, i2) {
              const { top: o2, left: s2 } = this._edgeInsets, r2 = this.height - this._edgeInsets.bottom, n2 = this.width - this._edgeInsets.right, a2 = new e.P(s2, o2), l2 = new e.P(n2, o2), c2 = new e.P(n2, r2), h2 = new e.P(s2, r2);
              let d2 = this.pointCoordinate(a2, t2), u5 = this.pointCoordinate(l2, t2);
              const _2 = this.pointCoordinate(c2, i2), p2 = this.pointCoordinate(h2, i2), f2 = (e2, t3) => (t3.y - e2.y) / (t3.x - e2.x);
              return d2.y > 1 && u5.y >= 0 ? d2 = new e.ac((1 - p2.y) / f2(p2, d2) + p2.x, 1) : d2.y < 0 && u5.y <= 1 && (d2 = new e.ac(-p2.y / f2(p2, d2) + p2.x, 0)), u5.y > 1 && d2.y >= 0 ? u5 = new e.ac((1 - _2.y) / f2(_2, u5) + _2.x, 1) : u5.y < 0 && d2.y <= 1 && (u5 = new e.ac(-_2.y / f2(_2, u5) + _2.x, 0)), new e.aG().extend(this.coordinateLocation(d2)).extend(this.coordinateLocation(u5)).extend(this.coordinateLocation(p2)).extend(this.coordinateLocation(_2));
            }
            _getBoundsRectangularTerrain() {
              const e2 = this.elevation;
              if (!e2.visibleDemTiles.length || e2.isUsingMockSource()) return this._getBoundsRectangular(0, 0);
              const t2 = e2.visibleDemTiles.reduce((e3, t3) => {
                if (t3.dem) {
                  const i2 = t3.dem.tree;
                  e3.min = Math.min(e3.min, i2.minimums[0]), e3.max = Math.max(e3.max, i2.maximums[0]);
                }
                return e3;
              }, { min: Number.MAX_VALUE, max: 0 });
              return this._getBoundsRectangular(t2.min * e2.exaggeration(), t2.max * e2.exaggeration());
            }
            getBounds() {
              return "mercator" === this.projection.name || "equirectangular" === this.projection.name ? this._terrainEnabled() ? this._getBoundsRectangularTerrain() : this._getBoundsRectangular(0, 0) : this._getBoundsNonRectangular();
            }
            horizonLineFromTop(e2 = true) {
              const t2 = this.height / 2 / Math.tan(this._fov / 2) / Math.tan(Math.max(this._pitch, 0.1)) - this.centerOffset.y, i2 = this.height / 2 - t2 * (1 - this._horizonShift);
              return e2 ? Math.max(0, i2) : i2;
            }
            getMaxBounds() {
              return this.maxBounds;
            }
            setMaxBounds(t2) {
              this.maxBounds = t2, this.minLat = -e.cv, this.maxLat = e.cv, this.minLng = -180, this.maxLng = 180, t2 && (this.minLat = t2.getSouth(), this.maxLat = t2.getNorth(), this.minLng = t2.getWest(), this.maxLng = t2.getEast(), this.maxLng < this.minLng && (this.maxLng += 360)), this.worldMinX = e.ay(this.minLng) * this.tileSize, this.worldMaxX = e.ay(this.maxLng) * this.tileSize, this.worldMinY = e.aH(this.maxLat) * this.tileSize, this.worldMaxY = e.aH(this.minLat) * this.tileSize, this._constrain();
            }
            calculatePosMatrix(e2, t2) {
              return this.projection.createTileMatrix(this, t2, e2);
            }
            calculateDistanceTileData(t2) {
              const i2 = t2.key, o2 = this._distanceTileDataCache;
              if (o2[i2]) return o2[i2];
              const s2 = t2.canonical, r2 = 1 / this.height, n2 = this.cameraWorldSize, a2 = n2 / this.zoomScale(s2.z), l2 = (s2.x + Math.pow(2, s2.z) * t2.wrap) * a2, c2 = s2.y * a2, h2 = this.point;
              h2.x *= n2 / this.worldSize, h2.y *= n2 / this.worldSize;
              const d2 = this.angle, u5 = Math.sin(-d2), _2 = -Math.cos(-d2);
              return o2[i2] = { bearing: [u5, _2], center: [(h2.x - l2) * r2, (h2.y - c2) * r2], scale: a2 / e.aj * r2 }, o2[i2];
            }
            calculateFogTileMatrix(t2) {
              const i2 = t2.key, o2 = this._fogTileMatrixCache;
              if (o2[i2]) return o2[i2];
              const s2 = this.projection.createTileMatrix(this, this.cameraWorldSizeForFog, t2);
              return e.az(s2, this.worldToFogMatrix, s2), o2[i2] = new Float32Array(s2), o2[i2];
            }
            calculateProjMatrix(t2, i2 = false, o2 = false) {
              const s2 = t2.key;
              let r2;
              if (r2 = o2 ? this._expandedProjMatrixCache : i2 ? this._alignedProjMatrixCache : this._projMatrixCache, r2[s2]) return r2[s2];
              const n2 = this.calculatePosMatrix(t2, this.worldSize);
              let a2;
              return a2 = this.projection.isReprojectedInTileSpace ? this.mercatorMatrix : o2 ? this.expandedFarZProjMatrix : i2 ? this.alignedProjMatrix : this.projMatrix, e.az(n2, a2, n2), r2[s2] = new Float32Array(n2), r2[s2];
            }
            calculatePixelsToTileUnitsMatrix(t2) {
              const i2 = t2.tileID.key, o2 = this._pixelsToTileUnitsCache;
              if (o2[i2]) return o2[i2];
              const s2 = e.cz(t2, this);
              return o2[i2] = s2, o2[i2];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            globeToMercatorMatrix() {
              if ("globe" === this.projection.name) {
                const t2 = 1 / this.worldSize, i2 = e.bn([], [t2, t2, t2]);
                return e.az(i2, i2, this.globeMatrix), i2;
              }
            }
            recenterOnTerrain() {
              if (!this._elevation || "globe" === this.projection.name) return;
              const t2 = this._elevation;
              this._updateCameraState();
              const i2 = e.c6(1, this._center.lat) * this.worldSize, o2 = this._computeCameraPosition(i2), s2 = this._camera.forward(), r2 = e.c6(1, this._center.lat);
              o2[2] /= r2, s2[2] /= r2, e.au(s2, s2);
              const n2 = t2.raycast(o2, s2, t2.exaggeration());
              if (n2) {
                const t3 = e.bF([], o2, s2, n2), i3 = new e.ac(t3[0], t3[1], e.c6(t3[2], e.aY(t3[1]))), a2 = (i3.z + e.ae([i3.x - o2[0], i3.y - o2[1], i3.z - o2[2] * r2])) * this._pixelsPerMercatorPixel;
                this._seaLevelZoom = this._zoomFromMercatorZ(a2), this._centerAltitude = i3.toAltitude(), this._center = this.coordinateLocation(i3), this._updateZoomFromElevation(), this._constrain(), this._calcMatrices();
              }
            }
            _constrainCamera(t2 = false) {
              if (!this._elevation) return;
              const i2 = this._elevation, o2 = e.c6(1, this._center.lat) * this.worldSize, s2 = this._computeCameraPosition(o2), r2 = i2.getAtPointOrZero(new e.ac(...s2)), n2 = this.pixelsPerMeter / this.worldSize * r2, a2 = this._minimumHeightOverTerrain(), l2 = s2[2] - n2;
              if (l2 <= a2) if (l2 < 0 || t2) {
                const t3 = this.locationCoordinate(this._center, this._centerAltitude), i3 = [s2[0], s2[1], t3.z - s2[2]], o3 = e.ae(i3);
                i3[2] -= (a2 - l2) / this._pixelsPerMercatorPixel;
                const r3 = e.ae(i3);
                if (0 === r3) return;
                e.b$(i3, i3, o3 / r3 * this._pixelsPerMercatorPixel), this._camera.position = [s2[0], s2[1], t3.z * this._pixelsPerMercatorPixel - i3[2]], this._updateStateFromCamera();
              } else this._isCameraConstrained = true;
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining) return;
              this._constraining = true;
              const t2 = "globe" === this.projection.name || this.mercatorFromTransition;
              if (this.projection.isReprojectedInTileSpace || t2) {
                const i3 = this.center;
                return i3.lat = e.aD(i3.lat, this.minLat, this.maxLat), (this.maxBounds || !this.renderWorldCopies && !t2) && (i3.lng = e.aD(i3.lng, this.minLng, this.maxLng)), this.center = i3, void (this._constraining = false);
              }
              const i2 = this._unmodified, { x: o2, y: s2 } = this.point;
              let r2 = 0, n2 = o2, a2 = s2;
              const l2 = this.width / 2, c2 = this.height / 2, h2 = this.worldMinY * this.scale, d2 = this.worldMaxY * this.scale;
              if (s2 - c2 < h2 && (a2 = h2 + c2), s2 + c2 > d2 && (a2 = d2 - c2), d2 - h2 < this.height && (r2 = Math.max(r2, this.height / (d2 - h2)), a2 = (d2 + h2) / 2), this.maxBounds || !this._renderWorldCopies || !this.projection.wrap) {
                const e2 = this.worldMinX * this.scale, t3 = this.worldMaxX * this.scale, i3 = this.worldSize / 2 - (e2 + t3) / 2;
                n2 = (o2 + i3 + this.worldSize) % this.worldSize - i3, n2 - l2 < e2 && (n2 = e2 + l2), n2 + l2 > t3 && (n2 = t3 - l2), t3 - e2 < this.width && (r2 = Math.max(r2, this.width / (t3 - e2)), n2 = (t3 + e2) / 2);
              }
              n2 === o2 && a2 === s2 || this._allowWorldUnderZoom || (this.center = this.unproject(new e.P(n2, a2))), r2 && !this._allowWorldUnderZoom && (this.zoom += this.scaleZoom(r2)), this._constrainCamera(), this._unmodified = i2, this._constraining = false;
            }
            _minZoomForBounds() {
              let e2 = Math.max(0, this.scaleZoom(this.height / (this.worldMaxY - this.worldMinY)));
              return this.maxBounds && (e2 = Math.max(e2, this.scaleZoom(this.width / (this.worldMaxX - this.worldMinX)))), e2;
            }
            _maxCameraBoundsDistance() {
              return this._mercatorZfromZoom(this._minZoomForBounds());
            }
            _calcMatrices() {
              if (!this.height) return;
              const t2 = this.centerOffset, i2 = "globe" === this.projection.name, o2 = this.pixelsPerMeter;
              "globe" === this.projection.name && (this._mercatorScaleRatio = e.c6(1, this.center.lat) / e.c6(1, e.cN));
              const s2 = e.cA(this.projection, this.zoom, this.width, this.height, 1024);
              this._pixelsPerMercatorPixel = this.projection.pixelSpaceConversion(this.center.lat, this.worldSize, s2), this.cameraToCenterDistance = 0.5 / Math.tan(0.5 * this._fov) * this.height * this._pixelsPerMercatorPixel, this._updateCameraState(), this._farZ = this.projection.farthestPixelDistance(this), this._nearZ = this.height / 50;
              const r2 = "meters" === this.projection.zAxisUnit ? o2 : 1, n2 = this._camera.getWorldToCamera(this.worldSize, r2);
              let a2;
              const l2 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, this._farZ);
              if (l2[8] = 2 * -t2.x / this.width, l2[9] = 2 * t2.y / this.height, this.isOrthographic) {
                let i3 = 0.5 * this.height / Math.tan(this._fov / 2) * 1 * Math.tan(0.5 * this._fov), o3 = i3 * this.aspect, s3 = -o3, r3 = -i3;
                o3 -= t2.x, s3 -= t2.x, i3 += t2.y, r3 += t2.y, a2 = this._camera.getCameraToClipOrthographic(s3, o3, r3, i3, this._nearZ, this._farZ), ((t3, i4, o4, s4) => {
                  for (let r4 = 0; r4 < 16; r4++) t3[r4] = e.ai(i4[r4], o4[r4], s4);
                })(a2, a2, l2, e.cO(this.pitch >= Ji ? 1 : this.pitch / Ji));
              } else a2 = l2;
              const c2 = e.cB([], l2, n2);
              let h2 = e.cB([], a2, n2);
              if (this.projection.isReprojectedInTileSpace) {
                const t3 = this.locationCoordinate(this.center), i3 = e.bx([]);
                e.bo(i3, i3, [t3.x * this.worldSize, t3.y * this.worldSize, 0]), e.az(i3, i3, e.cC(this)), e.bo(i3, i3, [-t3.x * this.worldSize, -t3.y * this.worldSize, 0]), e.az(h2, h2, i3), e.az(c2, c2, i3), this.inverseAdjustmentMatrix = e.cD(this);
              } else this.inverseAdjustmentMatrix = [1, 0, 0, 1];
              if (this.mercatorMatrix = e.cE([], h2, [this.worldSize, this.worldSize, this.worldSize / r2, 1]), this.projMatrix = h2, this.invProjMatrix = e.bi(new Float64Array(16), this.projMatrix), i2) {
                const i3 = this._camera.getCameraToClipPerspective(this._fov, this.width / this.height, this._nearZ, 1 / 0);
                i3[8] = 2 * -t2.x / this.width, i3[9] = 2 * t2.y / this.height, this.expandedFarZProjMatrix = e.cB([], i3, n2);
              } else this.expandedFarZProjMatrix = this.projMatrix;
              const d2 = e.bi([], a2);
              this.frustumCorners = e.cF.fromInvProjectionMatrix(d2, this.horizonLineFromTop(), this.height), this.cameraFrustum = e.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, 0, !i2);
              const u5 = new Float32Array(16);
              e.bx(u5), e.cE(u5, u5, [1, -1, 1]), e.cG(u5, u5, this._pitch), e.by(u5, u5, this.angle);
              const _2 = e.c4(new Float32Array(16), this._fov, this.width / this.height, this._nearZ, this._farZ);
              this.starsProjMatrix = e.bw(_2);
              const p2 = (Math.PI / 2 - this._pitch) * (this.height / this._fov) * this._horizonShift;
              _2[8] = 2 * -t2.x / this.width, _2[9] = 2 * (t2.y + p2) / this.height, this.skyboxMatrix = e.az(u5, _2, u5);
              const f2 = this.point, m2 = f2.x, g2 = f2.y, v3 = this.width % 2 / 2, y2 = this.height % 2 / 2, x2 = Math.cos(this.angle), b2 = Math.sin(this.angle), w2 = m2 - Math.round(m2) + x2 * v3 + b2 * y2, T2 = g2 - Math.round(g2) + x2 * y2 + b2 * v3, E2 = new Float64Array(h2);
              if (e.bo(E2, E2, [w2 > 0.5 ? w2 - 1 : w2, T2 > 0.5 ? T2 - 1 : T2, 0]), this.alignedProjMatrix = E2, h2 = e.bz(), e.cE(h2, h2, [this.width / 2, -this.height / 2, 1]), e.bo(h2, h2, [1, -1, 0]), this.labelPlaneMatrix = h2, h2 = e.bz(), e.cE(h2, h2, [1, -1, 1]), e.bo(h2, h2, [-1, -1, 0]), e.cE(h2, h2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = h2, this.pixelMatrix = e.az(new Float64Array(16), this.labelPlaneMatrix, c2), this._calcFogMatrices(), this._distanceTileDataCache = {}, h2 = e.bi(new Float64Array(16), this.pixelMatrix), !h2) throw new Error("failed to invert matrix");
              if (this.pixelMatrixInverse = h2, "globe" === this.projection.name || this.mercatorFromTransition) {
                this.globeMatrix = e.cH(this);
                const t3 = [this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]];
                this.globeCenterInViewSpace = e.ad(t3, t3, n2), this.globeRadius = this.worldSize / 2 / Math.PI - 1;
              } else this.globeMatrix = h2;
              this._projMatrixCache = {}, this._alignedProjMatrixCache = {}, this._pixelsToTileUnitsCache = {}, this._expandedProjMatrixCache = {};
            }
            _calcFogMatrices() {
              this._fogTileMatrixCache = {};
              const t2 = this.cameraWorldSizeForFog, i2 = this.cameraPixelsPerMeter, o2 = this._camera.position, s2 = 1 / this.height / this._pixelsPerMercatorPixel, r2 = [t2, t2, i2];
              e.b$(r2, r2, s2), e.b$(o2, o2, -1), e.cI(o2, o2, r2);
              const n2 = e.bz();
              e.bo(n2, n2, o2), e.cE(n2, n2, r2), this.mercatorFogMatrix = n2, this.worldToFogMatrix = this._camera.getWorldToCameraPosition(t2, i2, s2);
            }
            _computeCameraPosition(e2) {
              const t2 = (e2 = e2 || this.pixelsPerMeter) / this.pixelsPerMeter, i2 = this._camera.forward(), o2 = this.point, s2 = this._mercatorZfromZoom(this._seaLevelZoom ? this._seaLevelZoom : this._zoom) * t2 - e2 / this.worldSize * this._centerAltitude;
              return [o2.x / this.worldSize - i2[0] * s2, o2.y / this.worldSize - i2[1] * s2, e2 / this.worldSize * this._centerAltitude - i2[2] * s2];
            }
            _updateCameraState() {
              this.height && (this._camera.setPitchBearing(this._pitch, this.angle), this._camera.position = this._computeCameraPosition());
            }
            _translateCameraConstrained(t2) {
              const i2 = this._maxCameraBoundsDistance() * Math.cos(this._pitch), o2 = this._camera.position[2], s2 = t2[2];
              let r2 = 1;
              this.projection.wrap && (this.center = this.center.wrap()), s2 > 0 && (r2 = Math.min((i2 - o2) / s2, 1)), this._camera.position = e.bF([], this._camera.position, t2, r2), this._updateStateFromCamera();
            }
            _updateStateFromCamera() {
              const t2 = this._camera.position, i2 = this._camera.forward(), { pitch: o2, bearing: s2 } = this._camera.getPitchBearing(), r2 = e.c6(this._centerAltitude, this.center.lat) * this._pixelsPerMercatorPixel, n2 = this._mercatorZfromZoom(this._maxZoom) * Math.cos(e.al(this._maxPitch)), a2 = Math.max((t2[2] - r2) / Math.cos(o2), n2), l2 = this._zoomFromMercatorZ(a2);
              e.bF(t2, t2, i2, a2), this._pitch = e.aD(o2, e.al(this.minPitch), e.al(this.maxPitch)), this.angle = e.bX(s2, -Math.PI, Math.PI), this._setZoom(e.aD(l2, this._minZoom, this._maxZoom)), this._updateSeaLevelZoom(), this._center = this.coordinateLocation(new e.ac(t2[0], t2[1], t2[2])), this._unmodified = false, this._constrain(), this._calcMatrices();
            }
            _worldSizeFromZoom(e2) {
              return Math.pow(2, e2) * this.tileSize;
            }
            _mercatorZfromZoom(e2) {
              return this.cameraToCenterDistance / this._worldSizeFromZoom(e2);
            }
            _minimumHeightOverTerrain() {
              const e2 = Math.min(null != this._seaLevelZoom ? this._seaLevelZoom : this._zoom, this._maxZoom) + 4;
              return this._mercatorZfromZoom(e2);
            }
            _zoomFromMercatorZ(e2) {
              return this.scaleZoom(this.cameraToCenterDistance / (e2 * this.tileSize));
            }
            zoomFromMercatorZAdjusted(t2) {
              let i2 = 0, o2 = e.cx, s2 = 0, r2 = 1 / 0;
              for (; o2 - i2 > 1e-6 && o2 > i2; ) {
                const e2 = i2 + 0.5 * (o2 - i2), n2 = this.tileSize * Math.pow(2, e2), a2 = this.getCameraToCenterDistance(this.projection, e2, n2), l2 = this.scaleZoom(a2 / (t2 * this.tileSize)), c2 = Math.abs(e2 - l2);
                c2 < r2 && (r2 = c2, s2 = e2), e2 < l2 ? i2 = e2 : o2 = e2;
              }
              return s2;
            }
            _terrainEnabled() {
              return !(!this._elevation || !this.projection.supportsTerrain && (e.w("Terrain is not yet supported with alternate projections. Use mercator or globe to enable terrain."), 1));
            }
            anyCornerOffEdge(t2, i2) {
              const o2 = Math.min(t2.x, i2.x), s2 = Math.max(t2.x, i2.x), r2 = Math.min(t2.y, i2.y), n2 = Math.max(t2.y, i2.y);
              if (r2 < this.horizonLineFromTop(false)) return true;
              if ("mercator" !== this.projection.name) return false;
              const a2 = [new e.P(o2, r2), new e.P(s2, n2), new e.P(o2, n2), new e.P(s2, r2)], l2 = this.renderWorldCopies ? -3 : 0, c2 = this.renderWorldCopies ? 4 : 1;
              for (const e2 of a2) {
                const t3 = this.pointRayIntersection(e2);
                if (t3.t < 0) return true;
                const i3 = this.rayIntersectionCoordinate(t3);
                if (i3.x < l2 || i3.y < 0 || i3.x > c2 || i3.y > 1) return true;
              }
              return false;
            }
            isHorizonVisible() {
              return this.pitch + e.cJ(this.fovAboveCenter) > 88 || this.anyCornerOffEdge(new e.P(0, 0), new e.P(this.width, this.height));
            }
            zoomDeltaToMovement(t2, i2) {
              const o2 = e.ae(e.at([], this._camera.position, t2)), s2 = this._zoomFromMercatorZ(o2) + i2;
              return o2 - this._mercatorZfromZoom(s2);
            }
            getCameraPoint() {
              if ("globe" === this.projection.name) {
                const t2 = function([t3, i2, o2], s2) {
                  const r2 = [t3, i2, o2, 1];
                  e.aA(r2, r2, s2);
                  const n2 = r2[3] = Math.max(r2[3], 1e-6);
                  return r2[0] /= n2, r2[1] /= n2, r2[2] /= n2, r2;
                }([this.globeMatrix[12], this.globeMatrix[13], this.globeMatrix[14]], this.pixelMatrix);
                return new e.P(t2[0], t2[1]);
              }
              {
                const t2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
                return this.centerPoint.add(new e.P(0, t2));
              }
            }
            getCameraToCenterDistance(t2, i2 = this.zoom, o2 = this.worldSize) {
              const s2 = e.cA(t2, i2, this.width, this.height, 1024), r2 = t2.pixelSpaceConversion(this.center.lat, o2, s2);
              let n2 = 0.5 / Math.tan(0.5 * this._fov) * this.height * r2;
              return this.isOrthographic && (n2 = e.ai(1, n2, e.cO(this.pitch >= Ji ? 1 : this.pitch / Ji))), n2;
            }
            getWorldToCameraMatrix() {
              const t2 = this._camera.getWorldToCamera(this.worldSize, "meters" === this.projection.zAxisUnit ? this.pixelsPerMeter : 1);
              return "globe" === this.projection.name && e.az(t2, t2, this.globeMatrix), t2;
            }
            getFrustum(t2) {
              return e.cn.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, t2, "meters" === this.projection.zAxisUnit);
            }
          }
          const eo = (t2, i2) => {
            if (i2 > 0 && t2.terrain && e.w("Cutoff is currently disabled on terrain"), i2 <= 0 || t2.terrain) return { shouldRenderCutoff: false, uniformValues: { u_cutoff_params: [0, 0, 0, 1] } };
            const o2 = t2.transform, s2 = Math.max(Math.abs(o2._zoom - (t2.minCutoffZoom - 1)), 1), r2 = o2.isLODDisabled(false) ? e.af(60, 45, o2.pitch) : e.af(30, 15, o2.pitch), n2 = o2._farZ - o2._nearZ, a2 = i2 * o2.height, l2 = ((1 - (c2 = r2)) * o2.cameraToCenterDistance + c2 * (o2._farZ + a2)) * s2;
            var c2;
            return { shouldRenderCutoff: r2 < 1, uniformValues: { u_cutoff_params: [o2._nearZ, o2._farZ, (l2 - o2._nearZ) / n2, (l2 - a2 - o2._nearZ) / n2] } };
          }, to = { cascadeCount: 2, normalOffset: 3, shadowMapResolution: 2048 };
          class io {
            constructor(e2, t2) {
              this.aabb = e2, this.lastCascade = t2;
            }
          }
          class oo {
            add(e2, t2) {
              const i2 = this.receivers[e2.key];
              void 0 !== i2 ? (i2.aabb.min[0] = Math.min(i2.aabb.min[0], t2.min[0]), i2.aabb.min[1] = Math.min(i2.aabb.min[1], t2.min[1]), i2.aabb.min[2] = Math.min(i2.aabb.min[2], t2.min[2]), i2.aabb.max[0] = Math.max(i2.aabb.max[0], t2.max[0]), i2.aabb.max[1] = Math.max(i2.aabb.max[1], t2.max[1]), i2.aabb.max[2] = Math.max(i2.aabb.max[2], t2.max[2])) : this.receivers[e2.key] = new io(t2, null);
            }
            clear() {
              this.receivers = {};
            }
            get(e2) {
              return this.receivers[e2.key];
            }
            computeRequiredCascades(t2, i2, o2) {
              const s2 = e.cV.fromPoints(t2.points);
              let r2 = 0;
              for (const t3 in this.receivers) {
                const n2 = this.receivers[t3];
                if (!n2) continue;
                if (!s2.intersectsAabb(n2.aabb)) continue;
                n2.aabb.min = s2.closestPoint(n2.aabb.min), n2.aabb.max = s2.closestPoint(n2.aabb.max);
                const a2 = n2.aabb.getCorners();
                for (let t4 = 0; t4 < o2.length; t4++) {
                  let s3 = true;
                  for (const r3 of a2) {
                    const n3 = [r3[0] * i2, r3[1] * i2, r3[2]];
                    if (e.ad(n3, n3, o2[t4].matrix), n3[0] < -1 || n3[0] > 1 || n3[1] < -1 || n3[1] > 1) {
                      s3 = false;
                      break;
                    }
                  }
                  if (n2.lastCascade = t4, r2 = Math.max(r2, t4), s3) break;
                }
              }
              return r2 + 1;
            }
          }
          class so {
            constructor(e2) {
              this.painter = e2, this._enabled = false, this._shadowLayerCount = 0, this._numCascadesToRender = 0, this._cascades = [], this._groundShadowTiles = [], this._receivers = new oo(), this._depthMode = new Ni(e2.context.gl.LEQUAL, Ni.ReadWrite, [0, 1]), this._uniformValues = { u_light_matrix_0: new Float32Array(16), u_light_matrix_1: new Float32Array(16), u_shadow_intensity: 0, u_fade_range: [0, 0], u_shadow_normal_offset: [1, 1, 1], u_shadow_texel_size: 1, u_shadow_map_resolution: 1, u_shadow_direction: [0, 0, 1], u_shadow_bias: [36e-5, 12e-4, 0.012], u_shadowmap_0: 0, u_shadowmap_1: 0 }, this._forceDisable = false, this.useNormalOffset = false, e2.tp.registerParameter(this, ["Shadows"], "_forceDisable", { label: "forceDisable" }, () => {
                this.painter.style.map.triggerRepaint();
              }), e2.tp.registerParameter(to, ["Shadows"], "cascadeCount", { min: 1, max: 2, step: 1 }), e2.tp.registerParameter(to, ["Shadows"], "normalOffset", { min: 0, max: 10, step: 0.05 }), e2.tp.registerParameter(to, ["Shadows"], "shadowMapResolution", { min: 32, max: 2048, step: 32 }), e2.tp.registerBinding(this, ["Shadows"], "_numCascadesToRender", { readonly: true, label: "numCascadesToRender" });
            }
            destroy() {
              for (const e2 of this._cascades) e2.texture.destroy(), e2.framebuffer.destroy();
              this._cascades = [];
            }
            updateShadowParameters(t2, i2) {
              const o2 = this.painter;
              if (this._enabled = false, this._shadowLayerCount = 0, this._receivers.clear(), !i2 || !i2.properties) return;
              const s2 = i2.properties.get("shadow-intensity");
              if (!i2.shadowsEnabled() || s2 <= 0) return;
              if (this._shadowLayerCount = o2.style.order.reduce((e2, i3) => {
                const s3 = o2.style._mergedLayers[i3];
                return e2 + (s3.hasShadowPass() && !s3.isHidden(t2.zoom) ? 1 : 0);
              }, 0), this._enabled = this._shadowLayerCount > 0, !this.enabled) return;
              const r2 = o2.context, n2 = to.shadowMapResolution, a2 = to.shadowMapResolution;
              if (0 === this._cascades.length || to.shadowMapResolution !== this._cascades[0].texture.size[0]) {
                this._cascades = [];
                for (let t3 = 0; t3 < to.cascadeCount; ++t3) {
                  const t4 = o2._shadowMapDebug, i3 = r2.gl, s3 = r2.createFramebuffer(n2, a2, t4, "texture"), l3 = new e.T(r2, { width: n2, height: a2, data: null }, i3.DEPTH_COMPONENT16);
                  if (s3.depthAttachment.set(l3.texture), t4) {
                    const t5 = new e.T(r2, { width: n2, height: a2, data: null }, i3.RGBA8);
                    s3.colorAttachment.set(t5.texture);
                  }
                  this._cascades.push({ framebuffer: s3, texture: l3, matrix: [], far: 0, boundingSphereRadius: 0, frustum: new e.cn(), scale: 0 });
                }
              }
              this.shadowDirection = no(i2);
              let l2 = 0;
              if (t2.elevation) {
                const e2 = t2.elevation, i3 = [1e4, -1e4];
                e2.visibleDemTiles.filter((e3) => e3.dem).forEach((e3) => {
                  const t3 = e3.dem.tree;
                  i3[0] = Math.min(i3[0], t3.minimums[0]), i3[1] = Math.max(i3[1], t3.maximums[0]);
                }), 1e4 !== i3[0] && (l2 = (i3[1] - i3[0]) * e2.exaggeration());
              }
              const c2 = 1.5 * t2.cameraToCenterDistance, h2 = 3 * c2, d2 = new Float64Array(16);
              for (let i3 = 0; i3 < this._cascades.length; ++i3) {
                const o3 = this._cascades[i3];
                let s3 = t2.height / 50, r3 = 1;
                1 === to.cascadeCount ? r3 = h2 : 0 === i3 ? r3 = c2 : (s3 = c2, r3 = h2);
                const [n3, a3] = lo(t2, this.shadowDirection, s3, r3, to.shadowMapResolution, l2);
                o3.scale = t2.scale, o3.matrix = n3, o3.boundingSphereRadius = a3, e.bi(d2, o3.matrix), o3.frustum = e.cn.fromInvProjectionMatrix(d2, 1, 0, true), o3.far = r3;
              }
              const u5 = this._cascades.length - 1;
              this._uniformValues.u_fade_range = [0.75 * this._cascades[u5].far, this._cascades[u5].far], this._uniformValues.u_shadow_intensity = s2, this._uniformValues.u_shadow_direction = [this.shadowDirection[0], this.shadowDirection[1], this.shadowDirection[2]], this._uniformValues.u_shadow_texel_size = 1 / to.shadowMapResolution, this._uniformValues.u_shadow_map_resolution = to.shadowMapResolution, this._uniformValues.u_shadowmap_0 = Yi.ShadowMap0, this._uniformValues.u_shadowmap_1 = Yi.ShadowMap0 + 1, this._groundShadowTiles = o2.transform.coveringTiles({ tileSize: 512, renderWorldCopies: true });
              const _2 = o2.transform.elevation;
              for (const e2 of this._groundShadowTiles) {
                let t3 = { min: 0, max: 0 };
                if (_2) {
                  const i3 = _2.getMinMaxForTile(e2);
                  i3 && (t3 = i3);
                }
                this.addShadowReceiver(e2.toUnwrapped(), t3.min, t3.max);
              }
            }
            get enabled() {
              return this._enabled && !this._forceDisable;
            }
            set enabled(e2) {
              this._enabled = e2;
            }
            drawShadowPass(t2, i2) {
              if (!this.enabled) return;
              const o2 = this.painter, s2 = o2.context;
              this._numCascadesToRender = this._receivers.computeRequiredCascades(o2.transform.getFrustum(0), o2.transform.worldSize, this._cascades), s2.viewport.set([0, 0, to.shadowMapResolution, to.shadowMapResolution]);
              for (let r2 = 0; r2 < this._numCascadesToRender; ++r2) {
                o2.currentShadowCascade = r2, s2.bindFramebuffer.set(this._cascades[r2].framebuffer.framebuffer), s2.clear({ color: e.am.white, depth: 1 });
                for (const e2 of t2.order) {
                  const s3 = t2._mergedLayers[e2];
                  if (!s3.hasShadowPass() || s3.isHidden(o2.transform.zoom)) continue;
                  const r3 = t2.getLayerSourceCache(s3), n2 = r3 ? i2[r3.id] : void 0;
                  ("model" === s3.type || n2 && n2.length) && o2.renderLayer(o2, r3, s3, n2);
                }
              }
              o2.currentShadowCascade = 0;
            }
            drawGroundShadows() {
              if (!this.enabled) return;
              const e2 = this.painter, t2 = e2.style, i2 = e2.context, o2 = t2.directionalLight, s2 = t2.ambientLight;
              if (!o2 || !s2) return;
              const r2 = [], n2 = eo(e2, e2.longestCutoffRange);
              n2.shouldRenderCutoff && r2.push("RENDER_CUTOFF"), r2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), this.useNormalOffset && r2.push("NORMAL_OFFSET");
              const a2 = ao(t2, o2, s2), l2 = new Ni(i2.gl.LEQUAL, Ni.ReadOnly, e2.depthRangeFor3D);
              for (const t3 of this._groundShadowTiles) {
                const o3 = t3.toUnwrapped(), s3 = e2.isTileAffectedByFog(t3), c2 = e2.getOrCreateProgram("groundShadow", { defines: r2, overrideFog: s3 });
                this.setupShadows(o3, c2), e2.uploadCommonUniforms(i2, c2, o3, null, n2);
                const h2 = { u_matrix: e2.transform.calculateProjMatrix(o3), u_ground_shadow_factor: a2 };
                c2.draw(e2, i2.gl.TRIANGLES, l2, ji.disabled, ki.multiply, qi.disabled, h2, "ground_shadow", e2.tileExtentBuffer, e2.quadTriangleIndexBuffer, e2.tileExtentSegments, null, e2.transform.zoom, null, null);
              }
            }
            getShadowPassColorMode() {
              return this.painter._shadowMapDebug ? ki.unblended : ki.disabled;
            }
            getShadowPassDepthMode() {
              return this._depthMode;
            }
            getShadowCastingLayerCount() {
              return this._shadowLayerCount;
            }
            calculateShadowPassMatrixFromTile(t2) {
              const i2 = this.painter.transform, o2 = i2.calculatePosMatrix(t2, i2.worldSize);
              return e.az(o2, this._cascades[this.painter.currentShadowCascade].matrix, o2), Float32Array.from(o2);
            }
            calculateShadowPassMatrixFromMatrix(t2) {
              return e.az(t2, this._cascades[this.painter.currentShadowCascade].matrix, t2), Float32Array.from(t2);
            }
            setupShadows(t2, i2, o2, s2 = 0) {
              if (!this.enabled) return;
              const r2 = this.painter.transform, n2 = this.painter.context, a2 = n2.gl, l2 = this._uniformValues, c2 = new Float64Array(16), h2 = r2.calculatePosMatrix(t2, r2.worldSize);
              for (let t3 = 0; t3 < this._cascades.length; t3++) e.az(c2, this._cascades[t3].matrix, h2), l2[0 === t3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(c2), n2.activeTexture.set(a2.TEXTURE0 + Yi.ShadowMap0 + t3), this._cascades[t3].texture.bind(a2.NEAREST, a2.CLAMP_TO_EDGE);
              if (this.useNormalOffset = !!o2, this.useNormalOffset) {
                const i3 = e.cT(t2.canonical), n3 = 2 / r2.tileSize * e.aj / to.shadowMapResolution, a3 = n3 * this._cascades[0].boundingSphereRadius, c3 = n3 * this._cascades[this._cascades.length - 1].boundingSphereRadius, h3 = ("vector-tile" === o2 ? 1 : 3) / Math.pow(2, s2 - t2.canonical.z - (1 - r2.zoom + Math.floor(r2.zoom)));
                l2.u_shadow_normal_offset = [i3, a3 * h3, c3 * h3], l2.u_shadow_bias = [6e-5, 12e-4, 0.012];
              } else l2.u_shadow_bias = [36e-5, 12e-4, 0.012];
              i2.setShadowUniformValues(n2, l2);
            }
            setupShadowsFromMatrix(t2, i2, o2 = false) {
              if (!this.enabled) return;
              const s2 = this.painter.context, r2 = s2.gl, n2 = this._uniformValues, a2 = new Float64Array(16);
              for (let i3 = 0; i3 < to.cascadeCount; i3++) e.az(a2, this._cascades[i3].matrix, t2), n2[0 === i3 ? "u_light_matrix_0" : "u_light_matrix_1"] = Float32Array.from(a2), s2.activeTexture.set(r2.TEXTURE0 + Yi.ShadowMap0 + i3), this._cascades[i3].texture.bind(r2.NEAREST, r2.CLAMP_TO_EDGE);
              if (this.useNormalOffset = o2, o2) {
                const e2 = to.normalOffset;
                n2.u_shadow_normal_offset = [1, e2, e2], n2.u_shadow_bias = [6e-5, 12e-4, 0.012];
              } else n2.u_shadow_bias = [36e-5, 12e-4, 0.012];
              i2.setShadowUniformValues(s2, n2);
            }
            getShadowUniformValues() {
              return this._uniformValues;
            }
            getCurrentCascadeFrustum() {
              return this._cascades[this.painter.currentShadowCascade].frustum;
            }
            computeSimplifiedTileShadowVolume(t2, i2, o2, s2) {
              if (s2[2] >= 0) return {};
              const r2 = function(t3, i3, o3) {
                const s3 = o3 / (1 << t3.canonical.z);
                return new e.cV([t3.canonical.x * s3 + t3.wrap * o3, t3.canonical.y * s3 + t3.wrap * o3, 0], [(t3.canonical.x + 1) * s3 + t3.wrap * o3, (t3.canonical.y + 1) * s3 + t3.wrap * o3, i3]);
              }(t2, i2, o2).getCorners(), n2 = i2 / -s2[2];
              s2[0] < 0 ? (e.cU(r2[0], r2[0], [s2[0] * n2, 0, 0]), e.cU(r2[3], r2[3], [s2[0] * n2, 0, 0])) : s2[0] > 0 && (e.cU(r2[1], r2[1], [s2[0] * n2, 0, 0]), e.cU(r2[2], r2[2], [s2[0] * n2, 0, 0])), s2[1] < 0 ? (e.cU(r2[0], r2[0], [0, s2[1] * n2, 0]), e.cU(r2[1], r2[1], [0, s2[1] * n2, 0])) : s2[1] > 0 && (e.cU(r2[2], r2[2], [0, s2[1] * n2, 0]), e.cU(r2[3], r2[3], [0, s2[1] * n2, 0]));
              const a2 = {};
              return a2.vertices = r2, a2.planes = [ro(r2[1], r2[0], r2[4]), ro(r2[2], r2[1], r2[5]), ro(r2[3], r2[2], r2[6]), ro(r2[0], r2[3], r2[7])], a2;
            }
            addShadowReceiver(t2, i2, o2) {
              this._receivers.add(t2, e.cV.fromTileIdAndHeight(t2, i2, o2));
            }
            getMaxCascadeForTile(e2) {
              const t2 = this._receivers.get(e2);
              return t2 && t2.lastCascade ? t2.lastCascade : 0;
            }
          }
          function ro(t2, i2, o2) {
            const s2 = e.at([], o2, i2), r2 = e.at([], t2, i2), n2 = e.bG([], s2, r2), a2 = e.ae(n2);
            return 0 === a2 ? [0, 0, 1, 0] : (e.b$(n2, n2, 1 / a2), [n2[0], n2[1], n2[2], -e.bE(n2, i2)]);
          }
          function no(t2) {
            const i2 = t2.properties.get("direction"), o2 = e.cR(i2.x, i2.y, i2.z);
            o2[2] = e.aD(o2[2], 0, 75);
            const s2 = e.cW([o2[0], o2[1], o2[2]]);
            return e.cS(s2.x, s2.y, s2.z);
          }
          function ao(t2, i2, o2) {
            const s2 = "none" === i2.properties.get("color-use-theme"), r2 = i2.properties.get("color"), n2 = i2.properties.get("intensity"), a2 = i2.properties.get("direction"), l2 = [a2.x, a2.y, a2.z], c2 = "none" === o2.properties.get("color-use-theme"), h2 = o2.properties.get("color"), d2 = o2.properties.get("intensity"), u5 = Math.max(e.bE([0, 0, 1], l2), 0), _2 = [0, 0, 0];
            e.b$(_2, h2.toRenderColor(c2 ? null : t2.getLut(i2.scope)).toArray01Linear().slice(0, 3), d2);
            const p2 = [0, 0, 0];
            return e.b$(p2, r2.toRenderColor(s2 ? null : t2.getLut(o2.scope)).toArray01Linear().slice(0, 3), u5 * n2), e.cX([_2[0] > 0 ? _2[0] / (_2[0] + p2[0]) : 0, _2[1] > 0 ? _2[1] / (_2[1] + p2[1]) : 0, _2[2] > 0 ? _2[2] / (_2[2] + p2[2]) : 0]);
          }
          function lo(t2, i2, o2, s2, r2, n2) {
            const a2 = t2.zoom, l2 = t2.scale, c2 = t2.worldSize, h2 = 1 / c2, d2 = t2.aspect, u5 = Math.sqrt(1 + d2 * d2) * Math.tan(0.5 * t2.fovX), _2 = u5 * u5, p2 = s2 - o2, f2 = s2 + o2;
            let m2, g2;
            _2 > p2 / f2 ? (m2 = s2, g2 = s2 * u5) : (m2 = 0.5 * f2 * (1 + _2), g2 = 0.5 * Math.sqrt(p2 * p2 + 2 * (s2 * s2 + o2 * o2) * _2 + f2 * f2 * _2 * _2));
            const v3 = t2.projection.pixelsPerMeter(t2.center.lat, c2), y2 = t2._camera.getCameraToWorldMercator(), x2 = [0, 0, -m2 * h2];
            e.ad(x2, x2, y2);
            let b2 = g2 * h2;
            const w2 = t2._edgeInsets;
            if (!(0 === w2.left && 0 === w2.top && 0 === w2.right && 0 === w2.bottom || w2.left === w2.right && w2.top === w2.bottom)) {
              const i3 = t2._camera.getWorldToCamera(t2.worldSize, "meters" === t2.projection.zAxisUnit ? v3 : 1), r3 = t2._camera.getCameraToClipPerspective(t2._fov, t2.width / t2.height, o2, s2);
              r3[8] = 2 * -t2.centerOffset.x / t2.width, r3[9] = 2 * t2.centerOffset.y / t2.height;
              const n3 = new Float64Array(16);
              e.cB(n3, r3, i3);
              const h3 = new Float64Array(16);
              e.bi(h3, n3);
              const d3 = e.cn.fromInvProjectionMatrix(h3, c2, a2, true);
              for (const i4 of d3.points) {
                const o3 = ((T2 = i4)[0] /= l2, T2[1] /= l2, T2[2] = e.c6(T2[2], t2._center.lat), T2);
                b2 = Math.max(b2, e.c0(e.cY([], x2, o3)));
              }
            }
            var T2;
            b2 *= r2 / (r2 - 1);
            const E2 = Math.acos(i2[2]), S2 = Math.atan2(-i2[0], -i2[1]), I2 = new Xi();
            I2.position = x2, I2.setPitchBearing(E2, S2);
            const C3 = I2.getWorldToCamera(c2, v3), R2 = b2 * c2, D3 = Math.min(t2._mercatorZfromZoom(17) * c2 * -2, -2 * R2), A2 = I2.getCameraToClipOrthographic(-R2, R2, -R2, R2, D3, (R2 + n2 * v3) / i2[2]), L2 = new Float64Array(16);
            e.az(L2, A2, C3);
            const P2 = e.cS(Math.floor(1e6 * x2[0]) / 1e6 * c2, Math.floor(1e6 * x2[1]) / 1e6 * c2, 0), z2 = 0.5 * r2, M2 = [0, 0, 0];
            e.ad(M2, P2, L2), e.b$(M2, M2, z2);
            const O2 = [Math.floor(M2[0]), Math.floor(M2[1]), Math.floor(M2[2])], F2 = [0, 0, 0];
            e.at(F2, M2, O2), e.b$(F2, F2, -1 / z2);
            const B3 = new Float64Array(16);
            return e.bx(B3), e.bo(B3, B3, F2), e.az(L2, B3, L2), [L2, R2];
          }
          class co extends e.E {
            constructor(e2) {
              super(), this.requestManager = e2, this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            loadModel(t2, i2) {
              return e.aS(this.requestManager.transformRequest(i2, e.R.Model).url).then((i3) => {
                if (!i3) return;
                const o2 = e.aT(i3), s2 = new e.aU(t2, void 0, void 0, o2);
                return s2.computeBoundsAndApplyParent(), s2;
              }).catch((o2) => {
                if (o2 && 404 === o2.status) return null;
                this.fire(new e.z(new Error(`Could not load model ${t2} from ${i2}: ${o2.message}`)));
              });
            }
            load(t2, i2, o2 = { forceReload: false }) {
              this.models[i2] || (this.models[i2] = {});
              const s2 = Object.keys(t2), r2 = [], n2 = [];
              for (const e2 of s2) {
                const s3 = t2[e2];
                this.hasURLBeenRequested(s3) && !o2.forceReload || (this.modelByURL[s3] = { modelId: e2, scope: i2 }, r2.push(this.loadModel(e2, s3)), n2.push(e2)), this.models[i2][e2] || (this.models[i2][e2] = { model: null, numReferences: 1 });
              }
              this.numModelsLoading[i2] = (this.numModelsLoading[i2] || 0) + n2.length, Promise.allSettled(r2).then((t3) => {
                for (let e2 = 0; e2 < t3.length; e2++) {
                  const { status: o3 } = t3[e2];
                  if ("rejected" === o3) continue;
                  const { value: s3 } = t3[e2];
                  this.models[i2][n2[e2]] || (this.models[i2][n2[e2]] = { model: null, numReferences: 1 }), this.models[i2][n2[e2]].model = s3;
                }
                this.numModelsLoading[i2] -= n2.length, this.fire(new e.A("data", { dataType: "style" }));
              }).catch((t3) => {
                this.fire(new e.z(new Error(`Could not load models: ${t3.message}`)));
              });
            }
            isLoaded() {
              for (const e2 in this.numModelsLoading) if (this.numModelsLoading[e2] > 0) return false;
              return true;
            }
            hasModel(e2, t2, i2 = { exactIdMatch: false }) {
              return !!(i2.exactIdMatch ? this.getModel(e2, t2) : this.getModelByURL(this.modelUris[t2][e2]));
            }
            getModel(e2, t2) {
              return this.models[t2] || (this.models[t2] = {}), this.models[t2][e2] ? this.models[t2][e2].model : void 0;
            }
            getModelByURL(e2) {
              if (!e2) return null;
              const t2 = this.modelByURL[e2];
              return t2 ? this.models[t2.scope][t2.modelId].model : null;
            }
            hasModelBeenAdded(e2, t2) {
              return this.models[t2] && void 0 !== this.models[t2][e2];
            }
            getModelURIs(e2) {
              return this.modelUris[e2] || {};
            }
            addModel(e2, t2, i2) {
              this.models[i2] || (this.models[i2] = {}), this.modelUris[i2] || (this.modelUris[i2] = {});
              const o2 = this.requestManager.normalizeModelURL(t2);
              if ((this.hasModel(e2, i2, { exactIdMatch: true }) || this.hasModelBeenAdded(e2, i2)) && this.modelUris[i2][e2] === o2) this.models[i2][e2].numReferences++;
              else if (this.hasURLBeenRequested(o2)) {
                const { scope: e3, modelId: t3 } = this.modelByURL[o2];
                this.models[e3][t3].numReferences++;
              } else this.modelUris[i2][e2] = o2, this.load({ [e2]: this.modelUris[i2][e2] }, i2);
            }
            addModelURLs(e2, t2) {
              this.models[t2] || (this.models[t2] = {}), this.modelUris[t2] || (this.modelUris[t2] = {});
              const i2 = this.modelUris[t2];
              for (const t3 in e2) i2[t3] = this.requestManager.normalizeModelURL(e2[t3]);
            }
            reloadModels(e2) {
              this.load(this.modelUris[e2], e2, { forceReload: true });
            }
            addModelsFromBucket(t2, i2) {
              this.models[i2] || (this.models[i2] = {}), this.modelUris[i2] || (this.modelUris[i2] = {});
              const o2 = {};
              for (const s2 of t2) this.hasModel(s2, i2, { exactIdMatch: true }) || this.hasURLBeenRequested(s2) ? this.models[i2][s2].numReferences++ : this.modelUris[i2][s2] && !this.hasURLBeenRequested(s2) ? o2[s2] = this.modelUris[i2][s2] : !this.hasURLBeenRequested(s2) && e.cZ(s2, false) && (this.modelUris[i2][s2] = this.requestManager.normalizeModelURL(s2), o2[s2] = this.modelUris[i2][s2]);
              this.load(o2, i2);
            }
            hasURLBeenRequested(e2) {
              return void 0 !== this.modelByURL[e2];
            }
            removeModel(e2, t2, i2 = false) {
              if (this.models[t2] && this.models[t2][e2] && (this.models[t2][e2].numReferences--, 0 === this.models[t2][e2].numReferences)) {
                const o2 = this.modelUris[t2][e2];
                i2 || delete this.modelUris[t2][e2], delete this.modelByURL[o2];
                const s2 = this.models[t2][e2].model;
                if (!s2) return;
                delete this.models[t2][e2], s2.destroy();
              }
            }
            destroy() {
              for (const e2 of Object.keys(this.models)) for (const t2 of Object.keys(this.models[e2])) {
                const i2 = this.models[e2][t2].model;
                delete this.models[e2][t2], i2 && i2.destroy();
              }
              this.models = { "": {} }, this.modelUris = { "": {} }, this.modelByURL = {}, this.numModelsLoading = {};
            }
            listModels(e2) {
              return this.models[e2] || (this.models[e2] = {}), Object.keys(this.models[e2]);
            }
            upload(e2, t2) {
              this.models[t2] || (this.models[t2] = {});
              for (const i2 in this.models[t2]) this.models[t2][i2].model && this.models[t2][i2].model.upload(e2.context);
            }
          }
          const ho = new e.a7({ data: new e.a8(e.a5.colorTheme.data) }), uo = { "mbx-indoor-active-floorplans": { default: ["literal", []] }, "mbx-indoor-underground": { default: ["literal", false] }, "mbx-indoor-loaded-levels": { default: ["literal", []] }, "mbx-indoor-level-height": { default: ["literal", {}] }, "mbx-indoor-level-base": { default: ["literal", {}] }, "mbx-indoor-level-selected": { default: ["literal", {}] }, "mbx-indoor-level-overlapped": { default: ["literal", {}] } };
          function _o(e2) {
            return e2 = e2 || {}, Object.assign(e2, uo);
          }
          class po extends e.E {
            constructor(t2) {
              super(), this.mergeFloors = true, this._scope = void 0, this._queryFeatureSetId = void 0, this._buildingEntryFeatureSetId = void 0, this._selectedFloorplan = void 0, this._indoorData = void 0, this._selectedLevel = void 0, this._floorplanStates = {}, e.aV(["_onLoad", "_onMove", "_checkFloorplanVisible"], this), this._map = t2, this._checkFloorplanVisible(true), this._map.on("load", this._onLoad), this._map.on("move", this._onMove);
            }
            destroy() {
              this._map.indoor.off("load", this._onLoad), this._map.indoor.off("move", this._onMove), this._map = void 0;
            }
            _onLoad() {
              this._map.style.forEachFragmentStyle((t2) => {
                t2.stylesheet.indoor && (this._queryFeatureSetId ? this.fire(new e.z(new Error("Multiple indoor map styles detected, simultaneous usage is not allowed currently."))) : (this._queryFeatureSetId = t2.stylesheet.indoor.floorplanFeaturesetId, this._buildingEntryFeatureSetId = t2.stylesheet.indoor.buildingFeaturesetId, this._scope = t2.scope));
              }), this._queryFeatureSetId && this._buildingEntryFeatureSetId && this._map.addInteraction("mbx-indoor-buildingclick", { type: "click", target: { featuresetId: this._buildingEntryFeatureSetId, importId: this._scope }, handler: (e2) => (e2.feature && e2.feature.properties.floorplan && this.selectFloorplan(e2.feature.properties.floorplan), true) }), this._checkFloorplanVisible(true);
            }
            _onMove() {
              this._checkFloorplanVisible(false);
            }
            _checkFloorplanVisible(t2) {
              if (!this._queryFeatureSetId) return;
              if (!this._map.isStyleLoaded()) return;
              if (this._map.transform.zoom < 13) return;
              this._indoorData && !function(e2, t3) {
                const [i3, o3] = e2, { center: s3, radius: r3 } = t3, [n2, a2] = s3, l2 = Math.abs(i3 - n2);
                return Math.sqrt((l2 > 180 ? 360 - l2 : l2) ** 2 + (o3 - a2) ** 2) <= r3;
              }([this._map.getCenter().lng, this._map.getCenter().lat], this._indoorData.circumCircle) && (this._indoorData = void 0, this._selectedFloorplan = void 0, this._map.setConfigProperty(this._scope, "mbx-indoor-underground", false), this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", ["literal", []]), this.fire(new e.A("floorplangone")));
              const i2 = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, o2 = new e.P(this._map.transform.width / 2, this._map.transform.height / 2), s2 = [new e.P(0, 0), new e.P(this._map.transform.width, this._map.transform.height)], r2 = this._map.queryRenderedFeatures(t2 ? s2 : o2, i2);
              r2.length > 0 && (this._selectedFloorplan && r2[0].properties.id === this._selectedFloorplan.properties.id || (this._selectedFloorplan = r2[0], this._floorplanSelected(false)));
            }
            _floorplanSelected(t2) {
              this._indoorData = JSON.parse(this._selectedFloorplan.properties["indoor-data"]), this._indoorData.id = this._selectedFloorplan.properties.id, this._indoorData.circumCircle = function(e2) {
                const [[t3, i3], [o3, s3]] = e2, r2 = (o3 - t3 + 360) % 360, n2 = r2 > 180 ? 360 - r2 : r2;
                return { center: [(t3 + n2 / 2 + 360) % 360, (i3 + s3) / 2], radius: Math.sqrt(n2 ** 2 + (s3 - i3) ** 2) / 2 };
              }(this._indoorData.extent), this._floorplanStates[this._indoorData.id] || (this._floorplanStates[this._indoorData.id] = {});
              const i2 = this._floorplanStates[this._indoorData.id].selectedBuilding, o2 = this._floorplanStates[this._indoorData.id].selectedLevel;
              let s2;
              if (this._map.setConfigProperty(this._scope, "mbx-indoor-active-floorplans", this._indoorData.floorplanIDs), this._selectedLevel) for (const e2 of this._indoorData.levels) e2.id === this._selectedLevel.id && (s2 = e2.id);
              if (this.fire(new e.A("floorplanselected", { buildings: this._indoorData.buildings, levels: this._indoorData.levels, selectedLevelId: s2 })), i2) {
                const e2 = this._indoorData.buildings.find((e3) => e3.id === i2);
                this._buildingSelected(e2, false);
              } else this._indoorData.buildings.length > 0 && this._buildingSelected(this._indoorData.buildings[0], false);
              if (o2) {
                const e2 = this._indoorData.levels.find((e3) => e3.id === o2);
                this._updateLevels(e2, t2);
              } else t2 && this._indoorData["default-levels"].length > 0 && this.selectLevel(this._indoorData["default-levels"][0]);
            }
            _buildingSelected(t2, i2) {
              i2 && t2 && t2.extent && this._map.fitBounds(t2.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), this._floorplanStates[this._indoorData.id].selectedBuilding = t2 ? t2.id : void 0;
              const o2 = this._indoorData.levels.filter((e2) => t2.levels.includes(e2.id));
              this.fire(new e.A("buildingselected", { buildingId: t2.id, levels: o2 }));
            }
            _levelSelected(t2) {
              if ("overview" === t2) this._updateLevels(void 0, true);
              else {
                const e2 = this._indoorData.levels.find((e3) => e3.id === t2);
                this._updateLevels(e2, true);
              }
              this.fire(new e.A("levelselected", { levelId: "overview" === t2 ? void 0 : t2 }));
            }
            _updateLevels(e2, t2) {
              if (!e2) return this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", []]), this._map.setConfigProperty(this._scope, "mbx-indoor-underground", false), this._floorplanStates[this._indoorData.id].selectedLevel = void 0, void (t2 && this._indoorData.extent && this._map.fitBounds(this._indoorData.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }));
              function i2(e3) {
                const t3 = e3.indexOf("/floor/");
                if (-1 === t3) return e3;
                const i3 = t3 + 7, o3 = e3.indexOf("/", i3);
                return -1 === o3 ? e3.slice(i3) : e3.slice(i3, o3);
              }
              this._selectedLevel = e2, this._floorplanStates[this._indoorData.id].selectedLevel = e2 ? e2.id : void 0;
              const o2 = [], s2 = {}, r2 = {}, n2 = {}, a2 = {};
              for (const t3 of this._indoorData.levels) if (o2.push(t3.id), s2[t3.id] = t3.height, r2[t3.id] = t3.base, e2) {
                if (this.mergeFloors) {
                  const o3 = i2(e2.id), s3 = i2(t3.id);
                  n2[t3.id] = s3 === o3 ? "true" : "false";
                } else n2[t3.id] = t3.id === e2.id ? "true" : "false";
                a2[t3.id] = t3.base < e2.base ? "true" : "false";
              } else a2[t3.id] = true;
              if (this._map.setConfigProperty(this._scope, "mbx-indoor-loaded-levels", ["literal", o2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-height", ["literal", s2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-base", ["literal", r2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-selected", ["literal", n2]), this._map.setConfigProperty(this._scope, "mbx-indoor-level-overlapped", ["literal", a2]), e2 && (this._map.setConfigProperty(this._scope, "mbx-indoor-underground", !!e2.isUnderground), t2 && e2.extent)) {
                const t3 = this._map.cameraForBounds(e2.extent, { pitch: this._map.getPitch(), bearing: this._map.getBearing() }), i3 = this._map.getZoom(), o3 = t3.zoom ? Math.abs(i3 - t3.zoom) : 0;
                this._map.fitBounds(e2.extent, o3 >= 1 ? { pitch: this._map.getPitch(), bearing: this._map.getBearing() } : { pitch: this._map.getPitch(), bearing: this._map.getBearing(), zoom: i3 });
              }
            }
            selectFloorplan(t2) {
              const i2 = { target: { featuresetId: this._queryFeatureSetId, importId: this._scope } }, o2 = [new e.P(0, 0), new e.P(this._map.transform.width, this._map.transform.height)], s2 = this._map.queryRenderedFeatures(o2, i2);
              if (s2.length > 0) {
                for (const e2 of s2) if (JSON.parse(e2.properties["indoor-data"]).floorplanIDs.includes(t2)) {
                  this._selectedFloorplan = e2, this._floorplanSelected(true);
                  break;
                }
              }
            }
            selectBuilding(e2) {
              const t2 = this._indoorData.buildings.find((t3) => t3.id === e2);
              this._buildingSelected(t2, true);
            }
            selectLevel(e2) {
              this._levelSelected(e2);
            }
          }
          function fo(t2) {
            if (!t2.metadata || !t2.metadata.content_area) return;
            const i2 = e.q.devicePixelRatio, { left: o2, top: s2, width: r2, height: n2 } = t2.metadata.content_area, a2 = o2 * i2, l2 = s2 * i2;
            return [a2, l2, a2 + r2 * i2, l2 + n2 * i2];
          }
          function mo(t2) {
            if (t2) return t2.map(([t3, i2]) => [t3 * e.q.devicePixelRatio, i2 * e.q.devicePixelRatio]);
          }
          class go {
            constructor(e2, t2, i2) {
              this.id = e2, this.scope = t2, this.sourceCache = i2, this.pendingRequests = /* @__PURE__ */ new Set(), this.missingRequests = /* @__PURE__ */ new Set();
            }
            addPendingRequest(e2) {
              this.missingRequests.has(e2.name) || this.pendingRequests.has(e2.name) || this.pendingRequests.add(e2.name);
            }
            hasPendingRequests() {
              return this.pendingRequests.size > 0;
            }
            resolvePendingRequests() {
              const t2 = /* @__PURE__ */ new Map();
              if (!this.sourceCache.loaded()) return t2;
              const i2 = this.sourceCache.getVisibleCoordinates();
              if (0 === i2.length) return t2;
              const o2 = this.sourceCache.getSource();
              if (!(o2 instanceof st)) return t2;
              const s2 = i2.map((e2) => this.sourceCache.getTile(e2)), r2 = o2.getImages(s2, Array.from(this.pendingRequests));
              for (const [i3, o3] of r2) t2.set(e.I.from({ name: i3, iconsetId: this.id }), o3), this.pendingRequests.delete(i3);
              for (const e2 of this.pendingRequests) this.missingRequests.add(e2);
              return this.pendingRequests.clear(), t2;
            }
          }
          const vo = (e2, t2) => Ae(e2, t2 && t2.filter((e3) => "source.canvas" !== e3.identifier)), yo = e.aF(zt, ["addLayer", "removeLayer", "setLights", "setPaintProperty", "setLayoutProperty", "setSlot", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setTerrain", "setFog", "setSnow", "setRain", "setProjection", "setCamera", "addImport", "removeImport", "updateImport", "addIconset", "removeIconset"]), xo = e.aF(zt, ["setCenter", "setZoom", "setBearing", "setPitch"]), bo = /* @__PURE__ */ new Set(["background", "sky", "slot", "custom"]), wo = { version: 8, layers: [], sources: {} }, To = { duration: 300, delay: 0 };
          class Eo extends e.E {
            constructor(t2, i2 = {}) {
              super(), this.map = t2, this.scope = i2.scope || "", this.globalId = null, this.fragments = [], this.importDepth = i2.importDepth || 0, this.importsCache = i2.importsCache || /* @__PURE__ */ new Map(), this.resolvedImports = i2.resolvedImports || /* @__PURE__ */ new Set(), this.transition = e.l({}, To), this._buildingIndex = new At(this), this.crossTileSymbolIndex = new Fi(), this._mergedOrder = [], this._drapedFirstOrder = [], this._mergedLayers = {}, this._mergedSourceCaches = {}, this._mergedOtherSourceCaches = {}, this._mergedSymbolSourceCaches = {}, this._clipLayerPresent = false, this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this._changes = i2.styleChanges || new V(), this.dispatcher = i2.dispatcher ? i2.dispatcher : new e.D(e.d0(), this), i2.imageManager ? this.imageManager = i2.imageManager : (this.imageManager = new q(this.map._spriteFormat), this.imageManager.setEventedParent(this)), this.imageManager.addScope(this.scope), this.glyphManager = i2.glyphManager ? i2.glyphManager : new e.d1(t2._requestManager, i2.localFontFamily ? e.d2.all : i2.localIdeographFontFamily ? e.d2.ideographs : e.d2.none, i2.localFontFamily || i2.localIdeographFontFamily), i2.modelManager ? this.modelManager = i2.modelManager : (this.modelManager = new co(t2._requestManager), this.modelManager.setEventedParent(this)), this._layers = {}, this._sourceCaches = {}, this._otherSourceCaches = {}, this._symbolSourceCaches = {}, this._loaded = false, this._precompileDone = false, this._shouldPrecompile = false, this._availableImages = [], this._availableModels = {}, this._order = [], this._markersNeedUpdate = false, this.options = i2.configOptions ? i2.configOptions : /* @__PURE__ */ new Map(), this._configDependentLayers = i2.configDependentLayers ? i2.configDependentLayers : /* @__PURE__ */ new Set(), this._config = i2.config, this._styleColorTheme = { lut: null, lutLoading: false, lutLoadingCorrelationID: 0, colorTheme: null, colorThemeOverride: i2.colorThemeOverride }, this._styleColorThemeForScope = {}, this._initialConfig = i2.initialConfig, this.dispatcher.broadcast("setReferrer", e.d3());
              const o2 = this;
              this._rtlTextPluginCallback = Eo.registerForPluginStateChange((t3) => {
                o2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: t3.pluginStatus, pluginURL: t3.pluginURL }, (t4, i3) => {
                  if (e.d4(t4), i3 && i3.every((e2) => e2)) for (const e2 in o2._sourceCaches) {
                    const t5 = o2._sourceCaches[e2], i4 = t5.getSource().type;
                    "vector" !== i4 && "geojson" !== i4 || t5.reload();
                  }
                });
              }), this.on("data", (e2) => {
                if ("source" !== e2.dataType || "metadata" !== e2.sourceDataType) return;
                const t3 = this.getOwnSource(e2.sourceId);
                if (t3 && t3.vectorLayerIds) for (const e3 in this._layers) {
                  const i3 = this._layers[e3];
                  i3.source === t3.id && this._validateLayer(i3);
                }
              });
            }
            load(e2) {
              return e2 ? ("string" == typeof e2 ? this.loadURL(e2) : this.loadJSON(e2), this) : this;
            }
            _getGlobalId(t2) {
              if (!t2) return null;
              if ("string" == typeof t2) {
                if (e.f(t2)) return t2;
                const i2 = e.d5(t2);
                if (!i2.startsWith("http")) try {
                  return new URL(i2, location.href).toString();
                } catch (e2) {
                  return i2;
                }
                return i2;
              }
              return `json://${e.d6(JSON.stringify(t2))}`;
            }
            _diffStyle(t2, i2, o2) {
              this.globalId = this._getGlobalId(t2);
              const s2 = (e2, t3) => {
                try {
                  t3(null, this.setState(e2, o2));
                } catch (e3) {
                  t3(e3, false);
                }
              };
              if ("string" == typeof t2) {
                const o3 = this.map._requestManager.normalizeStyleURL(t2), r2 = this.map._requestManager.transformRequest(o3, e.R.Style);
                e.n(r2, (t3, o4) => {
                  t3 ? this.fire(new e.z(t3)) : o4 && s2(o4, i2);
                });
              } else "object" == typeof t2 && s2(t2, i2);
            }
            loadURL(t2, i2 = {}) {
              this.fire(new e.A("dataloading", { dataType: "style" }));
              const o2 = "boolean" == typeof i2.validate ? i2.validate : !e.f(t2);
              this.globalId = this._getGlobalId(t2), t2 = this.map._requestManager.normalizeStyleURL(t2, i2.accessToken), this.resolvedImports.add(t2);
              const s2 = this.importsCache.get(t2);
              if (s2) return this._load(s2, o2);
              const r2 = this.map._requestManager.transformRequest(t2, e.R.Style);
              this._request = e.n(r2, (i3, s3) => {
                if (this._request = null, i3) this.fire(new e.z(i3));
                else if (s3) return this.importsCache.set(t2, s3), this._load(s3, o2);
              });
            }
            loadJSON(t2, i2 = {}) {
              this.fire(new e.A("dataloading", { dataType: "style" })), this.globalId = this._getGlobalId(t2), this._request = e.q.frame(() => {
                this._request = null, this._load(t2, false !== i2.validate);
              });
            }
            loadEmpty() {
              this.fire(new e.A("dataloading", { dataType: "style" })), this._load(wo, false);
            }
            _loadImports(t2, i2, o2) {
              if (this.importDepth >= 4) return e.w("Style doesn't support nesting deeper than 5"), Promise.resolve();
              const s2 = [];
              for (const e2 of t2) {
                const t3 = this._createFragmentStyle(e2), r2 = new Promise((e3) => {
                  t3.once("style.import.load", e3), t3.once("error", e3);
                }).then(() => this.mergeAll());
                if (s2.push(r2), this.resolvedImports.has(e2.url)) {
                  t3.loadEmpty();
                  continue;
                }
                const n2 = e2.data || this.importsCache.get(e2.url);
                n2 ? (t3.loadJSON(n2, { validate: i2 }), this._isInternalStyle(n2) && (t3.globalId = null)) : e2.url ? t3.loadURL(e2.url, { validate: i2 }) : t3.loadEmpty();
                const a2 = { style: t3, id: e2.id, config: e2.config };
                if (o2) {
                  const e3 = this.fragments.findIndex(({ id: e4 }) => e4 === o2);
                  this.fragments = this.fragments.slice(0, e3).concat(a2).concat(this.fragments.slice(e3));
                } else this.fragments.push(a2);
              }
              return Promise.allSettled(s2);
            }
            getImportGlobalIds(e2 = this, t2 = /* @__PURE__ */ new Set()) {
              for (const i2 of e2.fragments) i2.style.globalId && t2.add(i2.style.globalId), this.getImportGlobalIds(i2.style, t2);
              return [...t2.values()];
            }
            _createFragmentStyle(t2) {
              const i2 = this.scope ? e.C(t2.id, this.scope) : t2.id;
              let o2;
              const s2 = this._initialConfig && this._initialConfig[i2];
              (t2.config || s2) && (o2 = e.l({}, t2.config, s2));
              const r2 = new Eo(this.map, { scope: i2, styleChanges: this._changes, importDepth: this.importDepth + 1, importsCache: this.importsCache, resolvedImports: new Set(this.resolvedImports), dispatcher: this.dispatcher, imageManager: this.imageManager, glyphManager: this.glyphManager, modelManager: this.modelManager, config: o2, configOptions: this.options, colorThemeOverride: t2["color-theme"], configDependentLayers: this._configDependentLayers });
              return r2.setEventedParent(this.map, { style: r2 }), r2;
            }
            _reloadImports() {
              this.mergeAll(), this._updateMapProjection(), this.updateConfigDependencies(), this.map._triggerCameraUpdate(this.camera), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), this._shouldPrecompile = this.map._precompilePrograms && this.isRootStyle();
            }
            _isInternalStyle(e2) {
              return this.isRootStyle() && (e2.fragment || !!e2.schema && false !== e2.fragment);
            }
            _load(t2, i2) {
              const o2 = t2.indoor ? _o(t2.schema) : t2.schema;
              if (this._isInternalStyle(t2)) {
                const o3 = e.l({}, wo, { imports: [{ id: "basemap", data: t2, url: "" }] });
                return void this._load(o3, i2);
              }
              if (this.updateConfig(this._config, o2), i2 && vo(this, me(t2))) return;
              this._loaded = true, this.stylesheet = e.d7(t2);
              const s2 = () => {
                for (const e2 in t2.sources) this.addSource(e2, t2.sources[e2], { validate: false, isInitialLoad: true });
                if (t2.iconsets) for (const e2 in t2.iconsets) this.addIconset(e2, t2.iconsets[e2]);
                t2.sprite ? this._loadIconset(t2.sprite) : (this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true })), this.setGlyphsUrl(t2.glyphs);
                const o3 = Pt(this.stylesheet.layers);
                if (this._order = o3.map((e2) => e2.id), this.stylesheet.light && e.w("The `light` root property is deprecated, prefer using `lights` with `flat` light type instead."), this.stylesheet.lights) if (1 === this.stylesheet.lights.length && "flat" === this.stylesheet.lights[0].type) {
                  const e2 = this.stylesheet.lights[0];
                  this.light = new Pe(e2.properties, e2.id);
                } else this.setLights(this.stylesheet.lights);
                this.light || (this.light = new Pe(this.stylesheet.light)), this._layers = {};
                for (const t3 of o3) {
                  const i3 = e.dc(t3, this.scope, this._styleColorTheme.lut, this.options);
                  0 !== i3.configDependencies.size && this._configDependentLayers.add(i3.fqid), i3.setEventedParent(this, { layer: { id: i3.id } }), this._layers[i3.id] = i3;
                  const o4 = this.getOwnLayerSourceCache(i3), s4 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
                  o4 && i3.canCastShadows() && s4 && (o4.castsShadows = true);
                }
                this.stylesheet.featuresets && this.setFeaturesetSelectors(this.stylesheet.featuresets), this.stylesheet.models && this.addModelURLs(this.stylesheet.models);
                const s3 = this.stylesheet.terrain;
                s3 && (this.checkCanvasFingerprintNoise(), this.disableElevatedTerrain || this.terrainSetForDrapingOnly() || this._createTerrain(s3, 1)), this.stylesheet.fog && this._createFog(this.stylesheet.fog), this.stylesheet.snow && this._createSnow(this.stylesheet.snow), this.stylesheet.rain && this._createRain(this.stylesheet.rain), this.stylesheet.transition && this.setTransition(this.stylesheet.transition), this.fire(new e.A("data", { dataType: "style" }));
                const r3 = this.isRootStyle();
                t2.imports ? this._loadImports(t2.imports, i2).then(() => {
                  this._reloadImports(), this.fire(new e.A(r3 ? "style.load" : "style.import.load"));
                }).catch((t3) => {
                  this.fire(new e.z(new Error("Failed to load imports", t3))), this.fire(new e.A(r3 ? "style.load" : "style.import.load"));
                }) : (this._reloadImports(), this.fire(new e.A(r3 ? "style.load" : "style.import.load")));
              };
              this._styleColorTheme.colorTheme = this.stylesheet["color-theme"];
              const r2 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
              if (r2) {
                const t3 = this._evaluateColorThemeData(r2);
                this._loadColorTheme(t3).then(() => {
                  s2();
                }).catch((t4) => {
                  e.w(`Couldn't load color theme from the stylesheet: ${t4}`), s2();
                });
              } else this._styleColorTheme.lut = null, s2();
            }
            isRootStyle() {
              return 0 === this.importDepth;
            }
            mergeAll() {
              let t2, i2, o2, s2, r2, n2, a2, l2, c2, h2;
              const d2 = {};
              this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((e2) => {
                if (e2.stylesheet) {
                  if (null != e2.light && (t2 = e2.light), e2.stylesheet.lights) for (const t3 of e2.stylesheet.lights) "ambient" === t3.type && null != e2.ambientLight && (i2 = e2.ambientLight), "directional" === t3.type && null != e2.directionalLight && (o2 = e2.directionalLight);
                  s2 = this._prioritizeTerrain(s2, e2.terrain, e2.stylesheet.terrain), e2.stylesheet.fog && null != e2.fog && (r2 = e2.fog), e2.stylesheet.snow && null != e2.snow && (n2 = e2.snow), e2.stylesheet.rain && null != e2.rain && (a2 = e2.rain), null != e2.stylesheet.camera && (h2 = e2.stylesheet.camera), null != e2.stylesheet.projection && (l2 = e2.stylesheet.projection), null != e2.stylesheet.transition && (c2 = e2.stylesheet.transition), d2[e2.scope] = e2._styleColorTheme;
                }
              }), this.light = t2, this.ambientLight = i2, this.directionalLight = o2, this.fog = r2, this.snow = n2, this.rain = a2, this._styleColorThemeForScope = d2, null === s2 ? delete this.terrain : this.terrain = s2, this.camera = h2 || { "camera-projection": "perspective" }, this.projection = l2 || { name: "mercator" }, this.transition = e.l({}, To, c2), this.mergeSources(), this.mergeLayers();
            }
            forEachFragmentStyle(e2) {
              const t2 = (i2) => {
                for (const e3 of i2.fragments) t2(e3.style);
                e2(i2);
              };
              t2(this);
            }
            _prioritizeTerrain(e2, t2, i2) {
              const o2 = e2 && 0 === e2.drapeRenderMode;
              return null === i2 ? t2 && 0 === t2.drapeRenderMode ? t2 : o2 ? e2 : null : null != t2 && (!e2 || o2 || t2 && 1 === t2.drapeRenderMode) ? t2 : e2;
            }
            mergeTerrain() {
              let e2;
              this.terrain && this.terrain.scope !== this.scope && delete this.terrain, this.forEachFragmentStyle((t2) => {
                e2 = this._prioritizeTerrain(e2, t2.terrain, t2.stylesheet.terrain);
              }), null === e2 ? delete this.terrain : this.terrain = e2;
            }
            mergeProjection() {
              let e2;
              this.forEachFragmentStyle((t2) => {
                null != t2.stylesheet.projection && (e2 = t2.stylesheet.projection);
              }), this.projection = e2 || { name: "mercator" };
            }
            mergeSources() {
              const t2 = {}, i2 = {}, o2 = {};
              this.forEachFragmentStyle((s2) => {
                for (const i3 in s2._sourceCaches) {
                  const o3 = e.C(i3, s2.scope);
                  t2[o3] = s2._sourceCaches[i3];
                }
                for (const t3 in s2._otherSourceCaches) {
                  const o3 = e.C(t3, s2.scope);
                  i2[o3] = s2._otherSourceCaches[t3];
                }
                for (const t3 in s2._symbolSourceCaches) {
                  const i3 = e.C(t3, s2.scope);
                  o2[i3] = s2._symbolSourceCaches[t3];
                }
              }), this._mergedSourceCaches = t2, this._mergedOtherSourceCaches = i2, this._mergedSymbolSourceCaches = o2;
            }
            mergeLayers() {
              const t2 = {}, i2 = [], o2 = {};
              this._mergedSlots = [], this._has3DLayers = false, this._hasCircleLayers = false, this._hasSymbolLayers = false, this.forEachFragmentStyle((o3) => {
                for (const s3 of o3._order) {
                  const r2 = o3._layers[s3];
                  if ("slot" === r2.type) {
                    const i3 = e.d8(s3);
                    if (t2[i3]) continue;
                    t2[i3] = [];
                  }
                  r2.slot && t2[r2.slot] ? t2[r2.slot].push(r2) : i2.push(r2);
                }
              }), this._mergedOrder = [];
              const s2 = (i3 = []) => {
                for (const r2 of i3) if ("slot" === r2.type) {
                  const i4 = e.d8(r2.id);
                  t2[i4] && s2(t2[i4]), this._mergedSlots.push(i4);
                } else {
                  const t3 = e.C(r2.id, r2.scope);
                  this._mergedOrder.push(t3), o2[t3] = r2, r2.is3D(!!this.terrain) && (this._has3DLayers = true), "circle" === r2.type && (this._hasCircleLayers = true), "symbol" === r2.type && (this._hasSymbolLayers = true), "clip" === r2.type && (this._clipLayerPresent = true);
                }
              };
              s2(i2), this._mergedOrder.sort((e2, t3) => {
                const i3 = o2[e2], s3 = o2[t3];
                return i3.hasInitialOcclusionOpacityProperties ? s3.is3D(!!this.terrain) ? 1 : 0 : i3.is3D(!!this.terrain) && s3.hasInitialOcclusionOpacityProperties ? -1 : 0;
              }), this._mergedLayers = o2, this.updateDrapeFirstLayers(), this._buildingIndex.processLayersChanged();
            }
            terrainSetForDrapingOnly() {
              return !!this.terrain && 0 === this.terrain.drapeRenderMode;
            }
            getCamera() {
              return this.stylesheet.camera;
            }
            setCamera(t2) {
              return this.stylesheet.camera = e.l({}, this.stylesheet.camera, t2), this.camera = this.stylesheet.camera, this;
            }
            _evaluateColorThemeData(t2) {
              return t2.data ? function(t3, i2, o2) {
                const s2 = e.l({}, i2);
                for (const t4 of Object.keys(e.a5.colorTheme)) void 0 === s2[t4] && (s2[t4] = e.a5.colorTheme[t4].default);
                const r2 = new e.a6(ho, t3, new Map(o2));
                return r2.setTransitionOrValue(s2, o2), r2.untransitioned().possiblyEvaluate(new e.aa(0));
              }(this.scope, t2, this.options).get("data") : null;
            }
            _loadColorTheme(t2) {
              this._styleColorTheme.lutLoading = true, this._styleColorTheme.lutLoadingCorrelationID += 1;
              const i2 = this._styleColorTheme.lutLoadingCorrelationID;
              return new Promise((o2, s2) => {
                const r2 = "data:image/png;base64,";
                if (!t2 || 0 === t2.length) return this._styleColorTheme.lut = null, this._styleColorTheme.lutLoading = false, void o2();
                let n2 = t2;
                n2.startsWith(r2) || (n2 = r2 + n2);
                const a2 = e.I.from("mapbox-reserved-lut"), l2 = new Image();
                l2.src = n2, l2.onerror = () => {
                  this._styleColorTheme.lutLoading = false, s2(new Error("Failed to load image data"));
                }, l2.onload = () => {
                  if (this._styleColorTheme.lutLoadingCorrelationID !== i2) return void o2();
                  this._styleColorTheme.lutLoading = false;
                  const { width: r3, height: n3, data: c2 } = e.q.getImageData(l2);
                  if (n3 > 32) return void s2(new Error("The height of the image must be less than or equal to 32 pixels."));
                  if (r3 !== n3 * n3) return void s2(new Error("The width of the image must be equal to the height squared."));
                  this.getImage(a2) && this.removeImage(a2), this.addImage(a2, { data: new e.r({ width: r3, height: n3 }, c2), pixelRatio: 1, sdf: false, usvg: false, version: 0 });
                  const h2 = this.imageManager.getImage(a2, this.scope);
                  h2 ? (this._styleColorTheme.lut = { image: h2.data, data: t2 }, o2()) : s2(new Error("Missing LUT image."));
                };
              });
            }
            getLut(e2) {
              const t2 = this._styleColorThemeForScope[e2];
              return t2 ? t2.lut : null;
            }
            setProjection(e2) {
              e2 ? this.stylesheet.projection = e2 : delete this.stylesheet.projection, this.mergeProjection(), this._updateMapProjection();
            }
            applyProjectionUpdate() {
              this._loaded && (this.dispatcher.broadcast("setProjection", this.map.transform.projectionOptions), this.map.transform.projection.requiresDraping ? (this.getTerrain() || this.stylesheet.terrain) && !this.disableElevatedTerrain || this.setTerrainForDraping() : this.terrainSetForDrapingOnly() && this.setTerrain(null, 0));
            }
            _updateMapProjection() {
              this.isRootStyle() && (this.map._useExplicitProjection ? this.applyProjectionUpdate() : this.map._prioritizeAndUpdateProjection(null, this.projection));
            }
            _loadSprite(t2) {
              this._spriteRequest = function(t3, i2, o2) {
                let s2, r2, n2;
                const a2 = e.q.devicePixelRatio > 1 ? "@2x" : "";
                let l2 = e.n(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".json"), e.R.SpriteJSON), (e2, t4) => {
                  l2 = null, n2 || (n2 = e2, s2 = t4, h2());
                }), c2 = e.o(i2.transformRequest(i2.normalizeSpriteURL(t3, a2, ".png"), e.R.SpriteImage), (e2, t4) => {
                  c2 = null, n2 || (n2 = e2, r2 = t4, h2());
                });
                function h2() {
                  if (n2) o2(n2);
                  else if (s2 && r2) {
                    const t4 = e.q.getImageData(r2), i3 = {};
                    for (const o3 in s2) {
                      const { width: r3, height: n3, x: a3, y: l3, sdf: c3, pixelRatio: h3, stretchX: d2, stretchY: u5, content: _2 } = s2[o3], p2 = new e.r({ width: r3, height: n3 });
                      e.r.copy(t4, p2, { x: a3, y: l3 }, { x: 0, y: 0 }, { width: r3, height: n3 }, null), i3[o3] = { data: p2, pixelRatio: h3, sdf: c3, stretchX: d2, stretchY: u5, content: _2, usvg: false };
                    }
                    o2(null, i3);
                  }
                }
                return { cancel() {
                  l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(t2, this.map._requestManager, (t3, i2) => {
                if (this._spriteRequest = null, t3) this.fire(new e.z(t3));
                else if (i2) {
                  const t4 = /* @__PURE__ */ new Map();
                  for (const o2 in i2) t4.set(e.I.from(o2), i2[o2]);
                  this.addImages(t4);
                }
                this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.A("data", { dataType: "style" }));
              });
            }
            addIconset(t2, i2) {
              if ("sprite" === i2.type) return void this._loadSprite(i2.url);
              const o2 = this.getOwnSourceCache(i2.source);
              if (!o2) return void this.fire(new e.z(new Error(`Source "${i2.source}" as specified by iconset "${t2}" does not exist and cannot be used as an iconset source`)));
              const s2 = o2.getSource();
              if ("raster-array" !== s2.type) return void this.fire(new e.z(new Error(`Source "${i2.source}" as specified by iconset "${t2}" is not a "raster-array" source and cannot be used as an iconset source`)));
              s2.partial = false;
              const r2 = new go(t2, this.scope, o2);
              this.imageManager.addImageProvider(r2, this.scope);
            }
            removeIconset(e2) {
              this.imageManager.removeImageProvider(e2, this.scope);
            }
            _loadIconset(t2) {
              if (!e.f(t2) && "icon_set" !== this.map._spriteFormat || "raster" === this.map._spriteFormat) return void this._loadSprite(t2);
              const i2 = "auto" === this.map._spriteFormat;
              var o2, s2;
              this._spriteRequest = (s2 = (o3, s3) => {
                if (this._spriteRequest = null, o3) i2 ? this._loadSprite(t2) : this.fire(new e.z(o3));
                else if (s3) {
                  const t3 = /* @__PURE__ */ new Map();
                  for (const i3 in s3) t3.set(e.I.from(i3), s3[i3]);
                  this.addImages(t3);
                }
                this.imageManager.setLoaded(true, this.scope), this.dispatcher.broadcast("spriteLoaded", { scope: this.scope, isLoaded: true }), this.fire(new e.A("data", { dataType: "style" }));
              }, e.br((o2 = this.map._requestManager).transformRequest(o2.normalizeIconsetURL(t2), e.R.Iconset), (t3, i3) => {
                if (t3) return void s2(t3);
                const o3 = {}, r2 = e.c_(new e.bq(i3));
                for (const t4 of r2.icons) {
                  const i4 = { version: 1, pixelRatio: e.q.devicePixelRatio, content: fo(t4), stretchX: t4.metadata ? mo(t4.metadata.stretch_x_areas) : void 0, stretchY: t4.metadata ? mo(t4.metadata.stretch_y_areas) : void 0, sdf: false, usvg: true, icon: t4 };
                  o3[t4.name] = i4;
                }
                s2(null, o3);
              }));
            }
            _validateLayer(t2) {
              const i2 = this.getOwnSource(t2.source);
              if (!i2) return;
              const o2 = t2.sourceLayer;
              o2 && ("geojson" === i2.type || i2.vectorLayerIds && -1 === i2.vectorLayerIds.indexOf(o2)) && this.fire(new e.z(new Error(`Source layer "${o2}" does not exist on source "${i2.id}" as specified by style layer "${t2.id}"`)));
            }
            loaded() {
              if (!this._loaded) return false;
              if (Object.keys(this._changes.getUpdatedSourceCaches()).length) return false;
              for (const e2 in this._sourceCaches) if (!this._sourceCaches[e2].loaded()) return false;
              if (!this.imageManager.isLoaded()) return false;
              if (this.imageManager.hasPatternsInFlight()) return false;
              if (!this.modelManager.isLoaded()) return false;
              if (this._styleColorTheme.lutLoading) return false;
              for (const { style: e2 } of this.fragments) if (!e2.loaded()) return false;
              return true;
            }
            _serializeImports() {
              if (this.stylesheet.imports) return this.stylesheet.imports.map((e2, t2) => {
                const i2 = this.fragments[t2];
                return i2 && i2.style && (e2.data = i2.style.serialize()), e2;
              });
            }
            _serializeSources() {
              const e2 = {};
              for (const t2 in this._sourceCaches) {
                const i2 = this._sourceCaches[t2].getSource();
                e2[i2.id] || (e2[i2.id] = i2.serialize());
              }
              return e2;
            }
            _serializeLayers(e2) {
              const t2 = [];
              for (const i2 of e2) {
                const e3 = this._layers[i2];
                e3 && "custom" !== e3.type && t2.push(e3.serialize());
              }
              return t2;
            }
            hasLightTransitions() {
              return !(!this.light || !this.light.hasTransition()) || !(!this.ambientLight || !this.ambientLight.hasTransition()) || !(!this.directionalLight || !this.directionalLight.hasTransition());
            }
            hasFogTransition() {
              return !!this.fog && this.fog.hasTransition();
            }
            hasSnowTransition() {
              return !!this.snow && this.snow.hasTransition();
            }
            hasRainTransition() {
              return !!this.rain && this.rain.hasTransition();
            }
            hasTransitions() {
              if (this.hasLightTransitions()) return true;
              if (this.hasFogTransition()) return true;
              if (this.hasSnowTransition()) return true;
              if (this.hasRainTransition()) return true;
              for (const e2 in this._sourceCaches) if (this._sourceCaches[e2].hasTransition()) return true;
              for (const e2 in this._layers) if (this._layers[e2].hasTransition()) return true;
              return false;
            }
            get order() {
              return this.terrain ? this._drapedFirstOrder : this._mergedOrder;
            }
            _getOrder(e2) {
              return e2 ? this.order : this._mergedOrder;
            }
            isLayerDraped(e2) {
              return !!this.terrain && e2.isDraped(this.getLayerSourceCache(e2));
            }
            _checkLoaded() {
              if (!this._loaded) throw new Error("Style is not done loading");
            }
            _checkLayer(t2) {
              const i2 = this.getOwnLayer(t2);
              if (i2) return i2;
              this.fire(new e.z(new Error(`The layer '${t2}' does not exist in the map's style.`)));
            }
            _checkSource(t2) {
              const i2 = this.getOwnSource(t2);
              if (i2) return i2;
              this.fire(new e.z(new Error(`The source '${t2}' does not exist in the map's style.`)));
            }
            precompilePrograms(e2, t2) {
              const i2 = this.map.painter;
              if (i2) for (let o2 = e2.minzoom || 0; o2 < (e2.maxzoom || 25.5); o2++) {
                const o3 = e2.getProgramIds();
                if (o3) for (const s2 of o3) {
                  const o4 = e2.getDefaultProgramParams(s2, t2.zoom, this._styleColorTheme.lut);
                  o4 && (i2.style = this, this.fog && (i2._fogVisible = true, o4.overrideFog = true, i2.getOrCreateProgram(s2, o4)), i2._fogVisible = false, o4.overrideFog = false, i2.getOrCreateProgram(s2, o4), (this.stylesheet.terrain || this.stylesheet.projection && "globe" === this.stylesheet.projection.name) && (o4.overrideRtt = true, i2.getOrCreateProgram(s2, o4)));
                }
              }
            }
            update(t2) {
              if (!this._loaded) return;
              this.ambientLight && this.ambientLight.recalculate(t2), this.directionalLight && this.directionalLight.recalculate(t2);
              const i2 = this.calculateLightsBrightness();
              t2.brightness = i2 || 0, i2 !== this._brightness && (this._brightness = i2, this.dispatcher.broadcast("setBrightness", i2));
              const o2 = this._changes.isDirty();
              let s2 = false;
              if (this._changes.isDirty()) {
                const e2 = this._changes.getLayerUpdatesByScope();
                for (const t3 in e2) {
                  const { updatedIds: i3, removedIds: o3 } = e2[t3];
                  (i3 || o3) && (this._updateWorkerLayers(t3, i3, o3), s2 = true);
                }
                this.updateSourceCaches(), this._updateTilesForChangedImages(), this.updateLayers(t2), this.light && this.light.updateTransitions(t2), this.ambientLight && this.ambientLight.updateTransitions(t2), this.directionalLight && this.directionalLight.updateTransitions(t2), this.fog && this.fog.updateTransitions(t2), this.snow && this.snow.updateTransitions(t2), this.rain && this.rain.updateTransitions(t2), this._changes.reset();
              }
              const r2 = {};
              for (const e2 in this._mergedSourceCaches) {
                const t3 = this._mergedSourceCaches[e2];
                r2[e2] = t3.used, t3.used = false, t3.tileCoverLift = 0;
              }
              for (const e2 of this._mergedOrder) {
                const i3 = this._mergedLayers[e2];
                if (i3.recalculate(t2, this._availableImages), !i3.isHidden(t2.zoom)) {
                  const e3 = this.getLayerSourceCache(i3);
                  e3 && (e3.used = true, e3.tileCoverLift = Math.max(e3.tileCoverLift, i3.tileCoverLift()));
                }
                !this._precompileDone && this._shouldPrecompile && ("requestIdleCallback" in window ? requestIdleCallback(() => {
                  this.precompilePrograms(i3, t2);
                }) : this.precompilePrograms(i3, t2));
              }
              this._shouldPrecompile && (this._precompileDone = true), this.terrain && s2 && this.mergeLayers();
              const n2 = this.imageManager.getPendingImageProviders();
              for (const e2 of n2) e2.sourceCache.used = true;
              for (const t3 in r2) {
                const i3 = this._mergedSourceCaches[t3];
                r2[t3] !== i3.used && i3.getSource().fire(new e.A("data", { sourceDataType: "visibility", dataType: "source", sourceId: i3.getSource().id }));
              }
              this.light && this.light.recalculate(t2), this.terrain && this.terrain.recalculate(t2), this.fog && this.fog.recalculate(t2), this.snow && this.snow.recalculate(t2), this.rain && this.rain.recalculate(t2), this.z = t2.zoom, this._markersNeedUpdate && (this._updateMarkersOpacity(), this._markersNeedUpdate = false), this.imageManager.clearUpdatedImages(this.scope), o2 && this.fire(new e.A("data", { dataType: "style" }));
            }
            updateImageProviders() {
              const e2 = this.imageManager.getPendingImageProviders();
              for (const t2 of e2) {
                const e3 = t2.resolvePendingRequests(), i2 = this.getFragmentStyle(t2.scope);
                i2 && i2.addImages(e3);
              }
            }
            _updateTilesForChangedImages() {
              const e2 = {};
              for (const t2 in this._mergedSourceCaches) {
                const i2 = this._mergedSourceCaches[t2].getSource().scope;
                e2[i2] = e2[i2] || this._changes.getUpdatedImages(i2), 0 !== e2[i2].length && this._mergedSourceCaches[t2].reloadTilesForDependencies(["icons", "patterns"], e2[i2]);
              }
              for (const t2 in e2) this._changes.resetUpdatedImages(t2);
            }
            _updateWorkerLayers(e2, t2, i2) {
              const o2 = this.getFragmentStyle(e2);
              o2 && this.dispatcher.broadcast("updateLayers", { layers: t2 ? o2._serializeLayers(t2) : [], scope: e2, removedIds: i2 || [], options: o2.options });
            }
            setState(t2, i2) {
              if (this._checkLoaded(), vo(this, me(t2))) return false;
              (t2 = e.d7(t2)).layers = Pt(t2.layers);
              const o2 = function(t3, i3) {
                if (!t3) return [{ command: zt.setStyle, args: [i3] }];
                let o3 = [];
                try {
                  if (!e.bv(t3.version, i3.version)) return [{ command: zt.setStyle, args: [i3] }];
                  if (e.bv(t3.center, i3.center) || o3.push({ command: zt.setCenter, args: [i3.center] }), e.bv(t3.zoom, i3.zoom) || o3.push({ command: zt.setZoom, args: [i3.zoom] }), e.bv(t3.bearing, i3.bearing) || o3.push({ command: zt.setBearing, args: [i3.bearing] }), e.bv(t3.pitch, i3.pitch) || o3.push({ command: zt.setPitch, args: [i3.pitch] }), e.bv(t3.sprite, i3.sprite) || o3.push({ command: zt.setSprite, args: [i3.sprite] }), e.bv(t3.glyphs, i3.glyphs) || o3.push({ command: zt.setGlyphs, args: [i3.glyphs] }), e.bv(t3.imports, i3.imports) || function(t4 = [], i4 = [], o4) {
                    i4 = i4 || [];
                    const s4 = (t4 = t4 || []).map(Nt), r4 = i4.map(Nt), n3 = t4.reduce(Ut, {}), a3 = i4.reduce(Ut, {}), l2 = s4.slice();
                    let c2, h2, d2, u5;
                    for (c2 = 0, h2 = 0; c2 < s4.length; c2++) d2 = s4[c2], a3.hasOwnProperty(d2) ? h2++ : (o4.push({ command: zt.removeImport, args: [d2] }), l2.splice(l2.indexOf(d2, h2), 1));
                    for (c2 = 0, h2 = 0; c2 < r4.length; c2++) d2 = r4[r4.length - 1 - c2], l2[l2.length - 1 - c2] !== d2 && (n3.hasOwnProperty(d2) ? (o4.push({ command: zt.removeImport, args: [d2] }), l2.splice(l2.lastIndexOf(d2, l2.length - h2), 1)) : h2++, u5 = l2[l2.length - c2], o4.push({ command: zt.addImport, args: [a3[d2], u5] }), l2.splice(l2.length - c2, 0, d2));
                    for (const t5 of i4) {
                      const i5 = n3[t5.id];
                      i5 && !e.bv(i5, t5) && o4.push({ command: zt.updateImport, args: [t5.id, t5] });
                    }
                  }(t3.imports, i3.imports, o3), e.bv(t3.transition, i3.transition) || o3.push({ command: zt.setTransition, args: [i3.transition] }), e.bv(t3.light, i3.light) || o3.push({ command: zt.setLight, args: [i3.light] }), e.bv(t3.fog, i3.fog) || o3.push({ command: zt.setFog, args: [i3.fog] }), e.bv(t3.snow, i3.snow) || o3.push({ command: zt.setSnow, args: [i3.snow] }), e.bv(t3.rain, i3.rain) || o3.push({ command: zt.setRain, args: [i3.rain] }), e.bv(t3.projection, i3.projection) || o3.push({ command: zt.setProjection, args: [i3.projection] }), e.bv(t3.lights, i3.lights) || o3.push({ command: zt.setLights, args: [i3.lights] }), e.bv(t3.camera, i3.camera) || o3.push({ command: zt.setCamera, args: [i3.camera] }), e.bv(t3.iconsets, i3.iconsets) || function(t4, i4, o4) {
                    let s4;
                    for (s4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(s4) && (i4.hasOwnProperty(s4) || o4.push({ command: zt.removeIconset, args: [s4] }));
                    for (s4 in i4) {
                      if (!i4.hasOwnProperty(s4)) continue;
                      const r4 = i4[s4];
                      t4.hasOwnProperty(s4) ? e.bv(t4[s4], r4) || (o4.push({ command: zt.removeIconset, args: [s4] }), o4.push({ command: zt.addIconset, args: [s4, r4] })) : o4.push({ command: zt.addIconset, args: [s4, r4] });
                    }
                  }(t3.iconsets, i3.iconsets, o3), !e.bv(t3["color-theme"], i3["color-theme"])) return [{ command: zt.setStyle, args: [i3] }];
                  const s3 = {}, r3 = [];
                  !function(t4, i4, o4, s4) {
                    let r4;
                    for (r4 in i4 = i4 || {}, t4 = t4 || {}) t4.hasOwnProperty(r4) && (i4.hasOwnProperty(r4) || Ot(r4, o4, s4));
                    for (r4 in i4) {
                      if (!i4.hasOwnProperty(r4)) continue;
                      const n3 = i4[r4];
                      t4.hasOwnProperty(r4) ? e.bv(t4[r4], n3) || ("geojson" === t4[r4].type && "geojson" === n3.type && Bt(t4, i4, r4) ? o4.push({ command: zt.setGeoJSONSourceData, args: [r4, n3.data] }) : Ft(r4, i4, o4, s4)) : Mt(r4, i4, o4);
                    }
                  }(t3.sources, i3.sources, r3, s3);
                  const n2 = [];
                  t3.layers && t3.layers.forEach((e2) => {
                    e2.source && s3[e2.source] ? o3.push({ command: zt.removeLayer, args: [e2.id] }) : n2.push(e2);
                  });
                  let a2 = t3.terrain;
                  a2 && s3[a2.source] && (o3.push({ command: zt.setTerrain, args: [void 0] }), a2 = void 0), o3 = o3.concat(r3), e.bv(a2, i3.terrain) || o3.push({ command: zt.setTerrain, args: [i3.terrain] }), function(t4, i4, o4) {
                    i4 = i4 || [];
                    const s4 = (t4 = t4 || []).map(Nt), r4 = i4.map(Nt), n3 = t4.reduce(Ut, {}), a3 = i4.reduce(Ut, {}), l2 = s4.slice(), c2 = /* @__PURE__ */ Object.create(null);
                    let h2, d2, u5, _2, p2, f2, m2;
                    for (h2 = 0, d2 = 0; h2 < s4.length; h2++) u5 = s4[h2], a3.hasOwnProperty(u5) ? d2++ : (o4.push({ command: zt.removeLayer, args: [u5] }), l2.splice(l2.indexOf(u5, d2), 1));
                    for (h2 = 0, d2 = 0; h2 < r4.length; h2++) u5 = r4[r4.length - 1 - h2], l2[l2.length - 1 - h2] !== u5 && (n3.hasOwnProperty(u5) ? (o4.push({ command: zt.removeLayer, args: [u5] }), l2.splice(l2.lastIndexOf(u5, l2.length - d2), 1)) : d2++, f2 = l2[l2.length - h2], o4.push({ command: zt.addLayer, args: [a3[u5], f2] }), l2.splice(l2.length - h2, 0, u5), c2[u5] = true);
                    for (h2 = 0; h2 < r4.length; h2++) if (u5 = r4[h2], _2 = n3[u5], p2 = a3[u5], !c2[u5] && !e.bv(_2, p2)) if (e.bv(_2.source, p2.source) && e.bv(_2["source-layer"], p2["source-layer"]) && e.bv(_2.type, p2.type)) {
                      for (m2 in kt(_2.layout, p2.layout, o4, u5, null, zt.setLayoutProperty), kt(_2.paint, p2.paint, o4, u5, null, zt.setPaintProperty), e.bv(_2.slot, p2.slot) || o4.push({ command: zt.setSlot, args: [u5, p2.slot] }), e.bv(_2.filter, p2.filter) || o4.push({ command: zt.setFilter, args: [u5, p2.filter] }), e.bv(_2.minzoom, p2.minzoom) && e.bv(_2.maxzoom, p2.maxzoom) || o4.push({ command: zt.setLayerZoomRange, args: [u5, p2.minzoom, p2.maxzoom] }), _2) _2.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? kt(_2[m2], p2[m2], o4, u5, m2.slice(6), zt.setPaintProperty) : e.bv(_2[m2], p2[m2]) || o4.push({ command: zt.setLayerProperty, args: [u5, m2, p2[m2]] }));
                      for (m2 in p2) p2.hasOwnProperty(m2) && !_2.hasOwnProperty(m2) && "layout" !== m2 && "paint" !== m2 && "filter" !== m2 && "metadata" !== m2 && "minzoom" !== m2 && "maxzoom" !== m2 && "slot" !== m2 && (0 === m2.indexOf("paint.") ? kt(_2[m2], p2[m2], o4, u5, m2.slice(6), zt.setPaintProperty) : e.bv(_2[m2], p2[m2]) || o4.push({ command: zt.setLayerProperty, args: [u5, m2, p2[m2]] }));
                    } else o4.push({ command: zt.removeLayer, args: [u5] }), f2 = l2[l2.lastIndexOf(u5) + 1], o4.push({ command: zt.addLayer, args: [p2, f2] });
                  }(n2, i3.layers, o3);
                } catch (e2) {
                  console.warn("Unable to compute style diff:", e2), o3 = [{ command: zt.setStyle, args: [i3] }];
                }
                return o3;
              }(this.serialize(), t2).filter((e2) => !(e2.command in xo));
              if (0 === o2.length) return false;
              const s2 = o2.filter((e2) => !(e2.command in yo));
              if (s2.length > 0) throw new Error(`Unimplemented: ${s2.map((e2) => e2.command).join(", ")}.`);
              const r2 = [];
              return o2.forEach((e2) => {
                r2.push(this[e2.command](...e2.args));
              }), i2 && Promise.all(r2).then(i2).catch(i2), this.stylesheet = t2, this.mergeAll(), this.dispatcher.broadcast("setLayers", { layers: this._serializeLayers(this._order), scope: this.scope, options: this.options }), true;
            }
            _updateWorkerImages() {
              this._availableImages = this.imageManager.listImages(this.scope), this.dispatcher.broadcast("setImages", { scope: this.scope, images: this._availableImages });
            }
            _updateWorkerModels() {
              this._availableModels = this.modelManager.getModelURIs(this.scope), this.dispatcher.broadcast("setModels", { scope: this.scope, models: this._availableModels });
            }
            addImages(t2) {
              for (const [i2, o2] of t2.entries()) {
                if (this.getImage(i2)) return this.fire(new e.z(new Error(`An image with the name "${i2.name}" already exists.`)));
                this.imageManager.addImage(i2, this.scope, o2), this._changes.updateImage(i2, this.scope);
              }
              return this._updateWorkerImages(), this.fire(new e.A("data", { dataType: "style" })), this;
            }
            addImage(t2, i2) {
              return this.getImage(t2) ? this.fire(new e.z(new Error(`An image with the name "${t2.name}" already exists.`))) : (this.imageManager.addImage(t2, this.scope, i2), this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", { dataType: "style" })), this);
            }
            updateImage(t2, i2, o2 = false) {
              this.imageManager.updateImage(t2, this.scope, i2), o2 && (this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", { dataType: "style" })));
            }
            getImage(e2) {
              return this.imageManager.getImage(e2, this.scope);
            }
            removeImage(t2) {
              return this.getImage(t2) ? (this.imageManager.removeImage(t2, this.scope), this._changes.updateImage(t2, this.scope), this._updateWorkerImages(), this.fire(new e.A("data", { dataType: "style" })), this) : this.fire(new e.z(new Error("No image with this name exists.")));
            }
            listImages() {
              return this._checkLoaded(), this._availableImages.slice();
            }
            addModelURLs(t2) {
              return this.modelManager.addModelURLs(t2, this.scope), this._updateWorkerModels(), this.fire(new e.A("data", { dataType: "style" })), this;
            }
            addModel(t2, i2, o2 = {}) {
              return this._checkLoaded(), this._validate(Re, `models.${t2}`, i2, null, o2) || (this.modelManager.addModel(t2, i2, this.scope), this.fire(new e.A("data", { dataType: "style" }))), this;
            }
            hasModel(e2) {
              return this.modelManager.hasModel(e2, this.scope);
            }
            removeModel(t2) {
              return this.hasModel(t2) ? (this.modelManager.removeModel(t2, this.scope), this.fire(new e.A("data", { dataType: "style" })), this) : this.fire(new e.z(new Error("No model with this ID exists.")));
            }
            listModels() {
              return this._checkLoaded(), this.modelManager.listModels(this.scope);
            }
            addSource(t2, i2, o2 = {}) {
              if (this._checkLoaded(), void 0 !== this.getOwnSource(t2)) throw new Error(`There is already a source with ID "${t2}".`);
              if (!i2.type) throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i2).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i2.type) >= 0 && this._validate(ge, `sources.${t2}`, i2, null, o2)) return;
              this.map && this.map._collectResourceTiming && (i2.collectResourceTiming = true);
              const s2 = nt(t2, i2, this.dispatcher, this);
              s2.scope = this.scope, s2.setEventedParent(this, () => ({ isSourceLoaded: this._isSourceCacheLoaded(s2.id), source: s2.serialize(), sourceId: s2.id }));
              const r2 = (t3) => {
                const i3 = (t3 ? "symbol:" : "other:") + s2.id, o3 = e.C(i3, this.scope), r3 = this._sourceCaches[i3] = new It(o3, s2, t3);
                (t3 ? this._symbolSourceCaches : this._otherSourceCaches)[s2.id] = r3, r3.onAdd(this.map);
              };
              r2(false), "vector" !== i2.type && "geojson" !== i2.type || r2(true), s2.onAdd && s2.onAdd(this.map), o2.isInitialLoad || (this.mergeSources(), this._changes.setDirty());
            }
            removeSource(t2) {
              this._checkLoaded();
              const i2 = this.getOwnSource(t2);
              if (!i2) throw new Error("There is no source with this ID");
              for (const i3 in this._layers) if (this._layers[i3].source === t2) return this.fire(new e.z(new Error(`Source "${t2}" cannot be removed while layer "${i3}" is using it.`)));
              if (this.terrain && this.terrain.scope === this.scope && this.terrain.get().source === t2) return this.fire(new e.z(new Error(`Source "${t2}" cannot be removed while terrain is using it.`)));
              if (this.stylesheet.iconsets) {
                const i3 = Object.entries(this.stylesheet.iconsets).find(([e2, i4]) => "source" === i4.type && i4.source === t2);
                if (i3) return this.fire(new e.z(new Error(`Source "${t2}" cannot be removed while iconset "${i3[0]}" is using it.`)));
              }
              const o2 = this.getOwnSourceCaches(t2);
              for (const t3 of o2) {
                const i3 = e.d8(t3.id);
                delete this._sourceCaches[i3], this._changes.discardSourceCacheUpdate(t3.id), t3.fire(new e.A("data", { sourceDataType: "metadata", dataType: "source", sourceId: t3.getSource().id })), t3.setEventedParent(null), t3.clearTiles();
              }
              return delete this._otherSourceCaches[t2], delete this._symbolSourceCaches[t2], this.mergeSources(), i2.setEventedParent(null), i2.onRemove && i2.onRemove(this.map), this._changes.setDirty(), this;
            }
            setGeoJSONSourceData(e2, t2) {
              this._checkLoaded(), this.getOwnSource(e2).setData(t2), this._changes.setDirty();
            }
            getOwnSource(e2) {
              const t2 = this.getOwnSourceCache(e2);
              return t2 && t2.getSource();
            }
            getOwnSources() {
              const e2 = [];
              for (const t2 in this._otherSourceCaches) {
                const i2 = this.getOwnSourceCache(t2);
                i2 && e2.push(i2.getSource());
              }
              return e2;
            }
            areTilesLoaded() {
              const e2 = this._mergedSourceCaches;
              for (const t2 in e2) {
                const i2 = e2[t2]._tiles;
                for (const e3 in i2) {
                  const t3 = i2[e3];
                  if ("loaded" !== t3.state && "errored" !== t3.state) return false;
                }
              }
              return true;
            }
            setLights(t2) {
              if (this._checkLoaded(), !t2) return delete this.ambientLight, void delete this.directionalLight;
              const i2 = this._getTransitionParameters();
              for (const o3 of t2) {
                if (this._validate(ye, "lights", o3)) return;
                switch (o3.type) {
                  case "ambient":
                    if (this.ambientLight) {
                      const e2 = this.ambientLight;
                      e2.set(o3), e2.updateTransitions(i2);
                    } else this.ambientLight = new $e(o3, qe || (qe = new e.a7({ color: new e.a8(e.a5.properties_light_ambient.color), "color-use-theme": new e.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e.a8(e.a5.properties_light_ambient.intensity) })), this.scope, this.options);
                    break;
                  case "directional":
                    if (this.directionalLight) {
                      const e2 = this.directionalLight;
                      e2.set(o3), e2.updateTransitions(i2);
                    } else this.directionalLight = new $e(o3, Ze || (Ze = new e.a7({ direction: new e.an(e.a5.properties_light_directional.direction), color: new e.a8(e.a5.properties_light_directional.color), "color-use-theme": new e.a8({ type: "string", default: "default", "property-type": "data-constant" }), intensity: new e.a8(e.a5.properties_light_directional.intensity), "cast-shadows": new e.a8(e.a5.properties_light_directional["cast-shadows"]), "shadow-quality": new e.a8(e.a5.properties_light_directional["shadow-quality"]), "shadow-intensity": new e.a8(e.a5.properties_light_directional["shadow-intensity"]) })), this.scope, this.options);
                }
              }
              const o2 = new e.aa(this.z || 0, i2);
              this.ambientLight && this.ambientLight.recalculate(o2), this.directionalLight && this.directionalLight.recalculate(o2), this._brightness = this.calculateLightsBrightness(), this.dispatcher.broadcast("setBrightness", this._brightness);
            }
            calculateLightsBrightness() {
              const t2 = this.directionalLight, i2 = this.ambientLight;
              if (!t2 || !i2) return;
              const o2 = (e2) => 0.2126 * (e2[0] <= 0.03928 ? e2[0] / 12.92 : Math.pow((e2[0] + 0.055) / 1.055, 2.4)) + 0.7152 * (e2[1] <= 0.03928 ? e2[1] / 12.92 : Math.pow((e2[1] + 0.055) / 1.055, 2.4)) + 0.0722 * (e2[2] <= 0.03928 ? e2[2] / 12.92 : Math.pow((e2[2] + 0.055) / 1.055, 2.4)), s2 = t2.properties.get("color").toRenderColor(null).toArray01(), r2 = t2.properties.get("intensity"), n2 = t2.properties.get("direction"), a2 = 1 - e.cR(n2.x, n2.y, n2.z)[2] / 90, l2 = o2(s2) * r2 * a2, c2 = i2.properties.get("color").toRenderColor(null).toArray01(), h2 = i2.properties.get("intensity"), d2 = o2(c2) * h2;
              return Number(((l2 + d2) / 2).toFixed(6));
            }
            getBrightness() {
              return this._brightness;
            }
            getLights() {
              if (!this.enable3dLights()) return null;
              const e2 = [];
              return this.directionalLight && e2.push(this.directionalLight.get()), this.ambientLight && e2.push(this.ambientLight.get()), e2;
            }
            enable3dLights() {
              return !!this.ambientLight && !!this.directionalLight;
            }
            getFragmentStyle(t2) {
              if (null == t2 || "" === t2 && this.isRootStyle()) return this;
              if (e.d9(t2)) {
                const i2 = e.da(t2), o2 = this.fragments.find(({ id: e2 }) => e2 === i2);
                if (!o2) return;
                const s2 = e.d8(t2);
                return o2.style.getFragmentStyle(s2);
              }
              {
                const e2 = this.fragments.find(({ id: e3 }) => e3 === t2);
                return e2 ? e2.style : void 0;
              }
            }
            setFeaturesetSelectors(t2) {
              if (!t2) return;
              const i2 = {}, o2 = (e2, t3 = "") => `${e2}::${t3}`;
              this._featuresetSelectors = {};
              for (const s2 in t2) {
                const r2 = this._featuresetSelectors[s2] = [];
                for (const n2 of t2[s2].selectors) {
                  if (n2.featureNamespace) {
                    const t4 = this.getOwnLayer(n2.layer);
                    if (!t4) {
                      e.w(`Layer is undefined for selector: ${n2.layer}`);
                      continue;
                    }
                    const r3 = o2(t4.source, t4.sourceLayer);
                    if (r3 in i2 && i2[r3] !== n2.featureNamespace) {
                      e.w(`"featureNamespace ${n2.featureNamespace} of featureset ${s2}'s selector is not associated to the same source, skip this selector`);
                      continue;
                    }
                    i2[r3] = n2.featureNamespace;
                  }
                  let t3;
                  if (n2.properties) for (const i3 in n2.properties) {
                    const o3 = e.X(n2.properties[i3]);
                    "success" === o3.result && (t3 = t3 || {}, t3[i3] = o3.value);
                  }
                  r2.push({ layerId: n2.layer, namespace: n2.featureNamespace, properties: t3, uniqueFeatureID: n2._uniqueFeatureID });
                }
              }
            }
            getFeaturesetDescriptors(e2) {
              const t2 = this.getFragmentStyle(e2);
              if (!t2 || !t2.stylesheet.featuresets) return [];
              const i2 = [];
              for (const e3 in t2.stylesheet.featuresets) i2.push({ featuresetId: e3, importId: t2.scope ? t2.scope : void 0 });
              return i2;
            }
            getFeaturesetLayers(t2, i2) {
              const o2 = this.getFragmentStyle(i2), s2 = o2.stylesheet.featuresets;
              if (!s2 || !s2[t2]) return this.fire(new e.z(new Error(`The featureset '${t2}' does not exist in the map's style and cannot be queried.`))), [];
              const r2 = [];
              for (const e2 of s2[t2].selectors) {
                const t3 = o2.getOwnLayer(e2.layer);
                t3 && r2.push(t3);
              }
              return r2;
            }
            getConfigProperty(t2, i2) {
              const o2 = this.getFragmentStyle(t2);
              if (!o2) return null;
              const s2 = e.C(i2, o2.scope), r2 = o2.options.get(s2), n2 = r2 ? r2.value || r2.default : null;
              return n2 ? n2.serialize() : null;
            }
            setConfigProperty(t2, i2, o2) {
              const s2 = this.getFragmentStyle(t2);
              if (!s2) return;
              const r2 = s2.stylesheet.indoor ? _o(s2.stylesheet.schema) : s2.stylesheet.schema;
              if (!r2 || !r2[i2]) return;
              const n2 = e.X(o2);
              if ("success" !== n2.result) return void vo(this, n2.value);
              const a2 = n2.value.expression, l2 = e.C(i2, s2.scope), c2 = s2.options.get(l2);
              if (!c2) return;
              let h2;
              const { minValue: d2, maxValue: u5, stepValue: _2, type: p2, values: f2 } = r2[i2], m2 = e.X(r2[i2].default);
              "success" === m2.result && (h2 = m2.value.expression), h2 ? (this.options.set(l2, Object.assign({}, c2, { value: a2, default: h2, minValue: d2, maxValue: u5, stepValue: _2, type: p2, values: f2 })), this.updateConfigDependencies(i2)) : this.fire(new e.z(new Error(`No schema defined for the config option "${i2}" in the "${t2}" fragment.`)));
            }
            getConfig(t2) {
              const i2 = this.getFragmentStyle(t2);
              if (!i2) return null;
              const o2 = i2.stylesheet.schema;
              if (!o2) return null;
              const s2 = {};
              for (const t3 in o2) {
                const o3 = e.C(t3, i2.scope), r2 = i2.options.get(o3), n2 = r2 ? r2.value || r2.default : null;
                s2[t3] = n2 ? n2.serialize() : null;
              }
              return s2;
            }
            setConfig(e2, t2) {
              const i2 = this.getFragmentStyle(e2);
              i2 && (i2.updateConfig(t2, i2.stylesheet.schema), this.updateConfigDependencies());
            }
            getSchema(e2) {
              const t2 = this.getFragmentStyle(e2);
              return t2 ? t2.stylesheet.schema : null;
            }
            setSchema(e2, t2) {
              const i2 = this.getFragmentStyle(e2);
              i2 && (i2.stylesheet.schema = t2, i2.updateConfig(i2._config, t2), this.updateConfigDependencies());
            }
            updateConfig(t2, i2) {
              if (this._config = t2, t2 || i2) if (i2) for (const o2 in i2) {
                let s2, r2;
                const n2 = e.X(i2[o2].default);
                if ("success" === n2.result && (s2 = n2.value.expression), t2 && void 0 !== t2[o2]) {
                  const i3 = e.X(t2[o2]);
                  "success" === i3.result && (r2 = i3.value.expression);
                }
                const { minValue: a2, maxValue: l2, stepValue: c2, type: h2, values: d2 } = i2[o2];
                if (s2) {
                  const t3 = e.C(o2, this.scope);
                  this.options.set(t3, { default: s2, value: r2, minValue: a2, maxValue: l2, stepValue: c2, type: h2, values: d2 });
                } else this.fire(new e.z(new Error(`No schema defined for config option "${o2}".`)));
              }
              else this.fire(new e.z(new Error("Attempting to set config for a style without schema.")));
            }
            updateConfigDependencies(e2) {
              for (const t2 of this._configDependentLayers) {
                const i2 = this.getLayer(t2);
                if (i2) {
                  if (e2 && !i2.configDependencies.has(e2)) continue;
                  i2.possiblyEvaluateVisibility(), this._updateLayer(i2);
                }
              }
              this.ambientLight && this.ambientLight.updateConfig(this.options), this.directionalLight && this.directionalLight.updateConfig(this.options), this.fog && this.fog.updateConfig(this.options), this.snow && this.snow.updateConfig(this.options), this.rain && this.rain.updateConfig(this.options), this.forEachFragmentStyle((e3) => {
                const t2 = e3._styleColorTheme.colorThemeOverride ? e3._styleColorTheme.colorThemeOverride : e3._styleColorTheme.colorTheme;
                if (t2) {
                  const i2 = e3._evaluateColorThemeData(t2);
                  (!e3._styleColorTheme.lut && "" !== i2 || e3._styleColorTheme.lut && i2 !== e3._styleColorTheme.lut.data) && e3.setColorTheme(t2);
                }
              }), this._changes.setDirty();
            }
            addLayer(t2, i2, o2 = {}) {
              this._checkLoaded();
              const s2 = t2.id;
              if (this._layers[s2]) return void this.fire(new e.z(new Error(`Layer with id "${s2}" already exists on this map`)));
              let r2;
              if ("custom" === t2.type) {
                if (vo(this, e.db(t2))) return;
                r2 = e.dc(t2, this.scope, this._styleColorTheme.lut, this.options);
              } else {
                if ("object" == typeof t2.source && (this.addSource(s2, t2.source), t2 = e.d7(t2), t2 = e.l(t2, { source: s2 })), this._validate(Ee, `layers.${s2}`, t2, { arrayIndex: -1 }, o2)) return;
                r2 = e.dc(t2, this.scope, this._styleColorTheme.lut, this.options), this._validateLayer(r2), r2.setEventedParent(this, { layer: { id: s2 } });
              }
              0 !== r2.configDependencies.size && this._configDependentLayers.add(r2.fqid);
              let n2 = this._order.length;
              if (i2) {
                const t3 = this._order.indexOf(i2);
                if (-1 === t3) return void this.fire(new e.z(new Error(`Layer with id "${i2}" does not exist on this map.`)));
                r2.slot === this._layers[i2].slot ? n2 = t3 : e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
              }
              this._order.splice(n2, 0, s2), this._layerOrderChanged = true, this._layers[s2] = r2;
              const a2 = this.getOwnLayerSourceCache(r2), l2 = !!this.directionalLight && this.directionalLight.shadowsEnabled();
              a2 && r2.canCastShadows() && l2 && (a2.castsShadows = true);
              const c2 = this._changes.getRemovedLayer(r2);
              if (c2 && r2.source && a2 && "custom" !== r2.type) {
                this._changes.discardLayerRemoval(r2);
                const t3 = e.C(r2.source, r2.scope);
                c2.type !== r2.type ? this._changes.updateSourceCache(t3, "clear") : (this._changes.updateSourceCache(t3, "reload"), a2.pause());
              }
              this._updateLayer(r2), r2.onAdd && r2.onAdd(this.map), r2.scope = this.scope, this.mergeLayers();
            }
            moveLayer(t2, i2) {
              this._checkLoaded();
              const o2 = this._checkLayer(t2);
              if (!o2) return;
              if (t2 === i2) return;
              const s2 = this._order.indexOf(t2);
              this._order.splice(s2, 1);
              let r2 = this._order.length;
              if (i2) {
                const t3 = this._order.indexOf(i2);
                if (-1 === t3) return void this.fire(new e.z(new Error(`Layer with id "${i2}" does not exist on this map.`)));
                o2.slot === this._layers[i2].slot ? r2 = t3 : e.w(`Layer with id "${i2}" has a different slot. Layers can only be rearranged within the same slot.`);
              }
              this._order.splice(r2, 0, t2), this._changes.setDirty(), this._layerOrderChanged = true, this.mergeLayers();
            }
            removeLayer(e2) {
              this._checkLoaded();
              const t2 = this._checkLayer(e2);
              if (!t2) return;
              t2.setEventedParent(null);
              const i2 = this._order.indexOf(e2);
              this._order.splice(i2, 1), delete this._layers[e2], this._changes.setDirty(), this._layerOrderChanged = true, this._configDependentLayers.delete(t2.fqid), this._changes.removeLayer(t2);
              const o2 = this.getOwnLayerSourceCache(t2);
              if (o2 && o2.castsShadows) {
                let e3 = false;
                for (const i3 in this._layers) if (this._layers[i3].source === t2.source && this._layers[i3].canCastShadows()) {
                  e3 = true;
                  break;
                }
                o2.castsShadows = e3;
              }
              t2.onRemove && t2.onRemove(this.map), this.mergeLayers();
            }
            getOwnLayer(e2) {
              return this._layers[e2];
            }
            hasLayer(e2) {
              return e2 in this._mergedLayers;
            }
            hasLayerType(e2) {
              for (const t2 in this._layers) if (this._layers[t2].type === e2) return true;
              return false;
            }
            setLayerZoomRange(e2, t2, i2) {
              this._checkLoaded();
              const o2 = this._checkLayer(e2);
              o2 && (o2.minzoom === t2 && o2.maxzoom === i2 || (null != t2 && (o2.minzoom = t2), null != i2 && (o2.maxzoom = i2), this._updateLayer(o2)));
            }
            getSlots() {
              return this._checkLoaded(), this._mergedSlots;
            }
            setSlot(e2, t2) {
              this._checkLoaded();
              const i2 = this._checkLayer(e2);
              i2 && i2.slot !== t2 && (i2.slot = t2, this._updateLayer(i2));
            }
            setFilter(t2, i2, o2 = {}) {
              this._checkLoaded();
              const s2 = this._checkLayer(t2);
              if (s2 && !e.bv(s2.filter, i2)) return null == i2 ? (s2.filter = void 0, void this._updateLayer(s2)) : void (this._validate(Se, `layers.${s2.id}.filter`, i2, { layerType: s2.type }, o2) || (s2.filter = e.d7(i2), this._updateLayer(s2)));
            }
            getFilter(t2) {
              const i2 = this._checkLayer(t2);
              if (i2) return e.d7(i2.filter);
            }
            setLayoutProperty(t2, i2, o2, s2 = {}) {
              this._checkLoaded();
              const r2 = this._checkLayer(t2);
              if (r2 && !e.bv(r2.getLayoutProperty(i2), o2)) {
                if (null != o2 && (!s2 || false !== s2.validate) && vo(r2, Ce.call(me, { key: `layers.${t2}.layout.${i2}`, layerType: r2.type, objectKey: i2, value: o2, styleSpec: e.a5, style: { glyphs: true, sprite: true } }))) return;
                r2.setLayoutProperty(i2, o2), 0 !== r2.configDependencies.size && this._configDependentLayers.add(r2.fqid), this._updateLayer(r2);
              }
            }
            getLayoutProperty(e2, t2) {
              const i2 = this._checkLayer(e2);
              if (i2) return i2.getLayoutProperty(t2);
            }
            setPaintProperty(t2, i2, o2, s2 = {}) {
              this._checkLoaded();
              const r2 = this._checkLayer(t2);
              if (!r2) return;
              if (e.bv(r2.getPaintProperty(i2), o2)) return;
              if (null != o2 && (!s2 || false !== s2.validate) && vo(r2, Ie.call(me, { key: `layers.${t2}.paint.${i2}`, layerType: r2.type, objectKey: i2, value: o2, styleSpec: e.a5 }))) return;
              const n2 = r2.setPaintProperty(i2, o2);
              0 !== r2.configDependencies.size && this._configDependentLayers.add(r2.fqid), n2 && this._updateLayer(r2), this._changes.updatePaintProperties(r2);
            }
            getPaintProperty(e2, t2) {
              const i2 = this._checkLayer(e2);
              if (i2) return i2.getPaintProperty(t2);
            }
            setFeatureState(t2, i2) {
              if (this._checkLoaded(), "target" in t2) {
                if ("featuresetId" in t2.target) {
                  const { featuresetId: e2, importId: o3 } = t2.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e2);
                  for (const { source: e3, sourceLayer: o4 } of r3) s3.setFeatureState({ id: t2.id, source: e3, sourceLayer: o4 }, i2);
                } else if ("layerId" in t2.target) {
                  const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                  this.setFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer }, i2);
                }
                return;
              }
              const o2 = t2.source, s2 = t2.sourceLayer, r2 = this._checkSource(o2);
              if (!r2) return;
              const n2 = r2.type;
              if ("geojson" === n2 && s2) return void this.fire(new e.z(new Error("GeoJSON sources cannot have a sourceLayer parameter.")));
              if ("vector" === n2 && !s2) return void this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
              void 0 === t2.id && this.fire(new e.z(new Error("The feature id parameter must be provided.")));
              const a2 = this.getOwnSourceCaches(o2);
              for (const e2 of a2) e2.setFeatureState(s2, t2.id, i2);
            }
            removeFeatureState(t2, i2) {
              if (this._checkLoaded(), "target" in t2) {
                if ("featuresetId" in t2.target) {
                  const { featuresetId: e2, importId: o3 } = t2.target, s3 = this.getFragmentStyle(o3), r3 = s3.getFeaturesetLayers(e2);
                  for (const { source: e3, sourceLayer: o4 } of r3) s3.removeFeatureState({ id: t2.id, source: e3, sourceLayer: o4 }, i2);
                } else if ("layerId" in t2.target) {
                  const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                  this.removeFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer }, i2);
                }
                return;
              }
              const o2 = t2.source, s2 = this._checkSource(o2);
              if (!s2) return;
              const r2 = s2.type, n2 = "vector" === r2 ? t2.sourceLayer : void 0;
              if ("vector" === r2 && !n2) return void this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
              if (i2 && "string" != typeof t2.id && "number" != typeof t2.id) return void this.fire(new e.z(new Error("A feature id is required to remove its specific state property.")));
              const a2 = this.getOwnSourceCaches(o2);
              for (const e2 of a2) e2.removeFeatureState(n2, t2.id, i2);
            }
            getFeatureState(t2) {
              if (this._checkLoaded(), "target" in t2) {
                let i3;
                if ("featuresetId" in t2.target) {
                  const { featuresetId: o3, importId: s3 } = t2.target, r2 = this.getFragmentStyle(s3), n2 = r2.getFeaturesetLayers(o3);
                  for (const { source: o4, sourceLayer: s4 } of n2) {
                    const n3 = r2.getFeatureState({ id: t2.id, source: o4, sourceLayer: s4 });
                    if (n3 && !i3) i3 = n3;
                    else if (!e.bv(i3, n3)) return void this.fire(new e.z(new Error("The same feature id exists in multiple sources in the featureset, but their feature states are not consistent through the sources.")));
                  }
                } else if ("layerId" in t2.target) {
                  const { layerId: e2 } = t2.target, o3 = this.getLayer(e2);
                  i3 = this.getFeatureState({ id: t2.id, source: o3.source, sourceLayer: o3.sourceLayer });
                }
                return i3;
              }
              const i2 = t2.source, o2 = t2.sourceLayer, s2 = this._checkSource(i2);
              if (s2) {
                if ("vector" !== s2.type || o2) return void 0 === t2.id && this.fire(new e.z(new Error("The feature id parameter must be provided."))), this.getOwnSourceCaches(i2)[0].getFeatureState(o2, t2.id);
                this.fire(new e.z(new Error("The sourceLayer parameter must be provided for vector source types.")));
              }
            }
            setTransition(t2) {
              return this.stylesheet.transition = e.l({}, this.stylesheet.transition, t2), this.transition = this.stylesheet.transition, this;
            }
            getTransition() {
              return e.l({}, this.stylesheet.transition);
            }
            serialize() {
              this._checkLoaded();
              const t2 = this.getTerrain(), i2 = t2 && this.terrain && this.terrain.scope === this.scope ? t2 : this.stylesheet.terrain;
              return e.dd({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, fragment: this.stylesheet.fragment, iconsets: this.stylesheet.iconsets, imports: this._serializeImports(), schema: this.stylesheet.schema, camera: this.stylesheet.camera, light: this.stylesheet.light, lights: this.stylesheet.lights, terrain: i2, fog: this.stylesheet.fog, snow: this.stylesheet.snow, rain: this.stylesheet.rain, center: this.stylesheet.center, "color-theme": this.stylesheet["color-theme"], zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, projection: this.stylesheet.projection, sources: this._serializeSources(), layers: this._serializeLayers(this._order) }, (e2) => void 0 !== e2);
            }
            _updateFilteredLayers(e2) {
              for (const t2 of Object.values(this._mergedLayers)) e2(t2) && this._updateLayer(t2);
            }
            _updateLayer(t2) {
              this._changes.updateLayer(t2);
              const i2 = this.getLayerSourceCache(t2), o2 = e.C(t2.source, t2.scope), s2 = this._changes.getUpdatedSourceCaches();
              t2.source && !s2[o2] && i2 && "raster" !== i2.getSource().type && (this._changes.updateSourceCache(o2, "reload"), i2.pause()), t2.invalidateCompiledFilter();
            }
            _flattenAndSortRenderedFeatures(e2) {
              const t2 = (e3) => this._mergedLayers[e3].is3D(!!this.terrain), i2 = this.order, o2 = {}, s2 = [];
              for (let r3 = i2.length - 1; r3 >= 0; r3--) {
                const n2 = i2[r3];
                if (t2(n2)) {
                  o2[n2] = r3;
                  for (const t3 of e2) {
                    const e3 = t3[n2];
                    if (e3) for (const t4 of e3) s2.push(t4);
                  }
                }
              }
              s2.sort((e3, t3) => t3.intersectionZ - e3.intersectionZ);
              const r2 = [];
              for (let n2 = i2.length - 1; n2 >= 0; n2--) {
                const a2 = i2[n2];
                if (t2(a2)) for (let e3 = s2.length - 1; e3 >= 0; e3--) {
                  const t3 = s2[e3].feature;
                  if (t3.layer && o2[t3.layer.id] < n2) break;
                  r2.push(t3), s2.pop();
                }
                else for (const t3 of e2) {
                  const e3 = t3[a2];
                  if (e3) for (const t4 of e3) r2.push(t4.feature);
                }
              }
              return r2;
            }
            queryRenderedFeatures(t2, i2, o2) {
              let s2;
              i2 && !Array.isArray(i2) && i2.filter && (this._validate(Se, "queryRenderedFeatures.filter", i2.filter, null, i2), s2 = e.b3(i2.filter));
              const r2 = {}, n2 = (e2) => {
                if (bo.has(e2.type)) return;
                const t3 = this.getOwnLayerSourceCache(e2), i3 = r2[t3.id] = r2[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
                e2.is3D(!!this.terrain) && (i3.has3DLayers = true), i3.layers[e2.fqid] = i3.layers[e2.fqid] || { styleLayer: e2, targets: [] }, i3.layers[e2.fqid].targets.push({ filter: s2 });
              };
              if (i2 && i2.layers) {
                if (!Array.isArray(i2.layers)) return this.fire(new e.z(new Error("parameters.layers must be an Array."))), [];
                for (const t3 of i2.layers) {
                  const i3 = this._layers[t3];
                  if (!i3) return this.fire(new e.z(new Error(`The layer '${t3}' does not exist in the map's style and cannot be queried for features.`))), [];
                  n2(i3);
                }
              } else for (const e2 in this._layers) n2(this._layers[e2]);
              const a2 = this._queryRenderedFeatures(t2, r2, o2), l2 = this._flattenAndSortRenderedFeatures(a2), c2 = [];
              for (const t3 of l2) e.de(t3.layer.id) === this.scope && c2.push(t3);
              return c2;
            }
            queryRenderedFeatureset(t2, i2, o2) {
              let s2;
              i2 && !Array.isArray(i2) && i2.filter && (this._validate(Se, "queryRenderedFeatures.filter", i2.filter, null, i2), s2 = e.b3(i2.filter));
              const r2 = "mock", n2 = [];
              if (i2 && i2.target) n2.push(Object.assign({}, i2, { targetId: r2, filter: s2 }));
              else {
                const e2 = this.getFeaturesetDescriptors();
                for (const t3 of e2) n2.push({ targetId: r2, filter: s2, target: t3 });
                for (const { style: e3 } of this.fragments) {
                  const t3 = e3.getFeaturesetDescriptors();
                  for (const e4 of t3) n2.push({ targetId: r2, filter: s2, target: e4 });
                }
              }
              const a2 = this.queryRenderedTargets(t2, n2, o2), l2 = [], c2 = /* @__PURE__ */ new Set();
              for (const t3 of a2) for (const i3 of t3.variants[r2]) lt(i3, t3, c2) || l2.push(new e.df(t3, i3));
              return l2;
            }
            queryRenderedTargets(t2, i2, o2) {
              const s2 = {}, r2 = (e2, t3, i3, o3) => {
                const r3 = s2[t3.id] = s2[t3.id] || { sourceCache: t3, layers: {}, has3DLayers: false };
                if (r3.layers[e2.fqid] = r3.layers[e2.fqid] || { styleLayer: e2, targets: [] }, e2.is3D(!!this.terrain) && (r3.has3DLayers = true), !o3) return i3.uniqueFeatureID = false, void r3.layers[e2.fqid].targets.push(i3);
                r3.layers[e2.fqid].targets.push(Object.assign({}, i3, { namespace: o3.namespace, properties: o3.properties, uniqueFeatureID: o3.uniqueFeatureID }));
              };
              for (const t3 of i2) if ("featuresetId" in t3.target) {
                const { featuresetId: i3, importId: o3 } = t3.target, s3 = this.getFragmentStyle(o3);
                if (!s3 || !s3._featuresetSelectors) continue;
                const n3 = s3._featuresetSelectors[i3];
                if (!n3) {
                  this.fire(new e.z(new Error(`The featureset '${i3}' does not exist in the map's style and cannot be queried for features.`)));
                  continue;
                }
                for (const e2 of n3) {
                  const i4 = s3.getOwnLayer(e2.layerId);
                  i4 && !bo.has(i4.type) && r2(i4, s3.getOwnLayerSourceCache(i4), t3, e2);
                }
              } else if ("layerId" in t3.target) {
                const { layerId: e2 } = t3.target, i3 = this.getLayer(e2);
                if (!i3 || bo.has(i3.type)) continue;
                r2(i3, this.getLayerSourceCache(i3), t3);
              }
              const n2 = this._queryRenderedFeatures(t2, s2, o2);
              return this._flattenAndSortRenderedFeatures(n2);
            }
            _queryRenderedFeatures(e2, t2, i2) {
              const o2 = [], s2 = !!this.map._showQueryGeometry, r2 = Xe.createFromScreenPoints(e2, i2);
              for (const e3 in t2) {
                const n2 = ct(r2, t2[e3], this._availableImages, i2, s2);
                Object.keys(n2).length && o2.push(n2);
              }
              if (this.placement) for (const e3 in t2) {
                if (!t2[e3].sourceCache._onlySymbols) continue;
                const i3 = ht(r2.screenGeometry, t2[e3], this._availableImages, this.placement.collisionIndex, this.placement.retainedQueryData);
                Object.keys(i3).length && o2.push(i3);
              }
              return o2;
            }
            querySourceFeatures(e2, t2) {
              const i2 = t2 && t2.filter;
              i2 && this._validate(Se, "querySourceFeatures.filter", i2, null, t2);
              let o2 = [];
              const s2 = this.getOwnSourceCaches(e2);
              for (const e3 of s2) o2 = o2.concat(dt(e3, t2));
              return o2;
            }
            addSourceType(e2, t2, i2) {
              return Eo.getSourceType(e2) ? i2(new Error(`A source type called "${e2}" already exists.`)) : (Eo.setSourceType(e2, t2), t2.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: e2, url: t2.workerSourceURL }, i2) : i2(null, null));
            }
            getFlatLight() {
              return this.light.getLight();
            }
            setFlatLight(t2, i2, o2 = {}) {
              this._checkLoaded();
              const s2 = this.light.getLight();
              let r2 = false;
              for (const i3 in t2) if (!e.bv(t2[i3], s2[i3])) {
                r2 = true;
                break;
              }
              if (!r2) return;
              const n2 = this._getTransitionParameters();
              this.light.setLight(t2, i2, o2), this.light.updateTransitions(n2);
            }
            getTerrain() {
              return this.terrain && 1 === this.terrain.drapeRenderMode ? this.terrain.get() : null;
            }
            setTerrainForDraping() {
              this.setTerrain({ source: "", exaggeration: 0 }, 0);
            }
            checkCanvasFingerprintNoise() {
              void 0 === this.disableElevatedTerrain && (this.disableElevatedTerrain = e.q.hasCanvasFingerprintNoise(), this.disableElevatedTerrain && e.w("Terrain and hillshade are disabled because of Canvas2D limitations when fingerprinting protection is enabled (e.g. in private browsing mode)."));
            }
            setTerrain(t2, i2 = 1) {
              if (this._checkLoaded(), !t2) return this.terrainSetForDrapingOnly() || (delete this.terrain, this.map.transform.projection.requiresDraping && this.setTerrainForDraping()), 0 === i2 && delete this.terrain, null === t2 ? this.stylesheet.terrain = null : delete this.stylesheet.terrain, this._force3DLayerUpdate(), void (this._markersNeedUpdate = true);
              this.checkCanvasFingerprintNoise();
              let o2 = t2;
              const s2 = null == t2.source;
              if (1 === i2) {
                if (this.disableElevatedTerrain) return;
                if ("object" == typeof o2.source) {
                  const t4 = "terrain-dem-src";
                  this.addSource(t4, o2.source), o2 = e.d7(o2), o2 = e.l(o2, { source: t4 });
                }
                const t3 = e.l({}, o2), i3 = {};
                if (this.terrain && s2) {
                  t3.source = this.terrain.get().source;
                  const e2 = this.terrain ? this.getFragmentStyle(this.terrain.scope) : null;
                  e2 && (i3.style = e2.serialize());
                }
                if (this._validate(xe, "terrain", t3, i3)) return;
              }
              if (!this.terrain || this.terrain.scope !== this.scope && !s2 || this.terrain && i2 !== this.terrain.drapeRenderMode) {
                if (!o2) return;
                this._createTerrain(o2, i2), this.fire(new e.A("data", { dataType: "style" }));
              } else {
                const i3 = this.terrain, s3 = i3.get();
                for (const t3 of Object.keys(e.a5.terrain)) !o2.hasOwnProperty(t3) && e.a5.terrain[t3].default && (o2[t3] = e.a5.terrain[t3].default);
                for (const o3 in t2) if (!e.bv(t2[o3], s3[o3])) {
                  i3.set(t2, this.options), this.stylesheet.terrain = t2;
                  const o4 = this._getTransitionParameters({ duration: 0 });
                  i3.updateTransitions(o4), this.fire(new e.A("data", { dataType: "style" }));
                  break;
                }
              }
              this.mergeTerrain(), this.updateDrapeFirstLayers(), this._markersNeedUpdate = true;
            }
            _createFog(e2) {
              const t2 = this.fog = new je(e2, this.map.transform, this.scope, this.options);
              this.stylesheet.fog = t2.get();
              const i2 = this._getTransitionParameters({ duration: 0 });
              t2.updateTransitions(i2);
            }
            _createSnow(e2) {
              const t2 = this.snow = new He(e2, this.map.transform, this.scope, this.options);
              this.stylesheet.snow = t2.get();
              const i2 = this._getTransitionParameters({ duration: 0 });
              t2.updateTransitions(i2);
            }
            _createRain(e2) {
              const t2 = this.rain = new We(e2, this.map.transform, this.scope, this.options);
              this.stylesheet.rain = t2.get();
              const i2 = this._getTransitionParameters({ duration: 0 });
              t2.updateTransitions(i2);
            }
            _updateMarkersOpacity() {
              0 !== this.map._markers.length && this.map._requestDomTask(() => {
                for (const e2 of this.map._markers) e2._evaluateOpacity();
              });
            }
            getFog() {
              return this.fog ? this.fog.get() : null;
            }
            setFog(t2) {
              if (this._checkLoaded(), !t2) return delete this.fog, delete this.stylesheet.fog, void (this._markersNeedUpdate = true);
              if (this.fog) {
                const i2 = this.fog;
                if (!e.bv(i2.get(), t2)) {
                  i2.set(t2, this.options), this.stylesheet.fog = i2.get();
                  const e2 = this._getTransitionParameters({ duration: 0 });
                  i2.updateTransitions(e2);
                }
              } else this._createFog(t2);
              this._markersNeedUpdate = true;
            }
            getSnow() {
              return this.snow ? this.snow.get() : null;
            }
            setSnow(t2) {
              if (this._checkLoaded(), !t2) return delete this.snow, void delete this.stylesheet.snow;
              if (this.snow) {
                const i2 = this.snow;
                if (!e.bv(i2.get(), t2)) {
                  i2.set(t2, this.options), this.stylesheet.snow = i2.get();
                  const e2 = this._getTransitionParameters({ duration: 0 });
                  i2.updateTransitions(e2);
                }
              } else this._createSnow(t2);
              this._markersNeedUpdate = true;
            }
            getRain() {
              return this.rain ? this.rain.get() : null;
            }
            setRain(t2) {
              if (this._checkLoaded(), !t2) return delete this.rain, void delete this.stylesheet.rain;
              if (this.rain) {
                const i2 = this.rain;
                if (!e.bv(i2.get(), t2)) {
                  i2.set(t2, this.options), this.stylesheet.rain = i2.get();
                  const e2 = this._getTransitionParameters({ duration: 0 });
                  i2.updateTransitions(e2);
                }
              } else this._createRain(t2);
              this._markersNeedUpdate = true;
            }
            _reloadColorTheme() {
              const t2 = () => {
                for (const e2 in this._layers) this._layers[e2].lut = this._styleColorTheme.lut;
                for (const e2 in this._sourceCaches) this._sourceCaches[e2].clearTiles();
              }, i2 = this._styleColorTheme.colorThemeOverride ? this._styleColorTheme.colorThemeOverride : this._styleColorTheme.colorTheme;
              if (!i2) return this._styleColorTheme.lut = null, void t2();
              const o2 = this._evaluateColorThemeData(i2);
              this._loadColorTheme(o2).then(() => {
                this.fire(new e.A("colorthemeset")), t2();
              }).catch((t3) => {
                e.w(`Couldn't set color theme: ${t3}`);
              });
            }
            setColorTheme(t2) {
              this._checkLoaded(), this._styleColorTheme.colorThemeOverride && e.w("Note: setColorTheme is called on a style with a color-theme override, the passed color-theme won't be visible."), this._styleColorTheme.colorTheme = t2, this._reloadColorTheme();
            }
            setImportColorTheme(e2, t2) {
              const i2 = this.getFragmentStyle(e2);
              i2 && (i2._styleColorTheme.colorThemeOverride = t2, i2._reloadColorTheme());
            }
            _getTransitionParameters(t2) {
              return { now: e.q.now(), transition: e.l(this.transition, t2) };
            }
            updateDrapeFirstLayers() {
              if (!this.terrain) return;
              const e2 = [], t2 = [];
              for (const i2 of this._mergedOrder) this.isLayerDraped(this._mergedLayers[i2]) ? e2.push(i2) : t2.push(i2);
              this._drapedFirstOrder = [], this._drapedFirstOrder.push(...e2), this._drapedFirstOrder.push(...t2);
            }
            _createTerrain(e2, t2) {
              const i2 = this.terrain = new ze(e2, t2, this.scope, this.options);
              1 === t2 && (this.stylesheet.terrain = e2), this.mergeTerrain(), this.updateDrapeFirstLayers(), this._force3DLayerUpdate();
              const o2 = this._getTransitionParameters({ duration: 0 });
              i2.updateTransitions(o2);
            }
            _force3DLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "fill-extrusion" === t2.type && this._updateLayer(t2);
              }
            }
            _forceSymbolLayerUpdate() {
              for (const e2 in this._layers) {
                const t2 = this._layers[e2];
                "symbol" === t2.type && this._updateLayer(t2);
              }
            }
            _validate(t2, i2, o2, s2, r2 = {}) {
              if (r2 && false === r2.validate) return false;
              const n2 = e.l({}, this.serialize());
              return vo(this, t2.call(me, e.l({ key: i2, style: n2, value: o2, styleSpec: e.a5 }, s2)));
            }
            _remove() {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), e.dg.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const e2 in this._mergedLayers) this._mergedLayers[e2].setEventedParent(null);
              for (const e2 in this._mergedSourceCaches) this._mergedSourceCaches[e2].clearTiles(), this._mergedSourceCaches[e2].setEventedParent(null);
              this.imageManager.removeScope(this.scope), this.setEventedParent(null), delete this.fog, delete this.snow, delete this.rain, delete this.terrain, delete this.ambientLight, delete this.directionalLight, this.isRootStyle() && (this.imageManager.setEventedParent(null), this.modelManager.setEventedParent(null), this.modelManager.destroy(), this.dispatcher.remove());
            }
            clearSource(e2) {
              const t2 = this.getSourceCaches(e2);
              for (const e3 of t2) e3.clearTiles();
            }
            clearSources() {
              for (const e2 in this._mergedSourceCaches) this._mergedSourceCaches[e2].clearTiles();
            }
            reloadSource(e2) {
              const t2 = this.getSourceCaches(e2);
              for (const e3 of t2) e3.resume(), e3.reload();
            }
            reloadSources() {
              for (const e2 of this.getSources()) e2.reload && e2.reload();
            }
            reloadModels() {
              this.modelManager.reloadModels(""), this.forEachFragmentStyle((e2) => {
                e2.modelManager.reloadModels(e2.scope);
              });
            }
            updateSources(e2) {
              let t2;
              this.directionalLight && (t2 = no(this.directionalLight));
              const i2 = /* @__PURE__ */ new Set();
              for (const e3 in this._mergedLayers) {
                const t3 = this._mergedLayers[e3];
                t3.hasElevation() && !i2.has(t3.source) && i2.add(t3.source);
              }
              for (const o2 in this._mergedSourceCaches) {
                const s2 = this._mergedSourceCaches[o2], r2 = i2.has(s2._source.id);
                s2.update(e2, void 0, void 0, t2, r2);
              }
            }
            _generateCollisionBoxes() {
              for (const e2 in this._sourceCaches) {
                const t2 = this._sourceCaches[e2];
                t2.resume(), t2.reload();
              }
            }
            _updatePlacement(t2, i2, o2, s2, r2, n2, a2 = false) {
              let l2 = false, c2 = false;
              const h2 = {}, d2 = {};
              for (const t3 of this._mergedOrder) {
                const o3 = this._mergedLayers[t3];
                if ("symbol" !== o3.type) continue;
                const s3 = e.C(o3.source, o3.scope);
                let r3 = h2[s3];
                if (!r3) {
                  const e2 = this.getLayerSourceCache(o3);
                  if (!e2) continue;
                  const t4 = e2.getRenderableIds(true).map((t5) => e2.getTileByID(t5));
                  d2[s3] = t4.slice(), r3 = h2[s3] = t4.sort((e3, t5) => t5.tileID.overscaledZ - e3.tileID.overscaledZ || (e3.tileID.isLessThan(t5.tileID) ? -1 : 1));
                }
                const n3 = this.crossTileSymbolIndex.addLayer(o3, r3, i2.center.lng, i2.projection);
                l2 = l2 || n3;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._mergedOrder), a2 = a2 || this._layerOrderChanged || 0 === s2, this._layerOrderChanged && this.fire(new e.A("neworder")), (a2 || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(e.q.now(), i2.zoom)) && (this.pauseablePlacement = new Li(i2, this._mergedOrder, a2, o2, s2, r2, this.placement, this.fog && i2.projection.supportsFog ? this.fog.state : null, this._buildingIndex), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._mergedOrder, this._mergedLayers, h2, d2, this.map.painter.scaleFactor), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(e.q.now()), c2 = true), l2 && this.pauseablePlacement.placement.setStale()), c2 || l2) {
                this._buildingIndex.onNewFrame(i2.zoom);
                for (let t3 = 0; t3 < this._mergedOrder.length; t3++) {
                  const i3 = this._mergedLayers[this._mergedOrder[t3]];
                  if ("symbol" !== i3.type) continue;
                  const o3 = this.isLayerClipped(i3);
                  this.placement.updateLayerOpacities(i3, h2[e.C(i3.source, i3.scope)], t3, o3 ? n2 : null);
                }
              }
              return { needsRerender: !this.pauseablePlacement.isDone() || this.placement.hasTransitions(e.q.now()) };
            }
            _releaseSymbolFadeTiles() {
              for (const e2 in this._sourceCaches) this._sourceCaches[e2].releaseSymbolFadeTiles();
            }
            addImport(t2, i2) {
              this._checkLoaded();
              const o2 = this.stylesheet.imports = this.stylesheet.imports || [];
              if (-1 !== o2.findIndex(({ id: e2 }) => e2 === t2.id)) return void this.fire(new e.z(new Error(`Import with id '${t2.id}' already exists in the map's style.`)));
              if (!i2) return o2.push(t2), this._loadImports([t2], true);
              const s2 = o2.findIndex(({ id: e2 }) => e2 === i2);
              return -1 === s2 && this.fire(new e.z(new Error(`Import with id "${i2}" does not exist on this map.`))), this.stylesheet.imports = o2.slice(0, s2).concat(t2).concat(o2.slice(s2)), this._loadImports([t2], true, i2);
            }
            updateImport(t2, i2) {
              this._checkLoaded();
              const o2 = this.stylesheet.imports || [], s2 = this.getImportIndex(t2);
              return -1 === s2 ? this : "string" == typeof i2 ? (this.setImportUrl(t2, i2), this) : (i2.url && i2.url !== o2[s2].url && this.setImportUrl(t2, i2.url), e.bv(i2.config, o2[s2].config) || this.setImportConfig(t2, i2.config, i2.data.schema), e.bv(i2.data, o2[s2].data) || this.setImportData(t2, i2.data), this);
            }
            moveImport(e2, t2) {
              this._checkLoaded();
              let i2 = this.stylesheet.imports || [];
              const o2 = this.getImportIndex(e2);
              if (-1 === o2) return this;
              const s2 = this.getImportIndex(t2);
              if (-1 === s2) return this;
              const r2 = i2[o2], n2 = this.fragments[o2];
              return i2 = i2.filter(({ id: t3 }) => t3 !== e2), this.fragments = this.fragments.filter(({ id: t3 }) => t3 !== e2), this.stylesheet.imports = i2.slice(0, s2).concat(r2).concat(i2.slice(s2)), this.fragments = this.fragments.slice(0, s2).concat(n2).concat(this.fragments.slice(s2)), this.mergeLayers(), this;
            }
            setImportUrl(e2, t2) {
              this._checkLoaded();
              const i2 = this.stylesheet.imports || [], o2 = this.getImportIndex(e2);
              if (-1 === o2) return this;
              i2[o2].url = t2;
              const s2 = this.fragments[o2];
              return s2.style = this._createFragmentStyle(i2[o2]), s2.style.on("style.import.load", () => this.mergeAll()), s2.style.loadURL(t2), this;
            }
            setImportData(e2, t2) {
              this._checkLoaded();
              const i2 = this.getImportIndex(e2), o2 = this.stylesheet.imports || [];
              return -1 === i2 ? this : t2 ? (this.fragments[i2].style.setState(t2), this._reloadImports(), this) : (delete o2[i2].data, this.setImportUrl(e2, o2[i2].url));
            }
            setImportConfig(e2, t2, i2) {
              this._checkLoaded();
              const o2 = this.getImportIndex(e2), s2 = this.stylesheet.imports || [];
              if (-1 === o2) return this;
              t2 ? s2[o2].config = t2 : delete s2[o2].config;
              const r2 = this.fragments[o2];
              i2 && r2.style.stylesheet && (r2.style.stylesheet.schema = i2);
              const n2 = r2.style.stylesheet && r2.style.stylesheet.schema;
              return r2.config = t2, r2.style.updateConfig(t2, n2), this.updateConfigDependencies(), this;
            }
            removeImport(e2) {
              this._checkLoaded();
              const t2 = this.stylesheet.imports || [], i2 = this.getImportIndex(e2);
              -1 !== i2 && (t2.splice(i2, 1), this.fragments[i2].style._remove(), this.fragments.splice(i2, 1), this._reloadImports());
            }
            getImportIndex(t2) {
              const i2 = (this.stylesheet.imports || []).findIndex((e2) => e2.id === t2);
              return -1 === i2 && this.fire(new e.z(new Error(`Import '${t2}' does not exist in the map's style and cannot be updated.`))), i2;
            }
            getLayer(e2) {
              return this._mergedLayers[e2];
            }
            getSources() {
              const e2 = [];
              for (const t2 in this._mergedOtherSourceCaches) {
                const i2 = this._mergedOtherSourceCaches[t2];
                i2 && e2.push(i2.getSource());
              }
              return e2;
            }
            getSource(e2, t2) {
              const i2 = this.getSourceCache(e2, t2);
              return i2 && i2.getSource();
            }
            getLayerSource(e2) {
              const t2 = this.getLayerSourceCache(e2);
              return t2 && t2.getSource();
            }
            getSourceCache(t2, i2) {
              const o2 = e.C(t2, i2);
              return this._mergedOtherSourceCaches[o2];
            }
            getLayerSourceCache(t2) {
              const i2 = e.C(t2.source, t2.scope);
              return "symbol" === t2.type ? this._mergedSymbolSourceCaches[i2] : this._mergedOtherSourceCaches[i2];
            }
            getSourceCaches(e2) {
              if (null == e2) return Object.values(this._mergedSourceCaches);
              const t2 = [];
              return this._mergedOtherSourceCaches[e2] && t2.push(this._mergedOtherSourceCaches[e2]), this._mergedSymbolSourceCaches[e2] && t2.push(this._mergedSymbolSourceCaches[e2]), t2;
            }
            updateSourceCaches() {
              const e2 = this._changes.getUpdatedSourceCaches();
              for (const t2 in e2) {
                const i2 = e2[t2];
                "reload" === i2 ? this.reloadSource(t2) : "clear" === i2 && this.clearSource(t2);
              }
            }
            updateLayers(e2) {
              const t2 = this._changes.getUpdatedPaintProperties();
              for (const i2 of t2) {
                const t3 = this.getLayer(i2);
                t3 && t3.updateTransitions(e2);
              }
            }
            getGlyphsUrl() {
              return this.stylesheet.glyphs;
            }
            setGlyphsUrl(e2) {
              this.stylesheet.glyphs = e2, this.glyphManager.setURL(e2, this.scope);
            }
            getImages(t2, i2, o2) {
              this.imageManager.getImages(i2.images, i2.scope, o2), this._updateTilesForChangedImages();
              const s2 = (t3) => {
                if (t3) {
                  const o3 = i2.images.map((t4) => e.I.toString(t4));
                  t3.setDependencies(i2.tileID.key, i2.type, o3);
                }
              }, r2 = e.C(i2.source, i2.scope);
              s2(this._mergedOtherSourceCaches[r2]), s2(this._mergedSymbolSourceCaches[r2]);
            }
            rasterizeImages(e2, t2, i2) {
              this.imageManager.rasterizeImages(t2, i2);
            }
            getGlyphs(e2, t2, i2) {
              this.glyphManager.getGlyphs(t2.stacks, t2.scope, i2);
            }
            getResource(t2, i2, o2) {
              return e.dh(i2, o2);
            }
            getOwnSourceCache(e2) {
              return this._otherSourceCaches[e2];
            }
            getOwnLayerSourceCache(e2) {
              return "symbol" === e2.type ? this._symbolSourceCaches[e2.source] : this._otherSourceCaches[e2.source];
            }
            getOwnSourceCaches(e2) {
              const t2 = [];
              return this._otherSourceCaches[e2] && t2.push(this._otherSourceCaches[e2]), this._symbolSourceCaches[e2] && t2.push(this._symbolSourceCaches[e2]), t2;
            }
            _isSourceCacheLoaded(t2) {
              const i2 = this.getOwnSourceCaches(t2);
              return 0 === i2.length ? (this.fire(new e.z(new Error(`There is no source with ID '${t2}'`))), false) : i2.every((e2) => e2.loaded());
            }
            has3DLayers() {
              return this._has3DLayers;
            }
            hasSymbolLayers() {
              return this._hasSymbolLayers;
            }
            hasCircleLayers() {
              return this._hasCircleLayers;
            }
            isLayerClipped(e2, t2) {
              if (!this._clipLayerPresent && "fill-extrusion" !== e2.type) return false;
              const i2 = "fill-extrusion" === e2.type && "building" === e2.sourceLayer;
              if (e2.is3D(!!this.terrain)) {
                if (i2 || t2 && "batched-model" === t2.type) return true;
                if ("model" === e2.type) return true;
              } else if ("symbol" === e2.type) return true;
              return false;
            }
            _clearWorkerCaches() {
              this.dispatcher.broadcast("clearCaches");
            }
            destroy() {
              this._clearWorkerCaches(), this.fragments.forEach((e2) => {
                e2.style._remove();
              }), this.terrainSetForDrapingOnly() && (delete this.terrain, delete this.stylesheet.terrain);
            }
          }
          Eo.getSourceType = function(e2) {
            return rt[e2];
          }, Eo.setSourceType = function(e2, t2) {
            rt[e2] = t2;
          }, Eo.registerForPluginStateChange = e.c$;
          var So = "\n#define EPSILON 0.0000001\n#define PI 3.141592653589793\n#ifdef RENDER_CUTOFF\nfloat cutoff_opacity(vec4 cutoff_params,float depth) {float near=cutoff_params.x;float far=cutoff_params.y;float cutoffStart=cutoff_params.z;float cutoffEnd=cutoff_params.w;float linearDepth=(depth-near)/(far-near);return clamp((linearDepth-cutoffStart)/(cutoffEnd-cutoffStart),0.0,1.0);}\n#endif", Io = "\nout vec4 glFragColor;highp float unpack_depth(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}highp vec4 pack_depth(highp float ndc_z) {highp float depth=ndc_z*0.5+0.5;const highp vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);const highp vec4 bit_mask =vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);highp vec4 res=fract(depth*bit_shift);res-=res.xxyz*bit_mask;return res;}\n#ifdef INDICATOR_CUTOUT\nuniform vec3 u_indicator_cutout_centers;uniform vec4 u_indicator_cutout_params;\n#endif\nvec4 applyCutout(vec4 color,float height) {\n#ifdef INDICATOR_CUTOUT\nfloat verticalFadeRange=u_indicator_cutout_centers.z*0.25;float holeMinOpacity=mix(1.0,u_indicator_cutout_params.x,smoothstep(u_indicator_cutout_centers.z,u_indicator_cutout_centers.z+verticalFadeRange,height));float holeRadius=max(u_indicator_cutout_params.y,0.0);float holeAspectRatio=u_indicator_cutout_params.z;float fadeStart=u_indicator_cutout_params.w;float distA=distance(vec2(gl_FragCoord.x,gl_FragCoord.y*holeAspectRatio),vec2(u_indicator_cutout_centers[0],u_indicator_cutout_centers[1]*holeAspectRatio));return color*min(smoothstep(fadeStart,holeRadius,distA)+holeMinOpacity,1.0);\n#else\nreturn color;\n#endif\n}\n#ifdef DEBUG_WIREFRAME\n#define HANDLE_WIREFRAME_DEBUG \\\nglFragColor=vec4(0.7,0.0,0.0,0.7); \\\ngl_FragDepth=gl_FragCoord.z-0.0001;\n#else\n#define HANDLE_WIREFRAME_DEBUG\n#endif\n#ifdef RENDER_CUTOFF\nuniform highp vec4 u_cutoff_params;in float v_cutoff_opacity;\n#endif\nvec4 textureLodCustom(sampler2D image,highp vec2 pos,highp vec2 lod_coord) {highp vec2 size=vec2(textureSize(image,0));highp vec2 dx=dFdx(lod_coord.xy*size);highp vec2 dy=dFdy(lod_coord.xy*size);highp float delta_max_sqr=max(dot(dx,dx),dot(dy,dy));highp float lod=0.5*log2(delta_max_sqr);return textureLod(image,pos,lod);}vec4 applyLUT(highp sampler3D lut,vec4 col) {vec3 size=vec3(textureSize(lut,0));vec3 uvw=(col.rbg*float(size-1.0)+0.5)/size;return vec4(texture(lut,uvw).rgb,col.a);}vec3 applyLUT(highp sampler3D lut,vec3 col) {return applyLUT(lut,vec4(col,1.0)).rgb;}", Co = "\n#define EXTENT 8192.0\n#define RAD_TO_DEG 180.0/PI\n#define DEG_TO_RAD PI/180.0\n#define GLOBE_RADIUS EXTENT/PI/2.0\nfloat wrap(float n,float min,float max) {float d=max-min;float w=mod(mod(n-min,d)+d,d)+min;return (w==min) ? max : w;}\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 mercator_tile_position(mat4 matrix,vec2 tile_anchor,vec3 tile_id,vec2 mercator_center) {\n#ifndef PROJECTED_POS_ON_VIEWPORT\nfloat tiles=tile_id.z;vec2 mercator=(tile_anchor/EXTENT+tile_id.xy)/tiles;mercator-=mercator_center;mercator.x=wrap(mercator.x,-0.5,0.5);vec4 mercator_tile=vec4(mercator.xy*EXTENT,EXTENT/(2.0*PI),1.0);mercator_tile=matrix*mercator_tile;return mercator_tile.xyz;\n#else\nreturn vec3(0.0);\n#endif\n}vec3 mix_globe_mercator(vec3 globe,vec3 mercator,float t) {return mix(globe,mercator,t);}mat3 globe_mercator_surface_vectors(vec3 pos_normal,vec3 up_dir,float zoom_transition) {vec3 normal=zoom_transition==0.0 ? pos_normal : normalize(mix(pos_normal,up_dir,zoom_transition));vec3 xAxis=normalize(vec3(normal.z,0.0,-normal.x));vec3 yAxis=normalize(cross(normal,xAxis));return mat3(xAxis,yAxis,normal);}\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(\nunpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const vec2 units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (units_to_pixels*pos+offset)/pattern_size;}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {return get_pattern_pos(pixel_coord_upper,pixel_coord_lower,pattern_size,vec2(tile_units_to_pixels),pos);}float mercatorXfromLng(float lng) {return (180.0+lng)/360.0;}float mercatorYfromLat(float lat) {return (180.0-(RAD_TO_DEG*log(tan(PI/4.0+lat/2.0*DEG_TO_RAD))))/360.0;}vec3 latLngToECEF(vec2 latLng) {latLng=DEG_TO_RAD*latLng;float cosLat=cos(latLng[0]);float sinLat=sin(latLng[0]);float cosLng=cos(latLng[1]);float sinLng=sin(latLng[1]);float sx=cosLat*sinLng*GLOBE_RADIUS;float sy=-sinLat*GLOBE_RADIUS;float sz=cosLat*cosLng*GLOBE_RADIUS;return vec3(sx,sy,sz);}\n#ifdef RENDER_CUTOFF\nuniform vec4 u_cutoff_params;out float v_cutoff_opacity;\n#endif\nconst vec4 AWAY=vec4(-1000.0,-1000.0,-1000.0,1);const float skirtOffset=24575.0;vec3 decomposeToPosAndSkirt(vec2 posWithComposedSkirt)\n{float skirt=float(posWithComposedSkirt.x >=skirtOffset);vec2 pos=posWithComposedSkirt-vec2(skirt*skirtOffset,0.0);return vec3(pos,skirt);}", Ro = "in highp vec3 a_pos_3f;uniform lowp mat4 u_matrix;out highp vec3 v_uv;void main() {const mat3 half_neg_pi_around_x=mat3(1.0,0.0, 0.0,0.0,0.0,-1.0,0.0,1.0, 0.0);v_uv=half_neg_pi_around_x*a_pos_3f;vec4 pos=u_matrix*vec4(a_pos_3f,1.0);gl_Position=pos.xyww;}", Do = "\n#define ELEVATION_SCALE 7.0\n#define ELEVATION_OFFSET 450.0\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_tl_up;uniform vec3 u_tile_tr_up;uniform vec3 u_tile_br_up;uniform vec3 u_tile_bl_up;uniform float u_tile_up_scale;vec3 elevationVector(vec2 pos) {vec2 uv=pos/EXTENT;vec3 up=normalize(mix(\nmix(u_tile_tl_up,u_tile_tr_up,uv.xxx),mix(u_tile_bl_up,u_tile_br_up,uv.xxx),uv.yyy));return up*u_tile_up_scale;}\n#else\nvec3 elevationVector(vec2 pos) { return vec3(0,0,1); }\n#endif\n#ifdef TERRAIN\nuniform highp sampler2D u_dem;uniform highp sampler2D u_dem_prev;uniform vec2 u_dem_tl;uniform vec2 u_dem_tl_prev;uniform float u_dem_scale;uniform float u_dem_scale_prev;uniform float u_dem_size;uniform float u_dem_lerp;uniform float u_exaggeration;uniform float u_meter_to_dem;uniform mat4 u_label_plane_matrix_inv;vec4 tileUvToDemSample(vec2 uv,float dem_size,float dem_scale,vec2 dem_tl) {vec2 pos=dem_size*(uv*dem_scale+dem_tl)+1.0;vec2 f=fract(pos);return vec4((pos-f+0.5)/(dem_size+2.0),f);}float currentElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale+u_dem_tl)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale,u_dem_tl);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(dd,0)).r;float bl=texture(u_dem,pos+vec2(0,dd)).r;float br=texture(u_dem,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}float prevElevation(vec2 apos) {\n#ifdef TERRAIN_DEM_FLOAT_FORMAT\nvec2 pos=(u_dem_size*(apos/8192.0*u_dem_scale_prev+u_dem_tl_prev)+1.5)/(u_dem_size+2.0);return u_exaggeration*texture(u_dem_prev,pos).r;\n#else\nfloat dd=1.0/(u_dem_size+2.0);vec4 r=tileUvToDemSample(apos/8192.0,u_dem_size,u_dem_scale_prev,u_dem_tl_prev);vec2 pos=r.xy;vec2 f=r.zw;float tl=texture(u_dem_prev,pos).r;float tr=texture(u_dem_prev,pos+vec2(dd,0)).r;float bl=texture(u_dem_prev,pos+vec2(0,dd)).r;float br=texture(u_dem_prev,pos+vec2(dd,dd)).r;return u_exaggeration*mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);\n#endif\n}\n#ifdef TERRAIN_VERTEX_MORPHING\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nfloat nextElevation=currentElevation(apos);float prevElevation=prevElevation(apos);return mix(prevElevation,nextElevation,u_dem_lerp);}\n#else\nfloat elevation(vec2 apos) {\n#ifdef ZERO_EXAGGERATION\nreturn 0.0;\n#endif\nreturn currentElevation(apos);}\n#endif\nvec4 fourSample(vec2 pos,vec2 off) {float tl=texture(u_dem,pos).r;float tr=texture(u_dem,pos+vec2(off.x,0.0)).r;float bl=texture(u_dem,pos+vec2(0.0,off.y)).r;float br=texture(u_dem,pos+off).r;return vec4(tl,tr,bl,br);}float flatElevation(vec2 pack) {vec2 apos=floor(pack/8.0);vec2 span=10.0*(pack-apos*8.0);vec2 uvTex=(apos-vec2(1.0,1.0))/8190.0;float size=u_dem_size+2.0;float dd=1.0/size;vec2 pos=u_dem_size*(uvTex*u_dem_scale+u_dem_tl)+1.0;vec2 f=fract(pos);pos=(pos-f+0.5)*dd;vec4 h=fourSample(pos,vec2(dd));float z=mix(mix(h.x,h.y,f.x),mix(h.z,h.w,f.x),f.y);vec2 w=floor(0.5*(span*u_meter_to_dem-1.0));vec2 d=dd*w;h=fourSample(pos-d,2.0*d+vec2(dd));vec4 diff=abs(h.xzxy-h.ywzw);vec2 slope=min(vec2(0.25),u_meter_to_dem*0.5*(diff.xz+diff.yw)/(2.0*w+vec2(1.0)));vec2 fix=slope*span;float base=z+max(fix.x,fix.y);return u_exaggeration*base;}float elevationFromUint16(float word) {return u_exaggeration*(word/ELEVATION_SCALE-ELEVATION_OFFSET);}\n#else\nfloat elevation(vec2 pos) { return 0.0; }\n#endif\n#ifdef DEPTH_OCCLUSION\nuniform highp sampler2D u_depth;uniform highp vec2 u_depth_size_inv;uniform highp vec2 u_depth_range_unpack;uniform highp float u_occluder_half_size;uniform highp float u_occlusion_depth_offset;\n#ifdef DEPTH_D24\nfloat unpack_depth(float depth) {return depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}vec4 unpack_depth4(vec4 depth) {return depth*u_depth_range_unpack.x+vec4(u_depth_range_unpack.y);}\n#else\nhighp float unpack_depth_rgba(vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded(vec4 frag) {vec3 coord=frag.xyz/frag.w;\n#ifdef DEPTH_D24\nfloat depth=unpack_depth(texture(u_depth,(coord.xy+1.0)*0.5).r);\n#else\nfloat depth=unpack_depth_rgba(texture(u_depth,(coord.xy+1.0)*0.5));\n#endif\nreturn coord.z+u_occlusion_depth_offset > depth;}highp vec4 getCornerDepths(vec2 coord) {highp vec3 df=vec3(u_occluder_half_size*u_depth_size_inv,0.0);highp vec2 uv=0.5*coord.xy+0.5;\n#ifdef DEPTH_D24\nhighp vec4 depth=vec4(\ntexture(u_depth,uv-df.xz).r,texture(u_depth,uv+df.xz).r,texture(u_depth,uv-df.zy).r,texture(u_depth,uv+df.zy).r\n);depth=unpack_depth4(depth);\n#else\nhighp vec4 depth=vec4(\nunpack_depth_rgba(texture(u_depth,uv-df.xz)),unpack_depth_rgba(texture(u_depth,uv+df.xz)),unpack_depth_rgba(texture(u_depth,uv-df.zy)),unpack_depth_rgba(texture(u_depth,uv+df.zy))\n);\n#endif\nreturn depth;}highp float occlusionFadeMultiSample(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec2 uv=0.5*coord.xy+0.5;int NX=3;int NY=4;highp vec2 df=u_occluder_half_size*u_depth_size_inv;highp vec2 oneStep=2.0*u_occluder_half_size*u_depth_size_inv/vec2(NX-1,NY-1);highp float res=0.0;for (int y=0; y < NY;++y) {for (int x=0; x < NX;++x) {\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depth,uv-df+vec2(float(x)*oneStep.x,float(y)*oneStep.y)));\n#endif\nres+=1.0-clamp(300.0*(coord.z+u_occlusion_depth_offset-depth),0.0,1.0);}}res=clamp(2.0*res/float(NX*NY)-0.5,0.0,1.0);return res;}highp float occlusionFade(vec4 frag) {highp vec3 coord=frag.xyz/frag.w;highp vec4 depth=getCornerDepths(coord.xy);return dot(vec4(0.25),vec4(1.0)-clamp(300.0*(vec4(coord.z+u_occlusion_depth_offset)-depth),0.0,1.0));}\n#else\nbool isOccluded(vec4 frag) { return false; }highp float occlusionFade(vec4 frag) { return 1.0; }highp float occlusionFadeMultiSample(vec4 frag) { return 1.0; }\n#endif//DEPTH_OCCLUSION", Ao = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump mat4 u_fog_matrix;out vec3 v_fog_pos;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}vec3 fog_position(vec3 pos) {return (u_fog_matrix*vec4(pos,1.0)).xyz;}vec3 fog_position(vec2 pos) {return fog_position(vec3(pos,0.0));}float fog(vec3 pos) {float depth=length(pos);float opacity=fog_opacity(fog_range(depth));return opacity*fog_horizon_blending(pos/depth);}\n#endif", Lo = "#ifdef FOG\nuniform mediump vec4 u_fog_color;uniform mediump vec2 u_fog_range;uniform mediump float u_fog_horizon_blend;uniform mediump vec2 u_fog_vertical_limit;uniform mediump float u_fog_temporal_offset;in vec3 v_fog_pos;uniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform highp vec2 u_viewport;uniform float u_globe_transition;uniform int u_is_globe;float fog_range(float depth) {return (depth-u_fog_range[0])/(u_fog_range[1]-u_fog_range[0]);}float fog_horizon_blending(vec3 camera_dir) {float t=max(0.0,camera_dir.z/u_fog_horizon_blend);return u_fog_color.a*exp(-3.0*t*t);}float fog_opacity(float t) {const float decay=6.0;float falloff=1.0-min(1.0,exp(-decay*t));falloff*=falloff*falloff;return u_fog_color.a*min(1.0,1.00747*falloff);}float globe_glow_progress() {highp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float sdf=length(closest_point-u_globe_pos)/u_globe_radius;return sdf+PI*0.5;}float fog_opacity(vec3 pos) {float depth=length(pos);return fog_opacity(fog_range(depth));}vec3 fog_apply(vec3 color,vec3 pos,float opacity_limit) {float depth=length(pos);float opacity;if (u_is_globe==1) {float glow_progress=globe_glow_progress();float t=mix(glow_progress,depth,u_globe_transition);opacity=fog_opacity(fog_range(t));} else {opacity=fog_opacity(fog_range(depth));opacity*=fog_horizon_blending(pos/depth);}return mix(color,u_fog_color.rgb,min(opacity,opacity_limit));}vec3 fog_apply(vec3 color,vec3 pos) {return fog_apply(color,pos,1.0);}vec4 fog_apply_from_vert(vec4 color,float fog_opac) {float alpha=EPSILON+color.a;color.rgb=mix(color.rgb/alpha,u_fog_color.rgb,fog_opac)*alpha;return color;}vec3 fog_apply_sky_gradient(vec3 camera_ray,vec3 sky_color) {float horizon_blend=fog_horizon_blending(normalize(camera_ray));return mix(sky_color,u_fog_color.rgb,horizon_blend);}vec4 fog_apply_premultiplied(vec4 color,vec3 pos) {float alpha=EPSILON+color.a;color.rgb=fog_apply(color.rgb/alpha,pos)*alpha;return color;}vec4 fog_apply_premultiplied(vec4 color,vec3 pos,float heightMeters) {float verticalProgress=(u_fog_vertical_limit.x > 0.0 || u_fog_vertical_limit.y > 0.0) ? smoothstep(u_fog_vertical_limit.x,u_fog_vertical_limit.y,heightMeters) : 0.0;float opacityLimit=1.0-smoothstep(0.9,1.0,fog_opacity(pos));return mix(fog_apply_premultiplied(color,pos),color,min(verticalProgress,opacityLimit));}vec3 fog_dither(vec3 color) {return color;}vec4 fog_dither(vec4 color) {return vec4(fog_dither(color.rgb),color.a);}\n#endif", Po = "#ifdef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;const vec4 NODATA=vec4(1);ivec4 _raTexLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}vec2 _raTexLinearMix(highp vec2 fxy,highp vec4 colorMix,highp float colorOffset,highp vec4 t00,highp vec4 t10,highp vec4 t01,highp vec4 t11) {vec2 c00=t00==NODATA ? vec2(0) : vec2(colorOffset+dot(t00,colorMix),1);vec2 c10=t10==NODATA ? vec2(0) : vec2(colorOffset+dot(t10,colorMix),1);vec2 c01=t01==NODATA ? vec2(0) : vec2(colorOffset+dot(t01,colorMix),1);vec2 c11=t11==NODATA ? vec2(0) : vec2(colorOffset+dot(t11,colorMix),1);return mix(mix(c01,c11,fxy.x),mix(c00,c10,fxy.x),fxy.y);}vec2 raTexture2D_image0_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image0,c.yz,0),texelFetch(u_image0,c.xz,0),texelFetch(u_image0,c.yw,0),texelFetch(u_image0,c.xw,0)\n);}vec2 raTexture2D_image1_linear(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec2 fxy;ivec4 c=_raTexLinearCoord(texCoord,texResolution,fxy);return _raTexLinearMix(fxy,colorMix,colorOffset,texelFetch(u_image1,c.yz,0),texelFetch(u_image1,c.xz,0),texelFetch(u_image1,c.yw,0),texelFetch(u_image1,c.xw,0)\n);}vec2 raTexture2D_image0_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image0,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}vec2 raTexture2D_image1_nearest(highp vec2 texCoord,highp vec2 texResolution,highp vec4 colorMix,highp float colorOffset) {vec4 t=texelFetch(u_image1,ivec2(texCoord*texResolution),0);return t==NODATA ? vec2(0) : vec2(colorOffset+dot(t,colorMix),1);}\n#endif", zo = "#ifdef RASTER_ARRAY\nuniform sampler2D u_velocity;uniform mediump vec2 u_velocity_res;uniform mediump float u_max_speed;const vec4 NO_DATA=vec4(1);const vec2 INVALID_VELOCITY=vec2(-1);uniform highp vec2 u_uv_offset;uniform highp float u_data_offset;uniform highp vec2 u_data_scale;ivec4 rasterArrayLinearCoord(highp vec2 texCoord,highp vec2 texResolution,out highp vec2 fxy) {texCoord=texCoord*texResolution-0.5;fxy=fract(texCoord);texCoord-=fxy;return ivec4(texCoord.xxyy+vec2(1.5,0.5).xyxy);}highp vec2 lookup_velocity(highp vec2 uv) {uv=u_uv_offset.x+u_uv_offset.y*uv;highp vec2 fxy;ivec4 c=rasterArrayLinearCoord(uv,u_velocity_res,fxy);highp vec4 tl=texelFetch(u_velocity,c.yz,0);highp vec4 tr=texelFetch(u_velocity,c.xz,0);highp vec4 bl=texelFetch(u_velocity,c.yw,0);highp vec4 br=texelFetch(u_velocity,c.xw,0);if (tl==NO_DATA) {return INVALID_VELOCITY;}if (tr==NO_DATA) {return INVALID_VELOCITY;}if (bl==NO_DATA) {return INVALID_VELOCITY;}if (br==NO_DATA) {return INVALID_VELOCITY;}highp vec4 t=mix(mix(bl,br,fxy.x),mix(tl,tr,fxy.x),fxy.y);highp vec2 velocity=u_data_offset+vec2(dot(t.rg,u_data_scale),dot(t.ba,u_data_scale));velocity.y=-velocity.y;velocity/=max(u_max_speed,length(velocity));return velocity;}\n#endif\nuniform highp float u_particle_pos_scale;uniform highp vec2 u_particle_pos_offset;highp vec4 pack_pos_to_rgba(highp vec2 p) {highp vec2 v=(p+u_particle_pos_offset)/u_particle_pos_scale;highp vec4 r=vec4(v.x,fract(v.x*255.0),v.y,fract(v.y*255.0));return vec4(r.x-r.y/255.0,r.y,r.z-r.w/255.0,r.w);}highp vec2 unpack_pos_from_rgba(highp vec4 v) {v=floor(v*255.0+0.5)/255.0;highp vec2 p=vec2(v.x+(v.y/255.0),v.z+(v.w/255.0));return u_particle_pos_scale*p-u_particle_pos_offset;}", Mo = "#ifdef RENDER_SHADOWS\nuniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_normal_offset;vec3 shadow_normal_offset(vec3 normal) {float tileInMeters=u_shadow_normal_offset[0];vec3 n=vec3(-normal.xy,tileInMeters*normal.z);float dotScale=min(1.0-dot(normal,u_shadow_direction),1.0)*0.5+0.5;return n*dotScale;}vec3 shadow_normal_offset_model(vec3 normal) {vec3 transformed_normal=vec3(-normal.xy,normal.z);float NDotL=dot(normalize(transformed_normal),u_shadow_direction);float dotScale=min(1.0-NDotL,1.0)*0.5+0.5;return normal*dotScale;}float shadow_normal_offset_multiplier0() {return u_shadow_normal_offset[1];}float shadow_normal_offset_multiplier1() {return u_shadow_normal_offset[2];}\n#endif//RENDER_SHADOWS", Oo = "#ifdef RENDER_SHADOWS\n#ifdef DEPTH_TEXTURE\nuniform highp sampler2D u_shadowmap_0;uniform highp sampler2D u_shadowmap_1;\n#else\nuniform sampler2D u_shadowmap_0;uniform sampler2D u_shadowmap_1;\n#endif\nuniform float u_shadow_intensity;uniform float u_shadow_map_resolution;uniform float u_shadow_texel_size;uniform highp vec3 u_shadow_normal_offset;uniform vec2 u_fade_range;uniform mediump vec3 u_shadow_direction;uniform highp vec3 u_shadow_bias;highp float shadow_sample_1(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_1,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_1,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}highp float shadow_sample_0(highp vec2 uv,highp float compare) {highp float shadow_depth;\n#ifdef DEPTH_TEXTURE\nshadow_depth=texture(u_shadowmap_0,uv).r;\n#else\nshadow_depth=unpack_depth(texture(u_shadowmap_0,uv))*0.5+0.5;\n#endif\nreturn step(shadow_depth,compare);}float shadow_occlusion_1(highp vec4 pos,highp float bias) {highp vec2 uv=pos.xy;return shadow_sample_1(uv,pos.z-bias);}float shadow_occlusion_0(highp vec4 pos,highp float bias) {highp float compare0=pos.z-bias;\n#ifdef TEXTURE_GATHER\nhighp vec2 uv=pos.xy;highp vec4 samples=textureGather(u_shadowmap_0,uv,0);lowp vec4 stepSamples=step(samples,vec4(compare0));\n#else\nhighp vec2 uv00=pos.xy-vec2(0.5*u_shadow_texel_size);highp vec2 uv10=uv00+vec2(u_shadow_texel_size,0.0);highp vec2 uv01=uv00+vec2(0.0,u_shadow_texel_size);highp vec2 uv11=uv01+vec2(u_shadow_texel_size,0.0);lowp vec4 stepSamples=vec4(\nshadow_sample_0(uv01,compare0),shadow_sample_0(uv11,compare0),shadow_sample_0(uv10,compare0),shadow_sample_0(uv00,compare0)\n);\n#endif\nvec2 f=fract(pos.xy*u_shadow_map_resolution-vec2(0.5));lowp vec2 lerpx=mix(stepSamples.wx,stepSamples.zy,f.xx);return clamp(mix(lerpx.x,lerpx.y,f.y),0.0,1.0);}float shadow_occlusion(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,highp float bias) {\n#ifdef SHADOWS_SINGLE_CASCADE\nlight_view_pos0.xyz/=light_view_pos0.w;vec2 abs_bounds=abs(light_view_pos0.xy);if (abs_bounds.x >=1.0 || abs_bounds.y >=1.0) {return 0.0;}light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);\n#else\nlight_view_pos0.xyz/=light_view_pos0.w;light_view_pos1.xyz/=light_view_pos1.w;vec4 uv=vec4(light_view_pos0.xy,light_view_pos1.xy);vec4 abs_bounds=abs(uv);if (abs_bounds.x < 1.0 && abs_bounds.y < 1.0) {light_view_pos0.xyz=light_view_pos0.xyz*0.5+0.5;return shadow_occlusion_0(light_view_pos0,bias);}if (abs_bounds.z >=1.0 || abs_bounds.w >=1.0) {return 0.0;}light_view_pos1.xyz=light_view_pos1.xyz*0.5+0.5;float occlusion1=shadow_occlusion_1(light_view_pos1,bias);return clamp(mix(occlusion1,0.0,smoothstep(u_fade_range.x,u_fade_range.y,view_depth)),0.0,1.0);\n#endif\n}highp float calculate_shadow_bias(float NDotL) {\n#ifdef NORMAL_OFFSET\nreturn 0.5*u_shadow_bias.x;\n#else\nreturn 0.5*(u_shadow_bias.x+clamp(u_shadow_bias.y*tan(acos(NDotL)),0.0,u_shadow_bias.z));\n#endif\n}float shadowed_light_factor_normal(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_opacity(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth,float shadow_opacity) {float NDotL=dot(N,u_shadow_direction);float bias=calculate_shadow_bias(NDotL);float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias)*shadow_opacity;return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}float shadowed_light_factor_normal_unbiased(vec3 N,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float NDotL=dot(N,u_shadow_direction);float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return mix(0.0,(1.0-(u_shadow_intensity*occlusion))*NDotL,step(0.0,NDotL));}highp vec2 compute_receiver_plane_depth_bias(highp vec3 pos_dx,highp vec3 pos_dy)\n{highp vec2 biasUV=vec2(\npos_dy.y*pos_dx.z-pos_dx.y*pos_dy.z,pos_dx.x*pos_dy.z-pos_dy.x*pos_dx.z);biasUV*=1.0/((pos_dx.x*pos_dy.y)-(pos_dx.y*pos_dy.x));return biasUV;}float shadowed_light_factor_plane_bias(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {highp vec3 light_view_pos0_xyz=light_view_pos0.xyz/light_view_pos0.w*0.5+0.5;highp vec3 light_view_pos0_ddx=dFdx(light_view_pos0_xyz);highp vec3 light_view_pos0_ddy=dFdy(light_view_pos0_xyz);highp vec2 plane_depth_bias=compute_receiver_plane_depth_bias(light_view_pos0_ddx,light_view_pos0_ddy);highp float bias=dot(vec2(u_shadow_texel_size,u_shadow_texel_size),plane_depth_bias)+0.0001;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadowed_light_factor(highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=0.0;float occlusion=shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);return 1.0-(u_shadow_intensity*occlusion);}float shadow_occlusion(float ndotl,highp vec4 light_view_pos0,highp vec4 light_view_pos1,float view_depth) {float bias=calculate_shadow_bias(ndotl);return shadow_occlusion(light_view_pos0,light_view_pos1,view_depth,bias);}\n#endif";
          const Fo = [];
          Vo(So, Fo), Vo(Co, Fo), Vo(Io, Fo);
          const Bo = { "_prelude_fog.vertex.glsl": Ao, "_prelude_terrain.vertex.glsl": Do, "_prelude_shadow.vertex.glsl": Mo, "_prelude_fog.fragment.glsl": Lo, "_prelude_shadow.fragment.glsl": Oo, "_prelude_lighting.glsl": "\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec3 u_lighting_ambient_color;uniform mediump vec3 u_lighting_directional_dir;uniform mediump vec3 u_lighting_directional_color;uniform mediump vec3 u_ground_radiance;float calculate_ambient_directional_factor(vec3 normal) {float NdotL=dot(normal,u_lighting_directional_dir);const float factor_reduction_max=0.3;float dir_luminance=dot(u_lighting_directional_color,vec3(0.2126,0.7152,0.0722));float directional_factor_min=1.0-factor_reduction_max*min(dir_luminance,1.0);float ambient_directional_factor=mix(directional_factor_min,1.0,min((NdotL+1.0),1.0));const float vertical_factor_min=0.92;float vertical_factor=mix(vertical_factor_min,1.0,normal.z*0.5+0.5);return vertical_factor*ambient_directional_factor;}vec3 linearProduct(vec3 srgbIn,vec3 k) {return srgbIn*pow(k,vec3(1./2.2));}vec3 apply_lighting(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return linearProduct(color,ambient_contrib+directional_contrib);}vec4 apply_lighting(vec4 color,vec3 normal,float dir_factor) {return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting(vec3 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return apply_lighting(color.rgb,normal,dir_factor);}vec4 apply_lighting(vec4 color,vec3 normal) {float dir_factor=max(dot(normal,u_lighting_directional_dir),0.0);return vec4(apply_lighting(color.rgb,normal,dir_factor),color.a);}vec3 apply_lighting_ground(vec3 color) {return color*u_ground_radiance;}vec4 apply_lighting_ground(vec4 color) {return vec4(apply_lighting_ground(color.rgb),color.a);}float calculate_NdotL(vec3 normal) {const float ext=0.70710678118;return (clamp(dot(normal,u_lighting_directional_dir),-ext,1.0)+ext)/(1.0+ext);}vec4 apply_lighting_with_emission_ground(vec4 color,float emissive_strength) {return mix(apply_lighting_ground(color),color,emissive_strength);}vec3 compute_flood_lighting(vec3 flood_light_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=flood_light_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);float occlusion_ramp=smoothstep(0.0,0.2,1.0-occlusion);return mix(fully_occluded_color,flood_light_color,occlusion_ramp);}vec3 compute_emissive_draped(vec3 unlit_color,float fully_occluded_factor,float occlusion,vec3 ground_shadow_factor) {vec3 fully_occluded_color=unlit_color*mix(ground_shadow_factor,vec3(1.0),fully_occluded_factor);return mix(fully_occluded_color,unlit_color,1.0-occlusion);}\n#endif//LIGHTING_3D_MODE", "_prelude_raster_array.glsl": Po, "_prelude_raster_particle.glsl": zo }, ko = {};
          Go("", Do), Go(Lo, Ao), Go(Oo, Mo), Go(Po, ""), Go(zo, "");
          const No = Go(Io, Co), Uo = So;
          var jo = { background: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec4 u_color;uniform float u_opacity;\n#ifdef LIGHTING_3D_MODE\nin vec4 v_color;\n#endif\nvoid main() {vec4 out_color;\n#ifdef LIGHTING_3D_MODE\nout_color=v_color;\n#else\nout_color=u_color;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_lighting.glsl"\nin vec2 a_pos;uniform mat4 u_matrix;\n#ifdef LIGHTING_3D_MODE\nuniform mediump vec4 u_color;out vec4 v_color;uniform float u_emissive_strength;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0,1);\n#ifdef LIGHTING_3D_MODE\nv_color=apply_lighting_with_emission_ground(u_color,u_emissive_strength);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), backgroundPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_pattern_tl;uniform vec2 u_pattern_br;uniform vec2 u_texsize;uniform float u_opacity;uniform float u_emissive_strength;uniform sampler2D u_image;in highp vec2 v_pos;void main() {highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(u_pattern_tl/u_texsize,u_pattern_br/u_texsize,imagecoord);vec4 out_color=textureLodCustom(u_image,pos,v_pos);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pattern_size;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec2 u_pattern_units_to_pixels;in vec2 a_pos;out highp vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_pattern_size,u_pattern_units_to_pixels,a_pos);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), building: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in highp vec3 v_normal;in highp float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\nuniform lowp float u_opacity;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 apply_lighting_linear(vec3 color,vec3 normal,float dir_factor) {float ambient_directional_factor=calculate_ambient_directional_factor(normal);vec3 ambient_contrib=ambient_directional_factor*u_lighting_ambient_color;vec3 directional_contrib=u_lighting_directional_color*dir_factor;return color*(ambient_contrib+directional_contrib);}void main() {vec4 color=vec4(v_color.rgb,1.0);vec3 normal=normalize(v_normal);vec3 xy_flipped_normal=vec3(-normal.xy,normal.z);float shadowed_lighting_factor=0.0;\n#ifdef RENDER_SHADOWS\nshadowed_lighting_factor=shadowed_light_factor_normal(xy_flipped_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nshadowed_lighting_factor=dot(normal,u_lighting_directional_dir);\n#endif\ncolor.rgb=apply_lighting_linear(color.rgb,xy_flipped_normal,shadowed_lighting_factor);color.rgb=mix(color.rgb,v_color.rgb,v_color.a);color*=u_opacity;\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,v_height));\n#endif\n#ifdef RENDER_CUTOFF\ncolor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_height);\n#endif\nglFragColor=vec4(linearTosRGB(color.rgb),color.a);\n#ifdef DEBUG_SHOW_NORMALS\ncolor.rgb=xy_flipped_normal*0.5+vec3(0.5,0.5,0.5);color.a=1.0;glFragColor=color;\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;in vec3 a_normal_3f;out vec4 v_color;out highp vec3 v_normal;out highp float v_height;uniform mat4 u_matrix;uniform mat4 u_normal_matrix;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define-attribute-vertex-shader-only highp vec2 part_color_emissive\nvoid main() {\n#pragma mapbox: initialize-attribute-custom highp vec2 part_color_emissive\nvec4 color_emissive=decode_color(part_color_emissive);v_color=vec4(sRGBToLinear(color_emissive.rgb),color_emissive.a);v_normal=vec3(u_normal_matrix*vec4(a_normal_3f,0.0));vec3 pos=a_pos_3f;v_height=pos.z;gl_Position=u_matrix*vec4(pos,1.0);\n#ifdef RENDER_SHADOWS\nvec3 shadow_pos=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset_model(v_normal);shadow_pos+=offset*shadow_normal_offset_multiplier0();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shadow_pos,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(shadow_pos,1.0);v_depth_shadows=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), buildingDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;void main() {gl_Position=u_matrix*vec4(a_pos_3f,1.0);v_depth=gl_Position.z/gl_Position.w;}"), circle: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec3 v_data;in float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nuniform float u_emissive_strength;void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float blur_positive=blur < 0.0 ? 0.0 : 1.0;lowp float antialiasblur=v_data.z;float extrude_length=length(extrude)+antialiasblur*(1.0-blur_positive);float antialiased_blur=-max(abs(blur),antialiasblur);float antialiase_blur_opacity=smoothstep(0.0,antialiasblur,extrude_length-1.0);float opacity_t=blur_positive==1.0 ? \nsmoothstep(0.0,-antialiased_blur,1.0-extrude_length) : \nsmoothstep(antialiased_blur,0.0,extrude_length-1.0)-antialiase_blur_opacity;float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(\nantialiased_blur,0.0,extrude_length-radius/(radius+stroke_width)\n);vec4 out_color=mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#endif\n#ifdef FOG\nout_color=fog_apply_premultiplied(out_color,v_fog_pos);\n#endif\nglFragColor=out_color*(v_visibility*opacity_t);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define NUM_VISIBILITY_RINGS 2\n#define INV_SQRT2 0.70710678\n#define ELEVATION_BIAS 0.0001\n#define NUM_SAMPLES_PER_RING 16\nuniform mat4 u_matrix;uniform mat2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\n#ifdef ELEVATED_ROADS\nin float a_circle_z_offset;\n#endif\nout vec3 v_data;out float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvec2 calc_offset(vec2 extrusion,float radius,float stroke_width, float view_scale) {return extrusion*(radius+stroke_width)*u_extrude_scale*view_scale;}float cantilevered_elevation(vec2 pos,float radius,float stroke_width,float view_scale) {vec2 c1=pos+calc_offset(vec2(-1,-1),radius,stroke_width,view_scale);vec2 c2=pos+calc_offset(vec2(1,-1),radius,stroke_width,view_scale);vec2 c3=pos+calc_offset(vec2(1,1),radius,stroke_width,view_scale);vec2 c4=pos+calc_offset(vec2(-1,1),radius,stroke_width,view_scale);float h1=elevation(c1)+ELEVATION_BIAS;float h2=elevation(c2)+ELEVATION_BIAS;float h3=elevation(c3)+ELEVATION_BIAS;float h4=elevation(c4)+ELEVATION_BIAS;return max(h4,max(h3,max(h1,h2)));}float circle_elevation(vec2 pos) {\n#if defined(TERRAIN)\nreturn elevation(pos)+ELEVATION_BIAS;\n#else\nreturn 0.0;\n#endif\n}vec4 project_vertex(vec2 extrusion,vec4 world_center,vec4 projected_center,float radius,float stroke_width, float view_scale,mat3 surface_vectors) {vec2 sample_offset=calc_offset(extrusion,radius,stroke_width,view_scale);\n#ifdef PITCH_WITH_MAP\n#ifdef PROJECTION_GLOBE_VIEW\nreturn u_matrix*( world_center+vec4(sample_offset.x*surface_vectors[0]+sample_offset.y*surface_vectors[1],0) );\n#else\nreturn u_matrix*( world_center+vec4(sample_offset,0,0) );\n#endif\n#else\nreturn projected_center+vec4(sample_offset,0,0);\n#endif\n}float get_sample_step() {\n#ifdef PITCH_WITH_MAP\nreturn 2.0*PI/float(NUM_SAMPLES_PER_RING);\n#else\nreturn PI/float(NUM_SAMPLES_PER_RING);\n#endif\n}void main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);vec4 world_center;mat3 surface_vectors;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(circle_center)*circle_elevation(circle_center);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*circle_elevation(circle_center);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,circle_center,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;vec3 pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);world_center=vec4(pos,1);\n#else \nsurface_vectors=mat3(1.0);float height=circle_elevation(circle_center);world_center=vec4(circle_center,height,1);\n#endif\n#ifdef ELEVATED_ROADS\nworld_center.z+=a_circle_z_offset+ELEVATION_BIAS;\n#endif\nvec4 projected_center=u_matrix*world_center;float view_scale=0.0;\n#ifdef PITCH_WITH_MAP\n#ifdef SCALE_WITH_MAP\nview_scale=1.0;\n#else\nview_scale=projected_center.w/u_camera_to_center_distance;\n#endif\n#else\n#ifdef SCALE_WITH_MAP\nview_scale=u_camera_to_center_distance;\n#else\nview_scale=projected_center.w;\n#endif\n#endif\ngl_Position=project_vertex(extrude,world_center,projected_center,radius,stroke_width,view_scale,surface_vectors);float visibility=0.0;\n#ifdef TERRAIN\nfloat step=get_sample_step();vec4 occlusion_world_center;vec4 occlusion_projected_center;\n#ifdef PITCH_WITH_MAP\nfloat cantilevered_height=cantilevered_elevation(circle_center,radius,stroke_width,view_scale);occlusion_world_center=vec4(circle_center,cantilevered_height,1);occlusion_projected_center=u_matrix*occlusion_world_center;\n#else\nocclusion_world_center=world_center;occlusion_projected_center=projected_center;\n#endif\nfor(int ring=0; ring < NUM_VISIBILITY_RINGS; ring++) {float scale=(float(ring)+1.0)/float(NUM_VISIBILITY_RINGS);for(int i=0; i < NUM_SAMPLES_PER_RING; i++) {vec2 extrusion=vec2(cos(step*float(i)),-sin(step*float(i)))*scale;vec4 frag_pos=project_vertex(extrusion,occlusion_world_center,occlusion_projected_center,radius,stroke_width,view_scale,surface_vectors);visibility+=float(!isOccluded(frag_pos));}}visibility/=float(NUM_VISIBILITY_RINGS)*float(NUM_SAMPLES_PER_RING);\n#else\nvisibility=1.0;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nvisibility=1.0;\n#endif\nv_visibility=visibility;lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);\n#ifdef FOG\nv_fog_pos=fog_position(world_center.xyz);\n#endif\n}'), clippingMask: Go("void main() {glFragColor=vec4(1.0);}", "in vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: Go('#include "_prelude_fog.fragment.glsl"\nuniform highp float u_intensity;in vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);glFragColor=vec4(val,1.0,1.0,1.0);\n#ifdef FOG\nif (u_is_globe==0) {glFragColor.r*=pow(1.0-fog_opacity(v_fog_pos),2.0);}\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;in vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;\n#endif\nout vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 tilePos=floor(a_pos*0.5);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 pos_normal_3=a_pos_normal_3/16384.0;mat3 surface_vectors=globe_mercator_surface_vectors(pos_normal_3,u_up_dir,u_zoom_transition);vec3 surface_extrusion=extrude.x*surface_vectors[0]+extrude.y*surface_vectors[1];vec3 globe_elevation=elevationVector(tilePos)*elevation(tilePos);vec3 globe_pos=a_pos_3+surface_extrusion+globe_elevation;vec3 mercator_elevation=u_up_dir*u_tile_up_scale*elevation(tilePos);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,tilePos,u_tile_id,u_merc_center)+surface_extrusion+mercator_elevation;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#else\npos=vec3(tilePos+extrude,elevation(tilePos));\n#endif\ngl_Position=u_matrix*vec4(pos,1);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), heatmapTexture: Go("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));glFragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(0.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}", "in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=vec4(a_pos,0,1);v_pos=a_pos*0.5+0.5;}"), collisionBox: Go("in float v_placed;in float v_notUsed;void main() {vec4 red =vec4(1.0,0.0,0.0,1.0);vec4 blue=vec4(0.0,0.0,1.0,0.5);glFragColor =mix(red,blue,step(0.5,v_placed))*0.5;glFragColor*=mix(1.0,0.1,step(0.5,v_notUsed));}", '#include "_prelude_terrain.vertex.glsl"\nin vec3 a_pos;in vec2 a_anchor_pos;in vec2 a_extrude;in vec2 a_placed;in vec2 a_shift;in vec2 a_elevation_from_sea;in float a_size_scale;in vec2 a_padding;in float a_auto_z_offset;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;out float v_placed;out float v_notUsed;void main() {float feature_elevation=a_elevation_from_sea.x+a_auto_z_offset;float terrain_elevation=(a_elevation_from_sea.y==1.0 ? 0.0 : elevation(a_anchor_pos));vec4 projectedPoint=u_matrix*vec4(a_pos+elevationVector(a_anchor_pos)*(feature_elevation+terrain_elevation),1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,1.5);gl_Position=projectedPoint;gl_Position.xy+=(a_extrude*a_size_scale+a_shift+a_padding)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}'), collisionCircle: Go("in float v_radius;in vec2 v_extrude;in float v_perspective_ratio;in float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);glFragColor=color*alpha*opacity_t;}", "in vec2 a_pos_2f;in float a_radius;in vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;out float v_radius;out vec2 v_extrude;out float v_perspective_ratio;out float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos_2f;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(\nmix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(\n0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: Go("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);glFragColor=mix(u_color,overlay_color,overlay_color.a);}", '#include "_prelude_terrain.vertex.glsl"\nin vec2 a_pos;\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;\n#endif\nout vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {float h=elevation(a_pos);v_uv=a_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\ngl_Position=u_matrix*vec4(a_pos_3+elevationVector(a_pos)*h,1);\n#else\ngl_Position=u_matrix*vec4(a_pos*u_overlay_scale,h,1);\n#endif\n}'), elevatedStructuresDepth: Go("void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=vec4(0.);\n#endif\n}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform float u_depth_bias;void main() {gl_Position=u_matrix*vec4(a_pos,a_height,1);gl_Position.z=gl_Position.z+u_depth_bias;}"), elevatedStructuresDepthReconstruct: Go("#ifdef DEPTH_RECONSTRUCTION\nin float v_height;\n#endif\nvoid main() {\n#ifdef DEPTH_RECONSTRUCTION\nif (v_height >=0.0)\ndiscard;\n#endif\nglFragColor=vec4(1.0,0.0,0.0,1.0);}", "in vec2 a_pos;in float a_height;uniform mat4 u_matrix;uniform vec3 u_camera_pos;uniform highp float u_depth_bias;uniform lowp float u_height_scale;uniform lowp float u_reset_depth;\n#ifdef DEPTH_RECONSTRUCTION\nout float v_height;\n#endif\nvoid main() {vec3 vpos=vec3(a_pos,a_height*u_height_scale);\n#ifdef DEPTH_RECONSTRUCTION\nif (u_camera_pos.z > vpos.z) {vpos-=(u_camera_pos-vpos)*(vpos.z/(u_camera_pos.z-vpos.z));}v_height=a_height;\n#endif\ngl_Position=u_matrix*vec4(vpos,1);gl_Position.z=u_reset_depth==1.0 ? gl_Position.w : gl_Position.z+u_depth_bias;}"), elevatedStructures: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin vec3 v_normal;in float v_height;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth;\n#endif\nvoid main() {vec3 color=vec3(241.0/255.0,236.0/255.0,225.0/255.0);\n#ifdef LIGHTING_3D_MODE\nvec3 normal=normalize(v_normal);\n#ifdef RENDER_SHADOWS\nfloat shadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,v_depth);color.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#else\ncolor=apply_lighting(color,normal);\n#endif\nif (v_height < 0.0) {float penetration=max(v_height+7.5,0.0);float occlusion=1.0-1.0/PI*acos(1.0-penetration/4.0);color=color*(1.0-pow(occlusion,2.0)*0.3);}\n#endif\n#ifdef FOG\ncolor=fog_apply(color,v_fog_pos);\n#endif\nvec4 out_color=vec4(color,1.0);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_height);\n#endif\nglFragColor=out_color;HANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;in float a_height;in vec3 a_pos_normal_3;uniform mat4 u_matrix;out vec3 v_normal;out float v_height;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {v_normal=a_pos_normal_3/16384.0;v_height=a_height;vec3 pos=vec3(a_pos,a_height);gl_Position=u_matrix*vec4(pos,1);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(v_normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fill: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\nvec4 out_color=color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=opacity;\n#ifdef INDICATOR_CUTOUT\nif (v_z_offset >=0.0) {out_color=applyCutout(out_color,v_z_offset);}\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=z_offset;\n#endif\n}'), fillOutline: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=outline_color;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nuniform mat4 u_matrix;uniform vec2 u_world;out highp vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp float z_offset\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillOutlinePattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nuniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nin highp vec2 v_pos;in highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);float dist=length(v_pos_world-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;out highp vec2 v_pos_world;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);v_pos_world=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin highp vec2 v_pos;uniform float u_emissive_strength;\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nglFragColor=out_color*opacity;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_tile_units_to_pixels;in vec2 a_pos;\n#ifdef ELEVATED_ROADS\nin float a_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\nout highp vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define lowp float pixel_ratio\n#pragma mapbox: define highp float z_offset\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern\n#pragma mapbox: initialize lowp float pixel_ratio\n#pragma mapbox: initialize highp float z_offset\n#ifdef FILL_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;\n#ifdef ELEVATED_ROADS\nz_offset+=a_road_z_offset;\n#endif\nfloat hidden=float(opacity==0.0);gl_Position=mix(u_matrix*vec4(a_pos,z_offset,1),AWAY,hidden);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,a_pos);\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=vec3(a_pos,z_offset);vec3 shd_pos1=vec3(a_pos,z_offset);\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), fillExtrusion: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nin vec4 v_color;in vec4 v_flat;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;\n#endif\nuniform lowp float u_opacity;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec2 v_ao;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nin vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nin highp vec3 v_normal;\n#endif\nuniform vec3 u_flood_light_color;uniform highp float u_vertical_scale;uniform float u_flood_light_intensity;uniform vec3 u_ground_shadow_factor;\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nin float v_flood_radius;in float v_has_floodlight;\n#endif\nin float v_height;\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float emissive_strength\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nvec3 normal=normalize(v_normal);\n#endif\nfloat z;vec4 color=v_color;\n#ifdef ZERO_ROOF_RADIUS\nz=float(normal.z > 0.00001);\n#ifdef LIGHTING_3D_MODE\nnormal=mix(normal,vec3(0.0,0.0,1.0),z);\n#else\ncolor=mix(v_color,v_roof_color,z);\n#endif\n#endif\nfloat h=max(0.0,v_height);float ao_shade=1.0;\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h_floors=h/(u_ao[1]*u_vertical_scale);float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);ao_shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;\n#ifdef ZERO_ROOF_RADIUS\nconcave*=(1.0-z);\n#endif\nfloat x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);ao_shade*=mix(1.0,x_shade*x_shade*x_shade,concave);\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\ncolor.rgb*=mix(ao_shade,1.0,v_has_floodlight);\n#else\ncolor.rgb*=ao_shade;\n#endif\n#else\ncolor.rgb*=ao_shade;\n#endif\n#endif\n#ifdef LIGHTING_3D_MODE\nfloat flood_radiance=0.0;\n#ifdef FLOOD_LIGHT\nflood_radiance=(1.0-min(h/v_flood_radius,1.0))*u_flood_light_intensity*v_has_floodlight;\n#endif\n#ifdef RENDER_SHADOWS\n#ifdef FLOOD_LIGHT\nfloat ndotl_unclamped=dot(normal,u_shadow_direction);float ndotl=max(0.0,ndotl_unclamped);float occlusion=ndotl_unclamped < 0.0 ? 1.0 : shadow_occlusion(ndotl,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 litColor=apply_lighting(color.rgb,normal,(1.0-u_shadow_intensity*occlusion)*ndotl);vec3 floodLitColor=compute_flood_lighting(u_flood_light_color*u_opacity,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=mix(litColor,floodLitColor,flood_radiance);\n#else\nfloat shadowed_lighting_factor;\n#ifdef RENDER_CUTOFF\nshadowed_lighting_factor=shadowed_light_factor_normal_opacity(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,v_cutoff_opacity);if (v_cutoff_opacity==0.0) {discard;}\n#else\nshadowed_lighting_factor=shadowed_light_factor_normal(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);\n#endif\ncolor.rgb=apply_lighting(color.rgb,normal,shadowed_lighting_factor);\n#endif\n#else\ncolor.rgb=apply_lighting(color.rgb,normal);\n#ifdef FLOOD_LIGHT\ncolor.rgb=mix(color.rgb,u_flood_light_color*u_opacity,flood_radiance);\n#endif\n#endif\ncolor.rgb=mix(color.rgb,v_flat.rgb,emissive_strength);color*=u_opacity;\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos,h));\n#endif\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,h);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_edge_radius;uniform float u_width_scale;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nuniform highp float u_vertical_scale;out vec4 v_color;out vec4 v_flat;\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nout vec4 v_roof_color;\n#endif\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nout highp vec3 v_normal;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec2 v_ao;\n#endif\n#if defined(LIGHTING_3D_MODE) && defined(FLOOD_LIGHT)\nout float v_flood_radius;out float v_has_floodlight;\n#endif\nout float v_height;vec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define highp float flood_light_wall_radius\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize highp float flood_light_wall_radius\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp float emissive_strength\nbase*=u_vertical_scale;height*=u_vertical_scale;vec4 pos_nx=floor(a_pos_normal_ed*0.5);vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));\n#if defined(ZERO_ROOF_RADIUS) || defined(RENDER_SHADOWS) || defined(LIGHTING_3D_MODE)\nv_normal=normal;\n#endif\nbase=max(0.0,base);float attr_height=height;height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=0.0;float c_ele=0.0;vec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\nh=t > 0.0 ? height : base;pos=vec3(pos_nx.xy,h);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*h);vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,pos.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*pos.z;pos=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\nfloat cutoff=1.0;vec3 scaled_pos=pos;\n#ifdef RENDER_CUTOFF\nvec3 centroid_random=vec3(centroid_pos.xy,centroid_pos.x+centroid_pos.y+1.0);vec3 ground_pos=centroid_pos.x==0.0 ? pos.xyz : (centroid_random/8.0);vec4 ground=u_matrix*vec4(ground_pos.xy,ele,1.0);cutoff=cutoff_opacity(u_cutoff_params,ground.z);if (centroid_pos.y !=0.0 && centroid_pos.x !=0.0) {vec3 g=floor(ground_pos);vec3 mod_=centroid_random-g*8.0;float seed=min(1.0,0.1*(min(3.5,max(mod_.x+mod_.y,0.2*attr_height))*0.35+mod_.z));if (cutoff < 0.8-seed) {cutoff=0.0;}}float cutoff_scale=cutoff;v_cutoff_opacity=cutoff;scaled_pos.z=mix(c_ele,h,cutoff_scale);\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (cutoff==0.0 && centroid_pos.x !=0.0) || (color.a==0.0));\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);scaled_pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;scaled_pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\ngl_Position=mix(u_matrix*vec4(scaled_pos,1),AWAY,hidden);h=h-ele;v_height=h;\n#ifdef RENDER_SHADOWS\nvec3 shd_pos0=pos;vec3 shd_pos1=pos;\n#ifdef NORMAL_OFFSET\nvec3 offset=shadow_normal_offset(normal);shd_pos0+=offset*shadow_normal_offset_multiplier0();shd_pos1+=offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);\n#endif\nfloat NdotL=0.0;float colorvalue=0.0;\n#ifndef LIGHTING_3D_MODE\ncolorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;NdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),NdotL);if (normal.y !=0.0) {float r=0.84;r=mix(0.7,0.98,1.0-u_lightintensity);NdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#endif\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec2(mix(concave,-concave,start),y_ground);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\n#ifdef FLOOD_LIGHT\nfloat is_wall=1.0-float(t > 0.0 && top_up_ny.y > 0.0);v_has_floodlight=float(flood_light_wall_radius > 0.0 && is_wall > 0.0);v_flood_radius=flood_light_wall_radius*u_vertical_scale;\n#endif\nv_color=vec4(color.rgb,1.0);float ndotl=calculate_NdotL(normal);v_flat.rgb=sRGBToLinear(color.rgb);v_flat.rgb=v_flat.rgb*(ndotl+(1.0-min(ndotl*57.29,1.0))*emissive_strength);v_flat=vec4(linearTosRGB(v_flat.rgb),1.0);\n#else\nv_color=vec4(0.0,0.0,0.0,1.0);v_color.rgb+=clamp(color.rgb*NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_color*=u_opacity;\n#endif\n#if defined(ZERO_ROOF_RADIUS) && !defined(LIGHTING_3D_MODE)\nfloat roofNdotL=clamp(u_lightpos.z,0.0,1.0);roofNdotL=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),roofNdotL);v_roof_color=vec4(0.0,0.0,0.0,1.0);v_roof_color.rgb+=clamp(color.rgb*roofNdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_roof_color*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n}'), fillExtrusionDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_edge_radius;uniform float u_width_scale;uniform float u_vertical_scale;\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nin vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp float line_width\n#pragma mapbox: define highp vec4 color\nout highp float v_depth;void main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp float line_width\n#pragma mapbox: initialize highp vec4 color\nbase*=u_vertical_scale;height*=u_vertical_scale;vec3 pos_nx=floor(a_pos_normal_ed.xyz*0.5);mediump vec3 top_up_ny=a_pos_normal_ed.xyz-2.0*pos_nx;base=max(0.0,base);height=max(0.0,top_up_ny.y==0.0 && top_up_ny.x==1.0 ? height-u_edge_radius : height);float t=top_up_ny.x;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nvec3 pos;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;float ele=elevation(pos_nx.xy);float c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);float h=t > 0.0 ? max(h_base,h_height) : h_base;pos=vec3(pos_nx.xy,h);\n#else\npos=vec3(pos_nx.xy,t > 0.0 ? height : base);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);pos.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;pos.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(pos,1),AWAY,hidden);v_depth=gl_Position.z/gl_Position.w;}'), fillExtrusionPattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform vec2 u_texsize;uniform sampler2D u_image;\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;in vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nin vec3 v_normal;\n#endif\nin highp vec2 v_pos;in vec4 v_lighting;uniform lowp float u_opacity;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;highp vec2 imagecoord=mod(v_pos,1.0);highp vec2 pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,imagecoord);highp vec2 lod_pos=mix(pattern_tl/u_texsize,pattern_br/u_texsize,v_pos);vec4 out_color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl/u_texsize,pattern_b_br/u_texsize,imagecoord);vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);out_color=out_color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting(out_color,normalize(v_normal))*u_opacity;\n#else\nout_color=out_color*v_lighting;\n#endif\n#ifdef FAUX_AO\nfloat intensity=u_ao[0];float h=max(0.0,v_ao.z);float h_floors=h/u_ao[1];float y_shade=1.0-0.9*intensity*min(v_ao.y,1.0);float shade=(1.0-0.08*intensity)*(y_shade+(1.0-y_shade)*(1.0-pow(1.0-min(h_floors/16.0,1.0),16.0)))+0.08*intensity*min(h_floors/160.0,1.0);float concave=v_ao.x*v_ao.x;float x_shade=mix(1.0,mix(0.6,0.75,min(h_floors/30.0,1.0)),intensity)+0.1*intensity*min(h,1.0);shade*=mix(1.0,x_shade*x_shade*x_shade,concave);out_color.rgb=out_color.rgb*shade;\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,height);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_lighting.glsl"\nuniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform float u_tile_units_to_pixels;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform float u_width_scale;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;in vec4 a_pos_normal_ed;in vec2 a_centroid_pos;\n#ifdef RENDER_WALL_MODE\nin vec3 a_join_normal_inside;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_pos_3;in vec3 a_pos_normal_3;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_tile_id;uniform float u_zoom_transition;uniform vec3 u_up_dir;uniform float u_height_lift;\n#endif\n#ifdef TERRAIN\nuniform int u_height_type;uniform int u_base_type;\n#endif\nout highp vec2 v_pos;out vec4 v_lighting;\n#ifdef FAUX_AO\nuniform lowp vec2 u_ao;out vec3 v_ao;\n#endif\n#ifdef LIGHTING_3D_MODE\nout vec3 v_normal;\n#endif\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define highp float pixel_ratio\n#pragma mapbox: define highp float line_width\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef FILL_EXTRUSION_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize highp float pixel_ratio\n#pragma mapbox: initialize highp float line_width\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec4 pos_nx=floor(a_pos_normal_ed*0.5);mediump vec4 top_up_ny_start=a_pos_normal_ed-2.0*pos_nx;mediump vec3 top_up_ny=top_up_ny_start.xyz;float x_normal=pos_nx.z/8192.0;vec3 normal=top_up_ny.y==1.0 ? vec3(0.0,0.0,1.0) : normalize(vec3(x_normal,(2.0*top_up_ny.z-1.0)*(1.0-abs(x_normal)),0.0));float edgedistance=a_pos_normal_ed.w;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;base=max(0.0,base);height=max(0.0,height);float t=top_up_ny.x;float z=t > 0.0 ? height : base;vec2 centroid_pos=vec2(0.0);\n#if defined(HAS_CENTROID) || defined(TERRAIN)\ncentroid_pos=a_centroid_pos;\n#endif\nfloat ele=0.0;float h=z;vec3 p;float c_ele;\n#ifdef TERRAIN\nbool is_flat_height=centroid_pos.x !=0.0 && u_height_type==1;bool is_flat_base=centroid_pos.x !=0.0 && u_base_type==1;ele=elevation(pos_nx.xy);c_ele=is_flat_height || is_flat_base ? (centroid_pos.y==0.0 ? elevationFromUint16(centroid_pos.x) : flatElevation(centroid_pos)) : ele;float h_height=is_flat_height ? max(c_ele+height,ele+base+2.0) : ele+height;float h_base=is_flat_base ? max(c_ele+base,ele+base) : ele+(base==0.0 ?-5.0 : base);h=t > 0.0 ? max(h_base,h_height) : h_base;p=vec3(pos_nx.xy,h);\n#else\np=vec3(pos_nx.xy,z);\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nfloat lift=float((t+base) > 0.0)*u_height_lift;h+=lift;vec3 globe_normal=normalize(mix(a_pos_normal_3/16384.0,u_up_dir,u_zoom_transition));vec3 globe_pos=a_pos_3+globe_normal*(u_tile_up_scale*(p.z+lift));vec3 merc_pos=mercator_tile_position(u_inv_rot_matrix,p.xy,u_tile_id,u_merc_center)+u_up_dir*u_tile_up_scale*p.z;p=mix_globe_mercator(globe_pos,merc_pos,u_zoom_transition);\n#endif\n#ifdef RENDER_WALL_MODE\nvec2 wall_offset=u_width_scale*line_width*(a_join_normal_inside.xy/EXTENT);p.xy+=(1.0-a_join_normal_inside.z)*wall_offset*0.5;p.xy-=a_join_normal_inside.z*wall_offset*0.5;\n#endif\nfloat hidden=float((centroid_pos.x==0.0 && centroid_pos.y==1.0) || (color.a==0.0));gl_Position=mix(u_matrix*vec4(p,1),AWAY,hidden);vec2 pos=normal.z==1.0\n? pos_nx.xy\n: vec2(edgedistance,z*u_height_factor);v_pos=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,display_size,u_tile_units_to_pixels,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float NdotL=0.0;\n#ifdef LIGHTING_3D_MODE\nNdotL=calculate_NdotL(normal);\n#else\nNdotL=clamp(dot(normal,u_lightpos),0.0,1.0);NdotL=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),NdotL);\n#endif\nif (normal.y !=0.0) {float r=0.84;\n#ifndef LIGHTING_3D_MODE\nr=mix(0.7,0.98,1.0-u_lightintensity);\n#endif\nNdotL*=(\n(1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),r,1.0)));}\n#ifdef FAUX_AO\nfloat concave=pos_nx.w-floor(pos_nx.w*0.5)*2.0;float start=top_up_ny_start.w;float y_ground=1.0-clamp(t+base,0.0,1.0);float top_height=height;\n#ifdef TERRAIN\ntop_height=mix(max(c_ele+height,ele+base+2.0),ele+height,float(centroid_pos.x==0.0))-ele;y_ground+=y_ground*5.0/max(3.0,top_height);\n#endif\nv_ao=vec3(mix(concave,-concave,start),y_ground,h-ele);NdotL*=(1.0+0.05*(1.0-top_up_ny.y)*u_ao[0]);\n#ifdef PROJECTION_GLOBE_VIEW\ntop_height+=u_height_lift;\n#endif\ngl_Position.z-=(0.0000006*(min(top_height,500.)+2.0*min(base,500.0)+60.0*concave+3.0*start))*gl_Position.w;\n#endif\n#ifdef LIGHTING_3D_MODE\nv_normal=normal;\n#else\nv_lighting.rgb+=clamp(NdotL*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(p);\n#endif\n}'), groundShadow: Go('#include "_prelude_shadow.fragment.glsl"\nprecision highp float;uniform vec3 u_ground_shadow_factor;in vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\nvoid main() {float light=shadowed_light_factor_plane_bias(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);vec3 shadow=mix(u_ground_shadow_factor,vec3(1.0),light);\n#ifdef RENDER_CUTOFF\nshadow=mix(vec3(1.0),shadow,cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w));\n#endif\n#ifdef FOG\nshadow=mix(shadow,vec3(1.0),v_fog_opacity);\n#endif\n#ifdef INDICATOR_CUTOUT\nshadow=mix(shadow,vec3(1.0),1.0-applyCutout(vec4(1.0),0.0).r);\n#endif\nglFragColor=vec4(shadow,1.0);}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;in vec2 a_pos;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\nvoid main() {gl_Position=u_matrix*vec4(a_pos,0.0,1.0);v_pos_light_view_0=u_light_matrix_0*vec4(a_pos,0.0,1.0);v_pos_light_view_1=u_light_matrix_1*vec4(a_pos,0.0,1.0);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);v_fog_opacity=fog(v_fog_pos);\n#endif\n}'), fillExtrusionGroundEffect: Go("uniform highp float u_ao_pass;uniform highp float u_opacity;uniform highp float u_flood_light_intensity;uniform highp vec3 u_flood_light_color;uniform highp float u_attenuation;uniform sampler2D u_fb;uniform float u_fb_size;\n#ifdef SDF_SUBPASS\nin highp vec2 v_pos;in highp vec4 v_line_segment;in highp float v_flood_light_radius_tile;in highp vec2 v_ao;float line_df(highp vec2 a,highp vec2 b,highp vec2 p) {highp vec2 ba=b-a;highp vec2 pa=p-a;highp float r=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-r*ba);}\n#ifdef FOG\nin highp float v_fog;\n#endif\n#endif\nvoid main() {\n#ifdef CLEAR_SUBPASS\nvec4 color=vec4(1.0);\n#ifdef CLEAR_FROM_TEXTURE\ncolor=texture(u_fb,gl_FragCoord.xy/vec2(u_fb_size));\n#endif\nglFragColor=color;\n#else\n#ifdef SDF_SUBPASS\nhighp float d=line_df(v_line_segment.xy,v_line_segment.zw,v_pos);highp float effect_radius=mix(v_flood_light_radius_tile,v_ao.y,u_ao_pass);d/=effect_radius;d=min(d,1.0);d=1.0-pow(1.0-d,u_attenuation);highp float effect_intensity=mix(u_flood_light_intensity,v_ao.x,u_ao_pass);highp float fog=1.0;\n#ifdef FOG\nfog=v_fog;\n#endif\n#ifdef RENDER_CUTOFF\nfog*=v_cutoff_opacity;\n#endif\nglFragColor=vec4(vec3(0.0),mix(1.0,d,effect_intensity*u_opacity*fog));\n#else\nvec4 color=mix(vec4(u_flood_light_color,1.0),vec4(vec3(0.0),1.0),u_ao_pass);\n#ifdef OVERDRAW_INSPECTOR\ncolor=vec4(1.0);\n#endif\nglFragColor=color;\n#endif\nHANDLE_WIREFRAME_DEBUG;\n#endif\n}", '#include "_prelude_fog.vertex.glsl"\nin highp vec4 a_pos_end;in highp float a_angular_offset_factor;in highp float a_hidden_by_landmark;\n#ifdef SDF_SUBPASS\nout highp vec2 v_pos;out highp vec4 v_line_segment;out highp float v_flood_light_radius_tile;out highp vec2 v_ao;\n#ifdef FOG\nout highp float v_fog;\n#endif\n#endif\nuniform highp float u_flood_light_intensity;uniform highp mat4 u_matrix;uniform highp float u_ao_pass;uniform highp float u_meter_to_tile;uniform highp float u_edge_radius;uniform highp float u_dynamic_offset;uniform highp vec2 u_ao;\n#pragma mapbox: define highp float flood_light_ground_radius\nconst float TANGENT_CUTOFF=4.0;const float NORM=32767.0;void main() {\n#pragma mapbox: initialize highp float flood_light_ground_radius\nvec2 p=a_pos_end.xy;vec2 q=floor(a_pos_end.zw*0.5);vec2 start_bottom=a_pos_end.zw-q*2.0;float fl_ground_radius=flood_light_ground_radius;fl_ground_radius=abs(flood_light_ground_radius);float direction=flood_light_ground_radius < 0.0 ?-1.0 : 1.0;float flood_radius_tile=fl_ground_radius*u_meter_to_tile;vec2 v=normalize(q-p);float ao_radius=u_ao.y/3.5;float effect_radius=mix(flood_radius_tile,ao_radius,u_ao_pass)+u_edge_radius;float angular_offset_factor=a_angular_offset_factor/NORM*TANGENT_CUTOFF;float angular_offset=direction*angular_offset_factor*effect_radius;float top=1.0-start_bottom.y;float side=(0.5-start_bottom.x)*2.0;vec2 extrusion_parallel=v*side*mix(u_dynamic_offset,angular_offset,top);vec2 perp=vec2(v.y,-v.x);vec2 extrusion_perp=direction*perp*effect_radius*top;vec3 pos=vec3(mix(q,p,start_bottom.x),0.0);pos.xy+=extrusion_parallel+extrusion_perp;\n#ifdef SDF_SUBPASS\nv_pos=pos.xy;v_line_segment=vec4(p,q)+perp.xyxy*u_edge_radius;v_flood_light_radius_tile=flood_radius_tile;v_ao=vec2(u_ao.x,ao_radius);\n#ifdef FOG\nv_fog_pos=fog_position(pos);v_fog=1.0-fog(v_fog_pos);\n#endif\n#endif\nfloat hidden_by_landmark=0.0;\n#ifdef HAS_CENTROID\nhidden_by_landmark=a_hidden_by_landmark;\n#endif\nfloat isFloodlit=float(fl_ground_radius > 0.0 && u_flood_light_intensity > 0.0);float hidden=mix(1.0-isFloodlit,isFloodlit,u_ao_pass);hidden+=hidden_by_landmark;gl_Position=mix(u_matrix*vec4(pos,1.0),AWAY,float(hidden > 0.0));\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n}'), hillshadePrepare: Go("precision highp float;uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;float getElevation(vec2 coord) {return texture(u_image,coord).r/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y));float b=getElevation(v_pos+vec2(0,-epsilon.y));float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y));float d=getElevation(v_pos+vec2(-epsilon.x,0));float e=getElevation(v_pos+vec2(epsilon.x,0));float f=getElevation(v_pos+vec2(-epsilon.x,epsilon.y));float g=getElevation(v_pos+vec2(0,epsilon.y));float h=getElevation(v_pos+vec2(epsilon.x,epsilon.y));float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2(\n(c+e+e+h)-(a+d+d+f),(f+g+g+h)-(a+b+b+c)\n)/pow(2.0,exaggeration+(19.2562-u_zoom));glFragColor=clamp(vec4(\nderiv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);}", "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;uniform float u_emissive_strength;void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);glFragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef LIGHTING_3D_MODE\nglFragColor=apply_lighting_with_emission_ground(glFragColor,u_emissive_strength);\n#endif\n#ifdef FOG\nglFragColor=fog_dither(fog_apply_premultiplied(glFragColor,v_fog_pos));\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n}'), line: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform lowp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_floor_width_scale;uniform float u_alpha_discard_threshold;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform sampler2D u_dash_image;in vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform sampler2D u_gradient_image;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nfloat luminance(vec3 c) {return (c.r+c.r+c.b+c.g+c.g+c.g)*0.1667;}uniform float u_emissive_strength;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nfloat linearstep(float edge0,float edge1,float x) {return  clamp((x-edge0)/(edge1-edge0),0.0,1.0);}void main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);\n#ifdef RENDER_LINE_DASH\nfloat sdfdist=texture(u_dash_image,v_tex).r;float sdfgamma=1.0/(2.0*u_device_pixel_ratio)/dash.z;float scaled_floorwidth=(floorwidth*u_floor_width_scale);alpha*=linearstep(0.5-sdfgamma/scaled_floorwidth,0.5+sdfgamma/scaled_floorwidth,sdfdist);\n#endif\nhighp vec4 out_color;\n#ifdef RENDER_LINE_GRADIENT\nout_color=texture(u_gradient_image,v_uv.xy);\n#else\nout_color=color;\n#endif\nfloat trim_alpha=1.0;\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);out_color=mix(out_color,u_trim_color,transition_factor);trim_alpha=1.0-transition_factor;}\n#endif\nif (u_alpha_discard_threshold !=0.0) {if (alpha < u_alpha_discard_threshold) {discard;}}\n#ifdef RENDER_LINE_BORDER\nfloat edgeBlur=((border_width*u_width_scale)+1.0/u_device_pixel_ratio);float alpha2=clamp(min(dist-(v_width2.t-edgeBlur),v_width2.s-dist)/edgeBlur,0.0,1.0);if (alpha2 < 1.) {float smoothAlpha=smoothstep(0.6,1.0,alpha2);if (border_color.a==0.0) {float Y=(out_color.a > 0.01) ? luminance(out_color.rgb/out_color.a) : 1.;float adjustment=(Y > 0.) ? 0.5/Y : 0.45;if (out_color.a > 0.25 && Y < 0.25) {vec3 borderColor=(Y > 0.) ? out_color.rgb : vec3(1,1,1)*out_color.a;out_color.rgb=out_color.rgb+borderColor*(adjustment*(1.0-smoothAlpha));} else {out_color.rgb*=(0.6 +0.4*smoothAlpha);}} else {out_color=mix(border_color*trim_alpha,out_color,smoothAlpha);}}\n#endif\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\nout_color.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\nout_color.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\nout_color=fog_dither(fog_apply_premultiplied(out_color,v_fog_pos));\n#endif\nout_color*=(alpha*opacity);\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define EXTRUDE_SCALE 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS) || defined(VARIABLE_LINE_WIDTH)\nin vec3 a_z_offset_width;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nin highp vec3 a_packed;\n#endif\n#ifdef RENDER_LINE_DASH\nin float a_linesofar;\n#endif\nuniform mat4 u_matrix;uniform mat2 u_pixels_to_tile_units;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;uniform float u_width_scale;uniform highp float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec3 v_uv;\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_LINE_DASH\nuniform vec2 u_texsize;uniform float u_tile_units_to_pixels;out vec2 v_tex;\n#endif\n#ifdef RENDER_LINE_GRADIENT\nuniform float u_image_height;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 dash\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float border_width\n#pragma mapbox: define lowp vec4 border_color\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize lowp vec4 dash\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float border_width\n#pragma mapbox: initialize lowp vec4 border_color\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth;\n#ifdef VARIABLE_LINE_WIDTH\nfloat left=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);halfwidth=(u_width_scale*(left==1.0 ? a_z_offset_width.y : a_z_offset_width.z))/2.0;\n#else\nhalfwidth=(u_width_scale*width)/2.0;\n#endif\noffset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*EXTRUDE_SCALE;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*EXTRUDE_SCALE*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat epsilon=0.0001;float extrude_length_without_perspective=max(length(dist),epsilon);float extrude_length_with_perspective=max(length(projected_extrude_xy/gl_Position.w*u_units_to_pixels),epsilon);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#if defined(RENDER_LINE_GRADIENT) || defined(RENDER_LINE_TRIM_OFFSET)\nhighp float a_uv_x=a_packed[0];float a_split_index=a_packed[1];highp float line_progress=a_packed[2];\n#ifdef RENDER_LINE_GRADIENT\nhighp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec3(a_uv_x,a_split_index*texel_height-half_texel_height,line_progress);\n#else\nv_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\n#endif\n#ifdef RENDER_LINE_DASH\nfloat scale=dash.z==0.0 ? 0.0 : u_tile_units_to_pixels/dash.z;float height=dash.y;v_tex=vec2(a_linesofar*scale/(floorwidth*u_floor_width_scale),(-normal.y*height+dash.x+0.5)/u_texsize.y);\n#endif\nv_width2=vec2(outset,inset);\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), linePattern: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\nuniform highp float u_device_pixel_ratio;uniform highp float u_width_scale;uniform highp float u_alpha_discard_threshold;uniform highp vec2 u_texsize;uniform highp float u_tile_units_to_pixels;uniform highp vec2 u_trim_offset;uniform highp vec2 u_trim_fade_range;uniform lowp vec4 u_trim_color;uniform sampler2D u_image;\n#ifdef LINE_PATTERN_TRANSITION\nuniform float u_pattern_transition;\n#endif\nin vec2 v_normal;in vec2 v_width2;in highp float v_linesofar;in float v_gamma_scale;in float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nin highp float v_road_z_offset;\n#endif\n#ifdef LINE_JOIN_NONE\nin vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\nuniform float u_emissive_strength;\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\nvec2 pattern_tl=pattern.xy;vec2 pattern_br=pattern.zw;vec2 display_size=(pattern_br-pattern_tl)/pixel_ratio;highp float pattern_size=display_size.x/u_tile_units_to_pixels;float aspect=display_size.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(u_width_scale*blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);highp float pattern_x=v_linesofar/pattern_size*aspect;highp float x=mod(pattern_x,1.0);highp float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;highp vec2 pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(x,y));highp vec2 lod_pos=mix(pattern_tl*texel_size-texel_size,pattern_br*texel_size+texel_size,vec2(pattern_x,y));vec4 color=textureLodCustom(u_image,pos,lod_pos);\n#ifdef LINE_PATTERN_TRANSITION\nvec2 pattern_b_tl=pattern_b.xy;vec2 pattern_b_br=pattern_b.zw;highp vec2 pos_b=mix(pattern_b_tl*texel_size-texel_size,pattern_b_br*texel_size+texel_size,vec2(x,y));vec4 color_b=textureLodCustom(u_image,pos_b,lod_pos);color=color*(1.0-u_pattern_transition)+color_b*u_pattern_transition;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float trim_start=u_trim_offset[0];highp float trim_end=u_trim_offset[1];highp float line_progress=v_uv[2];if (trim_end > trim_start) {highp float start_transition=max(0.0,min(1.0,(line_progress-trim_start)/max(u_trim_fade_range[0],1.0e-9)));highp float end_transition=max(0.0,min(1.0,(trim_end-line_progress)/max(u_trim_fade_range[1],1.0e-9)));highp float transition_factor=min(start_transition,end_transition);color=mix(color,color.a*u_trim_color,transition_factor);}\n#endif\n#ifdef LINE_JOIN_NONE\nhighp float pattern_len=pattern_size/aspect;highp float segment_phase=pattern_len-mod(v_linesofar-v_pattern_data.x+pattern_len,pattern_len);highp float visible_start=segment_phase-step(pattern_len*0.5,segment_phase)*pattern_len;highp float visible_end=floor((v_pattern_data.y-segment_phase)/pattern_len)*pattern_len+segment_phase;visible_end+=step(pattern_len*0.5,v_pattern_data.y-visible_end)*pattern_len;if (v_pattern_data.x < visible_start || v_pattern_data.x >=visible_end) {color=vec4(0.0);}\n#endif\n#ifdef LIGHTING_3D_MODE\ncolor=apply_lighting_with_emission_ground(color,u_emissive_strength);\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);\n#ifdef ELEVATED_ROADS\ncolor.rgb*=mix(v_road_z_offset !=0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#else\ncolor.rgb*=mix(u_ground_shadow_factor,vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=(alpha*opacity);if (u_alpha_discard_threshold !=0.0) {if (color.a < u_alpha_discard_threshold) {discard;}}\n#ifdef INDICATOR_CUTOUT\ncolor=applyCutout(color,v_z_offset);\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\n#define scale 0.015873016\nin vec2 a_pos_normal;in vec4 a_data;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\nin vec3 a_z_offset_width;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nin highp vec3 a_packed;\n#endif\nin highp float a_linesofar;\n#ifdef LINE_JOIN_NONE\nin highp vec3 a_pattern_data;out vec2 v_pattern_data;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#endif\nuniform mat4 u_matrix;uniform float u_tile_units_to_pixels;uniform vec2 u_units_to_pixels;uniform mat2 u_pixels_to_tile_units;uniform float u_device_pixel_ratio;uniform float u_width_scale;uniform float u_floor_width_scale;\n#ifdef ELEVATED\nuniform lowp float u_zbias_factor;uniform lowp float u_tile_to_meter;float sample_elevation(vec2 apos) {\n#ifdef ELEVATION_REFERENCE_SEA\nreturn 0.0;\n#else\nreturn elevation(apos);\n#endif\n}\n#endif\nout vec2 v_normal;out vec2 v_width2;out highp float v_linesofar;out float v_gamma_scale;out float v_width;\n#ifdef RENDER_LINE_TRIM_OFFSET\nout highp vec3 v_uv;\n#endif\n#ifdef ELEVATED_ROADS\nout highp float v_road_z_offset;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#pragma mapbox: define mediump float blur\n#pragma mapbox: define mediump float opacity\n#pragma mapbox: define mediump float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define mediump float floorwidth\n#pragma mapbox: define mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: define mediump vec4 pattern_b\n#endif\n#pragma mapbox: define mediump float pixel_ratio\nvoid main() {\n#pragma mapbox: initialize mediump float blur\n#pragma mapbox: initialize mediump float opacity\n#pragma mapbox: initialize mediump float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize mediump float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern\n#ifdef LINE_PATTERN_TRANSITION\n#pragma mapbox: initialize mediump vec4 pattern_b\n#endif\n#pragma mapbox: initialize mediump float pixel_ratio\nfloat a_z_offset;\n#if defined(ELEVATED) || defined(ELEVATED_ROADS)\na_z_offset=a_z_offset_width.x;\n#endif\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;vec2 pos=floor(a_pos_normal*0.5);vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=(u_width_scale*width)/2.0;offset=-1.0*offset*u_width_scale;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);vec2 dist=outset*a_extrude*scale;float u=0.5*a_direction;float t=1.0-abs(u);vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float hidden=float(opacity==0.0);vec2 extrude=dist*u_pixels_to_tile_units;vec4 projected_extrude=u_matrix*vec4(extrude,0.0,0.0);vec2 projected_extrude_xy=projected_extrude.xy;\n#ifdef ELEVATED_ROADS\nv_road_z_offset=a_z_offset;gl_Position=u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,a_z_offset,1.0)+projected_extrude;\n#else\n#ifdef ELEVATED\nvec2 offsetTile=offset2*u_pixels_to_tile_units;vec2 offset_pos=pos+offsetTile;float ele=0.0;\n#ifdef CROSS_SLOPE_VERTICAL\nfloat top=a_pos_normal.y-2.0*floor(a_pos_normal.y*0.5);float line_height=2.0*u_tile_to_meter*outset*top*u_pixels_to_tile_units[1][1]+a_z_offset;ele=sample_elevation(offset_pos)+line_height;projected_extrude=vec4(0);\n#else\n#ifdef CROSS_SLOPE_HORIZONTAL\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,max(ele1,ele2));ele=ele_max+a_z_offset;\n#else\nfloat ele0=sample_elevation(offset_pos);float ele1=max(sample_elevation(offset_pos+extrude),sample_elevation(offset_pos+extrude/2.0));float ele2=max(sample_elevation(offset_pos-extrude),sample_elevation(offset_pos-extrude/2.0));float ele_max=max(ele0,0.5*(ele1+ele2));ele=ele_max-ele0+ele1+a_z_offset;\n#endif\n#endif\ngl_Position=u_matrix*vec4(offset_pos,ele,1.0)+projected_extrude;float z=clamp(gl_Position.z/gl_Position.w,0.5,1.0);float zbias=max(0.00005,(pow(z,0.8)-z)*u_zbias_factor*u_exaggeration);gl_Position.z-=(gl_Position.w*zbias);gl_Position=mix(gl_Position,AWAY,hidden);\n#else\ngl_Position=mix(u_matrix*vec4(pos+offset2*u_pixels_to_tile_units,0.0,1.0)+projected_extrude,AWAY,hidden);\n#endif\n#endif\n#ifdef ELEVATED_ROADS\n#ifdef RENDER_SHADOWS\nvec3 shd_pos=vec3(pos+(offset2+dist)*u_pixels_to_tile_units,a_z_offset);vec3 shd_pos0=shd_pos;vec3 shd_pos1=shd_pos;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifndef RENDER_TO_TEXTURE\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude_xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=mix(extrude_length_without_perspective/extrude_length_with_perspective,1.0,step(0.01,blur));\n#else\nv_gamma_scale=1.0;\n#endif\n#ifdef RENDER_LINE_TRIM_OFFSET\nhighp float a_uv_x=a_packed[0];highp float line_progress=a_packed[2];v_uv=vec3(a_uv_x,0.0,line_progress);\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=(floorwidth*u_floor_width_scale);\n#ifdef LINE_JOIN_NONE\nv_width=(floorwidth*u_floor_width_scale)+ANTIALIASING;mediump float pixels_to_tile_units=1.0/u_tile_units_to_pixels;mediump float pixel_ratio_inverse=1.0/pixel_ratio;mediump float aspect=v_width/((pattern.w-pattern.y)*pixel_ratio_inverse);highp float subt_multiple=(pattern.z-pattern.x)*pixel_ratio_inverse*pixels_to_tile_units*aspect*32.0;highp float subt=floor(a_pattern_data.z/subt_multiple)*subt_multiple;float offset_sign=(fract(a_pattern_data.x)-0.5)*4.0;float line_progress_offset=offset_sign*v_width*0.5*pixels_to_tile_units;v_linesofar=(a_pattern_data.z-subt)+a_linesofar+line_progress_offset;v_pattern_data=vec2(a_pattern_data.x+line_progress_offset,a_pattern_data.y);\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(pos);\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=a_z_offset;\n#endif\n}'), raster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\n#include "_prelude_raster_array.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;uniform highp float u_zoom_transition;in vec2 v_pos0;in vec2 v_pos1;in float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nin float v_split_fade;\n#endif\nuniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;uniform float u_emissive_strength;\n#ifndef RASTER_ARRAY\nuniform highp sampler2D u_image0;uniform sampler2D u_image1;\n#endif\n#ifdef RASTER_COLOR\nuniform sampler2D u_color_ramp;uniform highp vec4 u_colorization_mix;uniform highp float u_colorization_offset;uniform vec2 u_texture_res;\n#endif\nvoid main() {vec4 color0,color1,color;vec2 value;\n#ifdef RASTER_COLOR\n#ifdef RASTER_ARRAY\n#ifdef RASTER_ARRAY_LINEAR\nvalue=mix(\nraTexture2D_image0_linear(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_linear(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#else\nvalue=mix(\nraTexture2D_image0_nearest(v_pos0,u_texture_res,u_colorization_mix,u_colorization_offset),raTexture2D_image1_nearest(v_pos1,u_texture_res,u_colorization_mix,u_colorization_offset),u_fade_t\n);\n#endif\nif (value.y > 0.0) value.x/=value.y;\n#else\ncolor=mix(texture(u_image0,v_pos0),texture(u_image1,v_pos1),u_fade_t);value=vec2(u_colorization_offset+dot(color.rgb,u_colorization_mix.rgb),color.a);\n#endif\ncolor=texture(u_color_ramp,vec2(value.x,0.5));if (color.a > 0.0) color.rgb/=color.a;color.a*=value.y;\n#else\ncolor0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);\n#endif\ncolor.a*=u_opacity;\n#ifdef GLOBE_POLES\ncolor.a*=1.0-smoothstep(0.0,0.05,u_zoom_transition);\n#endif\nvec3 rgb=color.rgb;rgb=vec3(\ndot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);vec3 out_color=mix(u_high_vec,u_low_vec,rgb);\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),u_emissive_strength).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef PROJECTION_GLOBE_VIEW\nglFragColor*=mix(1.0,1.0-smoothstep(0.0,0.05,u_zoom_transition),smoothstep(0.8,0.9,v_split_fade));\n#endif\n#ifdef RENDER_CUTOFF\nglFragColor=glFragColor*cutoff_opacity(u_cutoff_params,v_depth);\n#endif\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform vec2 u_perspective_transform;uniform vec2 u_texture_offset;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;in vec2 a_texture_pos;\n#endif\nout vec2 v_pos0;out vec2 v_pos1;out float v_depth;\n#ifdef PROJECTION_GLOBE_VIEW\nout float v_split_fade;\n#endif\nvoid main() {vec2 uv;\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;gl_Position=u_matrix*u_globe_matrix*vec4(globe_pos   ,1.0);uv=a_uv;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(a_globe_pos,1.0)).xyz);\n#endif\n#else\nfloat w=1.0+dot(a_texture_pos,u_perspective_transform);uv=a_texture_pos/8192.0;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);    \nv_split_fade=0.0;if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;float opposite_merc_center=mod(u_merc_center.x+0.5,1.0);float dist_from_poles=(abs(mercatorY-0.5)*2.0);float range=0.1;v_split_fade=abs(opposite_merc_center-mercatorX);v_split_fade=clamp(1.0-v_split_fade,0.0,1.0);v_split_fade=max(smoothstep(1.0-range,1.0,dist_from_poles),max(smoothstep(1.0-range,1.0,v_split_fade),smoothstep(1.0-range,1.0,1.0-v_split_fade)));}float tiles=u_grid_matrix[0][2];if (tiles > 0.0) {float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvY=mercatorY*tiles-idy;float uvX=mercatorX*tiles-idx;uv=vec2(uvX,uvY);}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\ngl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;v_pos0=u_texture_offset.x+u_texture_offset.y*v_pos0;v_pos1=u_texture_offset.x+u_texture_offset.y*v_pos1;\n#ifdef RENDER_CUTOFF\nv_depth=gl_Position.z;\n#endif\n}'), rasterParticle: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_fade_t;uniform float u_opacity;uniform highp float u_raster_elevation;in vec2 v_pos0;in vec2 v_pos1;uniform sampler2D u_image0;uniform sampler2D u_image1;void main() {vec4 color0,color1,color;color0=texture(u_image0,v_pos0);color1=texture(u_image1,v_pos1);if (color0.a > 0.0) color0.rgb/=color0.a;if (color1.a > 0.0) color1.rgb/=color1.a;color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 out_color=color.rgb;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(vec4(out_color,1.0),0.0).rgb;\n#endif\n#ifdef FOG\nhighp float fog_limit_high_meters=1000000.0;highp float fog_limit_low_meters=600000.0;float fog_limit=1.0-smoothstep(fog_limit_low_meters,fog_limit_high_meters,u_raster_elevation);out_color=fog_dither(fog_apply(out_color,v_fog_pos,fog_limit));\n#endif\nglFragColor=vec4(out_color*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\nuniform mat4 u_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform mat3 u_grid_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_raster_elevation;uniform float u_zoom_transition;uniform vec2 u_merc_center;\n#define GLOBE_UPSCALE GLOBE_RADIUS/6371008.8\nin vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {float w=1.0;vec2 uv;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float mercatorX=mercatorXfromLng(latLng[1]);float tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];float uvX=mercatorX*tiles-idx;float uvY=mercatorY*tiles-idy;uv=vec2(uvX,uvY);vec3 globe_pos=latLngToECEF(latLng.xy);globe_pos+=normalize(globe_pos)*u_raster_elevation*GLOBE_UPSCALE;vec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {vec2 merc_pos=vec2(mercatorX,mercatorY);merc_world_pos=vec4(merc_pos,u_raster_elevation,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition)*w,w);gl_Position=u_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n#else\nuv=a_texture_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*w,u_raster_elevation*w,w);\n#ifdef FOG\nv_fog_pos=fog_position(a_pos);\n#endif\n#endif\nv_pos0=uv;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}'), rasterParticleDraw: Go("uniform sampler2D u_color_ramp;in float v_particle_speed;void main() {glFragColor=texture(u_color_ramp,vec2(v_particle_speed,0.5));}", '#include "_prelude_raster_particle.glsl"\nin float a_index;uniform sampler2D u_particle_texture;uniform float u_particle_texture_side_len;uniform vec2 u_tile_offset;out float v_particle_speed;void main() {ivec2 pixel_coord=ivec2(\nmod(a_index,u_particle_texture_side_len),a_index/u_particle_texture_side_len);vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);vec2 pos=unpack_pos_from_rgba(pixel)+u_tile_offset;vec2 tex_coord=fract(pos);vec2 velocity=lookup_velocity(tex_coord);if (velocity==INVALID_VELOCITY) {gl_Position=AWAY;v_particle_speed=0.0;} else {gl_Position=vec4(2.0*pos-1.0,0,1);v_particle_speed=length(velocity);}gl_PointSize=1.0;}'), rasterParticleTexture: Go("uniform sampler2D u_texture;uniform float u_opacity;in vec2 v_tex_pos;void main() {vec4 color=texture(u_texture,v_tex_pos);glFragColor=vec4(floor(255.0*color*u_opacity)/255.0);}", "in vec2 a_pos;out vec2 v_tex_pos;void main() {vec2 uv=0.5*a_pos+vec2(0.5);v_tex_pos=uv;gl_Position=vec4(a_pos,0.0,1.0);}"), rasterParticleUpdate: Go('#include "_prelude_raster_particle.glsl"\nuniform sampler2D u_particle_texture;uniform mediump float u_particle_texture_side_len;uniform mediump float u_speed_factor;uniform highp float u_reset_rate;uniform highp float u_rand_seed;in highp vec2 v_tex_coord;vec2 linearstep(vec2 edge0,vec2 edge1,vec2 x) {return  clamp((x-edge0)/(edge1-edge0),vec2(0),vec2(1));}const highp vec3 rand_constants=vec3(12.9898,78.233,4375.85453);highp float rand(const highp vec2 co) {highp float t=dot(rand_constants.xy,co);return fract(sin(t)*(rand_constants.z+t));}void main() {ivec2 pixel_coord=ivec2(v_tex_coord*u_particle_texture_side_len);highp vec4 pixel=texelFetch(u_particle_texture,pixel_coord,0);highp vec2 pos=unpack_pos_from_rgba(pixel);highp vec2 velocity=lookup_velocity(clamp(pos,0.0,1.0));highp vec2 dp=velocity==INVALID_VELOCITY ? vec2(0) : velocity*u_speed_factor;pos=pos+dp;highp vec2 seed=(pos+v_tex_coord)*u_rand_seed;highp vec2 random_pos=vec2(rand(seed+1.3),rand(seed+2.1));highp vec2 persist_rate=pow(\nlinearstep(vec2(-u_particle_pos_offset),vec2(0),pos)*linearstep(vec2(1.0+u_particle_pos_offset),vec2(1),pos),vec2(4)\n);highp vec2 per_frame_persist=pow(persist_rate,abs(dp)/u_particle_pos_offset);highp float drop_rate=1.0-per_frame_persist.x*per_frame_persist.y;drop_rate=any(greaterThanEqual(abs(pos-0.5),vec2(0.5+u_particle_pos_offset))) ? 1.0 : drop_rate;highp float drop=step(1.0-drop_rate-u_reset_rate,rand(seed));highp vec2 next_pos=mix(pos,random_pos,drop);glFragColor=pack_pos_to_rgba(next_pos);}', "in vec2 a_pos;out vec2 v_tex_coord;void main() {v_tex_coord=0.5*(a_pos+vec2(1.0));gl_Position=vec4(a_pos,0.0,1.0);}"), symbol: Go('#include "_prelude_lighting.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;uniform bool u_is_halo;uniform lowp float u_scale_factor;\n#ifdef ICON_TRANSITION\nuniform float u_icon_transition;\n#endif\n#ifdef COLOR_ADJUSTMENT\nuniform mat4 u_color_adj_mat;\n#endif\n#ifdef INDICATOR_CUTOUT\nin highp float v_z_offset;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nin highp float v_z_offset;\n#endif\n#endif\n#endif\nin vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nin vec2 v_tex_b;\n#endif\nin float v_draw_halo;in vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nin float is_sdf;in vec2 v_tex_a_icon;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nuniform vec3 u_ground_shadow_factor;in highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in highp float v_depth;\n#endif\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\nvec4 out_color;float fade_opacity=v_gamma_scale_size_fade_opacity[2];\n#ifdef RENDER_TEXT_AND_SYMBOL\nif (is_sdf==ICON) {vec2 tex_icon=v_tex_a_icon;lowp float alpha=opacity*fade_opacity;glFragColor=texture(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nreturn;}\n#endif\n#ifdef RENDER_SDF\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_gamma_scale_size_fade_opacity.x;float size=v_gamma_scale_size_fade_opacity.y;float fontScale=u_is_text ? size/24.0 : size;out_color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;bool draw_halo=v_draw_halo > 0.0;if (draw_halo) {out_color=halo_color;gamma=(halo_blur*u_scale_factor*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width*u_scale_factor/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,v_tex_a).r;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);out_color*=alpha;\n#else\n#ifdef ICON_TRANSITION\nvec4 a=texture(u_texture,v_tex_a)*(1.0-u_icon_transition);vec4 b=texture(u_texture,v_tex_b)*u_icon_transition;out_color=(a+b);\n#else\nout_color=texture(u_texture,v_tex_a);\n#endif\n#ifdef COLOR_ADJUSTMENT\nout_color=u_color_adj_mat*out_color;\n#endif\n#endif\nout_color*=opacity*fade_opacity;\n#ifdef LIGHTING_3D_MODE\nout_color=apply_lighting_with_emission_ground(out_color,emissive_strength);\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nfloat light=shadowed_light_factor(v_pos_light_view_0,v_pos_light_view_1,v_depth);out_color.rgb*=mix(abs(v_z_offset) > 0.0 ? u_ground_shadow_factor : vec3(1.0),vec3(1.0),light);\n#endif\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nout_color=applyCutout(out_color,v_z_offset);\n#endif\nglFragColor=out_color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_terrain.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec4 a_pos_offset;in vec4 a_tex_size;in vec4 a_pixeloffset;in vec4 a_projected_pos;in float a_fade_opacity;\n#ifdef Z_OFFSET\nin float a_auto_z_offset;\n#endif\n#ifdef PROJECTION_GLOBE_VIEW\nin vec3 a_globe_anchor;in vec3 a_globe_normal;\n#endif\n#ifdef ICON_TRANSITION\nin vec2 a_texb;\n#endif\n#ifdef OCCLUSION_QUERIES\nin float a_occlusion_query_opacity;\n#endif\n#ifdef ELEVATED_ROADS\nin vec3 a_x_axis;in vec3 a_y_axis;uniform float u_normal_scale;\n#endif\n#ifdef INDICATOR_CUTOUT\nout highp float v_z_offset;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nout highp float v_z_offset;\n#endif\n#endif\n#endif\nuniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_elevation_from_sea;uniform bool u_pitch_with_map;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec3 u_up_vector;uniform vec2 u_texsize_icon;uniform bool u_is_halo;\n#ifdef PROJECTION_GLOBE_VIEW\nuniform vec3 u_tile_id;uniform mat4 u_inv_rot_matrix;uniform vec2 u_merc_center;uniform vec3 u_camera_forward;uniform float u_zoom_transition;uniform vec3 u_ecef_origin;uniform mat4 u_tile_matrix;\n#endif\nout vec2 v_tex_a;\n#ifdef ICON_TRANSITION\nout vec2 v_tex_b;\n#endif\nout float v_draw_halo;out vec3 v_gamma_scale_size_fade_opacity;\n#ifdef RENDER_TEXT_AND_SYMBOL\nout float is_sdf;out vec2 v_tex_a_icon;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out highp float v_depth;\n#endif\n#endif\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\n#pragma mapbox: define lowp float emissive_strength\n#pragma mapbox: define lowp float occlusion_opacity\n#pragma mapbox: define lowp float z_offset\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\n#pragma mapbox: initialize lowp float emissive_strength\n#pragma mapbox: initialize lowp float occlusion_opacity\n#pragma mapbox: initialize lowp float z_offset\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_tex_size.xy;vec2 a_size=a_tex_size.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_min_font_scale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[3];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 tile_anchor=a_pos;float e=u_elevation_from_sea ? z_offset : z_offset+elevation(tile_anchor);\n#ifdef Z_OFFSET\ne+=a_auto_z_offset;\n#endif\nvec3 h=elevationVector(tile_anchor)*e;float globe_occlusion_fade;vec3 world_pos;vec3 mercator_pos;vec3 world_pos_globe;\n#ifdef PROJECTION_GLOBE_VIEW\nmercator_pos=mercator_tile_position(u_inv_rot_matrix,tile_anchor,u_tile_id,u_merc_center);world_pos_globe=a_globe_anchor+h;world_pos=mix_globe_mercator(world_pos_globe,mercator_pos,u_zoom_transition);vec4 ecef_point=u_tile_matrix*vec4(world_pos,1.0);vec3 origin_to_point=ecef_point.xyz-u_ecef_origin;globe_occlusion_fade=dot(origin_to_point,u_camera_forward) >=0.0 ? 0.0 : 1.0;\n#else\nworld_pos=vec3(tile_anchor,0)+h;globe_occlusion_fade=1.0;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1);highp float camera_to_anchor_distance=projected_point.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(\n0.5+0.5*distance_ratio,0.0,1.5);size*=perspective_ratio;float font_scale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetprojected_point;vec2 a;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 displacement=vec3(a_globe_normal.z,0,-a_globe_normal.x);offsetprojected_point=u_matrix*vec4(a_globe_anchor+displacement,1);vec4 projected_point_globe=u_matrix*vec4(world_pos_globe,1);a=projected_point_globe.xy/projected_point_globe.w;\n#else\noffsetprojected_point=u_matrix*vec4(tile_anchor+vec2(1,0),0,1);a=projected_point.xy/projected_point.w;\n#endif\nvec2 b=offsetprojected_point.xy/offsetprojected_point.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}vec4 projected_pos;\n#ifdef PROJECTION_GLOBE_VIEW\n#ifdef PROJECTED_POS_ON_VIEWPORT\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xyz+h,1.0);\n#else\nvec3 proj_pos=mix_globe_mercator(a_projected_pos.xyz,mercator_pos,u_zoom_transition)+h;projected_pos=u_label_plane_matrix*vec4(proj_pos,1.0);    \n#endif\n#else\nprojected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,h.z,1.0);\n#endif\nhighp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);float z=0.0;vec2 offset=rotation_matrix*(a_offset/32.0*max(a_min_font_scale,font_scale)+a_pxoffset/16.0);\n#ifdef TERRAIN\n#ifdef PITCH_WITH_MAP_TERRAIN\nvec4 tile_pos=u_label_plane_matrix_inv*vec4(a_projected_pos.xy+offset,0.0,1.0);z=elevation(tile_pos.xy);\n#endif\n#endif\n#ifdef Z_OFFSET\nz+=u_pitch_with_map ? a_auto_z_offset+z_offset : 0.0;\n#else\nz+=u_pitch_with_map ? z_offset : 0.0;\n#endif\nfloat occlusion_fade=globe_occlusion_fade;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float out_fade_opacity=max(0.0,min(occlusion_fade,fade_opacity[0]+fade_change));\n#ifdef DEPTH_OCCLUSION\nfloat depth_occlusion=occlusionFadeMultiSample(projected_point);float depth_occlusion_multplier=mix(occlusion_opacity,1.0,depth_occlusion);out_fade_opacity*=depth_occlusion_multplier;\n#endif\n#ifdef OCCLUSION_QUERIES\nfloat occludedFadeMultiplier=mix(occlusion_opacity,1.0,a_occlusion_query_opacity);out_fade_opacity*=occludedFadeMultiplier;\n#endif\nfloat alpha=opacity*out_fade_opacity;float hidden=float(alpha==0.0 || projected_point.w <=0.0 || occlusion_fade==0.0);vec3 pos;\n#ifdef PROJECTION_GLOBE_VIEW\nvec3 xAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,u_up_vector)) : vec3(1,0,0);vec3 yAxis=u_pitch_with_map ? normalize(cross(a_globe_normal,xAxis)) : vec3(0,1,0);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\n#ifdef ELEVATED_ROADS\nvec3 xAxis=vec3(a_x_axis.xy,a_x_axis.z*u_normal_scale);vec3 yAxis=vec3(a_y_axis.xy,a_y_axis.z*u_normal_scale);pos=projected_pos.xyz/projected_pos.w+xAxis*offset.x+yAxis*offset.y;\n#else\npos=vec3(projected_pos.xy/projected_pos.w+offset,z);\n#endif\n#endif\ngl_Position=mix(u_coord_matrix*vec4(pos,1.0),AWAY,hidden);float gamma_scale=gl_Position.w;v_draw_halo=(u_is_halo && float(gl_InstanceID)==0.0) ? 1.0 : 0.0;v_gamma_scale_size_fade_opacity=vec3(gamma_scale,size,out_fade_opacity);v_tex_a=a_tex/u_texsize;\n#ifdef RENDER_TEXT_AND_SYMBOL\nis_sdf=a_size[0]-2.0*a_size_min;v_tex_a_icon=a_tex/u_texsize_icon;\n#endif\n#ifdef ICON_TRANSITION\nv_tex_b=a_texb/u_texsize;\n#endif\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nvec4 shd_pos=u_inv_matrix*vec4(pos,1.0);vec3 shd_pos0=shd_pos.xyz;vec3 shd_pos1=shd_pos.xyz;\n#ifdef NORMAL_OFFSET\nvec3 shd_pos_offset=shadow_normal_offset(vec3(0.0,0.0,1.0));shd_pos0+=shd_pos_offset*shadow_normal_offset_multiplier0();shd_pos1+=shd_pos_offset*shadow_normal_offset_multiplier1();\n#endif\nv_pos_light_view_0=u_light_matrix_0*vec4(shd_pos0,1);v_pos_light_view_1=u_light_matrix_1*vec4(shd_pos1,1);v_depth=gl_Position.w;\n#endif\n#endif\n#ifdef INDICATOR_CUTOUT\nv_z_offset=e;\n#else\n#ifdef Z_OFFSET\n#ifdef RENDER_SHADOWS\nv_z_offset=e;\n#endif\n#endif\n#endif\n}'), terrainRaster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;in vec2 v_pos0;\n#ifdef FOG\nin float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nin vec4 v_pos_light_view_0;in vec4 v_pos_light_view_1;\n#endif\nuniform vec3 u_ground_shadow_factor;void main() {vec4 image_color=texture(u_image0,v_pos0);vec4 color;\n#ifdef LIGHTING_3D_MODE\nconst vec3 normal=vec3(0.0,0.0,1.0);\n#ifdef RENDER_SHADOWS\nfloat cutoffOpacity=1.0;\n#ifdef RENDER_CUTOFF\ncutoffOpacity=cutoff_opacity(u_cutoff_params,1.0/gl_FragCoord.w);\n#endif\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nvec3 unlit_base=image_color.rgb*(1.0-image_color.a);vec3 emissive_base=image_color.rgb*image_color.a;float ndotl=u_shadow_direction.z;float occlusion=ndotl < 0.0 ? 1.0 : shadow_occlusion(v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w,0.0);ndotl=max(0.0,ndotl);vec3 lit=apply_lighting(unlit_base,normal,mix(1.0,(1.0-(u_shadow_intensity*occlusion))*ndotl,cutoffOpacity));vec3 emissive=compute_emissive_draped(emissive_base,1.0-u_shadow_intensity,occlusion,u_ground_shadow_factor);color.rgb=lit+emissive;color.a=1.0;\n#else\nfloat lighting_factor=shadowed_light_factor_normal_unbiased(normal,v_pos_light_view_0,v_pos_light_view_1,1.0/gl_FragCoord.w);color=apply_lighting(image_color,normal,mix(1.0,lighting_factor,cutoffOpacity));\n#endif\n#else\nfloat lighting_factor=u_lighting_directional_dir.z;color=apply_lighting(image_color,normal,lighting_factor);\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor.rgb=mix(color.rgb,image_color.rgb,image_color.a);color.a=1.0;\n#endif\n#endif\n#else\ncolor=image_color;\n#endif\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#else\ncolor=fog_dither(fog_apply_from_vert(color,v_fog_opacity));\n#endif\n#endif\nglFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;uniform float u_skirt_height;in vec2 a_pos;out vec2 v_pos0;\n#ifdef FOG\nout float v_fog_opacity;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out vec4 v_pos_light_view_0;out vec4 v_pos_light_view_1;out float v_depth;\n#endif\nvoid main() {vec3 decomposedPosAndSkirt=decomposeToPosAndSkirt(a_pos);float skirt=decomposedPosAndSkirt.z;vec2 decodedPos=decomposedPosAndSkirt.xy;float elevation=elevation(decodedPos)-skirt*u_skirt_height;v_pos0=decodedPos/8192.0;gl_Position=u_matrix*vec4(decodedPos,elevation,1.0);\n#ifdef FOG\n#ifdef ZERO_EXAGGERATION\nv_fog_pos=fog_position(decodedPos);\n#else\nv_fog_opacity=fog(fog_position(vec3(decodedPos,elevation)));\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec3 pos=vec3(decodedPos,elevation);v_pos_light_view_0=u_light_matrix_0*vec4(pos,1.);v_pos_light_view_1=u_light_matrix_1*vec4(pos,1.);\n#endif\n}'), terrainDepth: Go("precision highp float;in float v_depth;void main() {glFragColor=pack_depth(v_depth);}", '#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_matrix;in vec2 a_pos;out float v_depth;void main() {float elevation=elevation(a_pos);gl_Position=u_matrix*vec4(a_pos,elevation,1.0);v_depth=gl_Position.z/gl_Position.w;}'), skybox: Go('#include "_prelude_fog.fragment.glsl"\nin lowp vec3 v_uv;uniform lowp samplerCube u_cubemap;uniform lowp float u_opacity;uniform highp float u_temporal_offset;uniform highp vec3 u_sun_direction;float sun_disk(highp vec3 ray_direction,highp vec3 sun_direction) {highp float cos_angle=dot(normalize(ray_direction),sun_direction);const highp float cos_sun_angular_diameter=0.99996192306;const highp float smoothstep_delta=1e-5;return smoothstep(\ncos_sun_angular_diameter-smoothstep_delta,cos_sun_angular_diameter+smoothstep_delta,cos_angle);}float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec3 uv=v_uv;const float y_bias=0.015;uv.y+=y_bias;uv.y=pow(abs(uv.y),1.0/5.0);uv.y=map(uv.y,0.0,1.0,-1.0,1.0);vec3 sky_color=texture(u_cubemap,uv).rgb;\n#ifdef FOG\nsky_color=fog_apply_sky_gradient(v_uv.xzy,sky_color);\n#endif\nsky_color+=0.1*sun_disk(v_uv,u_sun_direction);glFragColor=vec4(sky_color*u_opacity,u_opacity);\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Ro), skyboxGradient: Go('#include "_prelude_fog.fragment.glsl"\nin highp vec3 v_uv;uniform lowp sampler2D u_color_ramp;uniform highp vec3 u_center_direction;uniform lowp float u_radius;uniform lowp float u_opacity;uniform highp float u_temporal_offset;void main() {float progress=acos(dot(normalize(v_uv),u_center_direction))/u_radius;vec4 color=texture(u_color_ramp,vec2(progress,0.5));\n#ifdef FOG\ncolor.rgb=fog_apply_sky_gradient(v_uv.xzy,color.rgb/color.a)*color.a;\n#endif\ncolor*=u_opacity;glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\n}', Ro), skyboxCapture: Go("\nin highp vec3 v_position;uniform highp float u_sun_intensity;uniform highp float u_luminance;uniform lowp vec3 u_sun_direction;uniform highp vec4 u_color_tint_r;uniform highp vec4 u_color_tint_m;precision highp float;\n#define BETA_R                  vec3(5.5e-6,13.0e-6,22.4e-6)\n#define BETA_M                  vec3(21e-6,21e-6,21e-6)\n#define MIE_G                   0.76\n#define DENSITY_HEIGHT_SCALE_R  8000.0\n#define DENSITY_HEIGHT_SCALE_M  1200.0\n#define PLANET_RADIUS           6360e3\n#define ATMOSPHERE_RADIUS       6420e3\n#define SAMPLE_STEPS            10\n#define DENSITY_STEPS           4\nfloat ray_sphere_exit(vec3 orig,vec3 dir,float radius) {float a=dot(dir,dir);float b=2.0*dot(dir,orig);float c=dot(orig,orig)-radius*radius;float d=sqrt(b*b-4.0*a*c);return (-b+d)/(2.0*a);}vec3 extinction(vec2 density) {return exp(-vec3(BETA_R*u_color_tint_r.a*density.x+BETA_M*u_color_tint_m.a*density.y));}vec2 local_density(vec3 point) {float height=max(length(point)-PLANET_RADIUS,0.0);float exp_r=exp(-height/DENSITY_HEIGHT_SCALE_R);float exp_m=exp(-height/DENSITY_HEIGHT_SCALE_M);return vec2(exp_r,exp_m);}float phase_ray(float cos_angle) {return (3.0/(16.0*PI))*(1.0+cos_angle*cos_angle);}float phase_mie(float cos_angle) {return (3.0/(8.0*PI))*((1.0-MIE_G*MIE_G)*(1.0+cos_angle*cos_angle))/((2.0+MIE_G*MIE_G)*pow(1.0+MIE_G*MIE_G-2.0*MIE_G*cos_angle,1.5));}vec2 density_to_atmosphere(vec3 point,vec3 light_dir) {float ray_len=ray_sphere_exit(point,light_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(DENSITY_STEPS);vec2 density_point_to_atmosphere=vec2(0.0);for (int i=0; i < DENSITY_STEPS;++i) {vec3 point_on_ray=point+light_dir*((float(i)+0.5)*step_len);density_point_to_atmosphere+=local_density(point_on_ray)*step_len;;}return density_point_to_atmosphere;}vec3 atmosphere(vec3 ray_dir,vec3 sun_direction,float sun_intensity) {vec2 density_orig_to_point=vec2(0.0);vec3 scatter_r=vec3(0.0);vec3 scatter_m=vec3(0.0);vec3 origin=vec3(0.0,PLANET_RADIUS,0.0);float ray_len=ray_sphere_exit(origin,ray_dir,ATMOSPHERE_RADIUS);float step_len=ray_len/float(SAMPLE_STEPS);for (int i=0; i < SAMPLE_STEPS;++i) {vec3 point_on_ray=origin+ray_dir*((float(i)+0.5)*step_len);vec2 density=local_density(point_on_ray)*step_len;density_orig_to_point+=density;vec2 density_point_to_atmosphere=density_to_atmosphere(point_on_ray,sun_direction);vec2 density_orig_to_atmosphere=density_orig_to_point+density_point_to_atmosphere;vec3 extinction=extinction(density_orig_to_atmosphere);scatter_r+=density.x*extinction;scatter_m+=density.y*extinction;}float cos_angle=dot(ray_dir,sun_direction);float phase_r=phase_ray(cos_angle);float phase_m=phase_mie(cos_angle);vec3 beta_r=BETA_R*u_color_tint_r.rgb*u_color_tint_r.a;vec3 beta_m=BETA_M*u_color_tint_m.rgb*u_color_tint_m.a;return (scatter_r*phase_r*beta_r+scatter_m*phase_m*beta_m)*sun_intensity;}const float A=0.15;const float B=0.50;const float C=0.10;const float D=0.20;const float E=0.02;const float F=0.30;vec3 uncharted2_tonemap(vec3 x) {return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}void main() {vec3 ray_direction=v_position;ray_direction.y=pow(ray_direction.y,5.0);const float y_bias=0.015;ray_direction.y+=y_bias;vec3 color=atmosphere(normalize(ray_direction),u_sun_direction,u_sun_intensity);float white_scale=1.0748724675633854;color=uncharted2_tonemap((log2(2.0/pow(u_luminance,4.0)))*color)*white_scale;glFragColor=vec4(color,1.0);}", "in highp vec3 a_pos_3f;uniform mat3 u_matrix_3f;out highp vec3 v_position;float map(float value,float start,float end,float new_start,float new_end) {return ((value-start)*(new_end-new_start))/(end-start)+new_start;}void main() {vec4 pos=vec4(u_matrix_3f*a_pos_3f,1.0);v_position=pos.xyz;v_position.y*=-1.0;v_position.y=map(v_position.y,-1.0,1.0,0.0,1.0);gl_Position=vec4(a_pos_3f.xy,0.0,1.0);}"), globeRaster: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform sampler2D u_image0;uniform float u_far_z_cutoff;in vec2 v_pos0;\n#ifndef FOG\nuniform highp vec3 u_frustum_tl;uniform highp vec3 u_frustum_tr;uniform highp vec3 u_frustum_br;uniform highp vec3 u_frustum_bl;uniform highp vec3 u_globe_pos;uniform highp float u_globe_radius;uniform vec2 u_viewport;\n#endif\nvoid main() {vec4 color;\n#ifdef CUSTOM_ANTIALIASING\nhighp vec2 uv=gl_FragCoord.xy/u_viewport;highp vec3 ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,uv.x),mix(u_frustum_bl,u_frustum_br,uv.x),1.0-uv.y);highp vec3 dir=normalize(ray_dir);highp vec3 closest_point=dot(u_globe_pos,dir)*dir;highp float norm_dist_from_center=1.0-length(closest_point-u_globe_pos)/u_globe_radius;const float antialias_pixel=2.0;highp float antialias_factor=antialias_pixel*fwidth(norm_dist_from_center);highp float antialias=smoothstep(0.0,antialias_factor,norm_dist_from_center);vec4 raster=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\nraster=apply_lighting_with_emission_ground(raster,raster.a);color=vec4(clamp(raster.rgb,vec3(0),vec3(1))*antialias,antialias);\n#else\nraster=apply_lighting_ground(raster);color=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=vec4(raster.rgb*antialias,raster.a*antialias);\n#endif\n#else\ncolor=texture(u_image0,v_pos0);\n#ifdef LIGHTING_3D_MODE\n#ifdef LIGHTING_3D_ALPHA_EMISSIVENESS\ncolor=apply_lighting_with_emission_ground(color,color.a);color.a=1.0;\n#else\ncolor=apply_lighting_ground(color);\n#endif\n#endif\n#endif\n#ifdef FOG\ncolor=fog_dither(fog_apply_premultiplied(color,v_fog_pos));\n#endif\ncolor*=1.0-step(u_far_z_cutoff,1.0/gl_FragCoord.w);glFragColor=color;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_terrain.vertex.glsl"\nuniform mat4 u_proj_matrix;uniform mat4 u_normalize_matrix;uniform mat4 u_globe_matrix;uniform mat4 u_merc_matrix;uniform float u_zoom_transition;uniform vec2 u_merc_center;uniform mat3 u_grid_matrix;uniform float u_skirt_height;\n#ifdef GLOBE_POLES\nin vec3 a_globe_pos;in vec2 a_uv;\n#else\nin vec2 a_pos;\n#endif\nout vec2 v_pos0;void main() {\n#ifdef GLOBE_POLES\nvec3 globe_pos=a_globe_pos;vec2 uv=a_uv;\n#else\nfloat tiles=u_grid_matrix[0][2];float idx=u_grid_matrix[1][2];float idy=u_grid_matrix[2][2];vec3 decomposed_pos_and_skirt=decomposeToPosAndSkirt(a_pos);vec3 latLng=u_grid_matrix*vec3(decomposed_pos_and_skirt.xy,1.0);float mercatorY=mercatorYfromLat(latLng[0]);float uvY=mercatorY*tiles-idy;float mercatorX=mercatorXfromLng(latLng[1]);float uvX=mercatorX*tiles-idx;vec3 globe_pos=latLngToECEF(latLng.xy);vec2 merc_pos=vec2(mercatorX,mercatorY);vec2 uv=vec2(uvX,uvY);\n#endif\nv_pos0=uv;vec2 tile_pos=uv*EXTENT;vec3 globe_derived_up_vector=normalize(globe_pos)*u_tile_up_scale;\n#ifdef GLOBE_POLES\nvec3 up_vector=globe_derived_up_vector;\n#else\nvec3 up_vector=elevationVector(tile_pos);\n#endif\nfloat height=elevation(tile_pos);globe_pos+=up_vector*height;\n#ifndef GLOBE_POLES\nglobe_pos-=globe_derived_up_vector*u_skirt_height*decomposed_pos_and_skirt.z;\n#endif\n#ifdef GLOBE_POLES\nvec4 interpolated_pos=u_globe_matrix*vec4(globe_pos,1.0);\n#else\nvec4 globe_world_pos=u_globe_matrix*vec4(globe_pos,1.0);vec4 merc_world_pos=vec4(0.0);if (u_zoom_transition > 0.0) {merc_world_pos=vec4(merc_pos,height-u_skirt_height*decomposed_pos_and_skirt.z,1.0);merc_world_pos.xy-=u_merc_center;merc_world_pos.x=wrap(merc_world_pos.x,-0.5,0.5);merc_world_pos=u_merc_matrix*merc_world_pos;}vec4 interpolated_pos=vec4(mix(globe_world_pos.xyz,merc_world_pos.xyz,u_zoom_transition),1.0);\n#endif\ngl_Position=u_proj_matrix*interpolated_pos;\n#ifdef FOG\nv_fog_pos=fog_position((u_normalize_matrix*vec4(globe_pos,1.0)).xyz);\n#endif\n}'), globeAtmosphere: Go('#include "_prelude_fog.fragment.glsl"\nuniform float u_transition;uniform highp float u_fadeout_range;uniform highp float u_temporal_offset;uniform vec4 u_color;uniform vec4 u_high_color;uniform vec4 u_space_color;uniform float u_horizon_angle;in highp vec3 v_ray_dir;in highp vec3 v_horizon_dir;void main() {highp vec3 dir=normalize(v_ray_dir);float globe_pos_dot_dir;\n#ifdef PROJECTION_GLOBE_VIEW\nglobe_pos_dot_dir=dot(u_globe_pos,dir);highp vec3 closest_point_forward=abs(globe_pos_dot_dir)*dir;float norm_dist_from_center=length(closest_point_forward-u_globe_pos)/u_globe_radius;if (norm_dist_from_center < 0.98) {\n#ifdef ALPHA_PASS\nglFragColor=vec4(0,0,0,0);return;\n#else\n#ifdef NATIVE\nglFragColor=vec4(1,1,1,1);\n#else\nglFragColor=vec4(0,0,0,1);\n#endif\nreturn;\n#endif\n}\n#endif\nhighp vec3 horizon_dir=normalize(v_horizon_dir);float horizon_angle_mercator=dir.y < horizon_dir.y ?\n0.0 : max(acos(clamp(dot(dir,horizon_dir),-1.0,1.0)),0.0);float horizon_angle;\n#ifdef PROJECTION_GLOBE_VIEW\nhighp vec3 closest_point=globe_pos_dot_dir*dir;highp float closest_point_to_center=length(closest_point-u_globe_pos);highp float theta=asin(clamp(closest_point_to_center/length(u_globe_pos),-1.0,1.0));horizon_angle=globe_pos_dot_dir < 0.0 ?\nPI-theta-u_horizon_angle : theta-u_horizon_angle;float angle_t=pow(u_transition,10.0);horizon_angle=mix(horizon_angle,horizon_angle_mercator,angle_t);\n#else\nhorizon_angle=horizon_angle_mercator;\n#endif\nhorizon_angle/=PI;float t=exp(-horizon_angle/u_fadeout_range);float alpha_0=u_color.a;float alpha_1=u_high_color.a;float alpha_2=u_space_color.a;vec3 color_stop_0=u_color.rgb;vec3 color_stop_1=u_high_color.rgb;vec3 color_stop_2=u_space_color.rgb;\n#ifdef ALPHA_PASS\nfloat a0=mix(alpha_2,1.0,alpha_1);float a1=mix(a0,1.0,alpha_0);float a2=mix(a0,a1,t);float a =mix(alpha_2,a2,t);glFragColor=vec4(1.0,1.0,1.0,a);\n#else\nvec3 c0=mix(color_stop_2,color_stop_1,alpha_1);vec3 c1=mix(c0,color_stop_0,alpha_0);vec3 c2=mix(c0,c1,t);vec3 c=c2;glFragColor=vec4(c*t,t);\n#endif\n}', "in vec3 a_pos;in vec2 a_uv;uniform vec3 u_frustum_tl;uniform vec3 u_frustum_tr;uniform vec3 u_frustum_br;uniform vec3 u_frustum_bl;uniform float u_horizon;out highp vec3 v_ray_dir;out highp vec3 v_horizon_dir;void main() {v_ray_dir=mix(\nmix(u_frustum_tl,u_frustum_tr,a_uv.x),mix(u_frustum_bl,u_frustum_br,a_uv.x),a_uv.y);v_horizon_dir=mix(\nmix(u_frustum_tl,u_frustum_bl,u_horizon),mix(u_frustum_tr,u_frustum_br,u_horizon),a_uv.x);gl_Position=vec4(a_pos,1.0);}"), model: Go('#include "_prelude_fog.fragment.glsl"\n#include "_prelude_shadow.fragment.glsl"\n#include "_prelude_lighting.glsl"\nuniform float u_opacity;uniform vec3 u_lightcolor;uniform vec3 u_lightpos;uniform float u_lightintensity;uniform vec4 u_baseColorFactor;uniform vec4 u_emissiveFactor;uniform float u_metallicFactor;uniform float u_roughnessFactor;uniform float u_emissive_strength;in highp vec4 v_position_height;in lowp vec4 v_color_mix;\n#ifdef RENDER_SHADOWS\nin highp vec4 v_pos_light_view_0;in highp vec4 v_pos_light_view_1;in float v_depth_shadows;\n#endif\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nuniform vec4 u_occlusionTextureTransform;\n#endif\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#ifdef HAS_ATTRIBUTE_a_pbr\nin lowp vec4 v_roughness_metallic_emissive_alpha;in mediump vec4 v_height_based_emission_params;\n#endif\n#ifdef HAS_TEXTURE_u_baseColorTexture\nuniform sampler2D u_baseColorTexture;uniform bool u_baseTextureIsAlpha;uniform bool u_alphaMask;uniform float u_alphaCutoff;\n#endif\n#ifdef HAS_TEXTURE_u_metallicRoughnessTexture\nuniform sampler2D u_metallicRoughnessTexture;\n#endif\n#ifdef HAS_TEXTURE_u_occlusionTexture\nuniform sampler2D u_occlusionTexture;uniform float u_aoIntensity;\n#endif\n#ifdef HAS_TEXTURE_u_normalTexture\nuniform sampler2D u_normalTexture;\n#endif\n#ifdef HAS_TEXTURE_u_emissionTexture\nuniform sampler2D u_emissionTexture;\n#endif\n#ifdef APPLY_LUT_ON_GPU\nuniform highp sampler3D u_lutTexture;\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nin highp float v_depth;uniform highp sampler2D u_depthTexture;uniform highp vec2 u_inv_depth_size;uniform highp vec2 u_depth_range_unpack;\n#ifdef DEPTH_D24\nhighp float unpack_depth(highp float depth) {return  depth*u_depth_range_unpack.x+u_depth_range_unpack.y;}\n#else\nhighp float unpack_depth_rgba(highp vec4 rgba_depth)\n{const highp vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(rgba_depth,bit_shift)*2.0-1.0;}\n#endif\nbool isOccluded() {highp vec2 coord=gl_FragCoord.xy*u_inv_depth_size;\n#ifdef DEPTH_D24\nhighp float depth=unpack_depth(texture(u_depthTexture,coord).r);\n#else\nhighp float depth=unpack_depth_rgba(texture(u_depthTexture,coord));\n#endif\nreturn v_depth > depth+0.0005;}\n#endif\n#define saturate(_x) clamp(_x,0.,1.)\nvec3 linearTosRGB(vec3 color) {return pow(color,vec3(1./2.2));}vec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}float calculate_NdotL(vec3 normal,vec3 lightDir) {const float ext=0.70710678118;return (clamp(dot(normal,lightDir),-ext,1.0)+ext)/(1.0+ext);}vec3 getDiffuseShadedColor(vec3 albedo,vec3 normal,vec3 lightDir,vec3 lightColor)\n{\n#ifdef LIGHTING_3D_MODE\nvec3 transformed_normal=vec3(-normal.xy,normal.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=saturate(dot(transformed_normal,u_lighting_directional_dir));\n#endif\nreturn apply_lighting(albedo,transformed_normal,lighting_factor);\n#else\nvec3 n=normal;float colorvalue=((albedo.x*0.2126)+(albedo.y*0.7152))+(albedo.z*0.0722);vec3 c=vec3(0.03,0.03,0.03);float directional=clamp(dot(n,vec3(lightDir)),0.0,1.0);directional=mix(1.0-u_lightintensity,max((1.0-colorvalue)+u_lightintensity,1.0),directional);vec3 c3=c+clamp((albedo*directional)*lightColor,mix(vec3(0.0),vec3(0.3),vec3(1.0)-lightColor),vec3(1.0));return c3;\n#endif\n}vec4 getBaseColor() {vec4 albedo=u_baseColorFactor;\n#ifdef HAS_ATTRIBUTE_a_color_3f\nalbedo*=vec4(color_3f,1.0);\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#else\n#ifdef HAS_ATTRIBUTE_a_color_4f\nalbedo*=color_4f;\n#endif\n#endif\n#if defined (HAS_TEXTURE_u_baseColorTexture) && defined (HAS_ATTRIBUTE_a_uv_2f)\nvec4 texColor=texture(u_baseColorTexture,uv_2f);if(u_alphaMask) {if (texColor.w < u_alphaCutoff) {discard;}}\n#ifdef UNPREMULT_TEXTURE_IN_SHADER\nif(texColor.w > 0.0) {texColor.rgb/=texColor.w;}texColor.w=1.0;\n#endif\nif(u_baseTextureIsAlpha) {if (texColor.r < 0.5) {discard;}} else {texColor.rgb=sRGBToLinear(texColor.rgb);albedo*=texColor;}\n#endif\nvec4 color=vec4(mix(albedo.rgb,v_color_mix.rgb,v_color_mix.a),albedo.a);\n#ifdef APPLY_LUT_ON_GPU\ncolor=applyLUT(u_lutTexture,color);\n#endif\nreturn color;}highp mat3 cotangentFrame(highp vec3 N,highp vec3 p,highp vec2 uv ) {\n#ifdef HAS_TEXTURE_u_normalTexture\nhighp vec3 dp1=vec3(dFdx(p.x),dFdx(p.y),dFdx(p.z));highp vec3 dp2=vec3(dFdy(p.x),dFdy(p.y),dFdy(p.z));highp vec2 duv1=vec2(dFdx(uv.x),dFdx(uv.y));highp vec2 duv2=vec2(dFdy(uv.x),dFdy(uv.y));highp vec3 dp2perp=cross( dp2,N );highp vec3 dp1perp=cross( N,dp1 );highp vec3 T=dp2perp*duv1.x+dp1perp*duv2.x;highp vec3 B=dp2perp*duv1.y+dp1perp*duv2.y;highp float lengthT=dot(T,T);highp float lengthB=dot(B,B);highp float maxLength=max(lengthT,lengthB);highp float invmax=inversesqrt( maxLength );highp mat3 res=mat3( T*invmax,B*invmax,N );return res;\n#else\nreturn mat3(1.0);\n#endif\n}highp vec3 getNormal(){highp vec3 n;\n#ifdef HAS_ATTRIBUTE_a_normal_3f\nn=normalize(normal_3f);\n#else\nhighp vec3 fdx=vec3(dFdx(v_position_height.x),dFdx(v_position_height.y),dFdx(v_position_height.z));highp vec3 fdy=vec3(dFdy(v_position_height.x),dFdy(v_position_height.y),dFdy(v_position_height.z));n=normalize(cross(fdx,fdy))*-1.0;\n#endif\n#if defined(HAS_TEXTURE_u_normalTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nvec3 nMap=texture( u_normalTexture,uv_2f).xyz;nMap=normalize(2.0*nMap-vec3(1.0));highp vec3 v=normalize(-v_position_height.xyz);highp mat3 TBN=cotangentFrame(n,v,uv_2f);n=normalize(TBN*nMap);\n#endif\nreturn n;}struct Material {float perceptualRoughness;float alphaRoughness;float metallic;vec3 f90;vec4 baseColor;vec3 diffuseColor;vec3 specularColor;highp vec3 normal;};Material getPBRMaterial() {Material mat;mat.baseColor=getBaseColor();mat.perceptualRoughness=u_roughnessFactor;mat.metallic=u_metallicFactor;\n#ifdef HAS_ATTRIBUTE_a_pbr\nmat.perceptualRoughness=v_roughness_metallic_emissive_alpha.x;mat.metallic=v_roughness_metallic_emissive_alpha.y;mat.baseColor.w*=v_roughness_metallic_emissive_alpha.w;\n#endif\n#if defined(HAS_TEXTURE_u_metallicRoughnessTexture) && defined(HAS_ATTRIBUTE_a_uv_2f) \nvec4 mrSample=texture(u_metallicRoughnessTexture,uv_2f);mat.perceptualRoughness*=mrSample.g;mat.metallic*=mrSample.b;\n#endif\nconst float c_minRoughness=0.04;mat.perceptualRoughness=clamp(mat.perceptualRoughness,c_minRoughness,1.0);mat.metallic=saturate(mat.metallic);mat.alphaRoughness=mat.perceptualRoughness*mat.perceptualRoughness;const vec3 f0=vec3(0.04);mat.diffuseColor=mat.baseColor.rgb*(vec3(1.0)-f0);mat.diffuseColor*=1.0-mat.metallic;mat.specularColor=mix(f0,mat.baseColor.rgb,mat.metallic);highp float reflectance=max(max(mat.specularColor.r,mat.specularColor.g),mat.specularColor.b);highp float reflectance90=saturate(reflectance*25.0);mat.f90=vec3(reflectance90);mat.normal=getNormal();return mat;}float V_GGX(float NdotL,float NdotV,float roughness)\n{float a2=roughness*roughness;float GGXV=NdotL*sqrt(NdotV*NdotV*(1.0-a2)+a2);float GGXL=NdotV*sqrt(NdotL*NdotL*(1.0-a2)+a2);return 0.5/(GGXV+GGXL);}float V_GGXFast(float NdotL,float NdotV,float roughness) {float a=roughness;float GGXV=NdotL*(NdotV*(1.0-a)+a);float GGXL=NdotV*(NdotL*(1.0-a)+a);return 0.5/(GGXV+GGXL);}vec3 F_Schlick(vec3 specularColor,vec3 f90,float VdotH)\n{return specularColor+(f90-specularColor)*pow(clamp(1.0-VdotH,0.0,1.0),5.0);}vec3 F_SchlickFast(vec3 specularColor,float VdotH)\n{float x=1.0-VdotH;float x4=x*x*x*x;return specularColor+(1.0-specularColor)*x4*x;}float D_GGX(highp float NdotH,float alphaRoughness)\n{highp float a4=alphaRoughness*alphaRoughness;highp float f=(NdotH*a4-NdotH)*NdotH+1.0;return a4/(PI*f*f);}vec3 diffuseBurley(Material mat,float LdotH,float NdotL,float NdotV)\n{float f90=2.0*LdotH*LdotH*mat.alphaRoughness-0.5;return (mat.diffuseColor/PI)*(1.0+f90*pow((1.0-NdotL),5.0))*(1.0+f90*pow((1.0-NdotV),5.0));}vec3 diffuseLambertian(Material mat)\n{\n#ifdef LIGHTING_3D_MODE\nreturn mat.diffuseColor;\n#else\nreturn mat.diffuseColor/PI;\n#endif\n}vec3 EnvBRDFApprox(vec3 specularColor,float roughness,highp float NdotV)\n{vec4 c0=vec4(-1,-0.0275,-0.572,0.022);vec4 c1=vec4(1,0.0425,1.04,-0.04);highp vec4 r=roughness*c0+c1;highp float a004=min(r.x*r.x,exp2(-9.28*NdotV))*r.x+r.y;vec2 AB=vec2(-1.04,1.04)*a004+r.zw;return specularColor*AB.x+AB.y;}vec3 computeIndirectLightContribution(Material mat,float NdotV,vec3 normal)\n{vec3 env_light=vec3(0.65,0.65,0.65);\n#ifdef LIGHTING_3D_MODE\nfloat ambient_factor=calculate_ambient_directional_factor(normal);env_light=u_lighting_ambient_color*ambient_factor;\n#endif\nvec3 envBRDF=EnvBRDFApprox(mat.specularColor,mat.perceptualRoughness,NdotV);vec3 indirectSpecular= envBRDF*env_light;vec3 indirectDiffuse=mat.diffuseColor*env_light;return indirectSpecular+indirectDiffuse;}vec3 computeLightContribution(Material mat,vec3 lightPosition,vec3 lightColor)\n{highp vec3 n=mat.normal;highp vec3 v=normalize(-v_position_height.xyz);highp vec3 l=normalize(lightPosition);highp vec3 h=normalize(v+l);float NdotV=clamp(abs(dot(n,v)),0.001,1.0);float NdotL=saturate(dot(n,l));highp float NdotH=saturate(dot(n,h));float VdotH=saturate(dot(v,h));vec3 f=F_SchlickFast(mat.specularColor,VdotH);float g=V_GGXFast(NdotL,NdotV,mat.alphaRoughness);float d=D_GGX(NdotH,mat.alphaRoughness);vec3 diffuseTerm=(1.0-f)*diffuseLambertian(mat);vec3 specularTerm=f*g*d;vec3 transformed_normal=vec3(-n.xy,n.z);float lighting_factor;\n#ifdef RENDER_SHADOWS\nlighting_factor=shadowed_light_factor_normal(transformed_normal,v_pos_light_view_0,v_pos_light_view_1,v_depth_shadows);\n#else\nlighting_factor=NdotL;\n#endif\nvec3 directLightColor=(specularTerm+diffuseTerm)*lighting_factor*lightColor;vec3 indirectLightColor=computeIndirectLightContribution(mat,NdotV,transformed_normal);vec3 color=(saturate(directLightColor)+indirectLightColor);float intensityFactor=1.0;\n#if !defined(LIGHTING_3D_MODE)\nconst vec3 luminosityFactor=vec3(0.2126,0.7152,0.0722);float luminance=dot(diffuseTerm,luminosityFactor);intensityFactor=mix((1.0-u_lightintensity),max((1.0-luminance+u_lightintensity),1.0),NdotL);\n#endif\ncolor*=intensityFactor;return color;}void main() {\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nif (isOccluded()) {discard;}\n#endif\nvec3 lightDir=u_lightpos;vec3 lightColor=u_lightcolor;\n#ifdef LIGHTING_3D_MODE\nlightDir=u_lighting_directional_dir;lightDir.xy=-lightDir.xy;lightColor=u_lighting_directional_color;\n#endif\nvec4 finalColor;\n#ifdef DIFFUSE_SHADED\nvec3 N=getNormal();vec3 baseColor=getBaseColor().rgb;vec3 diffuse=getDiffuseShadedColor(baseColor,N,lightDir,lightColor);\n#ifdef HAS_TEXTURE_u_occlusionTexture\nfloat ao=(texture(u_occlusionTexture,uv_2f).r-1.0)*u_aoIntensity+1.0;diffuse*=ao;\n#endif\nfinalColor=vec4(mix(diffuse,baseColor,u_emissive_strength),1.0)*u_opacity;\n#else\nMaterial mat=getPBRMaterial();vec3 color=computeLightContribution(mat,lightDir,lightColor);float ao=1.0;\n#if defined (HAS_TEXTURE_u_occlusionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\n#ifdef OCCLUSION_TEXTURE_TRANSFORM\nvec2 uv=uv_2f.xy*u_occlusionTextureTransform.zw+u_occlusionTextureTransform.xy;\n#else\nvec2 uv=uv_2f;\n#endif\nao=(texture(u_occlusionTexture,uv).x-1.0)*u_aoIntensity+1.0;color*=ao;\n#endif\nvec4 emissive=u_emissiveFactor;\n#if defined(HAS_TEXTURE_u_emissionTexture) && defined(HAS_ATTRIBUTE_a_uv_2f)\nemissive.rgb*=sRGBToLinear(texture(u_emissionTexture,uv_2f).rgb);\n#endif\n#ifdef APPLY_LUT_ON_GPU\nfloat emissiveFactorLength=max(length(u_emissiveFactor.rgb),0.001);emissive.rgb=sRGBToLinear(applyLUT(u_lutTexture,linearTosRGB(emissive.rgb/emissiveFactorLength).rbg))*emissiveFactorLength;\n#endif\ncolor+=emissive.rgb;float opacity=mat.baseColor.w*u_opacity;\n#ifdef HAS_ATTRIBUTE_a_pbr\nfloat resEmission=v_roughness_metallic_emissive_alpha.z;resEmission*=v_height_based_emission_params.z+v_height_based_emission_params.w*pow(clamp(v_height_based_emission_params.x,0.0,1.0),v_height_based_emission_params.y);vec3 color_mix=v_color_mix.rgb;\n#ifdef APPLY_LUT_ON_GPU\ncolor_mix=applyLUT(u_lutTexture,color_mix);\n#endif\ncolor=mix(color,color_mix,min(1.0,resEmission));\n#ifdef HAS_ATTRIBUTE_a_color_4f\nfloat distance=length(vec2(1.3*max(0.0,abs(color_4f.x)-color_4f.z),color_4f.y));distance+= mix(0.5,0.0,clamp(resEmission-1.0,0.0,1.0));opacity*=v_roughness_metallic_emissive_alpha.w*saturate(1.0-distance*distance);\n#endif\n#endif\nvec3 unlitColor=mat.baseColor.rgb*ao+emissive.rgb;color=mix(color,unlitColor,u_emissive_strength);color=linearTosRGB(color);color*=opacity;finalColor=vec4(color,opacity);\n#endif\n#ifdef FOG\nfinalColor=fog_dither(fog_apply_premultiplied(finalColor,v_fog_pos,v_position_height.w));\n#endif\n#ifdef RENDER_CUTOFF\nfinalColor*=v_cutoff_opacity;\n#endif\n#ifdef INDICATOR_CUTOUT\nfinalColor=applyCutout(finalColor,v_position_height.w);\n#endif\nglFragColor=finalColor;\n#ifdef OVERDRAW_INSPECTOR\nglFragColor=vec4(1.0);\n#endif\nHANDLE_WIREFRAME_DEBUG;}', '#include "_prelude_fog.vertex.glsl"\n#include "_prelude_shadow.vertex.glsl"\nin vec3 a_pos_3f;\n#pragma mapbox: define-attribute highp vec3 normal_3f\n#pragma mapbox: define-attribute highp vec2 uv_2f\n#pragma mapbox: define-attribute highp vec3 color_3f\n#pragma mapbox: define-attribute highp vec4 color_4f\n#pragma mapbox: define-attribute-vertex-shader-only highp vec4 pbr\n#pragma mapbox: define-attribute-vertex-shader-only highp vec3 heightBasedEmissiveStrength\nuniform mat4 u_matrix;uniform mat4 u_node_matrix;uniform mat4 u_lighting_matrix;uniform vec3 u_camera_pos;uniform vec4 u_color_mix;\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_normal_matrix;\n#endif\n#ifdef RENDER_SHADOWS\nuniform mat4 u_light_matrix_0;uniform mat4 u_light_matrix_1;out highp vec4 v_pos_light_view_0;out highp vec4 v_pos_light_view_1;out float v_depth_shadows;\n#endif\nout vec4 v_position_height;out lowp vec4 v_color_mix;\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nout highp float v_depth;\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\nout lowp vec4 v_roughness_metallic_emissive_alpha;out mediump vec4 v_height_based_emission_params;\n#endif\nvec3 sRGBToLinear(vec3 srgbIn) {return pow(srgbIn,vec3(2.2));}void main() {\n#pragma mapbox: initialize-attribute highp vec3 normal_3f\n#pragma mapbox: initialize-attribute highp vec2 uv_2f\n#pragma mapbox: initialize-attribute highp vec3 color_3f\n#pragma mapbox: initialize-attribute highp vec4 color_4f\n#pragma mapbox: initialize-attribute-custom highp vec4 pbr\n#pragma mapbox: initialize-attribute-custom highp vec3 heightBasedEmissiveStrength\nhighp mat4 normal_matrix;\n#ifdef INSTANCED_ARRAYS\nnormal_matrix=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\nnormal_matrix=u_normal_matrix;\n#endif\nvec3 local_pos;mat3 rs;\n#ifdef MODEL_POSITION_ON_GPU\nvec3 pos_color=normal_matrix[0].xyz;vec4 translate=normal_matrix[1];vec3 pos_a=floor(pos_color);vec3 rgb=1.05*(pos_color-pos_a);float hidden=float(pos_a.x > EXTENT);float color_mix=pos_a.z/100.0;v_color_mix=vec4(sRGBToLinear(rgb),color_mix);float meter_to_tile=normal_matrix[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);rs[0].x=normal_matrix[1].w;rs[0].yz=normal_matrix[2].xy;rs[1].xy=normal_matrix[2].zw;rs[1].z=normal_matrix[3].x;rs[2].xyz=normal_matrix[3].yzw;vec4 pos_node=u_lighting_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;local_pos=pos.xyz;gl_Position=mix(u_matrix*pos,AWAY,hidden);pos.z*=meter_to_tile;v_position_height.xyz=pos.xyz-u_camera_pos;\n#else\nlocal_pos=a_pos_3f;gl_Position=u_matrix*vec4(a_pos_3f,1);v_position_height.xyz=vec3(u_lighting_matrix*vec4(a_pos_3f,1));v_color_mix=vec4(sRGBToLinear(u_color_mix.rgb),u_color_mix.a);\n#endif\nv_position_height.w=a_pos_3f.z;\n#ifdef HAS_ATTRIBUTE_a_pbr\nvec4 albedo_c=decode_color(pbr.xy);vec2 e_r_m=unpack_float(pbr.z);vec2 r_m= unpack_float(e_r_m.y*16.0);r_m.r=r_m.r*16.0;v_color_mix=vec4(albedo_c.rgb,1.0);v_roughness_metallic_emissive_alpha=vec4(vec3(r_m,e_r_m.x)/255.0,albedo_c.a);v_roughness_metallic_emissive_alpha.z*=2.0;float heightBasedRelativeIntepolation=a_pos_3f.z*heightBasedEmissiveStrength.x+heightBasedEmissiveStrength.y;v_height_based_emission_params.x=heightBasedRelativeIntepolation;v_height_based_emission_params.y=heightBasedEmissiveStrength.z;vec2 emissionMultiplierValues=unpack_float(pbr.w)/256.0;v_height_based_emission_params.z=emissionMultiplierValues.x;v_height_based_emission_params.w=emissionMultiplierValues.y-emissionMultiplierValues.x;\n#endif\n#ifdef FOG\nv_fog_pos=fog_position(local_pos);\n#endif\n#ifdef RENDER_CUTOFF\nv_cutoff_opacity=cutoff_opacity(u_cutoff_params,gl_Position.z);\n#endif\n#ifdef TERRAIN_FRAGMENT_OCCLUSION\nv_depth=gl_Position.z/gl_Position.w;\n#endif\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nfloat x_squared_scale=dot(rs[0],rs[0]);float y_squared_scale=dot(rs[1],rs[1]);float z_squared_scale=dot(rs[2],rs[2]);vec3 squared_scale=vec3(x_squared_scale,y_squared_scale,z_squared_scale);normal_3f=rs*((u_lighting_matrix*vec4(normal_3f,0.0)).xyz/squared_scale);normal_3f=normalize(normal_3f);\n#else\nnormal_3f=vec3(normal_matrix*vec4(normal_3f,0));\n#endif\n#endif\n#ifdef HAS_ATTRIBUTE_a_pbr\n#ifdef HAS_ATTRIBUTE_a_color_4f\nv_roughness_metallic_emissive_alpha.w=clamp(color_4f.a*v_roughness_metallic_emissive_alpha.w*(v_roughness_metallic_emissive_alpha.z-1.0),0.0,1.0);\n#endif\n#endif\n#ifdef RENDER_SHADOWS\nvec4 shadow_pos=u_node_matrix*vec4(local_pos,1.0);\n#ifdef NORMAL_OFFSET\n#ifdef HAS_ATTRIBUTE_a_normal_3f\n#ifdef MODEL_POSITION_ON_GPU\nvec3 offset=shadow_normal_offset(vec3(-normal_3f.xy,normal_3f.z));shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#else\nvec3 offset=shadow_normal_offset_model(normal_3f);shadow_pos.xyz+=offset*shadow_normal_offset_multiplier0();\n#endif\n#endif\n#endif\nv_pos_light_view_0=u_light_matrix_0*shadow_pos;v_pos_light_view_1=u_light_matrix_1*shadow_pos;v_depth_shadows=gl_Position.w;\n#endif\n}'), modelDepth: Go("in highp float v_depth;void main() {\n#ifndef DEPTH_TEXTURE\nglFragColor=pack_depth(v_depth);\n#endif\n}", "in vec3 a_pos_3f;uniform mat4 u_matrix;out highp float v_depth;\n#ifdef MODEL_POSITION_ON_GPU\n#ifdef INSTANCED_ARRAYS\nin vec4 a_normal_matrix0;in vec4 a_normal_matrix1;in vec4 a_normal_matrix2;in vec4 a_normal_matrix3;\n#else\nuniform highp mat4 u_instance;\n#endif\nuniform highp mat4 u_node_matrix;\n#endif\nvoid main() {\n#ifdef MODEL_POSITION_ON_GPU\nhighp mat4 instance;\n#ifdef INSTANCED_ARRAYS\ninstance=mat4(a_normal_matrix0,a_normal_matrix1,a_normal_matrix2,a_normal_matrix3);\n#else\ninstance=u_instance;\n#endif\nvec3 pos_color=instance[0].xyz;vec4 translate=instance[1];vec3 pos_a=floor(pos_color);float hidden=float(pos_a.x > EXTENT);float meter_to_tile=instance[0].w;vec4 pos=vec4(pos_a.xy,translate.z,1.0);mat3 rs;rs[0].x=instance[1].w;rs[0].yz=instance[2].xy;rs[1].xy=instance[2].zw;rs[1].z=instance[3].x;rs[2].xyz=instance[3].yzw;vec4 pos_node=u_node_matrix*vec4(a_pos_3f,1.0);vec3 rotated_pos_node=rs*pos_node.xyz;vec3 pos_model_tile=(rotated_pos_node+vec3(translate.xy,0.0))*vec3(meter_to_tile,meter_to_tile,1.0);pos.xyz+=pos_model_tile;gl_Position=mix(u_matrix*pos,AWAY,hidden);\n#else\ngl_Position=u_matrix*vec4(a_pos_3f,1);\n#endif\nv_depth=gl_Position.z/gl_Position.w;}"), stars: Go("in highp vec2 v_uv;in mediump float v_intensity;float shapeCircle(in vec2 uv)\n{float beginFade=0.6;float lengthFromCenter=length(v_uv);return 1.0-clamp((lengthFromCenter-beginFade)/(1.0-beginFade),0.0,1.0);}void main() {float alpha=shapeCircle(v_uv);vec3 color=vec3(1.0,1.0,1.0);alpha*=v_intensity;glFragColor=vec4(color*alpha,alpha);HANDLE_WIREFRAME_DEBUG;}", "\nin vec3 a_pos_3f;in vec2 a_uv;in float a_size_scale;in float a_fade_opacity;uniform mat4 u_matrix;uniform vec3 u_up;uniform vec3 u_right;uniform float u_intensity_multiplier;out highp vec2 v_uv;out mediump float v_intensity;void main() {v_uv=a_uv;v_intensity=a_fade_opacity*u_intensity_multiplier;vec3 pos=a_pos_3f;pos+=a_uv.x*u_right*a_size_scale;pos+=a_uv.y*u_up*a_size_scale;gl_Position=u_matrix*vec4(pos,1.0);}"), snowParticle: Go("in highp vec2 uv;in highp float alphaMultiplier;uniform vec4 u_particleColor;uniform vec2 u_simpleShapeParameters;void main() {float t=clamp((length(uv)-u_simpleShapeParameters.x)/(1.0-u_simpleShapeParameters.x),0.0,1.0);float alpha=1.0-pow(t,pow(10.0,u_simpleShapeParameters.y));alpha*=alphaMultiplier;alpha*=u_particleColor.a;vec3 color=u_particleColor.rgb*alpha;glFragColor=vec4(color,alpha) ;HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_snowParticleData;in highp vec4 a_snowParticleDataHorizontalOscillation;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform vec2 u_screenSize;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity;uniform vec3 u_direction;uniform float u_horizontalOscillationRadius; \nuniform float u_horizontalOscillationRate; \nuniform float u_billboardSize;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;out highp vec2 uv;out highp float alphaMultiplier;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos.xyz*=halfBoxSize;pos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_snowParticleData.z;float coneAngleHeadingRad=a_snowParticleData.w*radians(360.0);vec3 localZ=normalize(u_direction);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 direction;direction.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);direction.z=cos(coneAnglePichRad);direction=normalize(direction);vec3 simPosLocal=vec3(0,0,0);float velocityScale=(1.0+3.0*a_snowParticleData.y)*u_velocity;simPosLocal+=direction*velocityScale*u_time;float horizontalOscillationRadius=u_horizontalOscillationRadius*a_snowParticleDataHorizontalOscillation.x;float horizontalOscillationAngle=u_horizontalOscillationRate*u_time*(-1.0+2.0*a_snowParticleDataHorizontalOscillation.y);simPosLocal.xy+=horizontalOscillationRadius*vec2(cos(horizontalOscillationAngle),sin(horizontalOscillationAngle));vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);float clipZ=-u_cam_pos.z+pos.z;vec4 posView=u_modelview*vec4(pos,1.0);float size=u_billboardSize;alphaMultiplier=1.0;vec4 posScreen=u_projection*posView;posScreen/=posScreen.w;posScreen.xy=vec2(0.5)+posScreen.xy*0.5;posScreen.xy*=u_screenSize;vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=u_screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-posScreen.xy)/(0.5*u_screenSize));screenDist+=a_snowParticleData.x*u_thinningParticleOffset;float scaleFactorMode=0.0;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);if (a_snowParticleData.x < u_thinningAffectedRatio) {scaleFactorMode=1.0-thinningFadeRatio;alphaMultiplier=thinningFadeRatio;}}vec4 posScreen1=u_projection*vec4(posView.x-size,posView.yzw);posScreen1/=posScreen1.w;vec4 posScreen2=u_projection*vec4(posView.x+size,posView.yzw);posScreen2/=posScreen2.w;posScreen1.xy=vec2(0.5)+posScreen1.xy*0.5;posScreen1.xy*=u_screenSize;posScreen2.xy=vec2(0.5)+posScreen2.xy*0.5;posScreen2.xy*=u_screenSize;float screenLength=length(posScreen1.xy-posScreen2.xy);float screenEpsilon=3.0;float scaleFactor=1.0;if (screenLength < screenEpsilon) {scaleFactor=screenEpsilon/max(screenLength,0.01);scaleFactor=mix(scaleFactor,1.0,scaleFactorMode);}float screenEpsilon2=15.0;if (screenLength > screenEpsilon2) {scaleFactor=screenEpsilon2/max(screenLength,0.01);}size*=scaleFactor;vec2 right=size*vec2(1,0);vec2 up=size*vec2(0,1);posView.xy+=right*a_uv.x;posView.xy+=up*a_uv.y;uv=a_uv;gl_Position=u_projection*posView;}"), rainParticle: Go("in highp vec2 uv;in highp float particleRandomValue;uniform sampler2D u_texScreen;uniform float u_distortionStrength;uniform vec4 u_color;uniform vec2 u_thinningCenterPos;uniform vec3 u_thinningShape;uniform float u_thinningAffectedRatio;uniform float u_thinningParticleOffset;uniform float u_shapeDirectionalPower;uniform float u_mode;void main() {vec2 st=uv*0.5+vec2(0.5);vec2 uvm=uv;uvm.y=-1.0+2.0*pow(st.y,u_shapeDirectionalPower);float shape=clamp(1.0-length(uvm),0.0,1.0);float alpha=abs(shape)*u_color.a;vec2 screenSize=vec2(textureSize(u_texScreen,0));vec2 thinningCenterPos=u_thinningCenterPos.xy;thinningCenterPos.y=screenSize.y-thinningCenterPos.y;float screenDist=length((thinningCenterPos-gl_FragCoord.xy)/(0.5*screenSize));screenDist+=(0.5+0.5*particleRandomValue)*u_thinningParticleOffset;float thinningShapeDist=u_thinningShape.x+u_thinningShape.y;float thinningAlpha=1.0;if (screenDist < thinningShapeDist) {float thinningFadeRatio=clamp((screenDist-u_thinningShape.x)/u_thinningShape.y,0.0,1.0);thinningFadeRatio=pow(thinningFadeRatio,u_thinningShape.z);thinningAlpha*=thinningFadeRatio;}vec2 offsetXY=normalize(uvm)*abs(shape);vec2 stScreen=(gl_FragCoord.xy+offsetXY*u_distortionStrength*thinningAlpha)/screenSize;vec3 colorScreen=texture(u_texScreen,stScreen).rgb;alpha*=thinningAlpha;glFragColor=mix(vec4(colorScreen,1.0),vec4(u_color.rgb*alpha,alpha),u_mode);HANDLE_WIREFRAME_DEBUG;}", "\nin highp vec3 a_pos_3f;in highp vec2 a_uv;in highp vec4 a_rainParticleData;uniform mat4 u_modelview;uniform mat4 u_projection;uniform vec3 u_cam_pos;uniform float u_time;uniform float u_boxSize;uniform float u_velocityConeAperture; \nuniform float u_velocity; \nuniform vec2 u_rainDropletSize;uniform vec3 u_rainDirection;out highp vec2 uv;out highp float particleRandomValue;void main() {vec3 pos=a_pos_3f;float halfBoxSize=0.5*u_boxSize;pos*=halfBoxSize; \npos+=u_cam_pos;float velocityConeApertureRad=radians(u_velocityConeAperture*0.5);float coneAnglePichRad=velocityConeApertureRad*a_rainParticleData.z;float coneAngleHeadingRad=a_rainParticleData.w*radians(360.0);vec3 localZ=normalize(u_rainDirection);vec3 localX=normalize(cross(localZ,vec3(1,0,0)));vec3 localY=normalize(cross(localZ,localX));vec3 directionLocal;directionLocal.x=cos(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.y=sin(coneAngleHeadingRad)*sin(coneAnglePichRad);directionLocal.z=cos(coneAnglePichRad);directionLocal=normalize(directionLocal);vec3 directionWorld=localX*directionLocal.x+localY*directionLocal.y+localZ*directionLocal.z;float velocityScale=(1.0+3.0*a_rainParticleData.y)*u_velocity;vec3 simPosLocal=vec3(0,0,0);simPosLocal+=directionLocal*velocityScale*u_time;vec3 simPos=localX*simPosLocal.x+\nlocalY*simPosLocal.y+localZ*simPosLocal.z;pos+=simPos;pos=fract((pos+vec3(halfBoxSize))/vec3(u_boxSize))*u_boxSize-vec3(halfBoxSize);vec4 posView=u_modelview*vec4(pos,1.0);vec3 directionView=normalize((u_modelview*vec4(directionWorld,0.0)).xyz);vec3 side=cross(directionView,normalize(posView.xyz));posView.xyz+=side*a_uv.x*u_rainDropletSize.x;posView.xyz+=directionView*a_uv.y*u_rainDropletSize.y;uv=a_uv;particleRandomValue=a_rainParticleData.x;gl_Position=u_projection*posView;}"), vignette: Go("uniform vec3 u_vignetteShape;uniform vec4 u_vignetteColor;in vec2 st;void main() {float screenDist=length(st);float alpha=clamp((screenDist-u_vignetteShape.x)/u_vignetteShape.y,0.0,1.0);alpha=pow(alpha,u_vignetteShape.z)*u_vignetteColor.a;vec3 color=u_vignetteColor.rgb;glFragColor=vec4(color*alpha,alpha) ;}", "in vec2 a_pos_2f;out vec2 st;void main() {st=a_pos_2f;gl_Position=vec4(a_pos_2f,0,1);}"), occlusion: Go("uniform vec4 u_color;void main() {glFragColor=u_color;}", '#include "_prelude_terrain.vertex.glsl"\nin highp vec2 a_offset_xy;uniform highp vec3 u_anchorPos;uniform mat4 u_matrix;uniform vec2 u_screenSizePx;uniform vec2 u_occluderSizePx;void main() {vec3 world_pos=u_anchorPos;\n#ifdef TERRAIN\nfloat e=elevation(world_pos.xy);world_pos.z+=e;\n#endif\nvec4 projected_point=u_matrix*vec4(world_pos,1.0);projected_point.xy+=projected_point.w*a_offset_xy*0.5*u_occluderSizePx/u_screenSizePx;gl_Position=projected_point;}') };
          function Vo(e2, t2) {
            const i2 = e2.replace(/\s*\/\/[^\n]*\n/g, "\n").split("\n");
            for (let e3 of i2) if (e3 = e3.trim(), "#" === e3[0] && e3.includes("if") && !e3.includes("endif")) {
              e3 = e3.replace("#", "").replace(/ifdef|ifndef|elif|if/g, "").replace(/!|defined|\(|\)|\|\||&&/g, "").replace(/\s+/g, " ").trim();
              const i3 = e3.split(" ");
              for (const e4 of i3) t2.includes(e4) || t2.push(e4);
            }
          }
          function Go(e2, t2) {
            const i2 = /#include\s+"([^"]+)"/g, o2 = /#pragma mapbox: ([\w\-]+) ([\w]+) ([\w]+) ([\w]+)/g;
            let s2 = t2.match(/(attribute(\S*)|(^\s*|;)in) (highp |mediump |lowp )?([\w]+) ([\w]+)/gm);
            s2 && (s2 = s2.map((e3) => {
              const t3 = e3.split(" ");
              return t3[t3.length - 1];
            }), s2 = [...new Set(s2)]);
            const r2 = {}, n2 = [], a2 = [];
            if (e2 = e2.replace(i2, (e3, t3) => (a2.push(t3), "")), (t2 = t2.replace(i2, (e3, t3) => (n2.push(t3), ""))).includes("flat out")) return void console.error('The usage of "flat" qualifier is disallowed, see: https://bugs.webkit.org/show_bug.cgi?id=268071');
            let l2 = [...Fo];
            Vo(e2, l2), Vo(t2, l2);
            for (const e3 of [...n2, ...a2]) Bo[e3] || console.error(`Undefined include: ${e3}`), ko[e3] || (ko[e3] = [], Vo(Bo[e3], ko[e3])), l2 = [...l2, ...ko[e3]];
            return { fragmentSource: e2 = e2.replace(o2, (e3, t3, i3, o3, s3) => (r2[s3] = true, "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
in ${i3} ${o3} ${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize" === t3 ? `
#ifdef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    in ${i3} ${o3} ${s3};
#endif
` : "initialize-attribute" === t3 ? "" : void 0)), vertexSource: t2 = t2.replace(o2, (e3, t3, i3, o3, s3) => {
              const n3 = "float" === o3 ? "vec2" : o3, a3 = s3.match(/color/) ? "color" : n3;
              return "define-attribute-vertex-shader-only" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
in ${i3} ${o3} a_${s3};
#endif
` : r2[s3] ? "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
in ${i3} ${n3} a_${s3};
out ${i3} ${o3} ${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize" === t3 ? "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = a_${s3};
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${s3} = unpack_mix_${a3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : "define-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    in ${i3} ${o3} a_${s3};
    out ${i3} ${o3} ${s3};
#endif
` : "initialize-attribute" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    ${s3} = a_${s3};
#endif
` : void 0 : "define" === t3 ? `
#ifndef HAS_UNIFORM_u_${s3}
uniform lowp float u_${s3}_t;
in ${i3} ${n3} a_${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "define-instanced" === t3 ? "mat4" === a3 ? `
#ifdef INSTANCED_ARRAYS
in vec4 a_${s3}0;
in vec4 a_${s3}1;
in vec4 a_${s3}2;
in vec4 a_${s3}3;
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : `
#ifdef INSTANCED_ARRAYS
in ${i3} ${n3} a_${s3};
#else
uniform ${i3} ${o3} u_${s3};
#endif
` : "initialize-attribute-custom" === t3 ? `
#ifdef HAS_ATTRIBUTE_a_${s3}
    ${i3} ${o3} ${s3} = a_${s3};
#endif
` : "vec4" === a3 ? `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = a_${s3};
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
` : `
#ifndef HAS_UNIFORM_u_${s3}
    ${i3} ${o3} ${s3} = unpack_mix_${a3}(a_${s3}, u_${s3}_t);
#else
    ${i3} ${o3} ${s3} = u_${s3};
#endif
`;
            }), staticAttributes: s2, usedDefines: l2, vertexIncludes: n2, fragmentIncludes: a2 };
          }
          class qo {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffers = [], this.vao = null;
            }
            bind(e2, t2, i2, o2, s2, r2, n2, a2) {
              this.context = e2;
              let l2 = this.boundPaintVertexBuffers.length !== o2.length;
              for (let e3 = 0; !l2 && e3 < o2.length; e3++) this.boundPaintVertexBuffers[e3] !== o2[e3] && (l2 = true);
              let c2 = this.boundDynamicVertexBuffers.length !== n2.length;
              for (let e3 = 0; !c2 && e3 < n2.length; e3++) this.boundDynamicVertexBuffers[e3] !== n2[e3] && (c2 = true);
              if (!this.vao || this.boundProgram !== t2 || this.boundLayoutVertexBuffer !== i2 || l2 || c2 || this.boundIndexBuffer !== s2 || this.boundVertexOffset !== r2) this.freshBind(t2, i2, o2, s2, r2, n2, a2);
              else {
                e2.bindVertexArrayOES.set(this.vao);
                for (const i3 of n2) i3 && (i3.bind(), a2 && i3.instanceCount && i3.setVertexAttribDivisor(e2.gl, t2, a2));
                s2 && s2.dynamicDraw && s2.bind();
              }
            }
            freshBind(e2, t2, i2, o2, s2, r2, n2) {
              const a2 = e2.numAttributes, l2 = this.context, c2 = l2.gl;
              this.vao && this.destroy(), this.vao = l2.gl.createVertexArray(), l2.bindVertexArrayOES.set(this.vao), this.boundProgram = e2, this.boundLayoutVertexBuffer = t2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = s2, this.boundDynamicVertexBuffers = r2, t2.enableAttributes(c2, e2), t2.bind(), t2.setVertexAttribPointers(c2, e2, s2);
              for (const t3 of i2) t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, s2);
              for (const t3 of r2) t3 && (t3.enableAttributes(c2, e2), t3.bind(), t3.setVertexAttribPointers(c2, e2, s2), n2 && t3.instanceCount && t3.setVertexAttribDivisor(c2, e2, n2));
              o2 && o2.bind(), l2.currentNumAttributes = a2;
            }
            destroy() {
              this.vao && (this.context.gl.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          function Zo(t2, i2) {
            const o2 = Math.pow(2, i2.canonical.z), s2 = i2.canonical.y;
            return [new e.ac(0, s2 / o2).toLngLat().lat, new e.ac(0, (s2 + 1) / o2).toLngLat().lat];
          }
          function Ho(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = t2.context, c2 = l2.gl, h2 = o2.hillshadeFBO;
            if (!h2) return;
            t2.prepareDrawTile();
            const d2 = t2.isTileAffectedByFog(i2), u5 = t2.getOrCreateProgram("hillshade", { overrideFog: d2 });
            l2.activeTexture.set(c2.TEXTURE0), c2.bindTexture(c2.TEXTURE_2D, h2.colorAttachment.get());
            const _2 = ((t3, i3, o3, s3) => {
              const r3 = o3.paint.get("hillshade-shadow-color"), n3 = "none" === o3.paint.get("hillshade-shadow-color-use-theme").constantOr("default"), a3 = o3.paint.get("hillshade-highlight-color"), l3 = "none" === o3.paint.get("hillshade-highlight-color-use-theme").constantOr("default"), c3 = o3.paint.get("hillshade-accent-color"), h3 = "none" === o3.paint.get("hillshade-accent-color-use-theme").constantOr("default"), d3 = o3.paint.get("hillshade-emissive-strength");
              let u6 = e.al(o3.paint.get("hillshade-illumination-direction"));
              if ("viewport" === o3.paint.get("hillshade-illumination-anchor")) u6 -= t3.transform.angle;
              else if (t3.style && t3.style.enable3dLights() && t3.style.directionalLight) {
                const i4 = t3.style.directionalLight.properties.get("direction"), o4 = e.cR(i4.x, i4.y, i4.z);
                u6 = e.al(o4[1]);
              }
              const _3 = !t3.options.moving;
              return { u_matrix: s3 || t3.transform.calculateProjMatrix(i3.tileID.toUnwrapped(), _3), u_image: 0, u_latrange: Zo(0, i3.tileID), u_light: [o3.paint.get("hillshade-exaggeration"), u6], u_shadow: r3.toRenderColor(n3 ? null : o3.lut), u_highlight: a3.toRenderColor(l3 ? null : o3.lut), u_emissive_strength: d3, u_accent: c3.toRenderColor(h3 ? null : o3.lut) };
            })(t2, o2, s2, t2.terrain ? i2.projMatrix : null);
            t2.uploadCommonUniforms(l2, u5, i2.toUnwrapped());
            const { tileBoundsBuffer: p2, tileBoundsIndexBuffer: f2, tileBoundsSegments: m2 } = t2.getTileBoundsBuffers(o2);
            u5.draw(t2, c2.TRIANGLES, r2, n2, a2, qi.disabled, _2, s2.id, p2, f2, m2);
          }
          function Wo(t2, i2, o2) {
            if (!i2.needsDEMTextureUpload) return;
            const s2 = t2.context, r2 = s2.gl;
            s2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || t2.getTileTexture(o2.stride);
            const n2 = o2.getPixels();
            i2.demTexture ? i2.demTexture.update(n2, { premultiply: false }) : i2.demTexture = new e.T(s2, n2, r2.R32F, { premultiply: false }), i2.needsDEMTextureUpload = false;
          }
          function $o(t2, i2, o2) {
            const s2 = t2.context, r2 = s2.gl;
            if (!i2.dem) return;
            const n2 = i2.dem;
            if (s2.activeTexture.set(r2.TEXTURE1), Wo(t2, i2, n2), !i2.demTexture) return;
            i2.demTexture.bind(r2.NEAREST, r2.CLAMP_TO_EDGE);
            const a2 = n2.dim;
            s2.activeTexture.set(r2.TEXTURE0);
            let l2 = i2.hillshadeFBO;
            if (!l2) {
              const t3 = new e.T(s2, { width: a2, height: a2, data: null }, r2.RGBA8);
              t3.bind(r2.LINEAR, r2.CLAMP_TO_EDGE), l2 = i2.hillshadeFBO = s2.createFramebuffer(a2, a2, true, "renderbuffer"), l2.colorAttachment.set(t3.texture);
            }
            s2.bindFramebuffer.set(l2.framebuffer), s2.viewport.set([0, 0, a2, a2]);
            const { tileBoundsBuffer: c2, tileBoundsIndexBuffer: h2, tileBoundsSegments: d2 } = t2.getMercatorTileBoundsBuffers(), u5 = [];
            t2.linearFloatFilteringSupported() && u5.push("TERRAIN_DEM_FLOAT_FORMAT"), t2.getOrCreateProgram("hillshadePrepare", { defines: u5 }).draw(t2, r2.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, ((t3, i3) => {
              const o3 = i3.stride, s3 = e.bz();
              return e.c5(s3, 0, e.aj, -e.aj, 0, 0, 1), e.bo(s3, s3, [0, -e.aj, 0]), { u_matrix: s3, u_image: 1, u_dimension: [o3, o3], u_zoom: t3.overscaledZ };
            })(i2.tileID, n2), o2.id, c2, h2, d2), i2.needsHillshadePrepare = false;
          }
          class Xo {
            constructor(e2) {
              this.gl = e2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(e2) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class Yo extends Xo {
            getDefault() {
              return e.am.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.clearColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class Ko extends Xo {
            getDefault() {
              return 1;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearDepth(e2), this.current = e2, this.dirty = false);
            }
          }
          class Jo extends Xo {
            getDefault() {
              return 0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.clearStencil(e2), this.current = e2, this.dirty = false);
            }
          }
          class Qo extends Xo {
            getDefault() {
              return [true, true, true, true];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.colorMask(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class es extends Xo {
            getDefault() {
              return true;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class ts extends Xo {
            getDefault() {
              return 255;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.stencilMask(e2), this.current = e2, this.dirty = false);
            }
          }
          class is extends Xo {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(e2) {
              const t2 = this.current;
              (e2.func !== t2.func || e2.ref !== t2.ref || e2.mask !== t2.mask || this.dirty) && (this.gl.stencilFunc(e2.func, e2.ref, e2.mask), this.current = e2, this.dirty = false);
            }
          }
          class os extends Xo {
            getDefault() {
              const e2 = this.gl;
              return [e2.KEEP, e2.KEEP, e2.KEEP];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || this.dirty) && (this.gl.stencilOp(e2[0], e2[1], e2[2]), this.current = e2, this.dirty = false);
            }
          }
          class ss extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.STENCIL_TEST) : t2.disable(t2.STENCIL_TEST), this.current = e2, this.dirty = false;
            }
          }
          class rs extends Xo {
            getDefault() {
              return [0, 1];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || this.dirty) && (this.gl.depthRange(e2[0], e2[1]), this.current = e2, this.dirty = false);
            }
          }
          class ns extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.DEPTH_TEST) : t2.disable(t2.DEPTH_TEST), this.current = e2, this.dirty = false;
            }
          }
          class as extends Xo {
            getDefault() {
              return this.gl.LESS;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.depthFunc(e2), this.current = e2, this.dirty = false);
            }
          }
          class ls extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.BLEND) : t2.disable(t2.BLEND), this.current = e2, this.dirty = false;
            }
          }
          class cs extends Xo {
            getDefault() {
              const e2 = this.gl;
              return [e2.ONE, e2.ZERO, e2.ONE, e2.ZERO];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.blendFuncSeparate(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class hs extends Xo {
            getDefault() {
              return e.am.transparent;
            }
            set(e2) {
              const t2 = this.current;
              (e2.r !== t2.r || e2.g !== t2.g || e2.b !== t2.b || e2.a !== t2.a || this.dirty) && (this.gl.blendColor(e2.r, e2.g, e2.b, e2.a), this.current = e2, this.dirty = false);
            }
          }
          class ds extends Xo {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.blendEquationSeparate(e2, e2), this.current = e2, this.dirty = false);
            }
          }
          class us extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              e2 ? t2.enable(t2.CULL_FACE) : t2.disable(t2.CULL_FACE), this.current = e2, this.dirty = false;
            }
          }
          class _s extends Xo {
            getDefault() {
              return this.gl.BACK;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.cullFace(e2), this.current = e2, this.dirty = false);
            }
          }
          class ps extends Xo {
            getDefault() {
              return this.gl.CCW;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.frontFace(e2), this.current = e2, this.dirty = false);
            }
          }
          let fs = class extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.useProgram(e2), this.current = e2, this.dirty = false);
            }
          };
          class ms extends Xo {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(e2) {
              (e2 !== this.current || this.dirty) && (this.gl.activeTexture(e2), this.current = e2, this.dirty = false);
            }
          }
          class gs extends Xo {
            getDefault() {
              const e2 = this.gl;
              return [0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight];
            }
            set(e2) {
              const t2 = this.current;
              (e2[0] !== t2[0] || e2[1] !== t2[1] || e2[2] !== t2[2] || e2[3] !== t2[3] || this.dirty) && (this.gl.viewport(e2[0], e2[1], e2[2], e2[3]), this.current = e2, this.dirty = false);
            }
          }
          class vs extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class ys extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindRenderbuffer(t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class xs extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindTexture(t2.TEXTURE_2D, e2), this.current = e2, this.dirty = false;
            }
          }
          class bs extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.bindBuffer(t2.ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class ws extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              const t2 = this.gl;
              t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class Ts extends Xo {
            getDefault() {
              return null;
            }
            set(e2) {
              this.gl && (e2 !== this.current || this.dirty) && (this.gl.bindVertexArray(e2), this.current = e2, this.dirty = false);
            }
          }
          class Es extends Xo {
            getDefault() {
              return 4;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_ALIGNMENT, e2), this.current = e2, this.dirty = false;
            }
          }
          class Ss extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class Is extends Xo {
            getDefault() {
              return false;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              const t2 = this.gl;
              t2.pixelStorei(t2.UNPACK_FLIP_Y_WEBGL, e2), this.current = e2, this.dirty = false;
            }
          }
          class Cs extends Xo {
            constructor(e2, t2) {
              super(e2), this.context = e2, this.parent = t2;
            }
            getDefault() {
              return null;
            }
          }
          class Rs extends Cs {
            setDirty() {
              this.dirty = true;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class Ds extends Cs {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferRenderbuffer(t2.FRAMEBUFFER, this.attachment(), t2.RENDERBUFFER, e2), this.current = e2, this.dirty = false;
            }
          }
          class As extends Cs {
            attachment() {
              return this.gl.DEPTH_ATTACHMENT;
            }
            set(e2) {
              if (e2 === this.current && !this.dirty) return;
              this.context.bindFramebuffer.set(this.parent);
              const t2 = this.gl;
              t2.framebufferTexture2D(t2.FRAMEBUFFER, this.attachment(), t2.TEXTURE_2D, e2, 0), this.current = e2, this.dirty = false;
            }
          }
          class Ls extends Ds {
            attachment() {
              return this.gl.DEPTH_STENCIL_ATTACHMENT;
            }
          }
          const Ps = (e2, t2, i2) => ({ u_matrix: e2, u_image0: 0, u_skirt_height: t2, u_ground_shadow_factor: i2 }), zs = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2) => ({ u_proj_matrix: Float32Array.from(e2), u_globe_matrix: t2, u_normalize_matrix: Float32Array.from(o2), u_merc_matrix: i2, u_zoom_transition: s2, u_merc_center: r2, u_image0: 0, u_frustum_tl: n2, u_frustum_tr: a2, u_frustum_br: l2, u_frustum_bl: c2, u_globe_pos: h2, u_globe_radius: d2, u_viewport: u5, u_grid_matrix: f2 ? Float32Array.from(f2) : new Float32Array(9), u_skirt_height: _2, u_far_z_cutoff: p2 });
          function Ms(e2, t2) {
            return null != e2 && null != t2 && !(!e2.hasData() || !t2.hasData()) && null != e2.demTexture && null != t2.demTexture && e2.tileID.key !== t2.tileID.key;
          }
          const Os = new class {
            constructor() {
              this.operations = {};
            }
            newMorphing(e2, t2, i2, o2, s2) {
              if (e2 in this.operations) {
                const t3 = this.operations[e2];
                t3.to.tileID.key !== i2.tileID.key && (t3.queued = i2);
              } else this.operations[e2] = { startTime: o2, phase: 0, duration: s2, from: t2, to: i2, queued: null };
            }
            getMorphValuesForProxy(e2) {
              if (!(e2 in this.operations)) return null;
              const t2 = this.operations[e2];
              return { from: t2.from, to: t2.to, phase: t2.phase };
            }
            update(e2) {
              for (const t2 in this.operations) {
                const i2 = this.operations[t2];
                for (i2.phase = (e2 - i2.startTime) / i2.duration; i2.phase >= 1 || !this._validOp(i2); ) if (!this._nextOp(i2, e2)) {
                  delete this.operations[t2];
                  break;
                }
              }
            }
            _nextOp(e2, t2) {
              return !!e2.queued && (e2.from = e2.to, e2.to = e2.queued, e2.queued = null, e2.phase = 0, e2.startTime = t2, true);
            }
            _validOp(e2) {
              return e2.from.hasData() && e2.to.hasData();
            }
          }(), Fs = { 0: null, 1: "TERRAIN_VERTEX_MORPHING" };
          function Bs(e2, t2, i2) {
            if (0 === t2) return 0;
            const o2 = t2 < 1 && 514 === i2 ? 0.25 / t2 : 1;
            return 6 * Math.pow(1.5, 22 - e2) * Math.max(t2, 1) * o2;
          }
          function ks(e2, t2) {
            const i2 = 1 << e2.z;
            return !t2 && (0 === e2.x || e2.x === i2 - 1) || 0 === e2.y || e2.y === i2 - 1;
          }
          const Ns = (e2) => ({ u_matrix: e2 });
          function Us(t2, i2, o2, s2, r2) {
            if (r2 > 0) {
              const n2 = e.q.now(), a2 = (n2 - t2.timeAdded) / r2, l2 = i2 ? (n2 - i2.timeAdded) / r2 : -1, c2 = o2.getSource(), h2 = s2.coveringZoomLevel({ tileSize: c2.tileSize, roundZoom: c2.roundZoom }), d2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(t2.tileID.overscaledZ - h2), u5 = d2 && t2.refreshedUponExpiration ? 1 : e.aD(d2 ? a2 : 1 - l2, 0, 1);
              return t2.refreshedUponExpiration && a2 >= 1 && (t2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - u5 } : { opacity: u5, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          class js extends It {
            constructor(t2) {
              const i2 = { type: "raster-dem", maxzoom: t2.transform.maxZoom }, o2 = new e.D(e.d0(), null), s2 = nt("mock-dem", i2, o2, t2.style);
              super("mock-dem", s2, false), s2.setEventedParent(this), this._sourceLoaded = true;
            }
            _loadTile(e2, t2) {
              e2.state = "loaded", t2(null);
            }
          }
          class Vs extends It {
            constructor(t2) {
              const i2 = nt("proxy", { type: "geojson", maxzoom: t2.transform.maxZoom }, new e.D(e.d0(), null), t2.style);
              super("proxy", i2, false), i2.setEventedParent(this), this.map = this.getSource().map = t2, this.used = this._sourceLoaded = true, this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
            update(e2, t2, i2) {
              if (e2.freezeTileCoverage) return;
              this.transform = e2;
              const o2 = e2.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }).reduce((t3, i3) => {
                if (t3[i3.key] = "", !this._tiles[i3.key]) {
                  const t4 = new wt(i3, this._source.tileSize * i3.overscaleFactor(), e2.tileZoom);
                  t4.state = "loaded", this._tiles[i3.key] = t4;
                }
                return t3;
              }, {});
              for (const e3 in this._tiles) e3 in o2 || (this.freeFBO(e3), this._tiles[e3].unloadVectorData(), delete this._tiles[e3]);
            }
            freeFBO(e2) {
              const t2 = this.proxyCachedFBO[e2];
              if (void 0 !== t2) {
                const i2 = Object.values(t2);
                this.renderCachePool.push(...i2), delete this.proxyCachedFBO[e2];
              }
            }
            deallocRenderCache() {
              this.renderCache.forEach((e2) => e2.fb.destroy()), this.renderCache = [], this.renderCachePool = [], this.proxyCachedFBO = {};
            }
          }
          class Gs extends e.aM {
            constructor(e2, t2, i2) {
              super(e2.overscaledZ, e2.wrap, e2.canonical.z, e2.canonical.x, e2.canonical.y), this.proxyTileKey = t2, this.projMatrix = i2;
            }
          }
          class qs extends e.dt {
            constructor(t2, i2) {
              super(), this._debugParams = { sortTilesHiZFirst: true, disableRenderCache: false }, t2.tp.registerParameter(this._debugParams, ["Terrain"], "sortTilesHiZFirst", {}, () => {
                this._style.map.triggerRepaint();
              }), t2.tp.registerParameter(this._debugParams, ["Terrain"], "disableRenderCache", {}, () => {
                this._style.map.triggerRepaint();
              }), t2.tp.registerButton(["Terrain"], "Invalidate Render Cache", () => {
                this.invalidateRenderCache = true, this._style.map.triggerRepaint();
              }), this.painter = t2, this.terrainTileForTile = {}, this.prevTerrainTileForTile = {};
              const [o2, s2, r2] = function(t3) {
                const i3 = new e.ba(), o3 = new e.a_(), s3 = 131;
                i3.reserve(17161), o3.reserve(33800);
                const r3 = e.aj / 128, n3 = e.aj + r3 / 2, a3 = n3 + r3;
                for (let t4 = -r3; t4 < a3; t4 += r3) for (let o4 = -r3; o4 < a3; o4 += r3) {
                  const s4 = o4 < 0 || o4 > n3 || t4 < 0 || t4 > n3 ? 24575 : 0, r4 = e.aD(Math.round(o4), 0, e.aj), a4 = e.aD(Math.round(t4), 0, e.aj);
                  i3.emplaceBack(r4 + s4, a4);
                }
                const l2 = (e2, t4) => {
                  const i4 = t4 * s3 + e2;
                  o3.emplaceBack(i4 + 1, i4, i4 + s3), o3.emplaceBack(i4 + s3, i4 + s3 + 1, i4 + 1);
                };
                for (let e2 = 1; e2 < 129; e2++) for (let t4 = 1; t4 < 129; t4++) l2(t4, e2);
                return [0, 129].forEach((e2) => {
                  for (let t4 = 0; t4 < 130; t4++) l2(t4, e2), l2(e2, t4);
                }), [i3, o3, 32768];
              }(), n2 = t2.context;
              this.gridBuffer = n2.createVertexBuffer(o2, e.bc.members), this.gridIndexBuffer = n2.createIndexBuffer(s2), this.gridSegments = e.bd.simpleSegment(0, 0, o2.length, s2.length), this.gridNoSkirtSegments = e.bd.simpleSegment(0, 0, o2.length, r2), this.proxyCoords = [], this.proxiedCoords = {}, this._visibleDemTiles = [], this._drapedRenderBatches = [], this._sourceTilesOverlap = {}, this.proxySourceCache = new Vs(i2.map), this.orthoMatrix = e.bz(), e.c5(this.orthoMatrix, "globe" === this.painter.transform.projection.name ? 0.015 : 0, e.aj, 0, e.aj, 0, 1);
              const a2 = n2.gl;
              this._overlapStencilMode = new ji({ func: a2.GEQUAL, mask: 255 }, 0, 255, a2.KEEP, a2.KEEP, a2.REPLACE), this._previousZoom = t2.transform.zoom, this.pool = [], this._findCoveringTileCache = {}, this._tilesDirty = {}, this.style = i2, this._useVertexMorphing = true, this._exaggeration = 1, this._mockSourceCache = new js(i2.map), this._pendingGroundEffectLayers = [];
            }
            set style(e2) {
              e2.on("data", this._onStyleDataEvent.bind(this)), this._style = e2, this._style.map.on("moveend", () => {
                this._clearLineLayersFromRenderCache();
              });
            }
            update(t2, i2, o2) {
              if (t2 && t2.terrain) {
                this._style !== t2 && (this.style = t2, this._evaluationZoom = void 0);
                const s2 = t2.terrain.properties, r2 = 0 === t2.terrain.drapeRenderMode, n2 = t2.terrain.isZoomDependent();
                this._previousUpdateTimestamp = this.enabled ? this._updateTimestamp : void 0, this._updateTimestamp = e.q.now();
                const a2 = t2.terrain && t2.terrain.scope, l2 = s2.get("source"), c2 = r2 ? this._mockSourceCache : t2.getSourceCache(l2, a2);
                if (!c2) return void e.w(`Couldn't find terrain source "${l2}".`);
                if (this.sourceCache = c2, this._attenuationRange = t2.terrain.getAttenuationRange(), this._exaggeration = n2 ? this.calculateExaggeration(i2) : s2.get("exaggeration"), !i2.projection.requiresDraping && n2 && 0 === this._exaggeration) return void this._disable();
                this.enabled = true;
                const h2 = () => {
                  this.sourceCache.used && e.w(`Raster DEM source '${this.sourceCache.id}' is used both for terrain and as layer source.
This leads to lower resolution of hillshade. For full hillshade resolution but higher memory consumption, define another raster DEM source.`);
                  const t3 = this.getScaledDemTileSize();
                  this.sourceCache.update(i2, t3, true), this.resetTileLookupCache(this.sourceCache.id);
                };
                this.sourceCache.usedForTerrain || (this.resetTileLookupCache(this.sourceCache.id), this.sourceCache.usedForTerrain = true, h2(), this._initializing = true), h2(), i2.updateElevation(true, o2), this.resetTileLookupCache(this.proxySourceCache.id), this.proxySourceCache.update(i2), this._emptyDEMTextureDirty = true, this._previousZoom = i2.zoom;
              } else this._disable();
            }
            calculateExaggeration(t2) {
              if (this._attenuationRange && t2.zoom >= Math.ceil(this._attenuationRange[1])) return this._style.terrain.getExaggeration(t2.zoom);
              const i2 = this._previousCameraAltitude, o2 = t2.getFreeCameraOptions().position.z / t2.pixelsPerMeter * t2.worldSize;
              this._previousCameraAltitude = o2;
              const s2 = null != i2 ? o2 - i2 : Number.MAX_VALUE;
              if (Math.abs(s2) < 2) return this._exaggeration;
              const r2 = t2.zoom, n2 = this._style.terrain;
              if (!this._previousUpdateTimestamp) return n2.getExaggeration(r2);
              let a2 = r2 - this._previousZoom;
              const l2 = this._previousUpdateTimestamp;
              let c2 = r2;
              null != this._evaluationZoom && (c2 = this._evaluationZoom, Math.abs(r2 - c2) > 0.5 && (a2 = 0.5 * (r2 - c2 + a2)), a2 * s2 < 0 && (c2 += a2)), this._evaluationZoom = c2;
              const h2 = n2.getExaggeration(c2), d2 = h2 === n2.getExaggeration(Math.max(0, c2 - 0.1));
              if (d2 && Math.abs(h2 - this._exaggeration) < 0.01) return h2;
              let u5 = Math.min(0.1, 375e-5 * (this._updateTimestamp - l2));
              return (d2 || h2 < 0.1 || Math.abs(a2) < 1e-4) && (u5 = Math.min(0.2, 4 * u5)), e.ai(this._exaggeration, h2, u5);
            }
            resetTileLookupCache(e2) {
              this._findCoveringTileCache[e2] = {};
            }
            attenuationRange() {
              return this._attenuationRange;
            }
            getDemUpscale() {
              return this.proxySourceCache.getSource().tileSize / 128;
            }
            getScaledDemTileSize() {
              return this.sourceCache.getSource().tileSize / 128 * this.proxySourceCache.getSource().tileSize;
            }
            _onStyleDataEvent(e2) {
              e2.coord && "source" === e2.dataType ? this._clearRenderCacheForTile(e2.sourceCacheId, e2.coord) : "style" === e2.dataType && (this.invalidateRenderCache = true, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this._previousCameraAltitude = void 0);
            }
            _disable() {
              if (this.enabled && (this.enabled = false, this._emptyDEMTextureDirty = true, this._sharedDepthStencil = void 0, this._evaluationZoom = void 0, this._previousUpdateTimestamp = void 0, this.proxySourceCache.deallocRenderCache(), this._style)) for (const e2 in this._style._mergedSourceCaches) this._style._mergedSourceCaches[e2].usedForTerrain = false;
            }
            destroy() {
              this._disable(), this._emptyDEMTexture && this._emptyDEMTexture.destroy(), this.pool.forEach((e2) => e2.fb.destroy()), this.pool = [], this.framebufferCopyTexture && this.framebufferCopyTexture.destroy();
            }
            _source() {
              return this.enabled ? this.sourceCache : null;
            }
            isUsingMockSource() {
              return this.sourceCache === this._mockSourceCache;
            }
            exaggeration() {
              return this.enabled ? this._exaggeration : 0;
            }
            get visibleDemTiles() {
              return this._visibleDemTiles;
            }
            get drapeBufferSize() {
              const e2 = 2 * this.proxySourceCache.getSource().tileSize;
              return [e2, e2];
            }
            set useVertexMorphing(e2) {
              this._useVertexMorphing = e2;
            }
            updateTileBinding(t2) {
              if (!this.enabled) return;
              this.prevTerrainTileForTile = this.terrainTileForTile;
              const i2 = this.proxySourceCache, o2 = this.painter.transform;
              this._initializing && (this._initializing = 0 === o2._centerAltitude && -1 === this.getAtPointOrZero(e.ac.fromLngLat(o2.center), -1), this._emptyDEMTextureDirty = !this._initializing);
              const s2 = this.proxyCoords = i2.getIds().map((e2) => {
                const t3 = i2.getTileByID(e2).tileID;
                return t3.projMatrix = o2.calculateProjMatrix(t3.toUnwrapped()), t3;
              });
              !function(t3, i3) {
                const o3 = i3.transform.pointCoordinate(i3.transform.getCameraPoint()), s3 = new e.P(o3.x, o3.y);
                t3.sort((t4, i4) => {
                  if (i4.overscaledZ - t4.overscaledZ) return i4.overscaledZ - t4.overscaledZ;
                  const o4 = new e.P(t4.canonical.x + (1 << t4.canonical.z) * t4.wrap, t4.canonical.y), r3 = new e.P(i4.canonical.x + (1 << i4.canonical.z) * i4.wrap, i4.canonical.y), n3 = s3.mult(1 << t4.canonical.z);
                  return n3.x -= 0.5, n3.y -= 0.5, n3.distSqr(o4) - n3.distSqr(r3);
                });
              }(s2, this.painter);
              const r2 = this.proxyToSource || {};
              this.proxyToSource = {}, s2.forEach((e2) => {
                this.proxyToSource[e2.key] = {};
              }), this.terrainTileForTile = {};
              const n2 = this._style._mergedSourceCaches;
              for (const e2 in n2) {
                const i3 = n2[e2];
                if (!i3.used) continue;
                if (i3 !== this.sourceCache && this.resetTileLookupCache(i3.id), this._setupProxiedCoordsForOrtho(i3, t2[e2], r2), i3.usedForTerrain) continue;
                const o3 = t2[e2];
                i3.getSource().reparseOverscaled && this._assignTerrainTiles(o3);
              }
              this.proxiedCoords[i2.id] = s2.map((e2) => new Gs(e2, e2.key, this.orthoMatrix)), this._assignTerrainTiles(s2), this._prepareDEMTextures(), this._setupDrapedRenderBatches(), this._initFBOPool(), this._setupRenderCache(r2), this.renderingToTexture = false;
              const a2 = {};
              this._visibleDemTiles = [];
              for (const e2 of this.proxyCoords) {
                const t3 = this.terrainTileForTile[e2.key];
                if (!t3) continue;
                const i3 = t3.tileID.key;
                i3 in a2 || (this._visibleDemTiles.push(t3), a2[i3] = i3);
              }
            }
            _assignTerrainTiles(e2) {
              this._initializing || e2.forEach((e3) => {
                if (this.terrainTileForTile[e3.key]) return;
                const t2 = this._findTileCoveringTileID(e3, this.sourceCache);
                t2 && (this.terrainTileForTile[e3.key] = t2);
              });
            }
            _prepareDEMTextures() {
              const e2 = this.painter.context, t2 = e2.gl;
              for (const i2 in this.terrainTileForTile) {
                const o2 = this.terrainTileForTile[i2], s2 = o2.dem;
                !s2 || o2.demTexture && !o2.needsDEMTextureUpload || (e2.activeTexture.set(t2.TEXTURE1), Wo(this.painter, o2, s2));
              }
            }
            _prepareDemTileUniforms(e2, t2, i2, o2) {
              if (!t2 || null == t2.demTexture) return false;
              const s2 = e2.tileID.canonical, r2 = Math.pow(2, t2.tileID.canonical.z - s2.z), n2 = o2 || "";
              return i2[`u_dem_tl${n2}`] = [s2.x * r2 % 1, s2.y * r2 % 1], i2[`u_dem_scale${n2}`] = r2, true;
            }
            get emptyDEMTexture() {
              return !this._emptyDEMTextureDirty && this._emptyDEMTexture ? this._emptyDEMTexture : this._updateEmptyDEMTexture();
            }
            _getLoadedAreaMinimum() {
              if (!this.enabled) return 0;
              let e2 = 0;
              const t2 = this._visibleDemTiles.reduce((t3, i2) => {
                if (!i2.dem) return t3;
                const o2 = i2.dem.tree.minimums[0];
                return o2 > 0 && e2++, t3 + o2;
              }, 0);
              return e2 ? t2 / e2 : 0;
            }
            _updateEmptyDEMTexture() {
              const t2 = this.painter.context, i2 = t2.gl;
              t2.activeTexture.set(i2.TEXTURE2);
              const o2 = this._getLoadedAreaMinimum(), s2 = new e.du({ width: 1, height: 1 }, new Float32Array([o2]));
              this._emptyDEMTextureDirty = false;
              let r2 = this._emptyDEMTexture;
              return r2 ? r2.update(s2, { premultiply: false }) : r2 = this._emptyDEMTexture = new e.T(t2, s2, i2.R32F, { premultiply: false }), r2;
            }
            setupElevationDraw(t2, i2, o2) {
              const s2 = this.painter.context, r2 = s2.gl, n2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 };
              n2.u_exaggeration = this.exaggeration();
              let a2 = null, l2 = null, c2 = 1;
              if (o2 && o2.morphing && this._useVertexMorphing) {
                const e2 = o2.morphing.srcDemTile, i3 = o2.morphing.dstDemTile;
                c2 = o2.morphing.phase, e2 && i3 && (this._prepareDemTileUniforms(t2, e2, n2, "_prev") && (l2 = e2), this._prepareDemTileUniforms(t2, i3, n2) && (a2 = i3));
              }
              const h2 = (e2) => e2 && e2.demTexture && this.painter.linearFloatFilteringSupported() ? r2.LINEAR : r2.NEAREST;
              let d2 = null;
              var u5;
              if (this.enabled ? l2 && a2 ? (d2 = a2.demTexture, s2.activeTexture.set(r2.TEXTURE4), l2.demTexture.bind(h2(l2), r2.CLAMP_TO_EDGE), n2.u_dem_lerp = c2) : (a2 = this.terrainTileForTile[t2.tileID.key], d2 = this._prepareDemTileUniforms(t2, a2, n2) ? a2.demTexture : this.emptyDEMTexture) : d2 = this.emptyDEMTexture, s2.activeTexture.set(r2.TEXTURE2), d2 && (n2.u_dem_size = 1 === (u5 = d2).size[0] ? 1 : u5.size[0] - 2, d2.bind(h2(a2), r2.CLAMP_TO_EDGE)), this.painter.setupDepthForOcclusion(o2 && o2.useDepthForOcclusion, i2, n2), o2 && o2.useMeterToDem && a2) {
                const t3 = (1 << a2.tileID.canonical.z) * e.c6(1, this.painter.transform.center.lat) * this.sourceCache.getSource().tileSize;
                n2.u_meter_to_dem = t3;
              }
              if (o2 && o2.labelPlaneMatrixInv && (n2.u_label_plane_matrix_inv = o2.labelPlaneMatrixInv), i2.setTerrainUniformValues(s2, n2), "globe" === this.painter.transform.projection.name) {
                const e2 = this.globeUniformValues(this.painter.transform, t2.tileID.canonical, o2 && o2.useDenormalizedUpVectorScale);
                i2.setGlobeUniformValues(s2, e2);
              }
            }
            globeUniformValues(t2, i2, o2) {
              const s2 = t2.projection;
              return { u_tile_tl_up: s2.upVector(i2, 0, 0), u_tile_tr_up: s2.upVector(i2, e.aj, 0), u_tile_br_up: s2.upVector(i2, e.aj, e.aj), u_tile_bl_up: s2.upVector(i2, 0, e.aj), u_tile_up_scale: o2 ? e.dv(1) : s2.upVectorScale(i2, t2.center.lat, t2.worldSize).metersToTile };
            }
            renderToBackBuffer(t2) {
              const i2 = this.painter, o2 = this.painter.context;
              0 !== t2.length && (o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), i2.gpuTimingDeferredRenderStart(), this.renderingToTexture = false, function(t3, i3, o3, s2, r2) {
                if ("globe" === t3.transform.projection.name) !function(t4, i4, o4, s3, r3) {
                  const n2 = t4.context, a2 = n2.gl;
                  let l2, c2;
                  const h2 = t4.transform, d2 = e.dl(t4, n2, h2), u5 = (e2, i5) => {
                    if (c2 === i5) return;
                    const o5 = [Fs[i5], "PROJECTION_GLOBE_VIEW"];
                    d2 && o5.push("CUSTOM_ANTIALIASING");
                    const s4 = t4.isTileAffectedByFog(e2);
                    l2 = t4.getOrCreateProgram("globeRaster", { defines: o5, overrideFog: s4 }), c2 = i5;
                  }, _2 = t4.colorModeForRenderPass(), p2 = new Ni(a2.LEQUAL, Ni.ReadWrite, t4.depthRangeFor3D);
                  Os.update(r3);
                  const f2 = e.dm(h2), m2 = [e.ay(h2.center.lng), e.aH(h2.center.lat)], g2 = t4.globeSharedBuffers, v3 = [h2.width * e.q.devicePixelRatio, h2.height * e.q.devicePixelRatio], y2 = Float32Array.from(h2.globeMatrix), x2 = { useDenormalizedUpVectorScale: true };
                  {
                    const h3 = t4.transform, d3 = Bs(h3.zoom, i4.exaggeration(), i4.sourceCache._source.tileSize);
                    c2 = -1;
                    const b2 = a2.TRIANGLES;
                    for (const c3 of s3) {
                      const s4 = o4.getTile(c3), w2 = ji.disabled, T2 = i4.prevTerrainTileForTile[c3.key], E2 = i4.terrainTileForTile[c3.key];
                      Ms(T2, E2) && Os.newMorphing(c3.key, T2, E2, r3, 250), n2.activeTexture.set(a2.TEXTURE0), s4.texture && s4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      const S2 = Os.getMorphValuesForProxy(c3.key), I2 = S2 ? 1 : 0;
                      S2 && e.L(x2, { morphing: { srcDemTile: S2.from, dstDemTile: S2.to, phase: e.dk(S2.phase) } });
                      const C3 = e.dn(c3.canonical), R2 = e.dp(C3.getCenter().lat), D3 = e.dq(c3.canonical, C3, R2, h3.worldSize / h3._pixelsPerMercatorPixel), A2 = e.bh(e.dr(c3.canonical)), L2 = zs(h3.expandedFarZProjMatrix, y2, f2, A2, e.ah(h3.zoom), m2, h3.frustumCorners.TL, h3.frustumCorners.TR, h3.frustumCorners.BR, h3.frustumCorners.BL, h3.globeCenterInViewSpace, h3.globeRadius, v3, d3, h3._farZ, D3);
                      if (u5(c3, I2), l2 && (i4.setupElevationDraw(s4, l2, x2), t4.uploadCommonUniforms(n2, l2, c3.toUnwrapped()), g2)) {
                        const [e2, i5, o5] = g2.getGridBuffers(R2, 0 !== d3);
                        l2.draw(t4, b2, p2, w2, _2, qi.backCCW, L2, "globe_raster", e2, i5, o5);
                      }
                    }
                  }
                  if (g2 && (t4.renderDefaultNorthPole || t4.renderDefaultSouthPole)) {
                    const r4 = ["GLOBE_POLES", "PROJECTION_GLOBE_VIEW"];
                    d2 && r4.push("CUSTOM_ANTIALIASING"), l2 = t4.getOrCreateProgram("globeRaster", { defines: r4 });
                    for (const r5 of s3) {
                      const { x: s4, y: c3, z: d3 } = r5.canonical, u6 = 0 === c3, f3 = c3 === (1 << d3) - 1, [y3, b2, w2, T2] = g2.getPoleBuffers(d3, false);
                      if (T2 && (u6 || f3)) {
                        const c4 = o4.getTile(r5);
                        n2.activeTexture.set(a2.TEXTURE0), c4.texture && c4.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                        let g3 = e.ds(d3, s4, h2);
                        const E2 = e.bh(e.dr(r5.canonical)), S2 = (e2, i5) => e2.draw(t4, a2.TRIANGLES, p2, ji.disabled, _2, qi.disabled, zs(h2.expandedFarZProjMatrix, g3, g3, E2, 0, m2, h2.frustumCorners.TL, h2.frustumCorners.TR, h2.frustumCorners.BR, h2.frustumCorners.BL, h2.globeCenterInViewSpace, h2.globeRadius, v3, 0, h2._farZ), "globe_pole_raster", i5, w2, T2);
                        i4.setupElevationDraw(c4, l2, x2), t4.uploadCommonUniforms(n2, l2, r5.toUnwrapped()), u6 && t4.renderDefaultNorthPole && S2(l2, y3), f3 && t4.renderDefaultSouthPole && (g3 = e.cE(e.bz(), g3, [1, -1, 1]), S2(l2, b2));
                      }
                    }
                  }
                }(t3, i3, o3, s2, r2);
                else {
                  const n2 = t3.context, a2 = n2.gl;
                  let l2, c2;
                  const h2 = t3.shadowRenderer, d2 = eo(t3, t3.longestCutoffRange), u5 = (e2) => {
                    if (c2 === e2) return;
                    const i4 = [];
                    i4.push(Fs[e2]), d2.shouldRenderCutoff && i4.push("RENDER_CUTOFF"), h2 && (i4.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), h2.useNormalOffset && i4.push("NORMAL_OFFSET")), l2 = t3.getOrCreateProgram("terrainRaster", { defines: i4 }), c2 = e2;
                  }, _2 = t3.colorModeForRenderPass(), p2 = new Ni(a2.LEQUAL, Ni.ReadWrite, t3.depthRangeFor3D);
                  Os.update(r2);
                  const f2 = t3.transform, m2 = Bs(f2.zoom, i3.exaggeration(), i3.sourceCache._source.tileSize);
                  let g2 = [0, 0, 0];
                  if (h2) {
                    const e2 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                    e2 && i4 && (g2 = ao(t3.style, e2, i4));
                  }
                  {
                    c2 = -1;
                    const v3 = a2.TRIANGLES, [y2, x2] = [i3.gridIndexBuffer, i3.gridSegments];
                    for (const c3 of s2) {
                      const s3 = o3.getTile(c3), b2 = ji.disabled, w2 = i3.prevTerrainTileForTile[c3.key], T2 = i3.terrainTileForTile[c3.key];
                      Ms(w2, T2) && Os.newMorphing(c3.key, w2, T2, r2, 250), n2.activeTexture.set(a2.TEXTURE0), s3.texture && s3.texture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                      const E2 = Os.getMorphValuesForProxy(c3.key), S2 = E2 ? 1 : 0;
                      let I2;
                      E2 && (I2 = { morphing: { srcDemTile: E2.from, dstDemTile: E2.to, phase: e.dk(E2.phase) } });
                      const C3 = Ps(c3.projMatrix, ks(c3.canonical, f2.renderWorldCopies) ? m2 / 10 : m2, g2);
                      if (u5(S2), !l2) continue;
                      i3.setupElevationDraw(s3, l2, I2);
                      const R2 = c3.toUnwrapped();
                      h2 && h2.setupShadows(R2, l2), t3.uploadCommonUniforms(n2, l2, R2, null, d2), l2.draw(t3, v3, p2, b2, _2, qi.backCCW, C3, "terrain_raster", i3.gridBuffer, y2, x2);
                    }
                  }
                }
              }(i2, this, this.proxySourceCache, t2, this._updateTimestamp), this.renderingToTexture = true, i2.gpuTimingDeferredRenderEnd(), t2.splice(0, t2.length));
            }
            renderBatch(t2) {
              if (0 === this._drapedRenderBatches.length) return t2 + 1;
              this.renderingToTexture = true;
              const i2 = this.painter, o2 = this.painter.context, s2 = this.proxySourceCache, r2 = this.proxiedCoords[s2.id], n2 = this._drapedRenderBatches.shift(), a2 = i2.style.order, l2 = [];
              let c2 = 0;
              for (const h2 of r2) {
                const r3 = s2.getTileByID(h2.proxyTileKey), d2 = s2.proxyCachedFBO[h2.key] ? s2.proxyCachedFBO[h2.key][t2] : void 0, u5 = void 0 !== d2 ? s2.renderCache[d2] : this.pool[c2++], _2 = void 0 !== d2;
                if (r3.texture = u5.tex, _2 && !u5.dirty) {
                  l2.push(r3.tileID);
                  continue;
                }
                let p2;
                o2.bindFramebuffer.set(u5.fb.framebuffer), this.renderedToTile = false, u5.dirty && (o2.clear({ color: e.am.transparent, stencil: 0 }), u5.dirty = false);
                for (let e2 = n2.start; e2 <= n2.end; ++e2) {
                  const t3 = i2.style._mergedLayers[a2[e2]];
                  if (t3.isHidden(i2.transform.zoom)) continue;
                  const s3 = i2.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h2.key][s3.id] : [h2];
                  if (!r4) continue;
                  const n3 = r4;
                  o2.viewport.set([0, 0, u5.fb.width, u5.fb.height]), p2 !== (s3 ? s3.id : null) && (this._setupStencil(u5, r4, t3, s3), p2 = s3 ? s3.id : null), i2.renderLayer(i2, s3, t3, n3);
                }
                if (0 === this._drapedRenderBatches.length) for (const e2 of this._pendingGroundEffectLayers) {
                  const t3 = i2.style._mergedLayers[a2[e2]];
                  if (t3.isHidden(i2.transform.zoom)) continue;
                  const s3 = i2.style.getLayerSourceCache(t3), r4 = s3 ? this.proxyToSource[h2.key][s3.id] : [h2];
                  if (!r4) continue;
                  const n3 = r4;
                  o2.viewport.set([0, 0, u5.fb.width, u5.fb.height]), p2 !== (s3 ? s3.id : null) && (this._setupStencil(u5, r4, t3, s3), p2 = s3 ? s3.id : null), i2.renderLayer(i2, s3, t3, n3);
                }
                this.renderedToTile ? (u5.dirty = true, l2.push(r3.tileID)) : _2 || --c2, 5 === c2 && (c2 = 0, this.renderToBackBuffer(l2));
              }
              return this.renderToBackBuffer(l2), this.renderingToTexture = false, o2.bindFramebuffer.set(null), o2.viewport.set([0, 0, i2.width, i2.height]), n2.end + 1;
            }
            postRender() {
            }
            isLayerOrderingCorrect(e2) {
              const t2 = e2.order.length;
              let i2 = -1, o2 = t2;
              for (let s2 = 0; s2 < t2; ++s2) this._style.isLayerDraped(e2._mergedLayers[e2.order[s2]]) ? i2 = Math.max(i2, s2) : o2 = Math.min(o2, s2);
              return o2 > i2;
            }
            getMinElevationBelowMSL() {
              let e2 = 0;
              return this._visibleDemTiles.filter((e3) => e3.dem).forEach((t2) => {
                e2 = Math.min(e2, t2.dem.tree.minimums[0]);
              }), 0 === e2 ? e2 : (e2 - 30) * this._exaggeration;
            }
            raycast(e2, t2, i2) {
              if (!this._visibleDemTiles) return null;
              const o2 = this._visibleDemTiles.filter((e3) => e3.dem).map((o3) => {
                const s2 = o3.tileID, r2 = 1 << s2.overscaledZ, { x: n2, y: a2 } = s2.canonical, l2 = n2 / r2, c2 = (n2 + 1) / r2, h2 = a2 / r2, d2 = (a2 + 1) / r2;
                return { minx: l2, miny: h2, maxx: c2, maxy: d2, t: o3.dem.tree.raycastRoot(l2, h2, c2, d2, e2, t2, i2), tile: o3 };
              });
              o2.sort((e3, t3) => (null !== e3.t ? e3.t : Number.MAX_VALUE) - (null !== t3.t ? t3.t : Number.MAX_VALUE));
              for (const s2 of o2) {
                if (null == s2.t) return null;
                const o3 = s2.tile.dem.tree.raycast(s2.minx, s2.miny, s2.maxx, s2.maxy, e2, t2, i2);
                if (null != o3) return o3;
              }
              return null;
            }
            _createFBO() {
              const t2 = this.painter.context, i2 = t2.gl, o2 = this.drapeBufferSize;
              t2.activeTexture.set(i2.TEXTURE0);
              const s2 = new e.T(t2, { width: o2[0], height: o2[1], data: null }, i2.RGBA8);
              s2.bind(i2.LINEAR, i2.CLAMP_TO_EDGE);
              const r2 = t2.createFramebuffer(o2[0], o2[1], true, null);
              return r2.colorAttachment.set(s2.texture), r2.depthAttachment = new Ls(t2, r2.framebuffer), void 0 === this._sharedDepthStencil ? (this._sharedDepthStencil = t2.createRenderbuffer(t2.gl.DEPTH_STENCIL, o2[0], o2[1]), this._stencilRef = 0, r2.depthAttachment.set(this._sharedDepthStencil), t2.clear({ stencil: 0 })) : r2.depthAttachment.set(this._sharedDepthStencil), t2.extTextureFilterAnisotropic && i2.texParameterf(i2.TEXTURE_2D, t2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, t2.extTextureFilterAnisotropicMax), { fb: r2, tex: s2, dirty: false };
            }
            _initFBOPool() {
              for (; this.pool.length < Math.min(5, this.proxyCoords.length); ) this.pool.push(this._createFBO());
            }
            _shouldDisableRenderCache() {
              if (this._debugParams.disableRenderCache) return true;
              if (this._style.hasLightTransitions()) return true;
              for (const e2 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[e2].hasTransition()) return true;
              return this._style.order.some((e2) => {
                const t2 = this._style._mergedLayers[e2], i2 = t2.isHidden(this.painter.transform.zoom);
                return "hillshade" === t2.type || "custom" === t2.type ? !i2 && t2.shouldRedrape() : !i2 && t2.hasTransition();
              });
            }
            _clearLineLayersFromRenderCache() {
              let t2 = false;
              for (const e2 of this._style.getSources()) if (e2 instanceof it) {
                t2 = true;
                break;
              }
              if (!t2) return;
              const i2 = {};
              for (let t3 = 0; t3 < this._style.order.length; ++t3) {
                const o2 = this._style._mergedLayers[this._style.order[t3]], s2 = this._style.getLayerSourceCache(o2);
                if (s2 && !i2[s2.id] && !o2.isHidden(this.painter.transform.zoom) && "line" === o2.type && o2.widthExpression() instanceof e.ab) {
                  i2[s2.id] = true;
                  for (const e2 of this.proxyCoords) {
                    const t4 = this.proxyToSource[e2.key][s2.id];
                    if (t4) for (const e3 of t4) this._clearRenderCacheForTile(s2.id, e3);
                  }
                }
              }
            }
            _clearRasterLayersFromRenderCache() {
              let e2 = false;
              for (const t3 in this._style._mergedSourceCaches) if (this._style._mergedSourceCaches[t3]._source instanceof ot) {
                e2 = true;
                break;
              }
              if (!e2) return;
              const t2 = {};
              for (let e3 = 0; e3 < this._style.order.length; ++e3) {
                const i2 = this._style._mergedLayers[this._style.order[e3]], o2 = this._style.getLayerSourceCache(i2);
                if (!o2 || t2[o2.id]) continue;
                if (i2.isHidden(this.painter.transform.zoom) || "raster" !== i2.type) continue;
                const s2 = i2.paint.get("raster-fade-duration");
                for (const e4 of this.proxyCoords) {
                  const t3 = this.proxyToSource[e4.key][o2.id];
                  if (t3) for (const e5 of t3) {
                    const t4 = Us(o2.getTile(e5), o2.findLoadedParent(e5, 0), o2, this.painter.transform, s2);
                    (1 !== t4.opacity || 0 !== t4.mix) && this._clearRenderCacheForTile(o2.id, e5);
                  }
                }
              }
            }
            _setupDrapedRenderBatches() {
              this._style.updateDrapeFirstLayers();
              const t2 = this._style.order, i2 = t2.length;
              if (0 === i2) return;
              const o2 = [];
              this._pendingGroundEffectLayers = [];
              let s2, r2 = 0, n2 = this._style._mergedLayers[t2[r2]];
              for (; !this._style.isLayerDraped(n2) && n2.isHidden(this.painter.transform.zoom) && ++r2 < i2; ) n2 = this._style._mergedLayers[t2[r2]];
              for (; r2 < i2; ++r2) {
                const e2 = this._style._mergedLayers[t2[r2]];
                e2.isHidden(this.painter.transform.zoom) || (this._style.isLayerDraped(e2) ? void 0 === s2 && (s2 = r2) : ("fill-extrusion" === e2.type && this._pendingGroundEffectLayers.push(r2), void 0 !== s2 && (o2.push({ start: s2, end: r2 - 1 }), s2 = void 0)));
              }
              if (void 0 !== s2 && o2.push({ start: s2, end: r2 - 1 }), 0 !== o2.length) {
                const t3 = o2[o2.length - 1];
                this._pendingGroundEffectLayers.every((e2) => e2 > t3.end) || e.w("fill-extrusion with flood lighting and/or ground ambient occlusion should be moved to be on top of all draped layers.");
              }
              this._drapedRenderBatches = o2;
            }
            _setupRenderCache(e2) {
              const t2 = this.proxySourceCache;
              if (this._shouldDisableRenderCache() || this.invalidateRenderCache) {
                if (this.invalidateRenderCache = false, t2.renderCache.length > t2.renderCachePool.length) {
                  const e3 = Object.values(t2.proxyCachedFBO);
                  t2.proxyCachedFBO = {};
                  for (let i3 = 0; i3 < e3.length; ++i3) {
                    const o3 = Object.values(e3[i3]);
                    t2.renderCachePool.push(...o3);
                  }
                }
                return;
              }
              this._clearRasterLayersFromRenderCache();
              const i2 = this.proxyCoords, o2 = this._tilesDirty;
              for (let s3 = i2.length - 1; s3 >= 0; s3--) {
                const r2 = i2[s3];
                if (t2.getTileByID(r2.key), void 0 !== t2.proxyCachedFBO[r2.key]) {
                  const i3 = e2[r2.key], s4 = this.proxyToSource[r2.key];
                  let n2 = 0;
                  for (const e3 in s4) {
                    const t3 = s4[e3], r3 = i3[e3];
                    if (!r3 || r3.length !== t3.length || t3.some((t4, i4) => t4 !== r3[i4] || o2[e3] && o2[e3].hasOwnProperty(t4.key))) {
                      n2 = -1;
                      break;
                    }
                    ++n2;
                  }
                  for (const e3 in t2.proxyCachedFBO[r2.key]) t2.renderCache[t2.proxyCachedFBO[r2.key][e3]].dirty = n2 < 0 || n2 !== Object.values(i3).length;
                }
              }
              const s2 = [...this._drapedRenderBatches];
              s2.sort((e3, t3) => t3.end - t3.start - (e3.end - e3.start));
              for (const e3 of s2) for (const o3 of i2) {
                if (t2.proxyCachedFBO[o3.key]) continue;
                let i3 = t2.renderCachePool.pop();
                void 0 === i3 && t2.renderCache.length < 50 && (i3 = t2.renderCache.length, t2.renderCache.push(this._createFBO())), void 0 !== i3 && (t2.proxyCachedFBO[o3.key] = {}, t2.proxyCachedFBO[o3.key][e3.start] = i3, t2.renderCache[i3].dirty = true);
              }
              this._tilesDirty = {};
            }
            _setupStencil(e2, t2, i2, o2) {
              if (!o2 || !this._sourceTilesOverlap[o2.id]) return void (this._overlapStencilType && (this._overlapStencilType = false));
              const s2 = this.painter.context, r2 = s2.gl;
              if (t2.length <= 1) return void (this._overlapStencilType = false);
              let n2;
              if (i2.isTileClipped()) n2 = t2.length, this._overlapStencilMode.test = { func: r2.EQUAL, mask: 255 }, this._overlapStencilType = "Clip";
              else {
                if (!(t2[0].overscaledZ > t2[t2.length - 1].overscaledZ)) return void (this._overlapStencilType = false);
                n2 = 1, this._overlapStencilMode.test = { func: r2.GREATER, mask: 255 }, this._overlapStencilType = "Mask";
              }
              this._stencilRef + n2 > 255 && (s2.clear({ stencil: 0 }), this._stencilRef = 0), this._stencilRef += n2, this._overlapStencilMode.ref = this._stencilRef, i2.isTileClipped() && this._renderTileClippingMasks(t2, this._overlapStencilMode.ref);
            }
            clipOrMaskOverlapStencilType() {
              return "Clip" === this._overlapStencilType || "Mask" === this._overlapStencilType;
            }
            stencilModeForRTTOverlap(e2) {
              return this.renderingToTexture && this._overlapStencilType ? ("Clip" === this._overlapStencilType && (this._overlapStencilMode.ref = this.painter._tileClippingMaskIDs[e2.key]), this._overlapStencilMode) : ji.disabled;
            }
            _renderTileClippingMasks(e2, t2) {
              const i2 = this.painter, o2 = this.painter.context, s2 = o2.gl;
              i2._tileClippingMaskIDs = {}, o2.setColorMode(ki.disabled), o2.setDepthMode(Ni.disabled);
              const r2 = i2.getOrCreateProgram("clippingMask");
              for (const o3 of e2) {
                const e3 = i2._tileClippingMaskIDs[o3.key] = --t2;
                r2.draw(i2, s2.TRIANGLES, Ni.disabled, new ji({ func: s2.ALWAYS, mask: 0 }, e3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), ki.disabled, qi.disabled, Ns(o3.projMatrix), "$clipping", i2.tileExtentBuffer, i2.quadTriangleIndexBuffer, i2.tileExtentSegments);
              }
            }
            pointCoordinate(t2) {
              const i2 = this.painter.transform;
              if (t2.x < 0 || t2.x > i2.width || t2.y < 0 || t2.y > i2.height) return null;
              const o2 = [t2.x, t2.y, 1, 1];
              e.aA(o2, o2, i2.pixelMatrixInverse), e.cw(o2, o2, 1 / o2[3]), o2[0] /= i2.worldSize, o2[1] /= i2.worldSize;
              const s2 = i2._camera.position, r2 = e.c6(1, i2.center.lat), n2 = [s2[0], s2[1], s2[2] / r2, 0], a2 = e.cY([], o2.slice(0, 3), n2);
              e.au(a2, a2);
              const l2 = this.raycast(n2, a2, this._exaggeration);
              return null !== l2 && l2 ? (e.bF(n2, n2, a2, l2), n2[3] = n2[2], n2[2] *= r2, n2) : null;
            }
            _setupProxiedCoordsForOrtho(t2, i2, o2) {
              if (t2.getSource() instanceof e.aP) return this._setupProxiedCoordsForImageSource(t2, i2, o2);
              this._findCoveringTileCache[t2.id] = this._findCoveringTileCache[t2.id] || {};
              const s2 = this.proxiedCoords[t2.id] = [], r2 = this.proxyCoords;
              for (let e2 = 0; e2 < r2.length; e2++) {
                const i3 = r2[e2], n3 = this._findTileCoveringTileID(i3, t2);
                if (n3) {
                  const e3 = this._createProxiedId(i3, n3, o2[i3.key] && o2[i3.key][t2.id]);
                  s2.push(e3), this.proxyToSource[i3.key][t2.id] = [e3];
                }
              }
              let n2 = false;
              const a2 = /* @__PURE__ */ new Set();
              for (let e2 = 0; e2 < i2.length; e2++) {
                const r3 = t2.getTile(i2[e2]);
                if (!r3 || !r3.hasData()) continue;
                const l2 = this._findTileCoveringTileID(r3.tileID, this.proxySourceCache);
                if (l2 && l2.tileID.canonical.z !== r3.tileID.canonical.z) {
                  const e3 = this.proxyToSource[l2.tileID.key][t2.id], i3 = this._createProxiedId(l2.tileID, r3, o2[l2.tileID.key] && o2[l2.tileID.key][t2.id]);
                  e3 ? e3.splice(e3.length - 1, 0, i3) : this.proxyToSource[l2.tileID.key][t2.id] = [i3];
                  const c2 = this.proxyToSource[l2.tileID.key][t2.id];
                  a2.has(c2) || a2.add(c2), s2.push(i3), n2 = true;
                }
              }
              if (this._sourceTilesOverlap[t2.id] = n2, n2 && this._debugParams.sortTilesHiZFirst) for (const e2 of a2) e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ);
            }
            _setupProxiedCoordsForImageSource(t2, i2, o2) {
              if (!t2.getSource().loaded()) return;
              const s2 = this.proxiedCoords[t2.id] = [], r2 = this.proxyCoords, n2 = t2.getSource(), a2 = n2.tileID;
              if (!a2) return;
              const l2 = new e.P(a2.x, a2.y)._div(1 << a2.z), c2 = n2.coordinates.map(e.ac.fromLngLat).reduce((e2, t3) => (e2.min.x = Math.min(e2.min.x, t3.x - l2.x), e2.min.y = Math.min(e2.min.y, t3.y - l2.y), e2.max.x = Math.max(e2.max.x, t3.x - l2.x), e2.max.y = Math.max(e2.max.y, t3.y - l2.y), e2), { min: new e.P(Number.MAX_VALUE, Number.MAX_VALUE), max: new e.P(-Number.MAX_VALUE, -Number.MAX_VALUE) }), h2 = (t3, i3) => {
                const o3 = t3.wrap + t3.canonical.x / (1 << t3.canonical.z), s3 = t3.canonical.y / (1 << t3.canonical.z), r3 = e.aj / (1 << t3.canonical.z), n3 = i3.wrap + i3.canonical.x / (1 << i3.canonical.z), a3 = i3.canonical.y / (1 << i3.canonical.z);
                return o3 + r3 < n3 + c2.min.x || o3 > n3 + c2.max.x || s3 + r3 < a3 + c2.min.y || s3 > a3 + c2.max.y;
              };
              for (let e2 = 0; e2 < r2.length; e2++) {
                const n3 = r2[e2];
                for (let e3 = 0; e3 < i2.length; e3++) {
                  const r3 = t2.getTile(i2[e3]);
                  if (!r3 || !r3.hasData()) continue;
                  if (h2(n3, r3.tileID)) continue;
                  const a3 = this._createProxiedId(n3, r3, o2[n3.key] && o2[n3.key][t2.id]), l3 = this.proxyToSource[n3.key][t2.id];
                  l3 ? l3.push(a3) : this.proxyToSource[n3.key][t2.id] = [a3], s2.push(a3);
                }
              }
            }
            _createProxiedId(t2, i2, o2) {
              let s2 = this.orthoMatrix;
              if (o2) {
                const e2 = o2.find((e3) => e3.key === i2.tileID.key);
                if (e2) return e2;
              }
              if (i2.tileID.key !== t2.key) {
                const o3 = t2.canonical.z - i2.tileID.canonical.z;
                let r2, n2, a2;
                s2 = e.bz();
                const l2 = i2.tileID.wrap - t2.wrap << t2.overscaledZ;
                o3 > 0 ? (r2 = e.aj >> o3, n2 = r2 * ((i2.tileID.canonical.x << o3) - t2.canonical.x + l2), a2 = r2 * ((i2.tileID.canonical.y << o3) - t2.canonical.y)) : (r2 = e.aj << -o3, n2 = e.aj * (i2.tileID.canonical.x - (t2.canonical.x + l2 << -o3)), a2 = e.aj * (i2.tileID.canonical.y - (t2.canonical.y << -o3))), e.c5(s2, 0, r2, 0, r2, 0, 1), e.bo(s2, s2, [n2, a2, 0]);
              }
              return new Gs(i2.tileID, t2.key, s2);
            }
            _findTileCoveringTileID(t2, i2) {
              let o2 = i2.getTile(t2);
              if (o2 && o2.hasData()) return o2;
              const s2 = this._findCoveringTileCache[i2.id], r2 = s2[t2.key];
              if (o2 = r2 ? i2.getTileByID(r2) : null, o2 && o2.hasData() || null === r2) return o2;
              let n2 = o2 ? o2.tileID : t2, a2 = n2.overscaledZ;
              const l2 = i2.getSource().minzoom, c2 = [];
              if (!r2) {
                const s3 = i2.getSource().maxzoom;
                if (t2.canonical.z >= s3) {
                  const o3 = t2.canonical.z - s3;
                  i2.getSource().reparseOverscaled ? (a2 = Math.max(t2.canonical.z + 2, i2.transform.tileZoom), n2 = new e.aM(a2, t2.wrap, s3, t2.canonical.x >> o3, t2.canonical.y >> o3)) : 0 !== o3 && (a2 = s3, n2 = new e.aM(a2, t2.wrap, s3, t2.canonical.x >> o3, t2.canonical.y >> o3));
                }
                n2.key !== t2.key && (c2.push(n2.key), o2 = i2.getTile(n2));
              }
              const h2 = (e2) => {
                c2.forEach((t3) => {
                  s2[t3] = e2;
                }), c2.length = 0;
              };
              for (a2 -= 1; a2 >= l2 && (!o2 || !o2.hasData()); a2--) {
                o2 && h2(o2.tileID.key);
                const e2 = n2.calculateScaledKey(a2);
                if (o2 = i2.getTileByID(e2), o2 && o2.hasData()) break;
                const t3 = s2[e2];
                if (null === t3) break;
                void 0 === t3 ? c2.push(e2) : o2 = i2.getTileByID(t3);
              }
              return h2(o2 ? o2.tileID.key : null), o2 && o2.hasData() ? o2 : null;
            }
            findDEMTileFor(e2) {
              return this.enabled ? this._findTileCoveringTileID(e2, this.sourceCache) : null;
            }
            prepareDrawTile() {
              this.renderedToTile = true;
            }
            _clearRenderCacheForTile(e2, t2) {
              let i2 = this._tilesDirty[e2];
              i2 || (i2 = this._tilesDirty[e2] = {}), i2[t2.key] = true;
            }
          }
          function Zs(t2, i2, o2) {
            const s2 = function(t3, i3, o3) {
              const s3 = e.bE(i3, t3), r3 = e.bE(o3, [0.2126, 0.7152, 0.0722]), n3 = (e2, t4, i4) => (1 - i4) * e2 + i4 * t4, a3 = n3(1 - 0.3 * Math.min(r3, 1), 1, Math.min(s3 + 1, 1));
              return n3(0.92, 1, Math.asin(e.aD(i3[2], -1, 1)) / Math.PI + 0.5) * a3;
            }(t2, [0, 0, 1], i2), r2 = [0, 0, 0];
            e.b$(r2, o2.slice(0, 3), s2);
            const n2 = [0, 0, 0];
            e.b$(n2, i2.slice(0, 3), t2[2]);
            const a2 = [0, 0, 0];
            return e.cU(a2, r2, n2), e.cX(a2);
          }
          const Hs = ["fill", "fillOutline", "fillPattern", "line", "linePattern", "background", "backgroundPattern", "hillshade", "raster"], Ws = ["stars", "rainParticle", "snowParticle", "fillExtrusion", "fillExtrusionGroundEffect", "elevatedStructures", "model", "symbol"];
          class $s {
            static cacheKey(e2, t2, i2, o2) {
              let s2 = `${t2}${o2 ? o2.cacheKey : ""}`;
              for (const t3 of i2) e2.usedDefines.includes(t3) && (s2 += `/${t3}`);
              return s2;
            }
            constructor(t2, i2, o2, s2, r2, n2) {
              const a2 = t2.gl;
              this.program = a2.createProgram(), this.configuration = s2, this.name = i2, this.fixedDefines = [...n2];
              const l2 = s2 ? s2.getBinderAttributes() : [], c2 = (o2.staticAttributes || []).concat(l2);
              let h2 = s2 ? s2.defines() : [];
              h2 = h2.concat(n2.map((e2) => `#define ${e2}`));
              const d2 = "#version 300 es\n";
              let u5 = d2 + h2.concat("precision mediump float;", Uo, No.fragmentSource).join("\n");
              for (const e2 of o2.fragmentIncludes) u5 += `
${Bo[e2]}`;
              u5 += `
${o2.fragmentSource}`;
              let _2 = d2 + h2.concat("precision highp float;", Uo, No.vertexSource).join("\n");
              for (const e2 of o2.vertexIncludes) _2 += `
${Bo[e2]}`;
              this.forceManualRenderingForInstanceIDShaders = t2.forceManualRenderingForInstanceIDShaders && -1 !== o2.vertexSource.indexOf("gl_InstanceID"), this.forceManualRenderingForInstanceIDShaders && (_2 += "\nuniform int u_instanceID;\n"), _2 += `
${o2.vertexSource}`, this.forceManualRenderingForInstanceIDShaders && (_2 = _2.replaceAll("gl_InstanceID", "u_instanceID"));
              const p2 = a2.createShader(a2.FRAGMENT_SHADER);
              if (a2.isContextLost()) return void (this.failedToCreate = true);
              a2.shaderSource(p2, u5), a2.compileShader(p2), a2.attachShader(this.program, p2);
              const f2 = a2.createShader(a2.VERTEX_SHADER);
              if (a2.isContextLost()) this.failedToCreate = true;
              else {
                a2.shaderSource(f2, _2), a2.compileShader(f2), a2.attachShader(this.program, f2), this.attributes = {}, this.numAttributes = c2.length;
                for (let e2 = 0; e2 < this.numAttributes; e2++) if (c2[e2]) {
                  const t3 = c2[e2].startsWith("a_") ? c2[e2] : `a_${c2[e2]}`;
                  a2.bindAttribLocation(this.program, e2, t3), this.attributes[t3] = e2;
                }
                a2.linkProgram(this.program), a2.deleteShader(f2), a2.deleteShader(p2), this.fixedUniforms = r2(t2), this.binderUniforms = s2 ? s2.getUniforms(t2) : [], this.forceManualRenderingForInstanceIDShaders && (this.instancingUniforms = ((t3) => ({ u_instanceID: new e.cc(t3) }))(t2)), (n2.includes("TERRAIN") || -1 !== i2.indexOf("symbol") || -1 !== i2.indexOf("circle")) && (this.terrainUniforms = ((t3) => ({ u_dem: new e.cc(t3), u_dem_prev: new e.cc(t3), u_dem_tl: new e.c9(t3), u_dem_scale: new e.cb(t3), u_dem_tl_prev: new e.c9(t3), u_dem_scale_prev: new e.cb(t3), u_dem_size: new e.cb(t3), u_dem_lerp: new e.cb(t3), u_exaggeration: new e.cb(t3), u_depth: new e.cc(t3), u_depth_size_inv: new e.c9(t3), u_depth_range_unpack: new e.c9(t3), u_occluder_half_size: new e.cb(t3), u_occlusion_depth_offset: new e.cb(t3), u_meter_to_dem: new e.cb(t3), u_label_plane_matrix_inv: new e.c8(t3) }))(t2)), n2.includes("GLOBE") && (this.globeUniforms = ((t3) => ({ u_tile_tl_up: new e.ca(t3), u_tile_tr_up: new e.ca(t3), u_tile_br_up: new e.ca(t3), u_tile_bl_up: new e.ca(t3), u_tile_up_scale: new e.cb(t3) }))(t2)), n2.includes("FOG") && (this.fogUniforms = ((t3) => ({ u_fog_matrix: new e.c8(t3), u_fog_range: new e.c9(t3), u_fog_color: new e.cQ(t3), u_fog_horizon_blend: new e.cb(t3), u_fog_vertical_limit: new e.c9(t3), u_fog_temporal_offset: new e.cb(t3), u_frustum_tl: new e.ca(t3), u_frustum_tr: new e.ca(t3), u_frustum_br: new e.ca(t3), u_frustum_bl: new e.ca(t3), u_globe_pos: new e.ca(t3), u_globe_radius: new e.cb(t3), u_globe_transition: new e.cb(t3), u_is_globe: new e.cc(t3), u_viewport: new e.c9(t3) }))(t2)), n2.includes("RENDER_CUTOFF") && (this.cutoffUniforms = ((t3) => ({ u_cutoff_params: new e.cQ(t3) }))(t2)), n2.includes("LIGHTING_3D_MODE") && (this.lightsUniforms = ((t3) => ({ u_lighting_ambient_color: new e.ca(t3), u_lighting_directional_dir: new e.ca(t3), u_lighting_directional_color: new e.ca(t3), u_ground_radiance: new e.ca(t3) }))(t2)), n2.includes("RENDER_SHADOWS") && (this.shadowUniforms = ((t3) => ({ u_light_matrix_0: new e.c8(t3), u_light_matrix_1: new e.c8(t3), u_fade_range: new e.c9(t3), u_shadow_normal_offset: new e.ca(t3), u_shadow_intensity: new e.cb(t3), u_shadow_texel_size: new e.cb(t3), u_shadow_map_resolution: new e.cb(t3), u_shadow_direction: new e.ca(t3), u_shadow_bias: new e.ca(t3), u_shadowmap_0: new e.cc(t3), u_shadowmap_1: new e.cc(t3) }))(t2));
              }
            }
            setTerrainUniformValues(e2, t2) {
              if (!this.terrainUniforms) return;
              const i2 = this.terrainUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setGlobeUniformValues(e2, t2) {
              if (!this.globeUniforms) return;
              const i2 = this.globeUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2) i2[e3] && i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setFogUniformValues(e2, t2) {
              if (!this.fogUniforms) return;
              const i2 = this.fogUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setCutoffUniformValues(e2, t2) {
              if (!this.cutoffUniforms) return;
              const i2 = this.cutoffUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setLightsUniformValues(e2, t2) {
              if (!this.lightsUniforms) return;
              const i2 = this.lightsUniforms;
              if (!this.failedToCreate) {
                e2.program.set(this.program);
                for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
              }
            }
            setShadowUniformValues(e2, t2) {
              if (this.failedToCreate || !this.shadowUniforms) return;
              const i2 = this.shadowUniforms;
              e2.program.set(this.program);
              for (const e3 in t2) i2[e3].set(this.program, e3, t2[e3]);
            }
            _drawDebugWireframe(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
              const d2 = t2.options.wireframe;
              if (false === d2.terrain && false === d2.layers2D && false === d2.layers3D) return;
              const u5 = t2.context;
              if (!(() => !(!d2.terrain || "terrainRaster" !== this.name && "globeRaster" !== this.name) || !(!d2.layers2D || t2._terrain && t2._terrain.renderingToTexture || !Hs.includes(this.name)) || !(!d2.layers3D || !Ws.includes(this.name)))()) return;
              const _2 = u5.gl, p2 = t2.wireframeDebugCache.getLinesFromTrianglesBuffer(t2.frameCounter, r2, u5);
              if (!p2) return;
              const f2 = [...this.fixedDefines];
              f2.push("DEBUG_WIREFRAME");
              const m2 = t2.getOrCreateProgram(this.name, { config: this.configuration, defines: f2 });
              u5.program.set(m2.program);
              const g2 = (e2, t3, i3) => {
                if (t3[e2] && i3[e2]) for (const o3 in t3[e2]) i3[e2][o3] && i3[e2][o3].set(i3.program, o3, t3[e2][o3].current);
              };
              c2 && c2.setUniforms(m2.program, u5, m2.binderUniforms, a2, { zoom: l2 }), g2("fixedUniforms", this, m2), g2("terrainUniforms", this, m2), g2("globeUniforms", this, m2), g2("fogUniforms", this, m2), g2("lightsUniforms", this, m2), g2("shadowUniforms", this, m2), p2.bind(), u5.setColorMode(new ki([_2.ONE, _2.ONE_MINUS_SRC_ALPHA, _2.ZERO, _2.ONE], e.am.transparent, [true, true, true, false])), u5.setDepthMode(new Ni(i2.func === _2.LESS ? _2.LEQUAL : i2.func, Ni.ReadOnly, i2.range)), u5.setStencilMode(ji.disabled);
              const v3 = 3 * n2.primitiveLength * 2, y2 = 3 * n2.primitiveOffset * 2 * 2;
              if (this.forceManualRenderingForInstanceIDShaders) {
                const e2 = h2 || 1;
                for (let t3 = 0; t3 < e2; ++t3) m2.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", t3), _2.drawElements(_2.LINES, v3, _2.UNSIGNED_SHORT, y2);
              } else h2 && h2 > 1 ? _2.drawElementsInstanced(_2.LINES, v3, _2.UNSIGNED_SHORT, y2, h2) : _2.drawElements(_2.LINES, v3, _2.UNSIGNED_SHORT, y2);
              r2.bind(), u5.program.set(this.program), u5.setDepthMode(i2), u5.setStencilMode(o2), u5.setColorMode(s2);
            }
            checkUniforms(e2, t2, i2) {
              if (this.fixedDefines.includes(t2)) {
                for (const o2 of Object.keys(i2)) if (!i2[o2].initialized) throw new Error(`Program '${this.name}', from draw '${e2}': uniform ${o2} not set but required by ${t2} being defined`);
              }
            }
            draw(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2) {
              const m2 = e2.context, g2 = m2.gl;
              if (this.failedToCreate) return;
              m2.program.set(this.program), m2.setDepthMode(i2), m2.setStencilMode(o2), m2.setColorMode(s2), m2.setCullFace(r2);
              for (const e3 of Object.keys(this.fixedUniforms)) this.fixedUniforms[e3].set(this.program, e3, n2[e3]);
              _2 && _2.setUniforms(this.program, m2, this.binderUniforms, d2, { zoom: u5 });
              const v3 = { [g2.POINTS]: 1, [g2.LINES]: 2, [g2.TRIANGLES]: 3, [g2.LINE_STRIP]: 1 }[t2];
              this.checkUniforms(a2, "RENDER_SHADOWS", this.shadowUniforms);
              const y2 = f2 && f2 > 0 ? 1 : void 0;
              for (const r3 of h2.get()) {
                const n3 = r3.vaos || (r3.vaos = {});
                if ((n3[a2] || (n3[a2] = new qo())).bind(m2, this, l2, _2 ? _2.getPaintVertexBuffers() : [], c2, r3.vertexOffset, p2 || [], y2), this.forceManualRenderingForInstanceIDShaders) {
                  const e3 = f2 || 1;
                  for (let i3 = 0; i3 < e3; ++i3) this.instancingUniforms.u_instanceID.set(this.program, "u_instanceID", i3), c2 ? g2.drawElements(t2, r3.primitiveLength * v3, g2.UNSIGNED_SHORT, r3.primitiveOffset * v3 * 2) : g2.drawArrays(t2, r3.vertexOffset, r3.vertexLength);
                } else f2 && f2 > 1 ? g2.drawElementsInstanced(t2, r3.primitiveLength * v3, g2.UNSIGNED_SHORT, r3.primitiveOffset * v3 * 2, f2) : c2 ? g2.drawElements(t2, r3.primitiveLength * v3, g2.UNSIGNED_SHORT, r3.primitiveOffset * v3 * 2) : g2.drawArrays(t2, r3.vertexOffset, r3.vertexLength);
                t2 === g2.TRIANGLES && c2 && this._drawDebugWireframe(e2, i2, o2, s2, c2, r3, d2, u5, _2, f2);
              }
            }
          }
          function Xs(t2, i2, o2 = 0) {
            const s2 = Math.pow(2, i2.tileID.overscaledZ), r2 = i2.tileSize * Math.pow(2, t2.transform.tileZoom) / s2, n2 = r2 * (i2.tileID.canonical.x + i2.tileID.wrap * s2), a2 = r2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture ? i2.imageAtlasTexture.size : [0, 0], u_tile_units_to_pixels: 1 / e.aw(i2, 1, t2.transform.tileZoom), u_pixel_coord_upper: [n2 >> 16, a2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & a2], u_pattern_transition: o2 };
          }
          const Ys = { terrain: 0, flat: 1 }, Ks = e.bz(), Js = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3) => {
            const y2 = i2.style.light, x2 = y2.properties.get("position"), b2 = [x2.x, x2.y, x2.z], w2 = e.dx();
            "viewport" === y2.properties.get("anchor") && (e.dy(w2, -i2.transform.angle), e.dz(b2, b2, w2));
            const T2 = y2.properties.get("color"), E2 = i2.transform, S2 = { u_matrix: t2, u_lightpos: b2, u_lightintensity: y2.properties.get("intensity"), u_lightcolor: [T2.r, T2.g, T2.b], u_vertical_gradient: +o2, u_opacity: s2, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: Ks, u_merc_center: [0, 0], u_up_dir: [0, 0, 0], u_height_lift: 0, u_height_type: Ys[h2], u_base_type: Ys[d2], u_ao: r2, u_edge_radius: n2, u_width_scale: a2, u_flood_light_color: f2, u_vertical_scale: m2, u_flood_light_intensity: g2, u_ground_shadow_factor: v3 };
            return "globe" === E2.projection.name && (S2.u_tile_id = [l2.canonical.x, l2.canonical.y, 1 << l2.canonical.z], S2.u_zoom_transition = u5, S2.u_inv_rot_matrix = p2, S2.u_merc_center = _2, S2.u_up_dir = E2.projection.upVector(new e.cp(0, 0, 0), _2[0] * e.aj, _2[1] * e.aj), S2.u_height_lift = c2), S2;
          }, Qs = (e2, t2, i2, o2, s2, r2) => ({ u_matrix: e2, u_edge_radius: t2, u_width_scale: i2, u_vertical_scale: o2, u_height_type: Ys[s2], u_base_type: Ys[r2] }), er = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3) => {
            const y2 = Js(t2, i2, o2, s2, r2, n2, a2, l2, h2, d2, u5, _2, p2, f2, m2, g2, 1, [0, 0, 0]), x2 = { u_height_factor: -Math.pow(2, l2.overscaledZ) / c2.tileSize / 8 };
            return e.l(y2, Xs(i2, c2, v3), x2);
          }, tr = (e2, t2, i2) => ({ u_matrix: e2, u_emissive_strength: t2, u_ground_shadow_factor: i2 }), ir = (t2, i2, o2, s2, r2, n2 = 0) => e.l(tr(t2, i2, r2), Xs(o2, s2, n2)), or = (e2, t2, i2, o2) => ({ u_matrix: e2, u_world: i2, u_emissive_strength: t2, u_ground_shadow_factor: o2 }), sr = (t2, i2, o2, s2, r2, n2, a2 = 0) => e.l(ir(t2, i2, o2, s2, n2, a2), { u_world: r2 }), rr = (e2, t2) => ({ u_matrix: e2, u_ground_shadow_factor: t2 }), nr = (e2, t2, i2, o2, s2) => ({ u_matrix: e2, u_camera_pos: [t2[0], t2[1], t2[2]], u_depth_bias: i2, u_height_scale: o2, u_reset_depth: s2 }), ar = (t2, i2, o2, s2) => {
            const r2 = e.aj / o2.tileSize;
            return { u_matrix: t2, u_camera_to_center_distance: i2.getCameraToCenterDistance(s2), u_extrude_scale: [i2.pixelsToGLUnits[0] / r2, i2.pixelsToGLUnits[1] / r2] };
          }, lr = (e2, t2, i2 = 1) => ({ u_matrix: e2, u_color: t2.toRenderColor(null), u_overlay: 0, u_overlay_scale: i2 }), cr = e.bz(), hr = (t2, i2, o2, s2, r2, n2, a2) => {
            const l2 = t2.transform, c2 = "globe" === l2.projection.name, h2 = c2 ? e.dA(l2.zoom, i2.canonical) * l2._pixelsPerMercatorPixel : e.aw(o2, 1, n2), d2 = { u_matrix: i2.projMatrix, u_extrude_scale: h2, u_intensity: a2, u_inv_rot_matrix: cr, u_merc_center: [0, 0], u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_up_dir: [0, 0, 0] };
            if (c2) {
              d2.u_inv_rot_matrix = s2, d2.u_merc_center = r2, d2.u_tile_id = [i2.canonical.x, i2.canonical.y, 1 << i2.canonical.z], d2.u_zoom_transition = e.ah(l2.zoom);
              const t3 = r2[0] * e.aj, o3 = r2[1] * e.aj;
              d2.u_up_dir = l2.projection.upVector(new e.cp(0, 0, 0), t3, o3);
            }
            return d2;
          };
          function dr(e2, [t2, i2, o2, s2], [r2, n2]) {
            if (r2 === n2) return [0, 0, 0, 0];
            const a2 = 255 * (e2 - 1) / (e2 * (n2 - r2));
            return [t2 * a2, i2 * a2, o2 * a2, s2 * a2];
          }
          function ur(e2, t2, [i2, o2]) {
            return i2 === o2 ? 0 : 0.5 / e2 + (t2 - i2) * (e2 - 1) / (e2 * (o2 - i2));
          }
          const _r = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3, y2, x2, b2) => ({ u_matrix: t2, u_normalize_matrix: i2, u_globe_matrix: o2, u_merc_matrix: s2, u_grid_matrix: r2, u_tl_parent: n2, u_scale_parent: h2, u_fade_t: d2.mix, u_opacity: d2.opacity * u5.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: u5.paint.get("raster-brightness-min"), u_brightness_high: u5.paint.get("raster-brightness-max"), u_saturation_factor: e.dB(u5.paint.get("raster-saturation")), u_contrast_factor: e.dC(u5.paint.get("raster-contrast")), u_spin_weights: pr(u5.paint.get("raster-hue-rotate")), u_perspective_transform: _2, u_raster_elevation: p2, u_zoom_transition: a2, u_merc_center: l2, u_cutoff_params: c2, u_colorization_mix: dr(e.dD, m2, v3), u_colorization_offset: ur(e.dD, g2, v3), u_color_ramp: f2, u_texture_offset: [x2 / (y2 + 2 * x2), y2 / (y2 + 2 * x2)], u_texture_res: [y2 + 2 * x2, y2 + 2 * x2], u_emissive_strength: b2 });
          function pr(e2) {
            e2 *= Math.PI / 180;
            const t2 = Math.sin(e2), i2 = Math.cos(e2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * t2 - i2 + 1) / 3, (Math.sqrt(3) * t2 - i2 + 1) / 3];
          }
          const fr = 0.05, mr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2) => ({ u_matrix: e2, u_normalize_matrix: t2, u_globe_matrix: i2, u_merc_matrix: o2, u_grid_matrix: s2, u_tl_parent: r2, u_scale_parent: c2, u_fade_t: h2.mix, u_opacity: h2.opacity, u_image0: 0, u_image1: 1, u_raster_elevation: d2, u_zoom_transition: n2, u_merc_center: a2, u_cutoff_params: l2 }), gr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_tile_offset: i2, u_velocity: o2, u_color_ramp: r2, u_velocity_res: s2, u_max_speed: n2, u_uv_offset: a2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [fr, fr] }), vr = (e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) => ({ u_particle_texture: e2, u_particle_texture_side_len: t2, u_velocity: i2, u_velocity_res: o2, u_max_speed: s2, u_speed_factor: r2, u_reset_rate: n2, u_rand_seed: Math.random(), u_uv_offset: a2, u_data_scale: [255 * l2[0], 255 * l2[1]], u_data_offset: c2, u_particle_pos_scale: 1.1, u_particle_pos_offset: [fr, fr] }), yr = e.bz(), xr = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3, y2, x2, b2, w2, T2) => {
            const E2 = r2.transform, S2 = { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: i2 ? i2.uSizeT : 0, u_size: i2 ? i2.uSize : 0, u_camera_to_center_distance: E2.getCameraToCenterDistance(y2), u_rotate_symbol: +o2, u_aspect_ratio: E2.width / E2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: n2, u_label_plane_matrix: a2, u_coord_matrix: l2, u_is_text: +h2, u_elevation_from_sea: c2 ? 1 : 0, u_pitch_with_map: +s2, u_texsize: d2, u_texsize_icon: u5, u_texture: 0, u_texture_icon: 1, u_tile_id: [0, 0, 0], u_zoom_transition: 0, u_inv_rot_matrix: yr, u_merc_center: [0, 0], u_camera_forward: [0, 0, 0], u_ecef_origin: [0, 0, 0], u_tile_matrix: yr, u_up_vector: [0, -1, 0], u_color_adj_mat: b2, u_icon_transition: w2 || 0, u_gamma_scale: s2 ? r2.transform.getCameraToCenterDistance(y2) * Math.cos(r2.terrain ? 0 : r2.transform._pitch) : 1, u_device_pixel_ratio: e.q.devicePixelRatio, u_is_halo: +_2, u_scale_factor: T2 || 1, u_ground_shadow_factor: x2, u_inv_matrix: e.bi(e.bz(), a2) };
            return "globe" === y2.name && (S2.u_tile_id = [p2.canonical.x, p2.canonical.y, 1 << p2.canonical.z], S2.u_zoom_transition = f2, S2.u_inv_rot_matrix = g2, S2.u_merc_center = m2, S2.u_camera_forward = E2._camera.forward(), S2.u_ecef_origin = e.dE(E2.globeMatrix, p2.toUnwrapped()), S2.u_tile_matrix = Float32Array.from(E2.globeMatrix), S2.u_up_vector = v3), S2;
          }, br = (e2, t2, i2, o2) => ({ u_matrix: e2, u_emissive_strength: t2, u_opacity: i2, u_color: o2 }), wr = (t2, i2, o2, s2, r2, n2, a2, l2, c2) => e.l(function(t3, i3, o3, s3, r3, n3) {
            const { width: a3, height: l3 } = s3.imageManager.getPixelSize(i3), c3 = Math.pow(2, n3.tileID.overscaledZ), h2 = n3.tileSize * Math.pow(2, s3.transform.tileZoom) / c3, d2 = h2 * (n3.tileID.canonical.x + n3.tileID.wrap * c3), u5 = h2 * n3.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl: o3.tl, u_pattern_br: o3.br, u_texsize: [a3, l3], u_pattern_size: o3.displaySize, u_pattern_units_to_pixels: r3 ? [s3.transform.width, -1 * s3.transform.height] : [1 / e.aw(n3, 1, s3.transform.tileZoom), 1 / e.aw(n3, 1, s3.transform.tileZoom)], u_pixel_coord_upper: [d2 >> 16, u5 >> 16], u_pixel_coord_lower: [65535 & d2, 65535 & u5] };
          }(0, n2, a2, s2, l2, c2), { u_matrix: t2, u_emissive_strength: i2, u_opacity: o2 }), Tr = new Float32Array(e.bx([])), Er = (t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2 = [0, 0, 0], f2) => {
            const m2 = r2.style.light, g2 = m2.properties.get("position"), v3 = [-g2.x, -g2.y, g2.z], y2 = e.dx();
            "viewport" === m2.properties.get("anchor") && (e.dy(y2, -r2.transform.angle), e.dz(v3, v3, y2));
            const x2 = "MASK" === d2.alphaMode, b2 = m2.properties.get("color").toRenderColor(null), w2 = _2.paint.get("model-ambient-occlusion-intensity"), T2 = _2.paint.get("model-color").constantOr(e.am.white).toRenderColor(null), E2 = _2.paint.get("model-color-mix-intensity").constantOr(0);
            return { u_matrix: t2, u_lighting_matrix: i2, u_normal_matrix: o2, u_node_matrix: s2 || Tr, u_lightpos: v3, u_lightintensity: m2.properties.get("intensity"), u_lightcolor: [b2.r, b2.g, b2.b], u_camera_pos: p2, u_opacity: n2, u_baseTextureIsAlpha: 0, u_alphaMask: +x2, u_alphaCutoff: d2.alphaCutoff, u_baseColorFactor: [a2.r, a2.g, a2.b, a2.a], u_emissiveFactor: [l2[0], l2[1], l2[2], 1], u_metallicFactor: c2, u_roughnessFactor: h2, u_baseColorTexture: Yi.BaseColor, u_metallicRoughnessTexture: Yi.MetallicRoughness, u_normalTexture: Yi.Normal, u_occlusionTexture: Yi.Occlusion, u_emissionTexture: Yi.Emission, u_lutTexture: Yi.LUT, u_color_mix: [T2.r, T2.g, T2.b, E2], u_aoIntensity: w2, u_emissive_strength: u5, u_occlusionTextureTransform: f2 || [0, 0, 0, 0] };
          }, Sr = (e2, t2 = Tr, i2 = Tr) => ({ u_matrix: e2, u_instance: t2, u_node_matrix: i2 }), Ir = { fillExtrusion: (t2) => ({ u_matrix: new e.c8(t2), u_lightpos: new e.ca(t2), u_lightintensity: new e.cb(t2), u_lightcolor: new e.ca(t2), u_vertical_gradient: new e.cb(t2), u_opacity: new e.cb(t2), u_edge_radius: new e.cb(t2), u_width_scale: new e.cb(t2), u_ao: new e.c9(t2), u_height_type: new e.cc(t2), u_base_type: new e.cc(t2), u_tile_id: new e.ca(t2), u_zoom_transition: new e.cb(t2), u_inv_rot_matrix: new e.c8(t2), u_merc_center: new e.c9(t2), u_up_dir: new e.ca(t2), u_height_lift: new e.cb(t2), u_flood_light_color: new e.ca(t2), u_vertical_scale: new e.cb(t2), u_flood_light_intensity: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2) }), fillExtrusionDepth: (t2) => ({ u_matrix: new e.c8(t2), u_edge_radius: new e.cb(t2), u_width_scale: new e.cb(t2), u_vertical_scale: new e.cb(t2), u_height_type: new e.cc(t2), u_base_type: new e.cc(t2) }), fillExtrusionPattern: (t2) => ({ u_matrix: new e.c8(t2), u_lightpos: new e.ca(t2), u_lightintensity: new e.cb(t2), u_lightcolor: new e.ca(t2), u_vertical_gradient: new e.cb(t2), u_height_factor: new e.cb(t2), u_edge_radius: new e.cb(t2), u_width_scale: new e.cb(t2), u_ao: new e.c9(t2), u_height_type: new e.cc(t2), u_base_type: new e.cc(t2), u_tile_id: new e.ca(t2), u_zoom_transition: new e.cb(t2), u_inv_rot_matrix: new e.c8(t2), u_merc_center: new e.c9(t2), u_up_dir: new e.ca(t2), u_height_lift: new e.cb(t2), u_image: new e.cc(t2), u_texsize: new e.c9(t2), u_pixel_coord_upper: new e.c9(t2), u_pixel_coord_lower: new e.c9(t2), u_tile_units_to_pixels: new e.cb(t2), u_opacity: new e.cb(t2), u_pattern_transition: new e.cb(t2) }), fillExtrusionGroundEffect: (t2) => ({ u_matrix: new e.c8(t2), u_opacity: new e.cb(t2), u_ao_pass: new e.cb(t2), u_meter_to_tile: new e.cb(t2), u_ao: new e.c9(t2), u_flood_light_intensity: new e.cb(t2), u_flood_light_color: new e.ca(t2), u_attenuation: new e.cb(t2), u_edge_radius: new e.cb(t2), u_fb: new e.cc(t2), u_fb_size: new e.cb(t2), u_dynamic_offset: new e.cb(t2) }), fill: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2) }), fillPattern: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_image: new e.cc(t2), u_texsize: new e.c9(t2), u_pixel_coord_upper: new e.c9(t2), u_pixel_coord_lower: new e.c9(t2), u_tile_units_to_pixels: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2), u_pattern_transition: new e.cb(t2) }), fillOutline: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_world: new e.c9(t2), u_ground_shadow_factor: new e.ca(t2) }), fillOutlinePattern: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_world: new e.c9(t2), u_image: new e.cc(t2), u_texsize: new e.c9(t2), u_pixel_coord_upper: new e.c9(t2), u_pixel_coord_lower: new e.c9(t2), u_tile_units_to_pixels: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2), u_pattern_transition: new e.cb(t2) }), building: (t2) => ({ u_matrix: new e.c8(t2), u_normal_matrix: new e.c8(t2), u_opacity: new e.cb(t2) }), buildingDepth: (t2) => ({ u_matrix: new e.c8(t2) }), elevatedStructuresDepth: (t2) => ({ u_matrix: new e.c8(t2), u_depth_bias: new e.cb(t2) }), elevatedStructures: (t2) => ({ u_matrix: new e.c8(t2), u_ground_shadow_factor: new e.ca(t2) }), elevatedStructuresDepthReconstruct: (t2) => ({ u_matrix: new e.c8(t2), u_camera_pos: new e.ca(t2), u_depth_bias: new e.cb(t2), u_height_scale: new e.cb(t2), u_reset_depth: new e.cb(t2) }), circle: e.dF, collisionBox: (t2) => ({ u_matrix: new e.c8(t2), u_camera_to_center_distance: new e.cb(t2), u_extrude_scale: new e.c9(t2) }), collisionCircle: (t2) => ({ u_matrix: new e.c8(t2), u_inv_matrix: new e.c8(t2), u_camera_to_center_distance: new e.cb(t2), u_viewport_size: new e.c9(t2) }), debug: (t2) => ({ u_color: new e.di(t2), u_matrix: new e.c8(t2), u_overlay: new e.cc(t2), u_overlay_scale: new e.cb(t2) }), clippingMask: (t2) => ({ u_matrix: new e.c8(t2) }), heatmap: (t2) => ({ u_extrude_scale: new e.cb(t2), u_intensity: new e.cb(t2), u_matrix: new e.c8(t2), u_inv_rot_matrix: new e.c8(t2), u_merc_center: new e.c9(t2), u_tile_id: new e.ca(t2), u_zoom_transition: new e.cb(t2), u_up_dir: new e.ca(t2) }), heatmapTexture: (t2) => ({ u_image: new e.cc(t2), u_color_ramp: new e.cc(t2), u_opacity: new e.cb(t2) }), hillshade: (t2) => ({ u_matrix: new e.c8(t2), u_image: new e.cc(t2), u_latrange: new e.c9(t2), u_light: new e.c9(t2), u_shadow: new e.di(t2), u_highlight: new e.di(t2), u_emissive_strength: new e.cb(t2), u_accent: new e.di(t2) }), hillshadePrepare: (t2) => ({ u_matrix: new e.c8(t2), u_image: new e.cc(t2), u_dimension: new e.c9(t2), u_zoom: new e.cb(t2) }), line: e.dG, linePattern: e.dH, raster: (t2) => ({ u_matrix: new e.c8(t2), u_normalize_matrix: new e.c8(t2), u_globe_matrix: new e.c8(t2), u_merc_matrix: new e.c8(t2), u_grid_matrix: new e.dj(t2), u_tl_parent: new e.c9(t2), u_scale_parent: new e.cb(t2), u_fade_t: new e.cb(t2), u_opacity: new e.cb(t2), u_image0: new e.cc(t2), u_image1: new e.cc(t2), u_brightness_low: new e.cb(t2), u_brightness_high: new e.cb(t2), u_saturation_factor: new e.cb(t2), u_contrast_factor: new e.cb(t2), u_spin_weights: new e.ca(t2), u_perspective_transform: new e.c9(t2), u_raster_elevation: new e.cb(t2), u_zoom_transition: new e.cb(t2), u_merc_center: new e.c9(t2), u_cutoff_params: new e.cQ(t2), u_colorization_mix: new e.cQ(t2), u_colorization_offset: new e.cb(t2), u_color_ramp: new e.cc(t2), u_texture_offset: new e.c9(t2), u_texture_res: new e.c9(t2), u_emissive_strength: new e.cb(t2) }), rasterParticle: (t2) => ({ u_matrix: new e.c8(t2), u_normalize_matrix: new e.c8(t2), u_globe_matrix: new e.c8(t2), u_merc_matrix: new e.c8(t2), u_grid_matrix: new e.dj(t2), u_tl_parent: new e.c9(t2), u_scale_parent: new e.cb(t2), u_fade_t: new e.cb(t2), u_opacity: new e.cb(t2), u_image0: new e.cc(t2), u_image1: new e.cc(t2), u_raster_elevation: new e.cb(t2), u_zoom_transition: new e.cb(t2), u_merc_center: new e.c9(t2), u_cutoff_params: new e.cQ(t2) }), rasterParticleTexture: (t2) => ({ u_texture: new e.cc(t2), u_opacity: new e.cb(t2) }), rasterParticleDraw: (t2) => ({ u_particle_texture: new e.cc(t2), u_particle_texture_side_len: new e.cb(t2), u_tile_offset: new e.c9(t2), u_velocity: new e.cc(t2), u_color_ramp: new e.cc(t2), u_velocity_res: new e.c9(t2), u_max_speed: new e.cb(t2), u_uv_offset: new e.c9(t2), u_data_scale: new e.c9(t2), u_data_offset: new e.cb(t2), u_particle_pos_scale: new e.cb(t2), u_particle_pos_offset: new e.c9(t2) }), rasterParticleUpdate: (t2) => ({ u_particle_texture: new e.cc(t2), u_particle_texture_side_len: new e.cb(t2), u_velocity: new e.cc(t2), u_velocity_res: new e.c9(t2), u_max_speed: new e.cb(t2), u_speed_factor: new e.cb(t2), u_reset_rate: new e.cb(t2), u_rand_seed: new e.cb(t2), u_uv_offset: new e.c9(t2), u_data_scale: new e.c9(t2), u_data_offset: new e.cb(t2), u_particle_pos_scale: new e.cb(t2), u_particle_pos_offset: new e.c9(t2) }), symbol: (t2) => ({ u_is_size_zoom_constant: new e.cc(t2), u_is_size_feature_constant: new e.cc(t2), u_size_t: new e.cb(t2), u_size: new e.cb(t2), u_camera_to_center_distance: new e.cb(t2), u_rotate_symbol: new e.cc(t2), u_aspect_ratio: new e.cb(t2), u_fade_change: new e.cb(t2), u_matrix: new e.c8(t2), u_label_plane_matrix: new e.c8(t2), u_coord_matrix: new e.c8(t2), u_is_text: new e.cc(t2), u_elevation_from_sea: new e.cc(t2), u_pitch_with_map: new e.cc(t2), u_texsize: new e.c9(t2), u_texsize_icon: new e.c9(t2), u_texture: new e.cc(t2), u_texture_icon: new e.cc(t2), u_gamma_scale: new e.cb(t2), u_device_pixel_ratio: new e.cb(t2), u_tile_id: new e.ca(t2), u_zoom_transition: new e.cb(t2), u_inv_rot_matrix: new e.c8(t2), u_merc_center: new e.c9(t2), u_camera_forward: new e.ca(t2), u_tile_matrix: new e.c8(t2), u_up_vector: new e.ca(t2), u_ecef_origin: new e.ca(t2), u_is_halo: new e.cc(t2), u_icon_transition: new e.cb(t2), u_color_adj_mat: new e.c8(t2), u_scale_factor: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2), u_inv_matrix: new e.c8(t2) }), background: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_opacity: new e.cb(t2), u_color: new e.di(t2) }), backgroundPattern: (t2) => ({ u_matrix: new e.c8(t2), u_emissive_strength: new e.cb(t2), u_opacity: new e.cb(t2), u_image: new e.cc(t2), u_pattern_tl: new e.c9(t2), u_pattern_br: new e.c9(t2), u_texsize: new e.c9(t2), u_pattern_size: new e.c9(t2), u_pixel_coord_upper: new e.c9(t2), u_pixel_coord_lower: new e.c9(t2), u_pattern_units_to_pixels: new e.c9(t2) }), terrainRaster: (t2) => ({ u_matrix: new e.c8(t2), u_image0: new e.cc(t2), u_skirt_height: new e.cb(t2), u_ground_shadow_factor: new e.ca(t2) }), skybox: (t2) => ({ u_matrix: new e.c8(t2), u_sun_direction: new e.ca(t2), u_cubemap: new e.cc(t2), u_opacity: new e.cb(t2), u_temporal_offset: new e.cb(t2) }), skyboxGradient: (t2) => ({ u_matrix: new e.c8(t2), u_color_ramp: new e.cc(t2), u_center_direction: new e.ca(t2), u_radius: new e.cb(t2), u_opacity: new e.cb(t2), u_temporal_offset: new e.cb(t2) }), skyboxCapture: (t2) => ({ u_matrix_3f: new e.dj(t2), u_sun_direction: new e.ca(t2), u_sun_intensity: new e.cb(t2), u_color_tint_r: new e.cQ(t2), u_color_tint_m: new e.cQ(t2), u_luminance: new e.cb(t2) }), globeRaster: (t2) => ({ u_proj_matrix: new e.c8(t2), u_globe_matrix: new e.c8(t2), u_normalize_matrix: new e.c8(t2), u_merc_matrix: new e.c8(t2), u_zoom_transition: new e.cb(t2), u_merc_center: new e.c9(t2), u_image0: new e.cc(t2), u_grid_matrix: new e.dj(t2), u_skirt_height: new e.cb(t2), u_far_z_cutoff: new e.cb(t2), u_frustum_tl: new e.ca(t2), u_frustum_tr: new e.ca(t2), u_frustum_br: new e.ca(t2), u_frustum_bl: new e.ca(t2), u_globe_pos: new e.ca(t2), u_globe_radius: new e.cb(t2), u_viewport: new e.c9(t2) }), globeAtmosphere: (t2) => ({ u_frustum_tl: new e.ca(t2), u_frustum_tr: new e.ca(t2), u_frustum_br: new e.ca(t2), u_frustum_bl: new e.ca(t2), u_horizon: new e.cb(t2), u_transition: new e.cb(t2), u_fadeout_range: new e.cb(t2), u_color: new e.cQ(t2), u_high_color: new e.cQ(t2), u_space_color: new e.cQ(t2), u_temporal_offset: new e.cb(t2), u_horizon_angle: new e.cb(t2) }), model: (t2) => ({ u_matrix: new e.c8(t2), u_lighting_matrix: new e.c8(t2), u_normal_matrix: new e.c8(t2), u_node_matrix: new e.c8(t2), u_lightpos: new e.ca(t2), u_lightintensity: new e.cb(t2), u_lightcolor: new e.ca(t2), u_camera_pos: new e.ca(t2), u_opacity: new e.cb(t2), u_baseColorFactor: new e.cQ(t2), u_emissiveFactor: new e.cQ(t2), u_metallicFactor: new e.cb(t2), u_roughnessFactor: new e.cb(t2), u_baseTextureIsAlpha: new e.cc(t2), u_alphaMask: new e.cc(t2), u_alphaCutoff: new e.cb(t2), u_baseColorTexture: new e.cc(t2), u_metallicRoughnessTexture: new e.cc(t2), u_normalTexture: new e.cc(t2), u_occlusionTexture: new e.cc(t2), u_emissionTexture: new e.cc(t2), u_lutTexture: new e.cc(t2), u_color_mix: new e.cQ(t2), u_aoIntensity: new e.cb(t2), u_emissive_strength: new e.cb(t2), u_occlusionTextureTransform: new e.cQ(t2) }), modelDepth: (t2) => ({ u_matrix: new e.c8(t2), u_instance: new e.c8(t2), u_node_matrix: new e.c8(t2) }), groundShadow: (t2) => ({ u_matrix: new e.c8(t2), u_ground_shadow_factor: new e.ca(t2) }), stars: (t2) => ({ u_matrix: new e.c8(t2), u_up: new e.ca(t2), u_right: new e.ca(t2), u_intensity_multiplier: new e.cb(t2) }), snowParticle: (t2) => ({ u_modelview: new e.c8(t2), u_projection: new e.c8(t2), u_time: new e.cb(t2), u_cam_pos: new e.ca(t2), u_velocityConeAperture: new e.cb(t2), u_velocity: new e.cb(t2), u_horizontalOscillationRadius: new e.cb(t2), u_horizontalOscillationRate: new e.cb(t2), u_boxSize: new e.cb(t2), u_billboardSize: new e.cb(t2), u_simpleShapeParameters: new e.c9(t2), u_screenSize: new e.c9(t2), u_thinningCenterPos: new e.c9(t2), u_thinningShape: new e.ca(t2), u_thinningAffectedRatio: new e.cb(t2), u_thinningParticleOffset: new e.cb(t2), u_particleColor: new e.cQ(t2), u_direction: new e.ca(t2) }), rainParticle: (t2) => ({ u_modelview: new e.c8(t2), u_projection: new e.c8(t2), u_time: new e.cb(t2), u_cam_pos: new e.ca(t2), u_texScreen: new e.cc(t2), u_velocityConeAperture: new e.cb(t2), u_velocity: new e.cb(t2), u_boxSize: new e.cb(t2), u_rainDropletSize: new e.c9(t2), u_distortionStrength: new e.cb(t2), u_rainDirection: new e.ca(t2), u_color: new e.cQ(t2), u_screenSize: new e.c9(t2), u_thinningCenterPos: new e.c9(t2), u_thinningShape: new e.ca(t2), u_thinningAffectedRatio: new e.cb(t2), u_thinningParticleOffset: new e.cb(t2), u_shapeDirectionalPower: new e.cb(t2), u_shapeNormalPower: new e.cb(t2), u_mode: new e.cb(t2) }), vignette: (t2) => ({ u_vignetteShape: new e.ca(t2), u_vignetteColor: new e.cQ(t2) }), occlusion: (t2) => ({ u_matrix: new e.c8(t2), u_anchorPos: new e.ca(t2), u_screenSizePx: new e.c9(t2), u_occluderSizePx: new e.c9(t2), u_color: new e.cQ(t2) }) };
          class Cr {
            constructor(e2, t2, i2, o2) {
              this.id = Cr.uniqueIdxCounter, Cr.uniqueIdxCounter++, this.context = e2;
              const s2 = e2.gl;
              this.buffer = s2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), e2.bindElementBuffer.set(this.buffer), s2.bufferData(s2.ELEMENT_ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? s2.DYNAMIC_DRAW : s2.STATIC_DRAW), this.dynamicDraw || o2 || t2.destroy();
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(e2) {
              this.id = Cr.uniqueIdxCounter, Cr.uniqueIdxCounter++;
              const t2 = this.context.gl;
              this.context.unbindVAO(), this.bind(), t2.bufferSubData(t2.ELEMENT_ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          Cr.uniqueIdxCounter = 0;
          const Rr = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class Dr {
            constructor(e2, t2, i2, o2, s2, r2) {
              this.length = t2.length, this.attributes = i2, this.itemSize = t2.bytesPerElement, this.dynamicDraw = o2, this.instanceCount = r2, this.context = e2;
              const n2 = e2.gl;
              this.buffer = n2.createBuffer(), e2.bindVertexBuffer.set(this.buffer), n2.bufferData(n2.ARRAY_BUFFER, t2.arrayBuffer, this.dynamicDraw ? n2.DYNAMIC_DRAW : n2.STATIC_DRAW), this.dynamicDraw || s2 || t2.destroy();
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(e2) {
              const t2 = this.context.gl;
              this.bind(), t2.bufferSubData(t2.ARRAY_BUFFER, 0, e2.arrayBuffer);
            }
            enableAttributes(e2, t2) {
              for (let i2 = 0; i2 < this.attributes.length; i2++) {
                const o2 = t2.attributes[this.attributes[i2].name];
                void 0 !== o2 && e2.enableVertexAttribArray(o2);
              }
            }
            setVertexAttribPointers(e2, t2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const s2 = this.attributes[o2], r2 = t2.attributes[s2.name];
                void 0 !== r2 && e2.vertexAttribPointer(r2, s2.components, e2[Rr[s2.type]], false, this.itemSize, s2.offset + this.itemSize * (i2 || 0));
              }
            }
            setVertexAttribDivisor(e2, t2, i2) {
              for (let o2 = 0; o2 < this.attributes.length; o2++) {
                const s2 = t2.attributes[this.attributes[o2].name];
                void 0 !== s2 && this.instanceCount && this.instanceCount > 0 && e2.vertexAttribDivisor(s2, i2);
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          class Ar {
            constructor(e2, t2, i2, o2, s2) {
              this.context = e2, this.width = t2, this.height = i2;
              const r2 = this.framebuffer = e2.gl.createFramebuffer();
              o2 && (this.colorAttachment = new Rs(e2, r2)), s2 && (this.depthAttachmentType = s2, this.depthAttachment = "renderbuffer" === s2 ? new Ds(e2, r2) : new As(e2, r2));
            }
            destroy() {
              const e2 = this.context.gl;
              if (this.colorAttachment) {
                const t2 = this.colorAttachment.get();
                t2 && e2.deleteTexture(t2);
              }
              if (this.depthAttachment && this.depthAttachmentType) if ("renderbuffer" === this.depthAttachmentType) {
                const t2 = this.depthAttachment.get();
                t2 && e2.deleteRenderbuffer(t2);
              } else {
                const t2 = this.depthAttachment.get();
                t2 && e2.deleteTexture(t2);
              }
              e2.deleteFramebuffer(this.framebuffer);
            }
          }
          class Lr {
            constructor(e2, t2) {
              this.gl = e2, this.clearColor = new Yo(this), this.clearDepth = new Ko(this), this.clearStencil = new Jo(this), this.colorMask = new Qo(this), this.depthMask = new es(this), this.stencilMask = new ts(this), this.stencilFunc = new is(this), this.stencilOp = new os(this), this.stencilTest = new ss(this), this.depthRange = new rs(this), this.depthTest = new ns(this), this.depthFunc = new as(this), this.blend = new ls(this), this.blendFunc = new cs(this), this.blendColor = new hs(this), this.blendEquation = new ds(this), this.cullFace = new us(this), this.cullFaceSide = new _s(this), this.frontFace = new ps(this), this.program = new fs(this), this.activeTexture = new ms(this), this.viewport = new gs(this), this.bindFramebuffer = new vs(this), this.bindRenderbuffer = new ys(this), this.bindTexture = new xs(this), this.bindVertexBuffer = new bs(this), this.bindElementBuffer = new ws(this), this.bindVertexArrayOES = new Ts(this), this.pixelStoreUnpack = new Es(this), this.pixelStoreUnpackPremultiplyAlpha = new Ss(this), this.pixelStoreUnpackFlipY = new Is(this), this.options = t2 ? Object.assign({}, t2) : {}, this.options.extTextureFilterAnisotropicForceOff || (this.extTextureFilterAnisotropic = e2.getExtension("EXT_texture_filter_anisotropic") || e2.getExtension("MOZ_EXT_texture_filter_anisotropic") || e2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT))), this.extDebugRendererInfo = e2.getExtension("WEBGL_debug_renderer_info"), this.extDebugRendererInfo && (this.renderer = e2.getParameter(this.extDebugRendererInfo.UNMASKED_RENDERER_WEBGL), this.vendor = e2.getParameter(this.extDebugRendererInfo.UNMASKED_VENDOR_WEBGL)), this.forceManualRenderingForInstanceIDShaders = t2 && !!t2.forceManualRenderingForInstanceIDShaders || this.renderer && -1 !== this.renderer.indexOf("PowerVR"), this.options.extTextureFloatLinearForceOff || (this.extTextureFloatLinear = e2.getExtension("OES_texture_float_linear")), this.extRenderToTextureHalfFloat = e2.getExtension("EXT_color_buffer_half_float"), this.extTimerQuery = e2.getExtension("EXT_disjoint_timer_query_webgl2"), this.maxTextureSize = e2.getParameter(e2.MAX_TEXTURE_SIZE), this.maxPointSize = e2.getParameter(e2.ALIASED_POINT_SIZE_RANGE)[1];
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArrayOES.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(e2, t2, i2) {
              return new Cr(this, e2, t2, i2);
            }
            createVertexBuffer(e2, t2, i2, o2, s2) {
              return new Dr(this, e2, t2, i2, o2, s2);
            }
            createRenderbuffer(e2, t2, i2) {
              const o2 = this.gl, s2 = o2.createRenderbuffer();
              return this.bindRenderbuffer.set(s2), o2.renderbufferStorage(o2.RENDERBUFFER, e2, t2, i2), this.bindRenderbuffer.set(null), s2;
            }
            createFramebuffer(e2, t2, i2, o2) {
              return new Ar(this, e2, t2, i2, o2);
            }
            clear({ color: e2, depth: t2, stencil: i2, colorMask: o2 }) {
              const s2 = this.gl;
              let r2 = 0;
              e2 && (r2 |= s2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set(o2 || [true, true, true, true])), void 0 !== t2 && (r2 |= s2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(t2), this.depthMask.set(true)), void 0 !== i2 && (r2 |= s2.STENCIL_BUFFER_BIT, this.clearStencil.set(i2), this.stencilMask.set(255)), s2.clear(r2);
            }
            setCullFace(e2) {
              false === e2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(e2.mode), this.frontFace.set(e2.frontFace));
            }
            setDepthMode(e2) {
              e2.func !== this.gl.ALWAYS || e2.mask ? (this.depthTest.set(true), this.depthFunc.set(e2.func), this.depthMask.set(e2.mask), this.depthRange.set(e2.range)) : this.depthTest.set(false);
            }
            setStencilMode(e2) {
              e2.test.func !== this.gl.ALWAYS || e2.mask ? (this.stencilTest.set(true), this.stencilMask.set(e2.mask), this.stencilOp.set([e2.fail, e2.depthFail, e2.pass]), this.stencilFunc.set({ func: e2.test.func, ref: e2.ref, mask: e2.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(t2) {
              e.bv(t2.blendFunction, ki.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(t2.blendFunction), this.blendColor.set(t2.blendColor), t2.blendEquation ? this.blendEquation.set(t2.blendEquation) : this.blendEquation.setDefault()), this.colorMask.set(t2.mask);
            }
            unbindVAO() {
              this.bindVertexArrayOES.set(null);
            }
          }
          let Pr;
          function zr(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = t2.context, c2 = l2.gl, h2 = t2.transform, d2 = t2.getOrCreateProgram("collisionBox"), u5 = [];
            let _2 = 0, p2 = 0;
            for (let l3 = 0; l3 < s2.length; l3++) {
              const f3 = s2[l3], m3 = i2.getTile(f3), g3 = m3.getBucket(o2);
              if (!g3) continue;
              const v4 = ci(f3, g3, h2);
              let y3 = v4;
              0 === r2[0] && 0 === r2[1] || (y3 = t2.translatePosMatrix(v4, m3, r2, n2));
              const x3 = a2 ? g3.textCollisionBox : g3.iconCollisionBox, b2 = g3.collisionCircleArray;
              if (b2.length > 0) {
                const t3 = e.bz(), i3 = y3;
                e.cB(t3, g3.placementInvProjMatrix, h2.glCoordMatrix), e.cB(t3, t3, g3.placementViewportMatrix), u5.push({ circleArray: b2, circleOffset: p2, transform: i3, invTransform: t3, projection: g3.getProjection() }), _2 += b2.length / 4, p2 = _2;
              }
              x3 && (t2.terrain && t2.terrain.setupElevationDraw(m3, d2), d2.draw(t2, c2.LINES, Ni.disabled, ji.disabled, t2.colorModeForRenderPass(), qi.disabled, ar(y3, h2, m3, g3.getProjection()), o2.id, x3.layoutVertexBuffer, x3.indexBuffer, x3.segments, null, h2.zoom, null, [x3.collisionVertexBuffer, x3.collisionVertexBufferExt]));
            }
            if (!a2 || !u5.length) return;
            const f2 = t2.getOrCreateProgram("collisionCircle"), m2 = new e.dI();
            m2.resize(4 * _2), m2._trim();
            let g2 = 0;
            for (const e2 of u5) for (let t3 = 0; t3 < e2.circleArray.length / 4; t3++) {
              const i3 = 4 * t3, o3 = e2.circleArray[i3 + 0], s3 = e2.circleArray[i3 + 1], r3 = e2.circleArray[i3 + 2], n3 = e2.circleArray[i3 + 3];
              m2.emplace(g2++, o3, s3, r3, n3, 0), m2.emplace(g2++, o3, s3, r3, n3, 1), m2.emplace(g2++, o3, s3, r3, n3, 2), m2.emplace(g2++, o3, s3, r3, n3, 3);
            }
            (!Pr || Pr.length < 2 * _2) && (Pr = function(t3) {
              const i3 = 2 * t3, o3 = new e.a_();
              o3.resize(i3), o3._trim();
              for (let e2 = 0; e2 < i3; e2++) {
                const t4 = 6 * e2;
                o3.uint16[t4 + 0] = 4 * e2 + 0, o3.uint16[t4 + 1] = 4 * e2 + 1, o3.uint16[t4 + 2] = 4 * e2 + 2, o3.uint16[t4 + 3] = 4 * e2 + 2, o3.uint16[t4 + 4] = 4 * e2 + 3, o3.uint16[t4 + 5] = 4 * e2 + 0;
              }
              return o3;
            }(_2));
            const v3 = l2.createIndexBuffer(Pr, true), y2 = l2.createVertexBuffer(m2, e.dJ.members, true);
            for (const i3 of u5) {
              const s3 = { u_matrix: i3.transform, u_inv_matrix: i3.invTransform, u_camera_to_center_distance: (x2 = h2).getCameraToCenterDistance(i3.projection), u_viewport_size: [x2.width, x2.height] };
              f2.draw(t2, c2.TRIANGLES, Ni.disabled, ji.disabled, t2.colorModeForRenderPass(), qi.disabled, s3, o2.id, y2, v3, e.bd.simpleSegment(0, 2 * i3.circleOffset, i3.circleArray.length, i3.circleArray.length / 2), null, h2.zoom);
            }
            var x2;
            y2.destroy(), v3.destroy();
          }
          const Mr = e.bz();
          function Or(t2) {
            const i2 = t2._camera.getWorldToCamera(t2.worldSize, 1), o2 = e.az([], i2, t2.globeMatrix);
            e.bi(o2, o2);
            const s2 = [0, 0, 0], r2 = [0, 1, 0, 0];
            return e.aA(r2, r2, o2), s2[0] = r2[0], s2[1] = r2[1], s2[2] = r2[2], e.au(s2, s2), s2;
          }
          function Fr({ width: t2, height: i2, anchor: o2, textOffset: s2, textScale: r2 }, n2) {
            const { horizontalAlign: a2, verticalAlign: l2 } = e.bV(o2), c2 = -(a2 - 0.5) * t2, h2 = -(l2 - 0.5) * i2, d2 = e.bU(o2, s2);
            return new e.P((c2 / r2 + d2[0]) * n2, (h2 / r2 + d2[1]) * n2);
          }
          function Br(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2) {
            const d2 = t2.text.placedSymbolArray, u5 = t2.text.dynamicLayoutVertexArray, _2 = t2.icon.dynamicLayoutVertexArray, p2 = {}, f2 = t2.getProjection(), m2 = hi(a2, f2, r2), g2 = r2.elevation, v3 = f2.upVectorScale(a2.canonical, r2.center.lat, r2.worldSize).metersToTile;
            u5.clear();
            for (let _3 = 0; _3 < d2.length; _3++) {
              const y2 = d2.get(_3), { tileAnchorX: x2, tileAnchorY: b2, numGlyphs: w2 } = y2, T2 = y2.hidden || !y2.crossTileID || t2.allowVerticalPlacement && !y2.placedOrientation ? null : s2[y2.crossTileID];
              if (T2) {
                let s3 = 0, d3 = 0, _4 = 0;
                if (g2) {
                  const e2 = g2 ? g2.getAtTileOffset(a2, x2, b2) : 0, [t3, i3, o3] = f2.upVector(a2.canonical, x2, b2);
                  s3 = e2 * t3 * v3, d3 = e2 * i3 * v3, _4 = e2 * o3 * v3;
                }
                let [E2, S2, I2, C3] = $t(y2.projectedAnchorX + s3, y2.projectedAnchorY + d3, y2.projectedAnchorZ + _4, o2 ? m2 : n2);
                const R2 = Xt(r2.getCameraToCenterDistance(f2), C3);
                let D3 = e.bJ(t2.textSizeData, c2, y2) * R2 / e.bO;
                o2 && (D3 *= t2.tilePixelRatio / l2);
                const A2 = Fr(T2, D3);
                o2 ? ({ x: E2, y: S2, z: I2 } = f2.projectTilePoint(x2 + A2.x, b2 + A2.y, a2.canonical), [E2, S2, I2] = $t(E2 + s3, S2 + d3, I2 + _4, n2)) : (i2 && A2._rotate(-r2.angle), E2 += A2.x, S2 += A2.y, I2 = 0);
                const L2 = t2.allowVerticalPlacement && y2.placedOrientation === e.bI.vertical ? Math.PI / 2 : 0;
                for (let t3 = 0; t3 < w2; t3++) e.bL(u5, E2, S2, I2, L2);
                h2 && y2.associatedIconIndex >= 0 && (p2[y2.associatedIconIndex] = { x: E2, y: S2, z: I2, angle: L2 });
              } else si(w2, u5);
            }
            if (h2) {
              _2.clear();
              const i3 = t2.icon.placedSymbolArray;
              for (let t3 = 0; t3 < i3.length; t3++) {
                const o3 = i3.get(t3), { numGlyphs: s3 } = o3, r3 = p2[t3];
                if (o3.hidden || !r3) si(s3, _2);
                else {
                  const { x: t4, y: i4, z: o4, angle: n3 } = r3;
                  for (let r4 = 0; r4 < s3; r4++) e.bL(_2, t4, i4, o4, n3);
                }
              }
              t2.icon.dynamicLayoutVertexBuffer.updateData(_2);
            }
            t2.text.dynamicLayoutVertexBuffer.updateData(u5);
          }
          function kr(t2, i2, o2, s2, r2, n2, a2 = {}) {
            const l2 = o2.paint.get("icon-translate"), c2 = o2.paint.get("text-translate"), h2 = o2.paint.get("icon-translate-anchor"), d2 = o2.paint.get("text-translate-anchor"), u5 = o2.layout.get("icon-rotation-alignment"), _2 = o2.layout.get("text-rotation-alignment"), p2 = o2.layout.get("icon-pitch-alignment"), f2 = o2.layout.get("text-pitch-alignment"), m2 = o2.layout.get("icon-keep-upright"), g2 = o2.layout.get("text-keep-upright"), v3 = o2.paint.get("icon-color-saturation"), y2 = o2.paint.get("icon-color-contrast"), x2 = o2.paint.get("icon-color-brightness-min"), b2 = o2.paint.get("icon-color-brightness-max"), w2 = "sea" === o2.layout.get("symbol-elevation-reference"), T2 = t2.context, E2 = T2.gl, S2 = t2.transform, I2 = "map" === u5, C3 = "map" === _2, R2 = "map" === p2, D3 = "map" === f2, A2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1);
            let L2 = false;
            const P2 = t2.depthModeForSublayer(0, Ni.ReadOnly), z2 = new Ni(t2.context.gl.LEQUAL, Ni.ReadOnly, t2.depthRangeFor3D), M2 = [e.ay(S2.center.lng), e.aH(S2.center.lat)], O2 = o2.layout.get("text-variable-anchor"), F2 = "globe" === S2.projection.name, B3 = [], k2 = [0, -1, 0];
            for (const r3 of s2) {
              const s3 = i2.getTile(r3), n3 = s3.getBucket(o2);
              if (!n3) continue;
              if ("mercator" === n3.projection.name && F2) continue;
              if (n3.fullyClipped) continue;
              const u6 = "globe" === n3.projection.name, _3 = u6 ? e.ah(S2.zoom) : 0, p3 = hi(r3, n3.getProjection(), S2), f3 = S2.calculatePixelsToTileUnitsMatrix(s3), T3 = O2 && n3.hasTextData(), N2 = n3.hasIconTextFit() && T3 && n3.hasIconData(), U2 = "road" === n3.elevationType ? z2 : P2, j2 = n3.getProjection().createInversionMatrix(S2, r3.canonical), V2 = t2.shadowRenderer, G2 = "road" === n3.elevationType && !!V2 && V2.enabled;
              let q2 = [0, 0, 0];
              if (G2) {
                const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
                e2 && i3 && (q2 = ao(t2.style, e2, i3));
              }
              const Z2 = (e2) => {
                S2.depthOcclusionForSymbolsAndCircles && (o2.hasInitialOcclusionOpacityProperties || t2.terrain) && (e2.push("DEPTH_D24"), e2.push("DEPTH_OCCLUSION"));
              }, H2 = () => {
                const i3 = I2 && "point" !== o2.layout.get("symbol-placement"), a3 = [];
                Z2(a3);
                const c3 = i3 || N2, d3 = o2.paint.get("icon-image-cross-fade");
                t2.terrainRenderModeElevated() && R2 && a3.push("PITCH_WITH_MAP_TERRAIN"), u6 && (a3.push("PROJECTION_GLOBE_VIEW"), c3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), d3 > 0 && a3.push("ICON_TRANSITION"), n3.icon.zOffsetVertexBuffer && a3.push("Z_OFFSET"), 0 === v3 && 0 === y2 && 0 === x2 && 1 === b2 || a3.push("COLOR_ADJUSTMENT"), n3.sdfIcons && a3.push("RENDER_SDF"), G2 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                const g3 = n3.icon.programConfigurations.get(o2.id), T4 = t2.getOrCreateProgram("symbol", { config: g3, defines: a3 }), C4 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], D4 = n3.iconSizeData, A3 = e.bH(D4, S2.zoom), L3 = R2 || 0 !== S2.pitch, P3 = Zt(p3, s3.tileID.canonical, R2, I2, S2, n3.getProjection(), f3), z3 = Wt(p3, s3.tileID.canonical, R2, I2, S2, n3.getProjection(), f3), O3 = t2.translatePosMatrix(z3, s3, l2, h2, true), B4 = t2.translatePosMatrix(p3, s3, l2, h2), V3 = c3 ? Mr : P3, H3 = I2 && !R2 && !i3;
                let W3 = k2;
                !F2 && !S2.mercatorFromTransition || I2 || (W3 = Or(S2));
                const $3 = u6 ? W3 : k2, X3 = o2.getColorAdjustmentMatrix(v3, y2, x2, b2), Y3 = xr(D4.kind, A3, H3, R2, t2, B4, V3, O3, w2, false, C4, [0, 0], true, r3, _3, M2, j2, $3, n3.getProjection(), q2, X3, d3), K3 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, J3 = 1 !== o2.layout.get("icon-size").constantOr(0) || n3.iconsNeedLinear, Q3 = n3.sdfIcons || t2.options.rotating || t2.options.zooming || J3 || L3 ? E2.LINEAR : E2.NEAREST, ee2 = n3.sdfIcons && 0 !== o2.paint.get("icon-halo-width").constantOr(1), te2 = t2.terrain && R2 && i3 ? e.bi(e.bz(), P3) : Mr;
                if (i3 && n3.icon) {
                  const e2 = S2.elevation, i4 = e2 ? e2.getAtTileOffsetFunc(r3, S2.center.lat, S2.worldSize, n3.getProjection()) : null, o3 = Ht(p3, s3.tileID.canonical, R2, I2, S2, n3.getProjection(), f3);
                  Kt(n3, p3, t2, false, o3, z3, R2, m2, i4, r3);
                }
                return { program: T4, buffers: n3.icon, uniformValues: Y3, atlasTexture: K3, atlasTextureIcon: null, atlasInterpolation: Q3, atlasInterpolationIcon: null, isSDF: n3.sdfIcons, hasHalo: ee2, depthMode: U2, tile: s3, renderWithShadows: G2, labelPlaneMatrixInv: te2 };
              }, W2 = () => {
                const i3 = C3 && "point" !== o2.layout.get("symbol-placement"), a3 = [], l3 = i3 || O2 || N2;
                t2.terrainRenderModeElevated() && D3 && a3.push("PITCH_WITH_MAP_TERRAIN"), u6 && (a3.push("PROJECTION_GLOBE_VIEW"), l3 && a3.push("PROJECTED_POS_ON_VIEWPORT")), n3.text.zOffsetVertexBuffer && a3.push("Z_OFFSET"), n3.iconsInText && a3.push("RENDER_TEXT_AND_SYMBOL"), a3.push("RENDER_SDF"), G2 && a3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), Z2(a3);
                const h3 = n3.text.programConfigurations.get(o2.id), m3 = t2.getOrCreateProgram("symbol", { config: h3, defines: a3 });
                let v4, y3 = [0, 0], x3 = null;
                const b3 = n3.textSizeData;
                n3.iconsInText && (y3 = s3.imageAtlasTexture ? s3.imageAtlasTexture.size : [0, 0], x3 = s3.imageAtlasTexture ? s3.imageAtlasTexture : null, v4 = D3 || 0 !== S2.pitch || t2.options.rotating || t2.options.zooming || "composite" === b3.kind || "camera" === b3.kind ? E2.LINEAR : E2.NEAREST);
                const T4 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture.size : [0, 0], I3 = o2.layout.get("text-size-scale-range"), R3 = e.aD(t2.scaleFactor, I3[0], I3[1]), A3 = e.bH(b3, S2.zoom, R3), L3 = Zt(p3, s3.tileID.canonical, D3, C3, S2, n3.getProjection(), f3), P3 = Wt(p3, s3.tileID.canonical, D3, C3, S2, n3.getProjection(), f3), z3 = t2.translatePosMatrix(P3, s3, c2, d2, true), B4 = t2.translatePosMatrix(p3, s3, c2, d2), V3 = l3 ? Mr : L3, H3 = C3 && !D3 && !i3;
                let W3 = k2;
                !F2 && !S2.mercatorFromTransition || C3 || (W3 = Or(S2));
                const $3 = xr(b3.kind, A3, H3, D3, t2, B4, V3, z3, w2, true, T4, y3, true, r3, _3, M2, j2, u6 ? W3 : k2, n3.getProjection(), q2, null, null, R3), X3 = s3.glyphAtlasTexture ? s3.glyphAtlasTexture : null, Y3 = E2.LINEAR, K3 = 0 !== o2.paint.get("text-halo-width").constantOr(1), J3 = t2.terrain && D3 && i3 ? e.bi(e.bz(), L3) : Mr;
                if (i3 && n3.text) {
                  const e2 = S2.elevation, i4 = e2 ? e2.getAtTileOffsetFunc(r3, S2.center.lat, S2.worldSize, n3.getProjection()) : null, o3 = Ht(p3, s3.tileID.canonical, D3, C3, S2, n3.getProjection(), f3);
                  Kt(n3, p3, t2, true, o3, P3, D3, g2, i4, r3);
                }
                return { program: m3, buffers: n3.text, uniformValues: $3, atlasTexture: X3, atlasTextureIcon: x3, atlasInterpolation: Y3, atlasInterpolationIcon: v4, isSDF: true, hasHalo: K3, depthMode: U2, tile: s3, renderWithShadows: G2, labelPlaneMatrixInv: J3 };
              }, $2 = n3.icon.segments.get().length, X2 = n3.text.segments.get().length, Y2 = $2 && !a2.onlyText ? H2() : null, K2 = X2 && !a2.onlyIcons ? W2() : null, J2 = o2.paint.get("icon-opacity").constantOr(1), Q2 = o2.paint.get("text-opacity").constantOr(1);
              if (A2 && n3.canOverlap) {
                L2 = true;
                const t3 = J2 && !a2.onlyText ? n3.icon.segments.get() : [], i3 = Q2 && !a2.onlyIcons ? n3.text.segments.get() : [];
                for (const i4 of t3) B3.push({ segments: new e.bd([i4]), sortKey: i4.sortKey, state: Y2 });
                for (const t4 of i3) B3.push({ segments: new e.bd([t4]), sortKey: t4.sortKey, state: K2 });
              } else a2.onlyText || B3.push({ segments: J2 ? n3.icon.segments : new e.bd([]), sortKey: 0, state: Y2 }), a2.onlyIcons || B3.push({ segments: Q2 ? n3.text.segments : new e.bd([]), sortKey: 0, state: K2 });
            }
            L2 && B3.sort((e2, t3) => e2.sortKey - t3.sortKey);
            for (const e2 of B3) {
              const i3 = e2.state;
              if (i3) if (t2.terrain ? t2.terrain.setupElevationDraw(i3.tile, i3.program, { useDepthForOcclusion: S2.depthOcclusionForSymbolsAndCircles, labelPlaneMatrixInv: i3.labelPlaneMatrixInv }) : t2.setupDepthForOcclusion(S2.depthOcclusionForSymbolsAndCircles, i3.program), T2.activeTexture.set(E2.TEXTURE0), i3.atlasTexture && i3.atlasTexture.bind(i3.atlasInterpolation, E2.CLAMP_TO_EDGE, true), i3.atlasTextureIcon && (T2.activeTexture.set(E2.TEXTURE1), i3.atlasTextureIcon && i3.atlasTextureIcon.bind(i3.atlasInterpolationIcon, E2.CLAMP_TO_EDGE, true)), i3.renderWithShadows && t2.shadowRenderer.setupShadows(i3.tile.tileID.toUnwrapped(), i3.program, "vector-tile", i3.tile.tileID.overscaledZ), t2.uploadCommonLightUniforms(t2.context, i3.program), i3.hasHalo) {
                const s3 = i3.uniformValues;
                s3.u_is_halo = 1, Nr(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, s3, 2), s3.u_is_halo = 0;
              } else {
                if (i3.isSDF) {
                  const s3 = i3.uniformValues;
                  i3.hasHalo && (s3.u_is_halo = 1, Nr(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, s3, 1)), s3.u_is_halo = 0;
                }
                Nr(i3.buffers, e2.segments, o2, t2, i3.program, i3.depthMode, r2, n2, i3.uniformValues, 1);
              }
            }
          }
          function Nr(e2, t2, i2, o2, s2, r2, n2, a2, l2, c2) {
            const h2 = [e2.dynamicLayoutVertexBuffer, e2.opacityVertexBuffer, e2.iconTransitioningVertexBuffer, e2.globeExtVertexBuffer, e2.zOffsetVertexBuffer];
            s2.draw(o2, o2.context.gl.TRIANGLES, r2, n2, a2, qi.disabled, l2, i2.id, e2.layoutVertexBuffer, e2.indexBuffer, t2, i2.paint, o2.transform.zoom, e2.programConfigurations.get(i2.id), h2, c2);
          }
          function Ur(t2, i2) {
            const o2 = 1 << t2.canonical.z, s2 = (i2.x * o2 - t2.canonical.x - t2.wrap * o2) * e.aj, r2 = (i2.y * o2 - t2.canonical.y) * e.aj, n2 = e.dS(i2.z, i2.y);
            return e.cS(s2, r2, n2);
          }
          function jr(t2, i2, o2, s2, r2) {
            if (!o2.layout || "none" === o2.layout.get("fill-elevation-reference")) return;
            const n2 = t2.context.gl, a2 = new Ni(t2.context.gl.LEQUAL, Ni.ReadWrite, t2.depthRangeFor3D), l2 = new Ni(t2.context.gl.GREATER, Ni.ReadWrite, t2.depthRangeFor3D), c2 = function(t3) {
              const i3 = e.cJ(t3.pitch);
              let o3 = 0.01;
              return t3.isOrthographic && (o3 = e.ai(1e-4, o3, e.cO(i3 >= Ji ? 1 : i3 / Ji))), 2 * o3;
            }(t2.transform), h2 = t2.transform.getFreeCameraOptions().position, d2 = "elevatedStructuresDepthReconstruct", u5 = t2.getOrCreateProgram(d2, { defines: ["DEPTH_RECONSTRUCTION"] }), _2 = t2.getOrCreateProgram(d2);
            for (const e2 of s2) {
              const s3 = i2.getTile(e2), d3 = s3.getBucket(o2);
              if (!d3) continue;
              const p2 = d3.elevatedStructures;
              if (!p2) continue;
              const f2 = d3.elevationBufferData.heightRange, m2 = Ur(e2.toUnwrapped(), h2), g2 = t2.translatePosMatrix(e2.projMatrix, s3, o2.paint.get("fill-translate"), o2.paint.get("fill-translate-anchor"));
              let v3, y2, x2, b2;
              if ("initialize" === r2) {
                if (!f2 || f2.min >= 1 || 0 === p2.depthSegments.segments[0].primitiveLength) continue;
                v3 = nr(g2, m2, c2, 1, 0), y2 = a2, x2 = p2.depthSegments, b2 = u5;
              } else if ("reset" === r2) {
                if (!f2 || f2.min >= 0 || 0 === p2.maskSegments.segments[0].primitiveLength) continue;
                v3 = nr(g2, m2, 0, 0, 1), y2 = l2, x2 = p2.maskSegments, b2 = u5;
              } else if ("geometry" === r2) {
                if (0 === p2.depthSegments.segments[0].primitiveLength) continue;
                v3 = nr(g2, m2, c2, 1, 0), y2 = a2, x2 = p2.depthSegments, b2 = _2;
              }
              b2.draw(t2, n2.TRIANGLES, y2, ji.disabled, ki.disabled, qi.disabled, v3, o2.id, p2.vertexBuffer, p2.indexBuffer, x2, o2.paint, t2.transform.zoom);
            }
          }
          function Vr(t2, i2, o2) {
            const { painter: s2, sourceCache: r2, layer: n2, coords: a2, colorMode: l2, elevationType: c2, terrainEnabled: h2, pass: d2 } = t2, u5 = s2.context.gl, _2 = n2.paint.get("fill-pattern"), p2 = n2.paint.get("fill-pattern-cross-fade"), f2 = _2.constantOr(null);
            let m2 = c2;
            "road" !== c2 || i2 && !h2 || (m2 = "none");
            const g2 = "road" === m2, v3 = t2.painter.shadowRenderer, y2 = g2 && !!v3 && v3.enabled, x2 = new Ni(s2.context.gl.LEQUAL, Ni.ReadOnly, s2.depthRangeFor3D);
            let b2 = [0, 0, 0];
            if (y2) {
              const e2 = s2.style.directionalLight, t3 = s2.style.ambientLight;
              e2 && t3 && (b2 = ao(s2.style, e2, t3));
            }
            const w2 = _2 && _2.constantOr(1), T2 = (t3, d3) => {
              let _3, m3, T3, E2, S2;
              d3 ? (_3 = w2 && !n2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", T3 = u5.LINES) : (_3 = w2 ? "fillPattern" : "fill", T3 = u5.TRIANGLES);
              for (const I2 of a2) {
                const a3 = r2.getTile(I2);
                if (w2 && !a3.patternsLoaded()) continue;
                const C3 = a3.getBucket(n2);
                if (!C3) continue;
                const R2 = i2 ? C3.elevationBufferData : C3.bufferData;
                if (R2.isEmpty()) continue;
                s2.prepareDrawTile();
                const D3 = R2.programConfigurations.get(n2.id), A2 = s2.isTileAffectedByFog(I2), L2 = [], P2 = [];
                g2 && (L2.push("ELEVATED_ROADS"), P2.push(R2.elevatedLayoutVertexBuffer)), y2 && L2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET"), w2 && (s2.context.activeTexture.set(u5.TEXTURE0), a3.imageAtlasTexture && a3.imageAtlasTexture.bind(u5.LINEAR, u5.CLAMP_TO_EDGE), D3.updatePaintBuffers());
                let z2 = false;
                if (f2 && a3.imageAtlas) {
                  const t4 = a3.imageAtlas, i3 = e.dN.from(f2), o3 = i3.getPrimary().scaleSelf(e.q.devicePixelRatio).toString(), s3 = i3.getSecondary(), r3 = t4.patternPositions.get(o3), n3 = s3 ? t4.patternPositions.get(s3.scaleSelf(e.q.devicePixelRatio).toString()) : null;
                  z2 = !!r3 && !!n3, r3 && D3.setConstantPatternPositions(r3, n3);
                }
                p2 > 0 && (z2 || D3.getPatternTransitionVertexBuffer("fill-pattern")) && L2.push("FILL_PATTERN_TRANSITION");
                const M2 = s2.getOrCreateProgram(_3, { config: D3, overrideFog: A2, defines: L2 }), O2 = s2.translatePosMatrix(I2.projMatrix, a3, n2.paint.get("fill-translate"), n2.paint.get("fill-translate-anchor"));
                y2 && v3.setupShadows(a3.tileID.toUnwrapped(), M2, "vector-tile", a3.tileID.overscaledZ);
                const F2 = n2.paint.get("fill-emissive-strength");
                if (d3) {
                  E2 = R2.lineIndexBuffer, S2 = R2.lineSegments;
                  const e2 = s2.terrain && s2.terrain.renderingToTexture ? s2.terrain.drapeBufferSize : [u5.drawingBufferWidth, u5.drawingBufferHeight];
                  m3 = "fillOutlinePattern" === _3 && w2 ? sr(O2, F2, s2, a3, e2, b2, p2) : or(O2, F2, e2, b2);
                } else E2 = R2.indexBuffer, S2 = R2.triangleSegments, m3 = w2 ? ir(O2, F2, s2, a3, b2, p2) : tr(O2, F2, b2);
                s2.uploadCommonUniforms(s2.context, M2, I2.toUnwrapped());
                let B3 = t3;
                ("road" === c2 && !h2 || "offset" === c2) && (B3 = x2), M2.draw(s2, T3, B3, o2 || s2.stencilModeForClipping(I2), l2, qi.disabled, m3, n2.id, R2.layoutVertexBuffer, E2, S2, n2.paint, s2.transform.zoom, D3, P2);
              }
            };
            s2.renderPass === d2 && T2(s2.depthModeForSublayer(1, "opaque" === s2.renderPass ? Ni.ReadWrite : Ni.ReadOnly), false), "none" === m2 && "translucent" === s2.renderPass && n2.paint.get("fill-antialias") && T2(s2.depthModeForSublayer(n2.getPaintProperty("fill-outline-color") ? 2 : 0, Ni.ReadOnly), true);
          }
          function Gr(t2, i2, o2, s2, r2, n2, a2, l2) {
            o2.resetLayerRenderingStats(t2);
            const c2 = t2.context, h2 = c2.gl, d2 = t2.transform, u5 = o2.paint.get("fill-extrusion-pattern"), _2 = o2.paint.get("fill-extrusion-pattern-cross-fade"), p2 = u5.constantOr(null), f2 = u5.constantOr(1), m2 = o2.paint.get("fill-extrusion-opacity"), g2 = t2.style.enable3dLights(), v3 = o2.paint.get(g2 && !f2 ? "fill-extrusion-ambient-occlusion-wall-radius" : "fill-extrusion-ambient-occlusion-radius"), y2 = [o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), v3], x2 = o2.layout.get("fill-extrusion-edge-radius"), b2 = x2 > 0 && !o2.paint.get("fill-extrusion-rounded-roof"), w2 = b2 ? 0 : x2, T2 = "globe" === d2.projection.name ? e.dT() : 0, E2 = "globe" === d2.projection.name, S2 = E2 ? e.ah(d2.zoom) : 0, I2 = [e.ay(d2.center.lng), e.aH(d2.center.lat)], C3 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), R2 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(C3 ? null : o2.lut).toArray01().slice(0, 3), D3 = o2.paint.get("fill-extrusion-flood-light-intensity"), A2 = o2.paint.get("fill-extrusion-vertical-scale"), L2 = 0 !== o2.paint.get("fill-extrusion-line-width").constantOr(1), P2 = o2.paint.get("fill-extrusion-height-alignment"), z2 = o2.paint.get("fill-extrusion-base-alignment"), M2 = eo(t2, o2.paint.get("fill-extrusion-cutoff-fade-range")), O2 = [];
            let F2;
            E2 && O2.push("PROJECTION_GLOBE_VIEW"), y2[0] > 0 && O2.push("FAUX_AO"), b2 && O2.push("ZERO_ROOF_RADIUS"), l2 && O2.push("HAS_CENTROID"), D3 > 0 && O2.push("FLOOD_LIGHT"), M2.shouldRenderCutoff && O2.push("RENDER_CUTOFF"), L2 && O2.push("RENDER_WALL_MODE");
            const B3 = "shadow" === t2.renderPass, k2 = t2.shadowRenderer, N2 = B3 && !!k2, U2 = B3 ? qi.disabled : qi.backCCW;
            t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = true);
            let j2 = [0, 0, 0];
            if (k2) {
              const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
              e2 && i3 && (j2 = ao(t2.style, e2, i3)), B3 || (O2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), k2.useNormalOffset && O2.push("NORMAL_OFFSET")), F2 = O2.concat(["SHADOWS_SINGLE_CASCADE"]);
            }
            const V2 = N2 ? "fillExtrusionDepth" : f2 ? "fillExtrusionPattern" : "fillExtrusion", G2 = o2.getLayerRenderingStats();
            for (const u6 of s2) {
              const s3 = i2.getTile(u6), g3 = s3.getBucket(o2);
              if (!g3 || g3.projection.name !== d2.projection.name) continue;
              let v4 = false;
              k2 && (v4 = 0 === k2.getMaxCascadeForTile(u6.toUnwrapped()));
              const x3 = t2.isTileAffectedByFog(u6), b3 = g3.programConfigurations.get(o2.id);
              let C4 = false;
              if (p2 && s3.imageAtlas) {
                const t3 = s3.imageAtlas, i3 = e.dN.from(p2), o3 = i3.getPrimary().scaleSelf(e.q.devicePixelRatio).toString(), r3 = i3.getSecondary(), n3 = t3.patternPositions.get(o3), a3 = r3 ? t3.patternPositions.get(r3.scaleSelf(e.q.devicePixelRatio).toString()) : null;
                C4 = !!n3 && !!a3, n3 && b3.setConstantPatternPositions(n3, a3);
              }
              _2 > 0 && (C4 || b3.getPatternTransitionVertexBuffer("fill-extrusion-pattern")) && O2.push("FILL_EXTRUSION_PATTERN_TRANSITION");
              const N3 = t2.getOrCreateProgram(V2, { config: b3, defines: v4 ? F2 : O2, overrideFog: x3 });
              if (t2.terrain && t2.terrain.setupElevationDraw(s3, N3, { useMeterToDem: true }), !g3.centroidVertexBuffer) {
                const e2 = N3.attributes.a_centroid_pos;
                void 0 !== e2 && h2.vertexAttrib2f(e2, 0, 0);
              }
              !B3 && k2 && k2.setupShadows(s3.tileID.toUnwrapped(), N3, "vector-tile", s3.tileID.overscaledZ), f2 && (t2.context.activeTexture.set(h2.TEXTURE0), s3.imageAtlasTexture && s3.imageAtlasTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), b3.updatePaintBuffers());
              const q2 = o2.paint.get("fill-extrusion-vertical-gradient"), Z2 = 1 / g3.tileToMeter;
              let H2;
              if (B3 && k2) {
                if (Xr(s3.tileID, g3, t2)) continue;
                const e2 = k2.calculateShadowPassMatrixFromTile(s3.tileID.toUnwrapped());
                H2 = Qs(e2, w2, Z2, A2, P2, z2);
              } else {
                const e2 = t2.translatePosMatrix(u6.expandedProjMatrix, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = d2.projection.createInversionMatrix(d2, u6.canonical);
                H2 = f2 ? er(e2, t2, q2, m2, y2, w2, Z2, u6, s3, T2, P2, z2, S2, I2, i3, R2, A2, _2) : Js(e2, t2, q2, m2, y2, w2, Z2, u6, T2, P2, z2, S2, I2, i3, R2, A2, D3, j2);
              }
              t2.uploadCommonUniforms(c2, N3, u6.toUnwrapped(), null, M2);
              let W2 = g3.segments;
              if ("mercator" === d2.projection.name && !B3 && (W2 = g3.getVisibleSegments(s3.tileID, t2.terrain, t2.transform.getFrustum(0)), !W2.get().length)) continue;
              if (G2) if (B3) for (const e2 of W2.get()) G2.numRenderedVerticesInShadowPass += e2.primitiveLength;
              else for (const e2 of W2.get()) G2.numRenderedVerticesInTransparentPass += e2.primitiveLength;
              const $2 = [];
              (t2.terrain || l2) && $2.push(g3.centroidVertexBuffer), E2 && $2.push(g3.layoutVertexExtBuffer), L2 && $2.push(g3.wallVertexBuffer), N3.draw(t2, c2.gl.TRIANGLES, r2, n2, a2, U2, H2, o2.id, g3.layoutVertexBuffer, g3.indexBuffer, W2, o2.paint, t2.transform.zoom, b3, $2);
            }
            t2.shadowRenderer && (t2.shadowRenderer.useNormalOffset = false);
          }
          function qr(t2, i2, o2, s2, r2, n2, a2, l2, c2, h2, d2, u5, _2, p2, f2, m2, g2, v3, y2) {
            const x2 = t2.context, b2 = x2.gl, w2 = t2.transform, T2 = t2.transform.zoom, E2 = [], S2 = eo(t2, o2.paint.get("fill-extrusion-cutoff-fade-range"));
            "clear" === h2 ? (E2.push("CLEAR_SUBPASS"), y2 && (E2.push("CLEAR_FROM_TEXTURE"), x2.activeTexture.set(b2.TEXTURE0), y2.bind(b2.LINEAR, b2.CLAMP_TO_EDGE))) : "sdf" === h2 && E2.push("SDF_SUBPASS"), g2 && E2.push("HAS_CENTROID"), S2.shouldRenderCutoff && E2.push("RENDER_CUTOFF");
            const I2 = o2.layout.get("fill-extrusion-edge-radius"), C3 = (e2, i3, s3, h3, v4) => {
              const b3 = i3.programConfigurations.get(o2.id), w3 = t2.isTileAffectedByFog(e2), C4 = t2.getOrCreateProgram("fillExtrusionGroundEffect", { config: b3, defines: E2, overrideFog: w3 }), R2 = /* @__PURE__ */ ((e3, t3, i4, o3, s4, r3, n3, a3, l3, c3, h4) => ({ u_matrix: t3, u_opacity: i4, u_ao_pass: o3 ? 1 : 0, u_meter_to_tile: s4, u_ao: r3, u_flood_light_intensity: n3, u_flood_light_color: a3, u_attenuation: l3, u_edge_radius: c3, u_fb: 0, u_fb_size: h4, u_dynamic_offset: 1 }))(0, h3, d2, c2, v4, [u5, _2 * v4], p2, f2, m2, T2 >= 17 ? 0 : I2 * v4, y2 ? y2.size[0] : 0), D3 = [];
              g2 && D3.push(i3.hiddenByLandmarkVertexBuffer), t2.uploadCommonUniforms(x2, C4, e2.toUnwrapped(), null, S2), C4.draw(t2, x2.gl.TRIANGLES, r2, n2, a2, l2, R2, o2.id, i3.vertexBuffer, i3.indexBuffer, s3, o2.paint, T2, b3, D3);
            };
            for (const r3 of s2) {
              const s3 = i2.getTile(r3), n3 = s3.getBucket(o2);
              if (!n3 || n3.projection.name !== w2.projection.name || !n3.groundEffect || n3.groundEffect && !n3.groundEffect.hasData()) continue;
              const a3 = n3.groundEffect, l3 = 1 / n3.tileToMeter;
              {
                const e2 = t2.translatePosMatrix(r3.projMatrix, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), i3 = a3.getDefaultSegment();
                C3(r3, a3, i3, e2, l3);
              }
              if (v3) for (let n4 = 0; n4 < 4; n4++) {
                const a4 = e.dU[n4](r3), c3 = i2.getTile(a4);
                if (!c3) continue;
                const h3 = c3.getBucket(o2);
                if (!h3 || h3.projection.name !== w2.projection.name || !h3.groundEffect || h3.groundEffect && !h3.groundEffect.hasData()) continue;
                const d3 = h3.groundEffect;
                let u6, _3;
                0 === n4 ? (u6 = [-e.aj, 0, 0], _3 = 1) : 1 === n4 ? (u6 = [e.aj, 0, 0], _3 = 0) : 2 === n4 ? (u6 = [0, -e.aj, 0], _3 = 3) : (u6 = [0, e.aj, 0], _3 = 2);
                const p3 = d3.regionSegments[_3];
                if (!p3) continue;
                const f3 = new Float32Array(16);
                e.bo(f3, r3.projMatrix, u6), C3(r3, d3, p3, t2.translatePosMatrix(f3, s3, o2.paint.get("fill-extrusion-translate"), o2.paint.get("fill-extrusion-translate-anchor")), l3);
              }
            }
          }
          function Zr(t2, i2, o2, s2, r2, n2, a2) {
            0 === s2.centroidVertexArray.length && s2.createCentroidsBuffer();
            const l2 = n2 ? n2.findDEMTileFor(o2) : null;
            if (!(l2 && l2.dem || a2)) return;
            n2 && l2 && l2.dem && s2.selfDEMTileTimestamp !== l2.dem._timestamp && (s2.borderDoneWithNeighborZ = [-1, -1, -1, -1], s2.selfDEMTileTimestamp = l2.dem._timestamp);
            const c2 = (t3) => new e.P(Math.ceil((t3 + e.dX) * e.dY), 0), h2 = (e2) => {
              const t3 = i2.getSource().minzoom, o3 = (e3) => {
                const t4 = i2.getTileByID(e3);
                if (t4 && t4.hasData()) return t4.getBucket(r2);
              }, s3 = [0, -1, 1];
              for (const i3 of s3) {
                if (e2.overscaledZ + i3 < t3) continue;
                const s4 = o3(e2.calculateScaledKey(e2.overscaledZ + i3));
                if (s4) return s4;
              }
            }, d2 = [0, 0, 0], u5 = (t3, i3) => (d2[0] = Math.min(t3.min.y, i3.min.y), d2[1] = Math.max(t3.max.y, i3.max.y), d2[2] = e.aj - i3.min.x > t3.max.x ? i3.min.x - e.aj : t3.max.x, d2), _2 = (t3, i3) => (d2[0] = Math.min(t3.min.x, i3.min.x), d2[1] = Math.max(t3.max.x, i3.max.x), d2[2] = e.aj - i3.min.y > t3.max.y ? i3.min.y - e.aj : t3.max.y, d2), p2 = [(e2, t3) => u5(e2, t3), (e2, t3) => u5(t3, e2), (e2, t3) => _2(e2, t3), (e2, t3) => _2(t3, e2)], f2 = (t3, i3, s3, r3, a3, c3, h3) => {
              if (!n2) return 0;
              const d3 = [[c3 ? s3 : t3, c3 ? t3 : s3, 0], [c3 ? s3 : i3, c3 ? i3 : s3, 0]], u6 = h3 < 0 ? e.aj + h3 : h3, _3 = [c3 ? u6 : (t3 + i3) / 2, c3 ? (t3 + i3) / 2 : u6, 0];
              return 0 === s3 && h3 < 0 || 0 !== s3 && h3 > 0 ? n2.getForTilePoints(a3, [_3], true, r3) : d3.push(_3), n2.getForTilePoints(o2, d3, true, l2), Math.max(d3[0][2], d3[1][2], _3[2]) / n2.exaggeration();
            };
            for (let t3 = 0; t3 < 4; t3++) {
              const i3 = s2.borderFeatureIndices[t3];
              if (0 === i3.length) continue;
              const r3 = e.dU[t3](o2), l3 = h2(r3);
              if (!(l3 && l3 instanceof e.dV)) continue;
              const d3 = n2 ? n2.findDEMTileFor(r3) : null;
              if (!(d3 && d3.dem || a2)) continue;
              if (n2 && d3 && d3.dem && s2.borderDEMTileTimestamp[t3] !== d3.dem._timestamp && (s2.borderDoneWithNeighborZ[t3] = -1, s2.borderDEMTileTimestamp[t3] = d3.dem._timestamp), s2.borderDoneWithNeighborZ[t3] === l3.canonical.z) continue;
              0 === l3.centroidVertexArray.length && l3.createCentroidsBuffer();
              const u6 = (t3 < 2 ? 1 : 5) - t3, _3 = l3.borderDoneWithNeighborZ[u6] !== s2.canonical.z, v3 = l3.borderFeatureIndices[u6];
              let y2 = 0;
              if (s2.canonical.z !== l3.canonical.z) {
                for (const e2 of i3) s2.showCentroid(s2.featuresOnBorder[e2]);
                if (_3) for (const e2 of v3) l3.showCentroid(l3.featuresOnBorder[e2]);
                s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[u6] = s2.canonical.z;
              }
              for (const o3 of i3) {
                const i4 = s2.featuresOnBorder[o3], n3 = s2.centroidData[i4.centroidDataIndex], h3 = i4.borders[t3];
                let _4;
                for (; y2 < v3.length; ) {
                  _4 = l3.featuresOnBorder[v3[y2]];
                  const e2 = _4.borders[u6];
                  if (e2[1] > h3[0] + 3 || e2[0] > h3[0] - 3) break;
                  l3.showCentroid(_4), y2++;
                }
                if (_4 && y2 < v3.length) {
                  const o4 = y2;
                  let x2 = 0;
                  for (; !(_4.borders[u6][0] > h3[1] - 3) && (x2++, ++y2 !== v3.length); ) _4 = l3.featuresOnBorder[v3[y2]];
                  _4 = l3.featuresOnBorder[v3[o4]];
                  let b2 = false;
                  if (x2 >= 1) {
                    const e2 = _4.borders[u6];
                    Math.abs(h3[0] - e2[0]) < 3 && Math.abs(h3[1] - e2[1]) < 3 && (x2 = 1, b2 = true, y2 = o4 + 1);
                  } else if (0 === x2) {
                    s2.showCentroid(i4);
                    continue;
                  }
                  const w2 = l3.centroidData[_4.centroidDataIndex];
                  a2 && b2 && (((m2 = n3).flags | (g2 = w2).flags) & e.dW ? (m2.flags |= e.dW, g2.flags |= e.dW) : (m2.flags &= ~e.dW, g2.flags &= ~e.dW));
                  const T2 = i4.intersectsCount() > 1 || _4.intersectsCount() > 1;
                  if (x2 > 1) y2 = o4, n3.centroidXY = w2.centroidXY = new e.P(0, 0);
                  else if (d3 && d3.dem && !T2) {
                    const i5 = p2[t3](n3, w2), o5 = t3 % 2 ? e.aj - 1 : 0, s3 = f2(i5[0], Math.min(e.aj - 1, i5[1]), o5, d3, r3, t3 < 2, i5[2]);
                    n3.centroidXY = w2.centroidXY = c2(s3);
                  } else T2 ? n3.centroidXY = w2.centroidXY = new e.P(0, 0) : (n3.centroidXY = s2.encodeBorderCentroid(i4), w2.centroidXY = l3.encodeBorderCentroid(_4));
                  s2.writeCentroidToBuffer(n3), l3.writeCentroidToBuffer(w2);
                } else s2.showCentroid(i4);
              }
              s2.borderDoneWithNeighborZ[t3] = l3.canonical.z, l3.borderDoneWithNeighborZ[u6] = s2.canonical.z;
            }
            var m2, g2;
            (s2.needsCentroidUpdate || !s2.centroidVertexBuffer && 0 !== s2.centroidVertexArray.length) && s2.uploadCentroid(t2);
          }
          const Hr = [1, 0, 0], Wr = [0, 1, 0], $r = [0, 0, 1];
          function Xr(t2, i2, o2) {
            const s2 = o2.transform, r2 = o2.shadowRenderer;
            if (!r2) return true;
            const n2 = t2.toUnwrapped(), a2 = s2.tileSize * r2._cascades[o2.currentShadowCascade].scale;
            let l2 = i2.maxHeight;
            if (s2.elevation) {
              const e2 = s2.elevation.getMinMaxForTile(t2);
              e2 && (l2 += e2.max);
            }
            const c2 = [...r2.shadowDirection];
            c2[2] = -c2[2];
            const h2 = r2.computeSimplifiedTileShadowVolume(n2, l2, a2, c2);
            if (!h2) return false;
            const d2 = [Hr, Wr, $r, c2, [c2[0], 0, c2[2]], [0, c2[1], c2[2]]], u5 = "globe" === s2.projection.name, _2 = s2.scaleZoom(a2), p2 = e.cn.fromInvProjectionMatrix(s2.invProjMatrix, s2.worldSize, _2, !u5), f2 = r2.getCurrentCascadeFrustum();
            return 0 === p2.intersectsPrecise(h2.vertices, h2.planes, d2) || 0 === f2.intersectsPrecise(h2.vertices, h2.planes, d2);
          }
          function Yr(t2) {
            return [t2[0] * e.dZ, t2[1] * e.dZ, t2[2] * e.dZ, 0];
          }
          function Kr(t2, i2, o2, s2, r2, n2, a2, l2, c2) {
            const h2 = s2.getSource(), d2 = o2.globeSharedBuffers;
            if (!d2) return;
            let u5, _2, p2;
            if (i2 && (u5 = s2.getTile(i2)), h2 instanceof e.aP ? (_2 = h2.texture, p2 = e.ds(0, 0, o2.transform)) : u5 && i2 && (_2 = u5.texture, p2 = e.ds(i2.canonical.z, i2.canonical.x, o2.transform)), !_2 || !p2) return;
            t2 || (p2 = e.cE(e.bz(), p2, [1, -1, 1]));
            const f2 = o2.context, m2 = f2.gl, g2 = "nearest" === r2.paint.get("raster-resampling") ? m2.NEAREST : m2.LINEAR, v3 = o2.colorModeForDrapableLayerRenderPass(n2), y2 = a2.defines;
            y2.push("GLOBE_POLES");
            const x2 = new Ni(m2.LEQUAL, Ni.ReadWrite, o2.depthRangeFor3D), b2 = Float32Array.from(o2.transform.expandedFarZProjMatrix), w2 = Float32Array.from(e.bh(e.dr(new e.cp(0, 0, 0))));
            o2.terrain && o2.terrain.prepareDrawTile(), f2.activeTexture.set(m2.TEXTURE0), _2.bind(g2, m2.CLAMP_TO_EDGE), f2.activeTexture.set(m2.TEXTURE1), _2.bind(g2, m2.CLAMP_TO_EDGE), "useMipmap" in _2 && f2.extTextureFilterAnisotropic && o2.transform.pitch > 20 && m2.texParameterf(m2.TEXTURE_2D, f2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, f2.extTextureFilterAnisotropicMax);
            const [T2, E2, S2, I2] = i2 ? d2.getPoleBuffers(i2.canonical.z, false) : d2.getPoleBuffers(0, true), C3 = r2.paint.get("raster-elevation");
            let R2;
            t2 ? (R2 = T2, o2.renderDefaultNorthPole = 0 !== C3) : (R2 = E2, o2.renderDefaultSouthPole = 0 !== C3);
            const D3 = Yr(a2.mix), A2 = ((e2, t3, i3, o3, s3, r3, n3, a3, l3, c3, h3, d3, u6) => _r(e2, t3, i3, new Float32Array(16), new Float32Array(9), [0, 0], o3, [0, 0], [0, 0, 0, 0], 1, { opacity: 1, mix: 0 }, r3, [0, 0], a3, 2, c3, h3, d3, 1, 0, u6))(b2, w2, p2, e.ah(o2.transform.zoom), 0, r2, 0, C3, 0, D3, a2.offset, a2.range, n2), L2 = o2.getOrCreateProgram("raster", { defines: y2 });
            o2.uploadCommonUniforms(f2, L2, null), L2.draw(o2, m2.TRIANGLES, x2, c2, v3, l2, A2, r2.id, R2, S2, I2);
          }
          function Jr(e2) {
            const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, s2 = 0.2 * e2.height, r2 = t2 + s2;
            return [t2, i2, (r2 - s2 - t2) / o2, (r2 - t2) / o2];
          }
          function Qr(e2, t2, i2, o2) {
            if (e2) return t2 instanceof st && e2 instanceof Tt ? t2.getTextureDescriptor(e2, i2, true) : { texture: e2.texture, mix: Yr(o2.mix), offset: o2.offset, buffer: 0, tileSize: 1 };
          }
          var en = e.d_([{ name: "a_index", type: "Int16", components: 1 }]);
          class tn {
            constructor(t2, i2, o2, s2) {
              const r2 = { width: o2[0], height: o2[1], data: null }, n2 = t2.gl;
              this.targetColorTexture = new e.T(t2, r2, n2.RGBA8, { useMipmap: false }), this.backgroundColorTexture = new e.T(t2, r2, n2.RGBA8, { useMipmap: false }), this.context = t2, this.updateParticleTexture(i2, s2), this.lastInvalidatedAt = 0;
            }
            updateParticleTexture(t2, i2) {
              if (this.particleTextureDimension === i2.width) return;
              (this.particleTexture0 || this.particleTexture1 || this.particleIndexBuffer || this.particleSegment) && (this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleIndexBuffer.destroy(), this.particleSegment.destroy());
              const o2 = this.context.gl, s2 = i2.width * i2.height;
              this.particleTexture0 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false }), this.particleTexture1 = new e.T(this.context, i2, o2.RGBA8, { premultiply: false, useMipmap: false });
              const r2 = new e.d$();
              r2.reserve(s2);
              for (let e2 = 0; e2 < s2; e2++) r2.emplaceBack(e2);
              this.particleIndexBuffer = this.context.createVertexBuffer(r2, en.members, true), this.particleSegment = e.bd.simpleSegment(0, 0, this.particleIndexBuffer.length, 0), this.particleTextureDimension = i2.width;
            }
            update(t2) {
              return !(this.lastInvalidatedAt < t2 && (this.lastInvalidatedAt = e.q.now(), 1));
            }
            destroy() {
              this.targetColorTexture.destroy(), this.backgroundColorTexture.destroy(), this.particleIndexBuffer.destroy(), this.particleTexture0.destroy(), this.particleTexture1.destroy(), this.particleSegment.destroy();
            }
          }
          function on(t2, i2, o2) {
            if (!t2) return null;
            const s2 = i2.getTextureDescriptor(t2, o2, true);
            if (!s2) return null;
            let { texture: r2, mix: n2, offset: a2, tileSize: l2, buffer: c2, format: h2 } = s2;
            if (!r2 || !h2) return null;
            let d2 = false;
            return "uint32" === h2 && (d2 = true, n2[3] = 0, n2 = dr(e.e0, n2, [0, o2.paint.get("raster-particle-max-speed")]), a2 = ur(e.e0, a2, [0, o2.paint.get("raster-particle-max-speed")])), { texture: r2, textureOffset: [c2 / (l2 + 2 * c2), l2 / (l2 + 2 * c2)], tileSize: l2, scalarData: d2, scale: n2, offset: a2, defines: ["RASTER_ARRAY", { uint8: "DATA_FORMAT_UINT8", uint16: "DATA_FORMAT_UINT16", uint32: "DATA_FORMAT_UINT32" }[h2]] };
          }
          function sn(e2) {
            const t2 = e2._nearZ, i2 = e2.projection.farthestPixelDistance(e2), o2 = i2 - t2, s2 = 0.2 * e2.height, r2 = t2 + s2;
            return [t2, i2, (r2 - s2 - t2) / o2, (r2 - t2) / o2];
          }
          const rn = new e.am(1, 0, 0, 1), nn = new e.am(0, 1, 0, 1), an = new e.am(0, 0, 1, 1), ln = new e.am(1, 0, 1, 1), cn = new e.am(0, 1, 1, 1);
          function hn(t2, i2, o2, s2, r2, n2, a2) {
            const l2 = t2.context, c2 = t2.transform, h2 = l2.gl, d2 = "globe" === c2.projection.name, u5 = d2 ? ["PROJECTION_GLOBE_VIEW"] : [];
            let _2 = e.bw(o2.projMatrix);
            if (d2 && e.ah(c2.zoom) > 0) {
              const t3 = e.bg(o2.canonical, c2), i3 = e.e1(t3);
              _2 = e.az(new Float32Array(16), c2.globeMatrix, i3), e.az(_2, c2.projMatrix, _2);
            }
            const p2 = e.bz();
            p2[12] += 2 * r2 / (e.q.devicePixelRatio * c2.width), p2[13] += 2 * n2 / (e.q.devicePixelRatio * c2.height), e.az(_2, p2, _2);
            const f2 = t2.getOrCreateProgram("debug", { defines: u5 }), m2 = i2.getTileByID(o2.key);
            t2.terrain && t2.terrain.setupElevationDraw(m2, f2);
            const g2 = Ni.disabled, v3 = ji.disabled, y2 = t2.colorModeForRenderPass(), x2 = "$debug";
            l2.activeTexture.set(h2.TEXTURE0), t2.emptyTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), d2 ? m2._makeGlobeTileDebugBuffers(t2.context, c2) : m2._makeDebugTileBoundsBuffers(t2.context, c2.projection);
            const b2 = m2._tileDebugBuffer || t2.debugBuffer, w2 = m2._tileDebugIndexBuffer || t2.debugIndexBuffer, T2 = m2._tileDebugSegments || t2.debugSegments;
            if (f2.draw(t2, h2.LINE_STRIP, g2, v3, y2, qi.disabled, lr(_2, s2), x2, b2, w2, T2, null, null, null, [m2._globeTileDebugBorderBuffer]), a2) {
              const e2 = m2.latestRawTileData, i3 = Math.floor((e2 && e2.byteLength || 0) / 1024);
              let s3 = o2.canonical.toString();
              o2.overscaledZ !== o2.canonical.z && (s3 += ` => ${o2.overscaledZ}`), s3 += ` ${m2.state}`, s3 += ` ${i3}kb`, function(e3, t3) {
                e3.initDebugOverlayCanvas();
                const i4 = e3.debugOverlayCanvas, o3 = e3.context.gl, s4 = e3.debugOverlayCanvas.getContext("2d");
                s4.clearRect(0, 0, i4.width, i4.height), s4.shadowColor = "white", s4.shadowBlur = 2, s4.lineWidth = 1.5, s4.strokeStyle = "white", s4.textBaseline = "top", s4.font = "bold 36px Open Sans, sans-serif", s4.fillText(t3, 5, 5), s4.strokeText(t3, 5, 5), e3.debugOverlayTexture.update(i4), e3.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
              }(t2, s3);
            }
            const E2 = i2.getTile(o2).tileSize, S2 = 512 / Math.min(E2, 512) * (o2.overscaledZ / c2.zoom) * 0.5, I2 = m2._tileDebugTextBuffer || t2.debugBuffer, C3 = m2._tileDebugTextIndexBuffer || t2.quadTriangleIndexBuffer, R2 = m2._tileDebugTextSegments || t2.debugSegments;
            f2.draw(t2, h2.TRIANGLES, g2, v3, ki.alphaBlended, qi.disabled, lr(_2, e.am.transparent, S2), x2, I2, C3, R2, null, null, null, [m2._globeTileDebugTextBuffer]);
          }
          function dn(e2, t2, i2, o2) {
            _n(e2, 0, t2 + i2 / 2, e2.transform.width, i2, o2);
          }
          function un(e2, t2, i2, o2) {
            _n(e2, t2 - i2 / 2, 0, i2, e2.transform.height, o2);
          }
          function _n(t2, i2, o2, s2, r2, n2) {
            const a2 = t2.context, l2 = a2.gl;
            l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * e.q.devicePixelRatio, o2 * e.q.devicePixelRatio, s2 * e.q.devicePixelRatio, r2 * e.q.devicePixelRatio), a2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
          }
          const pn = e.d_([{ name: "a_pos_3f", components: 3, type: "Float32" }]), { members: fn } = pn;
          function mn(e2, t2, i2, o2) {
            e2.emplaceBack(t2, i2, o2);
          }
          class gn {
            constructor(t2) {
              this.vertexArray = new e.e2(), this.indices = new e.a_(), mn(this.vertexArray, -1, -1, 1), mn(this.vertexArray, 1, -1, 1), mn(this.vertexArray, -1, 1, 1), mn(this.vertexArray, 1, 1, 1), mn(this.vertexArray, -1, -1, -1), mn(this.vertexArray, 1, -1, -1), mn(this.vertexArray, -1, 1, -1), mn(this.vertexArray, 1, 1, -1), this.indices.emplaceBack(5, 1, 3), this.indices.emplaceBack(3, 7, 5), this.indices.emplaceBack(6, 2, 0), this.indices.emplaceBack(0, 4, 6), this.indices.emplaceBack(2, 6, 7), this.indices.emplaceBack(7, 3, 2), this.indices.emplaceBack(5, 4, 0), this.indices.emplaceBack(0, 1, 5), this.indices.emplaceBack(0, 2, 3), this.indices.emplaceBack(3, 1, 0), this.indices.emplaceBack(7, 6, 4), this.indices.emplaceBack(4, 5, 7), this.vertexBuffer = t2.createVertexBuffer(this.vertexArray, fn), this.indexBuffer = t2.createIndexBuffer(this.indices), this.segment = e.bd.simpleSegment(0, 0, 36, 12);
            }
          }
          function vn(t2, i2, o2, s2, r2, n2) {
            const a2 = t2.context.gl, l2 = i2.paint.get("sky-atmosphere-color"), c2 = i2.paint.get("sky-atmosphere-halo-color"), h2 = i2.paint.get("sky-atmosphere-sun-intensity"), d2 = ((e2, t3, i3, o3, s3) => ({ u_matrix_3f: e2, u_sun_direction: t3, u_sun_intensity: i3, u_color_tint_r: [o3.r, o3.g, o3.b, o3.a], u_color_tint_m: [s3.r, s3.g, s3.b, s3.a], u_luminance: 5e-5 }))(e.e4(e.dx(), s2), r2, h2, l2, c2);
            a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_CUBE_MAP_POSITIVE_X + n2, i2.skyboxTexture, 0), o2.draw(t2, a2.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.frontCW, d2, "skyboxCapture", i2.skyboxGeometry.vertexBuffer, i2.skyboxGeometry.indexBuffer, i2.skyboxGeometry.segment);
          }
          const yn = e.d_([{ type: "Float32", name: "a_pos", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }]);
          class xn {
            constructor(t2) {
              const i2 = new e.e5();
              i2.emplaceBack(-1, 1, 1, 0, 0), i2.emplaceBack(1, 1, 1, 1, 0), i2.emplaceBack(1, -1, 1, 1, 1), i2.emplaceBack(-1, -1, 1, 0, 1);
              const o2 = new e.a_();
              o2.emplaceBack(0, 1, 2), o2.emplaceBack(2, 3, 0), this.vertexBuffer = t2.createVertexBuffer(i2, yn.members), this.indexBuffer = t2.createIndexBuffer(o2), this.segments = e.bd.simpleSegment(0, 0, 4, 2);
            }
            destroy() {
              this.vertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy();
            }
          }
          const bn = e.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_size_scale", components: 1 }, { type: "Float32", name: "a_fade_opacity", components: 1 }]);
          class wn {
            constructor() {
              this.starsCount = 16e3, this.sizeMultiplier = 0.15, this.sizeRange = 100, this.intensityRange = 200;
            }
          }
          class Tn {
            constructor(t2) {
              this.colorModeAlphaBlendedWriteRGB = new ki([1, Bi, 1, Bi], e.am.transparent, [true, true, true, false]), this.colorModeWriteAlpha = new ki([1, 0, 1, 0], e.am.transparent, [false, false, false, true]), this.params = new wn(), this.updateNeeded = true, t2.tp.registerParameter(this.params, ["Stars"], "starsCount", { min: 100, max: 16e3, step: 1 }, () => {
                this.updateNeeded = true;
              }), t2.tp.registerParameter(this.params, ["Stars"], "sizeMultiplier", { min: 0.01, max: 2, step: 0.01 }), t2.tp.registerParameter(this.params, ["Stars"], "sizeRange", { min: 0, max: 200, step: 1 }, () => {
                this.updateNeeded = true;
              }), t2.tp.registerParameter(this.params, ["Stars"], "intensityRange", { min: 0, max: 200, step: 1 }, () => {
                this.updateNeeded = true;
              });
            }
            update(t2) {
              const i2 = t2.context;
              if (!this.atmosphereBuffer || this.updateNeeded) {
                this.updateNeeded = false, this.atmosphereBuffer = new xn(i2);
                const t3 = this.params.sizeRange, o2 = this.params.intensityRange, s2 = function(t4) {
                  const i3 = e.ea(30), o3 = [];
                  for (let s3 = 0; s3 < t4; ++s3) {
                    const t5 = 2 * Math.PI * i3(), s4 = Math.acos(1 - 2 * i3()) - 0.5 * Math.PI;
                    o3.push(e.cS(Math.cos(s4) * Math.cos(t5), Math.cos(s4) * Math.sin(t5), Math.sin(s4)));
                  }
                  return o3;
                }(this.params.starsCount), r2 = e.ea(300), n2 = new e.e6(), a2 = new e.a_();
                let l2 = 0;
                for (let i3 = 0; i3 < s2.length; ++i3) {
                  const c2 = e.b$([], s2[i3], 200), h2 = Math.max(0, 1 + 0.01 * t3 * (1 * r2() - 0.5)), d2 = Math.max(0, 1 + 0.01 * o2 * (1 * r2() - 0.5));
                  n2.emplaceBack(c2[0], c2[1], c2[2], -1, -1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, -1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], 1, 1, h2, d2), n2.emplaceBack(c2[0], c2[1], c2[2], -1, 1, h2, d2), a2.emplaceBack(l2 + 0, l2 + 1, l2 + 2), a2.emplaceBack(l2 + 0, l2 + 2, l2 + 3), l2 += 4;
                }
                this.starsVx = i2.createVertexBuffer(n2, bn.members), this.starsIdx = i2.createIndexBuffer(a2), this.starsSegments = e.bd.simpleSegment(0, 0, n2.length, a2.length);
              }
            }
            destroy() {
              this.atmosphereBuffer && this.atmosphereBuffer.destroy(), this.starsVx && this.starsVx.destroy(), this.starsIdx && this.starsIdx.destroy();
            }
            drawAtmosphereGlow(t2, i2) {
              const o2 = t2.context, s2 = o2.gl, r2 = t2.transform, n2 = new Ni(s2.LEQUAL, Ni.ReadOnly, [0, 1]), a2 = e.ah(r2.zoom), l2 = t2.style.getLut(i2.scope), c2 = "none" === i2.properties.get("color-use-theme"), h2 = i2.properties.get("color").toRenderColor(c2 ? null : l2).toArray01(), d2 = "none" === i2.properties.get("high-color-use-theme"), u5 = i2.properties.get("high-color").toRenderColor(d2 ? null : l2).toArray01(), _2 = "none" === i2.properties.get("space-color-use-theme"), p2 = i2.properties.get("space-color").toRenderColor(_2 ? null : l2).toArray01PremultipliedAlpha(), f2 = 5e-4, m2 = e.e7(i2.properties.get("horizon-blend"), 0, 1, f2, 0.25), g2 = e.dl(t2, o2, r2) && m2 === f2 ? r2.worldSize / (2 * Math.PI * 1.025) - 1 : r2.globeRadius, v3 = t2.frameCounter / 1e3 % 1, y2 = e.ae(r2.globeCenterInViewSpace), x2 = Math.sqrt(Math.pow(y2, 2) - Math.pow(g2, 2)), b2 = Math.acos(x2 / y2), w2 = (e2) => {
                const i3 = "globe" === r2.projection.name ? ["PROJECTION_GLOBE_VIEW", "FOG"] : ["FOG"];
                e2 && i3.push("ALPHA_PASS");
                const l3 = t2.getOrCreateProgram("globeAtmosphere", { defines: i3 }), c3 = /* @__PURE__ */ ((e3, t3, i4, o3, s3, r3, n3, a3, l4, c4, h3, d4) => ({ u_frustum_tl: e3, u_frustum_tr: t3, u_frustum_br: i4, u_frustum_bl: o3, u_horizon: s3, u_transition: r3, u_fadeout_range: n3, u_color: a3, u_high_color: l4, u_space_color: c4, u_temporal_offset: h3, u_horizon_angle: d4 }))(r2.frustumCorners.TL, r2.frustumCorners.TR, r2.frustumCorners.BR, r2.frustumCorners.BL, r2.frustumCorners.horizon, a2, m2, h2, u5, p2, v3, b2);
                t2.uploadCommonUniforms(o2, l3);
                const d3 = this.atmosphereBuffer;
                d3 && l3.draw(t2, s2.TRIANGLES, n2, ji.disabled, e2 ? this.colorModeWriteAlpha : this.colorModeAlphaBlendedWriteRGB, qi.backCW, c3, e2 ? "atmosphere_glow_alpha" : "atmosphere_glow", d3.vertexBuffer, d3.indexBuffer, d3.segments);
              };
              w2(false), w2(true);
            }
            drawStars(t2, i2) {
              const o2 = e.aD(i2.properties.get("star-intensity"), 0, 1);
              if (0 === o2) return;
              const s2 = t2.context, r2 = s2.gl, n2 = t2.transform, a2 = t2.getOrCreateProgram("stars"), l2 = e.bY([]);
              e.b_(l2, l2, -n2._pitch), e.bZ(l2, l2, -n2.angle), e.b_(l2, l2, e.al(n2._center.lat)), e.e8(l2, l2, -e.al(n2._center.lng));
              const c2 = e.c3(new Float32Array(16), l2), h2 = e.az([], n2.starsProjMatrix, c2), d2 = e.e4([], c2), u5 = e.e9([], d2), _2 = [0, 1, 0];
              e.dz(_2, _2, u5), e.b$(_2, _2, this.params.sizeMultiplier);
              const p2 = [1, 0, 0];
              e.dz(p2, p2, u5), e.b$(p2, p2, this.params.sizeMultiplier);
              const f2 = (m2 = _2, g2 = p2, v3 = o2, { u_matrix: Float32Array.from(h2), u_up: m2, u_right: g2, u_intensity_multiplier: v3 });
              var m2, g2, v3;
              t2.uploadCommonUniforms(s2, a2), this.starsVx && this.starsIdx && a2.draw(t2, r2.TRIANGLES, Ni.disabled, ji.disabled, this.colorModeAlphaBlendedWriteRGB, qi.disabled, f2, "atmosphere_stars", this.starsVx, this.starsIdx, this.starsSegments);
            }
          }
          function En(t2, i2) {
            const o2 = [...t2], s2 = i2.cameraWorldSizeForFog / i2.worldSize, r2 = e.bx([]);
            return e.cE(r2, r2, [s2, s2, 1]), e.az(o2, r2, o2), e.az(o2, i2.worldToFogMatrix, o2), o2;
          }
          function Sn(t2, i2, o2, s2, r2) {
            const n2 = o2.material, a2 = s2.context, { baseColorTexture: l2, metallicRoughnessTexture: c2 } = n2.pbrMetallicRoughness, { normalTexture: h2, occlusionTexture: d2, emissionTexture: u5 } = n2;
            function _2(e2, i3, o3) {
              if (e2 && (t2.push(i3), a2.activeTexture.set(a2.gl.TEXTURE0 + o3), e2.gfxTexture)) {
                const { minFilter: t3, magFilter: i4, wrapS: o4, wrapT: s3 } = e2.sampler;
                e2.gfxTexture.bindExtraParam(t3, i4, o4, s3);
              }
            }
            _2(l2, "HAS_TEXTURE_u_baseColorTexture", Yi.BaseColor), _2(c2, "HAS_TEXTURE_u_metallicRoughnessTexture", Yi.MetallicRoughness), _2(h2, "HAS_TEXTURE_u_normalTexture", Yi.Normal), _2(d2, "HAS_TEXTURE_u_occlusionTexture", Yi.Occlusion), _2(u5, "HAS_TEXTURE_u_emissionTexture", Yi.Emission), r2 && (r2.texture || (r2.texture = new e.ed(s2.context, r2.image, [r2.image.height, r2.image.height, r2.image.height], a2.gl.RGBA8)), a2.activeTexture.set(a2.gl.TEXTURE0 + Yi.LUT), r2.texture && r2.texture.bind(a2.gl.LINEAR, a2.gl.CLAMP_TO_EDGE), t2.push("APPLY_LUT_ON_GPU")), o2.texcoordBuffer && (t2.push("HAS_ATTRIBUTE_a_uv_2f"), i2.push(o2.texcoordBuffer)), o2.colorBuffer && (t2.push(12 === o2.colorBuffer.itemSize ? "HAS_ATTRIBUTE_a_color_3f" : "HAS_ATTRIBUTE_a_color_4f"), i2.push(o2.colorBuffer)), o2.normalBuffer && (t2.push("HAS_ATTRIBUTE_a_normal_3f"), i2.push(o2.normalBuffer)), o2.pbrBuffer && (t2.push("HAS_ATTRIBUTE_a_pbr"), t2.push("HAS_ATTRIBUTE_a_heightBasedEmissiveStrength"), i2.push(o2.pbrBuffer)), "OPAQUE" !== n2.alphaMode && "MASK" !== n2.alphaMode || t2.push("UNPREMULT_TEXTURE_IN_SHADER"), n2.defined || t2.push("DIFFUSE_SHADED");
            const p2 = s2.shadowRenderer;
            p2 && (t2.push("RENDER_SHADOWS", "DEPTH_TEXTURE"), p2.useNormalOffset && t2.push("NORMAL_OFFSET"));
          }
          function In(t2, i2, o2, s2, r2, n2) {
            const a2 = o2.paint.get("model-opacity").constantOr(1), l2 = i2.context, c2 = new Ni(i2.context.gl.LEQUAL, Ni.ReadWrite, i2.depthRangeFor3D), h2 = i2.transform, d2 = t2.mesh, u5 = d2.material, _2 = u5.pbrMetallicRoughness, p2 = i2.style.fog;
            let f2;
            f2 = "pixels" === i2.transform.projection.zAxisUnit ? [...t2.nodeModelMatrix] : e.az([], s2.zScaleMatrix, t2.nodeModelMatrix), e.az(f2, s2.negCameraPosMatrix, f2);
            const m2 = e.bi([], f2);
            e.ee(m2, m2);
            const g2 = "none" === o2.paint.get("model-color-use-theme").constantOr("default"), v3 = o2.paint.get("model-emissive-strength").constantOr(0), y2 = Er(new Float32Array(t2.worldViewProjection), new Float32Array(f2), new Float32Array(m2), null, i2, a2, _2.baseColorFactor.toRenderColor(null), u5.emissiveFactor, _2.metallicFactor, _2.roughnessFactor, u5, v3, o2), x2 = { defines: [] }, b2 = [], w2 = i2.shadowRenderer;
            w2 && (w2.useNormalOffset = false), Sn(x2.defines, b2, d2, i2, g2 ? null : o2.lut);
            let T2 = null;
            if (p2) {
              const e2 = En(t2.nodeModelMatrix, i2.transform);
              if (T2 = new Float32Array(e2), "globe" !== h2.projection.name) {
                const t3 = d2.aabb.min, i3 = d2.aabb.max, [o3, s3] = p2.getOpacityForBounds(e2, t3[0], t3[1], i3[0], i3[1]);
                x2.overrideFog = o3 >= Fe || s3 >= Fe;
              }
            }
            const E2 = eo(i2, o2.paint.get("model-cutoff-fade-range"));
            E2.shouldRenderCutoff && x2.defines.push("RENDER_CUTOFF");
            const S2 = i2.getOrCreateProgram("model", x2);
            i2.uploadCommonUniforms(l2, S2, null, T2, E2), "shadow" !== i2.renderPass && w2 && w2.setupShadowsFromMatrix(t2.nodeModelMatrix, S2), S2.draw(i2, l2.gl.TRIANGLES, c2, r2, n2, d2.material.doubleSided ? qi.disabled : qi.backCCW, y2, o2.id, d2.vertexBuffer, d2.indexBuffer, d2.segments, o2.paint, i2.transform.zoom, void 0, b2);
          }
          function Cn(t2, i2, o2, s2, r2, n2, a2) {
            let l2;
            l2 = "globe" === t2.projection.name ? e.ef(o2, t2) : [...o2], e.az(l2, l2, i2.matrix);
            const c2 = e.az([], s2, l2);
            if (i2.meshes) for (const o3 of i2.meshes) {
              if ("BLEND" !== o3.material.alphaMode) {
                a2.push({ mesh: o3, depth: 0, modelIndex: r2, worldViewProjection: c2, nodeModelMatrix: l2 });
                continue;
              }
              const i3 = e.ad([], o3.centroid, c2);
              !t2.isOrthographic && i3[2] <= 0 || n2.push({ mesh: o3, depth: i3[2], modelIndex: r2, worldViewProjection: c2, nodeModelMatrix: l2 });
            }
            if (i2.children) for (const e2 of i2.children) Cn(t2, e2, o2, s2, r2, n2, a2);
          }
          function Rn(e2, t2, i2, o2) {
            const s2 = i2.shadowRenderer;
            if (!s2) return;
            const r2 = s2.getShadowPassDepthMode(), n2 = s2.getShadowPassColorMode(), a2 = s2.calculateShadowPassMatrixFromMatrix(t2), l2 = Sr(a2);
            i2.getOrCreateProgram("modelDepth", { defines: i2._shadowMapDebug ? [] : ["DEPTH_TEXTURE"] }).draw(i2, i2.context.gl.TRIANGLES, r2, ji.disabled, n2, qi.backCCW, l2, o2.id, e2.vertexBuffer, e2.indexBuffer, e2.segments, o2.paint, i2.transform.zoom, void 0, void 0);
          }
          function Dn(t2, i2, o2) {
            const s2 = i2.updateZoomBasedPaintProperties(), r2 = function(t3, i3, o3) {
              let s3, r3, n2, a2 = t3.terrain ? t3.terrain.exaggeration() : 0;
              if (t3.terrain && a2 > 0) {
                const i4 = t3.terrain, r4 = i4.findDEMTileFor(o3);
                r4 && r4.dem ? s3 = e.el.create(i4, o3, r4) : a2 = 0;
              }
              if (0 === a2 && (i3.terrainElevationMin = 0, i3.terrainElevationMax = 0), a2 === i3.validForExaggeration && (0 === a2 || s3 && s3._demTile && s3._demTile.tileID === i3.validForDEMTile.id && s3._dem._timestamp === i3.validForDEMTile.timestamp)) return false;
              for (const e2 in i3.instancesPerModel) {
                const t4 = i3.instancesPerModel[e2];
                for (let e3 = 0; e3 < t4.instancedDataArray.length; ++e3) {
                  const o4 = (s3 ? a2 * s3.getElevationAt(0 | t4.instancedDataArray.float32[16 * e3], 0 | t4.instancedDataArray.float32[16 * e3 + 1], true, true) : 0) + t4.instancesEvaluatedElevation[e3];
                  t4.instancedDataArray.float32[16 * e3 + 6] = o4, r3 = r3 ? Math.min(i3.terrainElevationMin, o4) : o4, n2 = n2 ? Math.max(i3.terrainElevationMax, o4) : o4;
                }
              }
              return i3.terrainElevationMin = r3 || 0, i3.terrainElevationMax = n2 || 0, i3.validForExaggeration = a2, i3.validForDEMTile = s3 && s3._demTile ? { id: s3._demTile.tileID, timestamp: s3._dem._timestamp } : { id: void 0, timestamp: 0 }, true;
            }(t2, i2, o2);
            (s2 || r2) && (i2.uploaded = false, i2.upload(t2.context));
          }
          const An = { shadowUniformsInitialized: false, useSingleShadowCascade: false, tileMatrix: new Float64Array(16), shadowTileMatrix: new Float32Array(16), aabb: new e.cV([0, 0, 0], [e.aj, e.aj, 0]) };
          function Ln(t2, i2) {
            const o2 = 1 << t2.canonical.z, s2 = i2.getFreeCameraOptions().position, r2 = i2.elevation, n2 = t2.canonical.x / o2, a2 = (t2.canonical.x + 1) / o2, l2 = t2.canonical.y / o2, c2 = (t2.canonical.y + 1) / o2;
            let h2 = i2._centerAltitude;
            if (r2) {
              const e2 = r2.getMinMaxForTile(t2);
              e2 && e2.max > h2 && (h2 = e2.max);
            }
            const d2 = e.aD(s2.x, n2, a2) - s2.x, u5 = e.aD(s2.y, l2, c2) - s2.y, _2 = e.c6(h2, i2.center.lat) - s2.z;
            return i2._zoomFromMercatorZ(Math.sqrt(d2 * d2 + u5 * u5 + _2 * _2));
          }
          function Pn(e2, t2, i2, o2, s2, r2, n2) {
            const a2 = e2.context, l2 = "shadow" === e2.renderPass, c2 = e2.shadowRenderer, h2 = l2 && c2 ? c2.getShadowPassDepthMode() : new Ni(a2.gl.LEQUAL, Ni.ReadWrite, e2.depthRangeFor3D), d2 = e2.isTileAffectedByFog(r2);
            if (i2.meshes) for (const u5 of i2.meshes) {
              const _2 = ["MODEL_POSITION_ON_GPU"], p2 = [];
              let f2, m2, g2;
              o2.instancedDataArray.length > 20 && _2.push("INSTANCED_ARRAYS");
              const v3 = eo(e2, t2.paint.get("model-cutoff-fade-range"));
              if (v3.shouldRenderCutoff && _2.push("RENDER_CUTOFF"), l2 && c2) f2 = e2.getOrCreateProgram("modelDepth", { defines: _2 }), m2 = Sr(n2.shadowTileMatrix, n2.shadowTileMatrix, Float32Array.from(i2.matrix)), g2 = c2.getShadowPassColorMode();
              else {
                Sn(_2, p2, u5, e2, "none" === t2.paint.get("model-color-use-theme").constantOr("default") ? null : t2.lut), f2 = e2.getOrCreateProgram("model", { defines: _2, overrideFog: d2 });
                const o3 = u5.material, l3 = o3.pbrMetallicRoughness, h3 = t2.paint.get("model-opacity").constantOr(1), y3 = t2.paint.get("model-emissive-strength").constantOr(0);
                m2 = Er(r2.expandedProjMatrix, Float32Array.from(i2.matrix), new Float32Array(16), null, e2, h3, l3.baseColorFactor.toRenderColor(null), o3.emissiveFactor, l3.metallicFactor, l3.roughnessFactor, o3, y3, t2, s2), c2 && (n2.shadowUniformsInitialized ? f2.setShadowUniformValues(a2, c2.getShadowUniformValues()) : (c2.setupShadows(r2.toUnwrapped(), f2, "model-tile", r2.overscaledZ), n2.shadowUniformsInitialized = true)), g2 = v3.shouldRenderCutoff || h3 < 1 || "OPAQUE" !== o3.alphaMode ? ki.alphaBlended : ki.unblended;
              }
              e2.uploadCommonUniforms(a2, f2, r2.toUnwrapped(), null, v3);
              const y2 = u5.material.doubleSided ? qi.disabled : qi.backCCW;
              if (o2.instancedDataArray.length > 20) p2.push(o2.instancedDataBuffer), f2.draw(e2, a2.gl.TRIANGLES, h2, ji.disabled, g2, y2, m2, t2.id, u5.vertexBuffer, u5.indexBuffer, u5.segments, t2.paint, e2.transform.zoom, void 0, p2, o2.instancedDataArray.length);
              else {
                const i3 = l2 ? "u_instance" : "u_normal_matrix";
                for (let s3 = 0; s3 < o2.instancedDataArray.length; ++s3) m2[i3] = new Float32Array(o2.instancedDataArray.arrayBuffer, 64 * s3, 16), f2.draw(e2, a2.gl.TRIANGLES, h2, ji.disabled, g2, y2, m2, t2.id, u5.vertexBuffer, u5.indexBuffer, u5.segments, t2.paint, e2.transform.zoom, void 0, p2);
              }
            }
            if (i2.children) for (const a3 of i2.children) Pn(e2, t2, a3, o2, s2, r2, n2);
          }
          const zn = [1, -1, 1];
          function Mn(t2, i2, o2, s2) {
            if (!o2.modelManager) return true;
            const r2 = o2.modelManager;
            if (!o2.shadowRenderer) return true;
            const n2 = o2.shadowRenderer, a2 = i2.aabb;
            let l2 = true, c2 = t2.maxHeight;
            if (0 === c2) {
              let e2 = 0;
              for (const i3 in t2.instancesPerModel) {
                const t3 = r2.getModel(i3, s2);
                t3 ? e2 = Math.max(e2, Math.max(Math.max(t3.aabb.max[0], t3.aabb.max[1]), t3.aabb.max[2])) : l2 = false;
              }
              c2 = t2.maxScale * e2 * 1.41 + t2.maxVerticalOffset, l2 && (t2.maxHeight = c2);
            }
            a2.max[2] = c2, a2.min[2] += t2.terrainElevationMin, a2.max[2] += t2.terrainElevationMax, e.ad(a2.min, a2.min, i2.tileMatrix), e.ad(a2.max, a2.max, i2.tileMatrix);
            const h2 = a2.intersects(n2.getCurrentCascadeFrustum());
            return 0 === o2.currentShadowCascade && (t2.isInsideFirstShadowMapFrustum = 2 === h2), 0 === h2;
          }
          function On(t2, i2) {
            const o2 = t2.uniformValues.u_cutoff_params[0], s2 = t2.uniformValues.u_cutoff_params[1], r2 = t2.uniformValues.u_cutoff_params[2], n2 = t2.uniformValues.u_cutoff_params[3];
            return s2 === o2 || n2 === r2 ? 1 : e.aD(((i2 - o2) / (s2 - o2) - r2) / (n2 - r2), 0, 1);
          }
          function Fn(t2, i2, o2, s2) {
            if (i2.pitch < 20) return 1;
            const r2 = i2.getWorldToCameraMatrix();
            e.az(r2, r2, t2);
            const n2 = e.ei(o2.min[0], o2.min[1], o2.min[2], 1);
            let a2 = e.aA(e.ej(), n2, r2), l2 = a2, c2 = a2;
            n2[1] = o2.max[1], a2 = e.aA(e.ej(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2, n2[0] = o2.max[0], a2 = e.aA(e.ej(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2, n2[1] = o2.min[1], a2 = e.aA(e.ej(), n2, r2), l2 = a2[1] < l2[1] ? a2 : l2, c2 = a2[1] > c2[1] ? a2 : c2;
            const h2 = e.aD(s2[0], 0, 1), d2 = 100 * i2.pixelsPerMeter * e.aD(s2[1], 0, 1), u5 = e.aD(s2[2], 0, 1), _2 = e.ek(e.ej(), l2, c2, h2), p2 = Math.tan(0.5 * i2.fovX), f2 = -_2[2] * p2;
            if (0 === d2) return _2[1] < -Math.abs(f2) ? u5 : 1;
            const m2 = (-Math.abs(f2) - _2[1]) / d2, g2 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, v3 = e.aD(g2(1, u5, m2), u5, 1);
            return g2(1, v3, e.aD((i2.pitch - 20) / 20, 0, 1));
          }
          class Bn {
          }
          class kn {
            constructor() {
              this._storage = /* @__PURE__ */ new Map();
            }
            getLinesFromTrianglesBuffer(t2, i2, o2) {
              {
                const e2 = this._storage.get(i2.id);
                if (e2) return e2.lastUsedFrameIdx = t2, e2.buf;
              }
              const s2 = o2.gl, r2 = s2.getBufferParameter(s2.ELEMENT_ARRAY_BUFFER, s2.BUFFER_SIZE), n2 = new ArrayBuffer(r2), a2 = new Int16Array(n2);
              s2.getBufferSubData(s2.ELEMENT_ARRAY_BUFFER, 0, new Int16Array(n2));
              const l2 = new e.en();
              for (let e2 = 0; e2 < r2 / 2; e2 += 3) {
                const t3 = a2[e2], i3 = a2[e2 + 1], o3 = a2[e2 + 2];
                l2.emplaceBack(t3, i3), l2.emplaceBack(i3, o3), l2.emplaceBack(o3, t3);
              }
              const c2 = o2.bindVertexArrayOES.current, h2 = new Bn();
              return h2.buf = new Cr(o2, l2), h2.lastUsedFrameIdx = t2, this._storage.set(i2.id, h2), o2.bindVertexArrayOES.set(c2), h2.buf;
            }
            update(e2) {
              for (const [t2, i2] of this._storage) e2 - i2.lastUsedFrameIdx > 30 && (i2.buf.destroy(), this._storage.delete(t2));
            }
            destroy() {
              for (const [e2, t2] of this._storage) t2.buf.destroy(), this._storage.delete(e2);
            }
          }
          class Nn {
            constructor(e2) {
              this.occluderSize = 30, this.depthOffset = -1e-4, e2.registerParameter(this, ["Occlusion"], "occluderSize", { min: 1, max: 100, step: 1 }), e2.registerParameter(this, ["Occlusion"], "depthOffset", { min: -0.05, max: 0, step: 1e-5 });
            }
          }
          const Un = e.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_rainParticleData", components: 4 }]);
          class jn {
            registerParameter() {
            }
            registerButton() {
            }
            registerBinding() {
            }
            refreshUI() {
            }
          }
          class Vn {
            constructor(e2, t2) {
              this.revealStart = 11, this.revealRange = 2, e2.registerParameter(this, [...t2, "Reveal"], "revealStart", { min: 0, max: 17, step: 0.05 }), e2.registerParameter(this, [...t2, "Reveal"], "revealRange", { min: 0.1, max: 5.1, step: 0.05 });
            }
          }
          const Gn = e.d_([{ type: "Float32", name: "a_pos_2f", components: 2 }]);
          class qn {
            destroy() {
              this.vignetteVx && this.vignetteVx.destroy(), this.vignetteIdx && this.vignetteIdx.destroy();
            }
            draw(t2, i2) {
              const o2 = t2.getOrCreateProgram("vignette");
              if (!this.vignetteVx || !this.vignetteIdx) {
                const i3 = new e.eo(), o3 = new e.a_();
                i3.emplaceBack(-1, -1), i3.emplaceBack(1, -1), i3.emplaceBack(1, 1), i3.emplaceBack(-1, 1), o3.emplaceBack(0, 1, 2), o3.emplaceBack(0, 2, 3), this.vignetteVx = t2.context.createVertexBuffer(i3, Gn.members), this.vignetteIdx = t2.context.createIndexBuffer(o3);
              }
              const s2 = e.bd.simpleSegment(0, 0, 4, 6);
              if (this.vignetteVx && this.vignetteIdx) {
                t2.uploadCommonUniforms(t2.context, o2);
                const e2 = { u_vignetteShape: (r2 = { vignetteShape: [i2.start, i2.range, Math.pow(10, i2.fadePower)], vignetteColor: [i2.color.r, i2.color.g, i2.color.b, i2.color.a * i2.strength] }).vignetteShape, u_vignetteColor: r2.vignetteColor };
                o2.draw(t2, t2.context.gl.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, e2, "vignette", this.vignetteVx, this.vignetteIdx, s2);
              }
              var r2;
            }
          }
          class Zn {
            constructor() {
              this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
            }
            update(t2, i2) {
              const o2 = t2.getFreeCameraOptions().position, s2 = o2.toAltitude(), r2 = o2.toLngLat(), n2 = e.al(r2.lng), a2 = e.al(r2.lat), l2 = t2.pixelsPerMeter / i2, c2 = n2 * e.eq, h2 = e.eq * Math.log(Math.tan(Math.PI / 4 + a2 / 2));
              if (void 0 === this._offsetXPrev) this._offsetXPrev = 0, this._offsetYPrev = 0, this._elevationPrev = 0, this._accumulatedOffsetX = 0, this._accumulatedOffsetY = 0, this._accumulatedElevation = 0;
              else {
                const e2 = -this._offsetYPrev + h2, t3 = -this._elevationPrev + s2;
                this._accumulatedOffsetX += (-this._offsetXPrev + c2) * l2, this._accumulatedOffsetY += e2 * l2, this._accumulatedElevation += t3 * l2, this._offsetXPrev = c2, this._offsetYPrev = h2, this._elevationPrev = s2;
              }
            }
            getPosition() {
              return [this._accumulatedOffsetX, this._accumulatedOffsetY, this._accumulatedElevation];
            }
          }
          function Hn(e2, t2) {
            return [-(e2[0] - Math.floor(e2[0] / t2) * t2), -(e2[1] - Math.floor(e2[1] / t2) * t2), -(e2[2] - Math.floor(e2[2] / t2) * t2)];
          }
          function Wn(t2) {
            const i2 = e.ea(1323123451230), o2 = [];
            for (let s2 = 0; s2 < t2; ++s2) {
              const t3 = 2 * i2() - 1, s3 = 2 * i2() - 1, r2 = 2 * i2() - 1;
              o2.push(e.cS(t3, s3, r2));
            }
            return o2;
          }
          function $n(t2, i2, o2, s2, r2) {
            const n2 = e.aD((r2 - o2) / (s2 - o2), 0, 1);
            return (1 - n2) * t2 + n2 * i2;
          }
          class Xn {
            constructor(e2) {
              this._movement = new Zn(), this._accumulatedTimeFromStart = 0, this._prevTime = Date.now() / 1e3, this._vignette = new qn(), this._ppmScaleFactor = e2;
            }
            destroy() {
              this.particlesVx && this.particlesVx.destroy(), this.particlesIdx && this.particlesIdx.destroy(), this._vignette && this._vignette.destroy();
            }
            updateOnRender(t2, i2) {
              const o2 = t2.transform;
              this._movement.update(o2, this._ppmScaleFactor);
              const s2 = o2.starsProjMatrix, r2 = e.bY([]);
              e.b_(r2, r2, e.al(90) - o2._pitch), e.bZ(r2, r2, -o2.angle);
              const n2 = e.c3(new Float32Array(16), r2), a2 = e.ep(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1), l2 = e.ee([], a2), c2 = e.az([], l2, n2), h2 = Date.now() / 1e3;
              return this._accumulatedTimeFromStart += (h2 - this._prevTime) * i2, this._prevTime = h2, { projectionMatrix: s2, modelviewMatrix: c2 };
            }
          }
          class Yn extends Xn {
            constructor(e2) {
              super(4.25), this._params = { overrideStyleParameters: false, intensity: 0.5, timeFactor: 1, velocityConeAperture: 0, velocity: 300, boxSize: 2500, dropletSizeX: 1, dropletSizeYScale: 10, distortionStrength: 70, screenThinning: { intensity: 0.57, start: 0.46, range: 1.17, fadePower: 0.17, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 0.66, g: 0.68, b: 0.74, a: 0.7 }, direction: { x: -50, y: -35 }, shapeDirPower: 2, shapeNormalPower: 1 }, this._revealParams = new Vn(e2.tp, ["Precipitation", "Rain"]), this._vignetteParams = { strength: 1, start: 0.7, range: 1, fadePower: 0.4, color: { r: 0.27, g: 0.27, b: 0.27, a: 1 } }, this.particlesCount = 16e3;
            }
            update(t2) {
              const i2 = t2.context;
              if (!this.particlesVx) {
                const t3 = Wn(this.particlesCount), o2 = new e.er(), s2 = new e.a_();
                let r2 = 0;
                const n2 = e.ea(1323123451230);
                for (let e2 = 0; e2 < t3.length; ++e2) {
                  const i3 = t3[e2], a2 = [2 * n2() - 1, n2(), n2(), n2()];
                  o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...a2), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...a2), s2.emplaceBack(r2 + 0, r2 + 1, r2 + 2), s2.emplaceBack(r2 + 0, r2 + 2, r2 + 3), r2 += 4;
                }
                this.particlesVx = i2.createVertexBuffer(o2, Un.members), this.particlesIdx = i2.createIndexBuffer(s2);
              }
            }
            draw(t2) {
              if (!this._params.overrideStyleParameters && !t2.style.rain) return;
              const i2 = this._params.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, o2 = t2.transform.zoom;
              if (i2.revealStart > o2) return;
              const s2 = $n(0, 1, i2.revealStart, i2.revealStart + i2.revealRange, o2);
              if (!this.particlesVx || !this.particlesIdx) return;
              const r2 = structuredClone(this._params);
              let n2 = [-r2.direction.x, r2.direction.y, -100];
              e.au(n2, n2);
              const a2 = structuredClone(this._vignetteParams);
              a2.strength *= s2, r2.overrideStyleParameters || (r2.intensity = t2.style.rain.state.density, r2.timeFactor = t2.style.rain.state.intensity, r2.color = structuredClone(t2.style.rain.state.color), n2 = structuredClone(t2.style.rain.state.direction), r2.screenThinning.intensity = t2.style.rain.state.centerThinning, r2.dropletSizeX = t2.style.rain.state.dropletSize[0], r2.dropletSizeYScale = t2.style.rain.state.dropletSize[1] / t2.style.rain.state.dropletSize[0], r2.distortionStrength = 100 * t2.style.rain.state.distortionStrength, a2.strength = 1, a2.color = structuredClone(t2.style.rain.state.vignetteColor));
              const l2 = this.updateOnRender(t2, r2.timeFactor), c2 = t2.context, h2 = c2.gl, d2 = t2.transform;
              this.screenTexture && this.screenTexture.size[0] === t2.width && this.screenTexture.size[1] === t2.height || (this.screenTexture = new e.T(c2, { width: t2.width, height: t2.height, data: null }, h2.RGBA8)), r2.distortionStrength > 0 && (c2.activeTexture.set(h2.TEXTURE0), this.screenTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE), h2.copyTexSubImage2D(h2.TEXTURE_2D, 0, 0, 0, 0, 0, t2.width, t2.height));
              const u5 = t2.getOrCreateProgram("rainParticle");
              t2.uploadCommonUniforms(c2, u5), c2.activeTexture.set(h2.TEXTURE0), this.screenTexture.bind(h2.LINEAR, h2.CLAMP_TO_EDGE);
              const _2 = [r2.color.r, r2.color.g, r2.color.b, r2.color.a], p2 = (i3, o3) => {
                const s3 = Hn(this._movement.getPosition(), i3), a3 = r2.dropletSizeX, c3 = r2.dropletSizeX * r2.dropletSizeYScale, p3 = t2.width / 2, f2 = t2.height / 2, m2 = $n(0, r2.screenThinning.start, 0, 1, r2.screenThinning.intensity), g2 = $n(1e-3, r2.screenThinning.range, 0, 1, r2.screenThinning.intensity), v3 = $n(0, r2.screenThinning.particleOffset, 0, 1, r2.screenThinning.intensity), y2 = (x2 = { modelview: l2.modelviewMatrix, projection: l2.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: s3, velocityConeAperture: r2.velocityConeAperture, velocity: r2.velocity, boxSize: i3, rainDropletSize: [a3, c3], distortionStrength: r2.distortionStrength, rainDirection: n2, color: _2, screenSize: [d2.width, d2.height], thinningCenterPos: [p3, f2], thinningShape: [m2, g2, Math.pow(10, r2.screenThinning.fadePower)], thinningAffectedRatio: r2.screenThinning.affectedRatio, thinningParticleOffset: v3, shapeDirectionalPower: r2.shapeDirPower, shapeNormalPower: r2.shapeNormalPower, mode: o3 ? 0 : 1 }, { u_modelview: Float32Array.from(x2.modelview), u_projection: Float32Array.from(x2.projection), u_time: x2.time, u_cam_pos: x2.camPos, u_texScreen: 0, u_velocityConeAperture: x2.velocityConeAperture, u_velocity: x2.velocity, u_boxSize: x2.boxSize, u_rainDropletSize: x2.rainDropletSize, u_distortionStrength: x2.distortionStrength, u_rainDirection: x2.rainDirection, u_color: x2.color, u_screenSize: x2.screenSize, u_thinningCenterPos: x2.thinningCenterPos, u_thinningShape: x2.thinningShape, u_thinningAffectedRatio: x2.thinningAffectedRatio, u_thinningParticleOffset: x2.thinningParticleOffset, u_shapeDirectionalPower: x2.shapeDirectionalPower, u_shapeNormalPower: x2.shapeNormalPower, u_mode: x2.mode });
                var x2;
                const b2 = Math.round(r2.intensity * this.particlesCount), w2 = e.bd.simpleSegment(0, 0, 4 * b2, 2 * b2);
                u5.draw(t2, h2.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, y2, "rain_particles", this.particlesVx, this.particlesIdx, w2);
              };
              r2.distortionStrength > 0 && p2(r2.boxSize, true), p2(r2.boxSize, false), this._vignette.draw(t2, a2);
            }
          }
          const Kn = e.d_([{ type: "Float32", name: "a_pos_3f", components: 3 }, { type: "Float32", name: "a_uv", components: 2 }, { type: "Float32", name: "a_snowParticleData", components: 4 }, { type: "Float32", name: "a_snowParticleDataHorizontalOscillation", components: 2 }]);
          class Jn extends Xn {
            constructor(e2) {
              super(2.25), this._params = { overrideStyleParameters: false, intensity: 0.85, timeFactor: 0.75, velocityConeAperture: 70, velocity: 40, horizontalOscillationRadius: 4, horizontalOscillationRate: 1.5, boxSize: 2e3, billboardSize: 2, shapeFadeStart: 0.27, shapeFadePower: 0.21, screenThinning: { intensity: 0.4, start: 0.15, range: 1.4, fadePower: 0.24, affectedRatio: 1, particleOffset: -0.2 }, color: { r: 1, g: 1, b: 1, a: 1 }, direction: { x: -50, y: -35 } }, this._revealParams = new Vn(e2.tp, ["Precipitation", "Snow"]), this._vignetteParams = { strength: 0.3, start: 0.78, range: 0.46, fadePower: 0.2, color: { r: 1, g: 1, b: 1, a: 1 } }, this.particlesCount = 16e3;
            }
            update(t2) {
              const i2 = t2.context;
              if (!this.particlesVx) {
                const t3 = Wn(this.particlesCount), o2 = new e.es(), s2 = new e.a_();
                let r2 = 0;
                const n2 = e.ea(1323123451230);
                for (let e2 = 0; e2 < t3.length; ++e2) {
                  const i3 = t3[e2], a2 = n2(), l2 = n2(), c2 = n2(), h2 = [e2 / t3.length, a2, l2, c2], d2 = [n2(), n2()];
                  o2.emplaceBack(i3[0], i3[1], i3[2], -1, -1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, -1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], 1, 1, ...h2, ...d2), o2.emplaceBack(i3[0], i3[1], i3[2], -1, 1, ...h2, ...d2), s2.emplaceBack(r2 + 0, r2 + 1, r2 + 2), s2.emplaceBack(r2 + 0, r2 + 2, r2 + 3), r2 += 4;
                }
                this.particlesVx = i2.createVertexBuffer(o2, Kn.members), this.particlesIdx = i2.createIndexBuffer(s2);
              }
            }
            draw(t2) {
              if (!this._params.overrideStyleParameters && !t2.style.snow) return;
              const i2 = structuredClone(this._params);
              let o2 = [-i2.direction.x, i2.direction.y, -100];
              e.au(o2, o2);
              const s2 = structuredClone(this._vignetteParams), r2 = i2.overrideStyleParameters ? this._revealParams : { revealStart: 0, revealRange: 0.01 }, n2 = t2.transform.zoom;
              if (r2.revealStart > n2) return;
              const a2 = $n(0, 1, r2.revealStart, r2.revealStart + r2.revealRange, n2);
              s2.strength *= a2, i2.overrideStyleParameters || (i2.intensity = t2.style.snow.state.density, i2.timeFactor = t2.style.snow.state.intensity, i2.color = structuredClone(t2.style.snow.state.color), o2 = structuredClone(t2.style.snow.state.direction), i2.screenThinning.intensity = t2.style.snow.state.centerThinning, i2.billboardSize = 2.79 * t2.style.snow.state.flakeSize, s2.strength = 1, s2.color = structuredClone(t2.style.snow.state.vignetteColor));
              const l2 = this.updateOnRender(t2, i2.timeFactor);
              if (!this.particlesVx || !this.particlesIdx) return;
              const c2 = t2.context, h2 = c2.gl, d2 = t2.transform, u5 = t2.getOrCreateProgram("snowParticle");
              t2.uploadCommonUniforms(c2, u5), ((i3, s3, r3) => {
                const n3 = Hn(this._movement.getPosition(), i3), a3 = d2.width / 2, c3 = d2.height / 2, _2 = $n(0, r3.screenThinning.start, 0, 1, r3.screenThinning.intensity), p2 = $n(1e-3, r3.screenThinning.range, 0, 1, r3.screenThinning.intensity), f2 = $n(0, r3.screenThinning.particleOffset, 0, 1, r3.screenThinning.intensity), m2 = (g2 = { modelview: l2.modelviewMatrix, projection: l2.projectionMatrix, time: this._accumulatedTimeFromStart, camPos: n3, velocityConeAperture: r3.velocityConeAperture, velocity: r3.velocity, horizontalOscillationRadius: r3.horizontalOscillationRadius, horizontalOscillationRate: r3.horizontalOscillationRate, boxSize: i3, billboardSize: 1 * r3.billboardSize, simpleShapeParameters: [r3.shapeFadeStart, r3.shapeFadePower], screenSize: [d2.width, d2.height], thinningCenterPos: [a3, c3], thinningShape: [_2, p2, Math.pow(10, r3.screenThinning.fadePower)], thinningAffectedRatio: r3.screenThinning.affectedRatio, thinningParticleOffset: f2, color: [r3.color.r, r3.color.g, r3.color.b, r3.color.a], direction: o2 }, { u_modelview: Float32Array.from(g2.modelview), u_projection: Float32Array.from(g2.projection), u_time: g2.time, u_cam_pos: g2.camPos, u_velocityConeAperture: g2.velocityConeAperture, u_velocity: g2.velocity, u_horizontalOscillationRadius: g2.horizontalOscillationRadius, u_horizontalOscillationRate: g2.horizontalOscillationRate, u_boxSize: g2.boxSize, u_billboardSize: g2.billboardSize, u_simpleShapeParameters: g2.simpleShapeParameters, u_screenSize: g2.screenSize, u_thinningCenterPos: g2.thinningCenterPos, u_thinningShape: g2.thinningShape, u_thinningAffectedRatio: g2.thinningAffectedRatio, u_thinningParticleOffset: g2.thinningParticleOffset, u_particleColor: g2.color, u_direction: g2.direction });
                var g2;
                const v3 = Math.round(r3.intensity * this.particlesCount), y2 = e.bd.simpleSegment(0, 0, 4 * v3, 2 * v3);
                this.particlesVx && this.particlesIdx && u5.draw(t2, h2.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, m2, "snow_particles", this.particlesVx, this.particlesIdx, y2);
              })(i2.boxSize, 0, i2), this._vignette.draw(t2, s2);
            }
          }
          const Qn = { symbol: function(t2, i2, o2, s2, r2) {
            if ("translucent" !== t2.renderPass) return;
            const n2 = ji.disabled, a2 = t2.colorModeForRenderPass(), l2 = o2.layout.get("text-variable-anchor"), c2 = o2.layout.get("text-size-scale-range"), h2 = e.aD(t2.scaleFactor, c2[0], c2[1]);
            l2 && function(t3, i3, o3, s3, r3, n3, a3, l3) {
              const c3 = i3.transform, h3 = "map" === r3, d3 = "map" === n3;
              for (const i4 of t3) {
                const t4 = s3.getTile(i4), r4 = t4.getBucket(o3);
                if (!r4 || !r4.text || !r4.text.segments.get().length) continue;
                const n4 = e.bH(r4.textSizeData, c3.zoom, l3), u6 = hi(i4, r4.getProjection(), c3), _2 = c3.calculatePixelsToTileUnitsMatrix(t4), p2 = Zt(u6, t4.tileID.canonical, d3, h3, c3, r4.getProjection(), _2), f2 = r4.hasIconTextFit() && r4.hasIconData();
                n4 && Br(r4, h3, d3, a3, c3, p2, i4, Math.pow(2, c3.zoom - t4.tileID.overscaledZ), n4, f2);
              }
            }(s2, t2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), r2, h2);
            const d2 = 0 !== o2.paint.get("icon-opacity").constantOr(1), u5 = 0 !== o2.paint.get("text-opacity").constantOr(1);
            void 0 !== o2.layout.get("symbol-sort-key").constantOr(1) && (d2 || u5) ? kr(t2, i2, o2, s2, n2, a2) : (d2 && kr(t2, i2, o2, s2, n2, a2, { onlyIcons: true }), u5 && kr(t2, i2, o2, s2, n2, a2, { onlyText: true })), i2.map.showCollisionBoxes && (zr(t2, i2, o2, s2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), zr(t2, i2, o2, s2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
          }, circle: function(t2, i2, o2, s2) {
            if ("translucent" !== t2.renderPass) return;
            const r2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), a2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1), c2 = o2.paint.get("circle-emissive-strength");
            if (0 === r2.constantOr(1) && (0 === n2.constantOr(1) || 0 === a2.constantOr(1))) return;
            const h2 = t2.context, d2 = h2.gl, u5 = t2.transform, _2 = t2.depthModeForSublayer(0, Ni.ReadOnly), p2 = ji.disabled, f2 = t2.colorModeForDrapableLayerRenderPass(c2), m2 = "globe" === u5.projection.name, g2 = [e.ay(u5.center.lng), e.aH(u5.center.lat)], v3 = [];
            for (let r3 = 0; r3 < s2.length; r3++) {
              const n3 = s2[r3], a3 = i2.getTile(n3), c3 = a3.getBucket(o2);
              if (!c3 || c3.projection.name !== u5.projection.name) continue;
              const h3 = c3.programConfigurations.get(o2.id), d3 = e.dK(o2), _3 = t2.isTileAffectedByFog(n3);
              m2 && d3.push("PROJECTION_GLOBE_VIEW"), d3.push("DEPTH_D24"), t2.terrain && u5.depthOcclusionForSymbolsAndCircles && d3.push("DEPTH_OCCLUSION");
              const p3 = t2.getOrCreateProgram("circle", { config: h3, defines: d3, overrideFog: _3 }), f3 = c3.layoutVertexBuffer, y3 = c3.globeExtVertexBuffer, x2 = c3.indexBuffer, b2 = u5.projection.createInversionMatrix(u5, n3.canonical), w2 = { programConfiguration: h3, program: p3, layoutVertexBuffer: f3, globeExtVertexBuffer: y3, indexBuffer: x2, uniformValues: e.dL(t2, n3, a3, b2, g2, o2), tile: a3 };
              if (l2) {
                const t3 = c3.segments.get();
                for (const i3 of t3) v3.push({ segments: new e.bd([i3]), sortKey: i3.sortKey, state: w2 });
              } else v3.push({ segments: c3.segments, sortKey: 0, state: w2 });
            }
            l2 && v3.sort((e2, t3) => e2.sortKey - t3.sortKey);
            const y2 = { useDepthForOcclusion: u5.depthOcclusionForSymbolsAndCircles };
            for (const e2 of v3) {
              const { programConfiguration: i3, program: s3, layoutVertexBuffer: r3, globeExtVertexBuffer: n3, indexBuffer: a3, uniformValues: l3, tile: c3 } = e2.state, m3 = e2.segments;
              t2.terrain && t2.terrain.setupElevationDraw(c3, s3, y2), t2.uploadCommonUniforms(h2, s3, c3.tileID.toUnwrapped()), s3.draw(t2, d2.TRIANGLES, _2, p2, f2, qi.disabled, l3, o2.id, r3, a3, m3, o2.paint, u5.zoom, i3, [n3]);
            }
          }, heatmap: function(t2, i2, o2, s2) {
            if (0 !== o2.paint.get("heatmap-opacity")) if ("offscreen" === t2.renderPass) {
              const r2 = t2.context, n2 = r2.gl, a2 = ji.disabled, l2 = new ki([n2.ONE, n2.ONE, n2.ONE, n2.ONE], e.am.transparent, [true, true, true, true]);
              !function(e2, t3, i3, o3) {
                const s3 = e2.gl, r3 = t3.width * o3, n3 = t3.height * o3;
                e2.activeTexture.set(s3.TEXTURE1), e2.viewport.set([0, 0, r3, n3]);
                let a3 = i3.heatmapFbo;
                if (!a3 || a3 && (a3.width !== r3 || a3.height !== n3)) {
                  a3 && a3.destroy();
                  const t4 = s3.createTexture();
                  s3.bindTexture(s3.TEXTURE_2D, t4), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_S, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_WRAP_T, s3.CLAMP_TO_EDGE), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MIN_FILTER, s3.LINEAR), s3.texParameteri(s3.TEXTURE_2D, s3.TEXTURE_MAG_FILTER, s3.LINEAR), a3 = i3.heatmapFbo = e2.createFramebuffer(r3, n3, true, null), function(e3, t5, i4, o4, s4, r4) {
                    const n4 = e3.gl;
                    n4.texImage2D(n4.TEXTURE_2D, 0, e3.extRenderToTextureHalfFloat ? n4.RGBA16F : n4.RGBA, s4, r4, 0, n4.RGBA, e3.extRenderToTextureHalfFloat ? n4.HALF_FLOAT : n4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                  }(e2, 0, t4, a3, r3, n3);
                } else s3.bindTexture(s3.TEXTURE_2D, a3.colorAttachment.get()), e2.bindFramebuffer.set(a3.framebuffer);
              }(r2, t2, o2, "globe" === t2.transform.projection.name ? 0.5 : 0.25), r2.clear({ color: e.am.transparent });
              const c2 = t2.transform, h2 = "globe" === c2.projection.name, d2 = h2 ? ["PROJECTION_GLOBE_VIEW"] : [], u5 = h2 ? qi.frontCCW : qi.disabled, _2 = [e.ay(c2.center.lng), e.aH(c2.center.lat)];
              for (let e2 = 0; e2 < s2.length; e2++) {
                const p2 = s2[e2];
                if (i2.hasRenderableParent(p2)) continue;
                const f2 = i2.getTile(p2), m2 = f2.getBucket(o2);
                if (!m2 || m2.projection.name !== c2.projection.name) continue;
                const g2 = t2.isTileAffectedByFog(p2), v3 = m2.programConfigurations.get(o2.id), y2 = t2.getOrCreateProgram("heatmap", { config: v3, defines: d2, overrideFog: g2 }), { zoom: x2 } = t2.transform;
                t2.terrain && t2.terrain.setupElevationDraw(f2, y2), t2.uploadCommonUniforms(r2, y2, p2.toUnwrapped());
                const b2 = c2.projection.createInversionMatrix(c2, p2.canonical);
                y2.draw(t2, n2.TRIANGLES, Ni.disabled, a2, l2, u5, hr(t2, p2, f2, b2, _2, x2, o2.paint.get("heatmap-intensity")), o2.id, m2.layoutVertexBuffer, m2.indexBuffer, m2.segments, o2.paint, t2.transform.zoom, v3, h2 ? [m2.globeExtVertexBuffer] : null);
              }
              r2.viewport.set([0, 0, t2.width, t2.height]);
            } else "translucent" === t2.renderPass && (t2.context.setColorMode(t2.colorModeForRenderPass()), function(t3, i3) {
              const o3 = t3.context, s3 = o3.gl, r2 = i3.heatmapFbo;
              if (!r2) return;
              o3.activeTexture.set(s3.TEXTURE0), s3.bindTexture(s3.TEXTURE_2D, r2.colorAttachment.get()), o3.activeTexture.set(s3.TEXTURE1);
              let n2 = i3.colorRampTexture;
              n2 || (n2 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, s3.RGBA8)), n2.bind(s3.LINEAR, s3.CLAMP_TO_EDGE), t3.getOrCreateProgram("heatmapTexture").draw(t3, s3.TRIANGLES, Ni.disabled, ji.disabled, t3.colorModeForRenderPass(), qi.disabled, ((e2, t4, i4, o4) => ({ u_image: 0, u_color_ramp: 1, u_opacity: t4.paint.get("heatmap-opacity") }))(0, i3), i3.id, t3.viewportBuffer, t3.quadTriangleIndexBuffer, t3.viewportSegments, i3.paint, t3.transform.zoom);
            }(t2, o2));
          }, line: function(t2, i2, o2, s2) {
            if ("translucent" !== t2.renderPass) return;
            const r2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
            if (0 === r2.constantOr(1) || 0 === n2.constantOr(1)) return;
            const a2 = o2.paint.get("line-emissive-strength"), l2 = o2.paint.get("line-occlusion-opacity"), c2 = o2.layout.get("line-elevation-reference"), h2 = "meters" === o2.layout.get("line-width-unit"), d2 = "sea" === c2, u5 = !(!t2.terrain || !t2.terrain.enabled), _2 = t2.context, p2 = _2.gl;
            if (o2.hasElevatedBuckets && "globe" === t2.transform.projection.name) return;
            const f2 = o2.layout.get("line-cross-slope"), m2 = void 0 !== f2, g2 = f2 < 1, v3 = t2.colorModeForDrapableLayerRenderPass(a2), y2 = t2.terrain && t2.terrain.renderingToTexture, x2 = y2 ? 1 : e.q.devicePixelRatio, b2 = o2.paint.get("line-dasharray"), w2 = b2.constantOr(1), T2 = o2.layout.get("line-cap"), E2 = b2.constantOr(null), S2 = T2.constantOr(null), I2 = o2.paint.get("line-pattern"), C3 = I2.constantOr(1), R2 = o2.paint.get("line-pattern-cross-fade"), D3 = I2.constantOr(null), A2 = o2.paint.get("line-opacity").constantOr(1);
            let L2 = !C3 && 1 !== A2 || t2.depthOcclusion && l2 > 0 && l2 < 1;
            const P2 = o2.paint.get("line-gradient"), z2 = C3 ? "linePattern" : "line", M2 = e.dM(o2);
            let O2;
            if (y2 && t2.terrain && t2.terrain.clipOrMaskOverlapStencilType() && (L2 = false), 0 !== l2 && t2.depthOcclusion) {
              const t3 = o2.paint._values["line-opacity"];
              t3 && t3.value && "constant" === t3.value.kind ? O2 = t3.value : e.w(`Occlusion opacity for layer ${o2.id} is supported only when line-opacity isn't data-driven.`);
            }
            "constant" !== n2.value.kind && false === n2.value.isLineProgressConstant && M2.push("VARIABLE_LINE_WIDTH");
            const F2 = (s3, r3, n3, a3, c3, u6) => {
              for (const f3 of s3) {
                const s4 = i2.getTile(f3);
                if (C3 && !s4.patternsLoaded()) continue;
                const m3 = s4.getBucket(o2);
                if (!m3) continue;
                if ("none" !== m3.elevationType && !c3 || "none" === m3.elevationType && c3) continue;
                t2.prepareDrawTile();
                const g3 = [...r3], b3 = t2.shadowRenderer, T3 = "road" === m3.elevationType && !!b3 && b3.enabled;
                let I3 = [0, 0, 0];
                if (T3) {
                  const e2 = t2.style.directionalLight, i3 = t2.style.ambientLight;
                  e2 && i3 && (I3 = ao(t2.style, e2, i3)), g3.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                }
                const M3 = m3.programConfigurations.get(o2.id);
                let F3 = false;
                if (D3 && s4.imageAtlas) {
                  const t3 = e.dN.from(D3), i3 = t3.getPrimary().scaleSelf(x2).toString(), o3 = s4.imageAtlas.patternPositions.get(i3), r4 = t3.getSecondary(), n4 = r4 ? s4.imageAtlas.patternPositions.get(r4.scaleSelf(x2).toString()) : null;
                  F3 = !!o3 && !!n4, o3 && M3.setConstantPatternPositions(o3, n4);
                }
                R2 > 0 && (F3 || M3.getPatternTransitionVertexBuffer("line-pattern")) && g3.push("LINE_PATTERN_TRANSITION");
                const B4 = t2.isTileAffectedByFog(f3), k3 = t2.getOrCreateProgram(z2, { config: M3, defines: g3, overrideFog: B4, overrideRtt: !c3 && void 0 });
                if (!C3 && E2 && S2 && s4.lineAtlas) {
                  const e2 = s4.lineAtlas.getDash(E2, S2);
                  e2 && M3.setConstantPatternPositions(e2);
                }
                T3 && b3.setupShadows(s4.tileID.toUnwrapped(), k3, "vector-tile", s4.tileID.overscaledZ);
                let [N2, U2] = o2.paint.get("line-trim-offset");
                if ("round" === S2 || "square" === S2) {
                  const e2 = 1;
                  N2 !== U2 && (0 === N2 && (N2 -= e2), 1 === U2 && (U2 += e2));
                }
                const j2 = y2 ? f3.projMatrix : null, V2 = h2 ? 1 / m3.tileToMeter / e.aw(s4, 1, t2.transform.zoom) : 1, G2 = h2 ? 1 / m3.tileToMeter / e.aw(s4, 1, Math.floor(t2.transform.zoom)) : 1, q2 = C3 ? e.dO(t2, s4, o2, j2, x2, V2, G2, [N2, U2], I3, R2) : e.dP(t2, s4, o2, j2, m3.lineClipsArray.length, x2, V2, G2, [N2, U2], I3);
                if (P2) {
                  const s5 = m3.gradients[o2.id];
                  let r4 = s5.texture;
                  if (o2.gradientVersion !== s5.version) {
                    let n4 = 256;
                    if (o2.stepInterpolant) {
                      const o3 = i2.getSource().maxzoom, s6 = f3.canonical.z === o3 ? Math.ceil(1 << t2.transform.maxZoom - f3.canonical.z) : 1;
                      n4 = e.aD(e.dQ(m3.maxLineLength / e.aj * 1024 * s6), 256, _2.maxTextureSize);
                    }
                    s5.gradient = e.dR({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: n4, image: s5.gradient || void 0, clips: m3.lineClipsArray }), s5.texture ? s5.texture.update(s5.gradient) : s5.texture = new e.T(_2, s5.gradient, p2.RGBA8), s5.version = o2.gradientVersion, r4 = s5.texture;
                  }
                  _2.activeTexture.set(p2.TEXTURE1), r4.bind(o2.stepInterpolant ? p2.NEAREST : p2.LINEAR, p2.CLAMP_TO_EDGE);
                }
                w2 && (_2.activeTexture.set(p2.TEXTURE0), s4.lineAtlasTexture && s4.lineAtlasTexture.bind(p2.LINEAR, p2.REPEAT), M3.updatePaintBuffers()), C3 && (_2.activeTexture.set(p2.TEXTURE0), s4.imageAtlasTexture && s4.imageAtlasTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), M3.updatePaintBuffers()), c3 && !d2 && t2.terrain.setupElevationDraw(s4, k3), t2.uploadCommonUniforms(_2, k3, f3.toUnwrapped());
                const Z2 = (e2) => {
                  null != O2 && (O2.value = A2 * l2), k3.draw(t2, p2.TRIANGLES, n3, e2, v3, qi.disabled, q2, o2.id, m3.layoutVertexBuffer, m3.indexBuffer, m3.segments, o2.paint, t2.transform.zoom, M3, [m3.layoutVertexBuffer2, m3.patternVertexBuffer, m3.zOffsetVertexBuffer]), null != O2 && (O2.value = A2);
                };
                if (L2 && !c3) {
                  const e2 = t2.stencilModeForClipping(f3).ref;
                  0 === e2 && y2 && _2.clear({ stencil: 0 });
                  const i3 = { func: p2.EQUAL, mask: 255 };
                  q2.u_alpha_discard_threshold = 0.8, Z2(new ji(i3, e2, 255, p2.KEEP, p2.KEEP, p2.INVERT)), q2.u_alpha_discard_threshold = 0, Z2(new ji(i3, e2, 255, p2.KEEP, p2.KEEP, p2.KEEP));
                } else q2.u_alpha_discard_threshold = L2 && c3 && u6 ? 0.8 : 0, Z2(c3 ? a3 : t2.stencilModeForClipping(f3));
              }
            };
            let B3 = t2.depthModeForSublayer(0, Ni.ReadOnly);
            const k2 = new Ni(t2.depthOcclusion ? p2.GREATER : p2.LEQUAL, Ni.ReadOnly, t2.depthRangeFor3D);
            if (o2.hasNonElevatedBuckets) {
              const i3 = !y2 && t2.terrain;
              0 !== l2 && i3 ? e.w(`Occlusion opacity for layer ${o2.id} is supported on terrain only if the layer has line-z-offset enabled.`) : i3 ? e.w(`Cannot render non-elevated lines in immediate mode when terrain is enabled. Layer: ${o2.id}.`) : F2(s2, M2, B3, ji.disabled, false, true);
            }
            if (o2.hasElevatedBuckets) {
              "hd-road-markup" === c2 ? u5 || (B3 = k2, M2.push("ELEVATED_ROADS")) : (M2.push("ELEVATED"), B3 = k2, m2 && M2.push(g2 ? "CROSS_SLOPE_HORIZONTAL" : "CROSS_SLOPE_VERTICAL"), d2 && M2.push("ELEVATION_REFERENCE_SEA"));
              const e2 = L2 ? t2.stencilModeFor3D() : ji.disabled;
              t2.forceTerrainMode = true, F2(s2, M2, B3, e2, true, true), L2 && F2(s2, M2, B3, e2, true, false), t2.forceTerrainMode = false;
            }
            L2 && (t2.resetStencilClippingMasks(), y2 && _2.clear({ stencil: 0 })), 0 === l2 || t2.depthOcclusion || y2 || t2.layersWithOcclusionOpacity.push(t2.currentLayer);
          }, fill: function(t2, i2, o2, s2) {
            const r2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
            if (0 === n2.constantOr(1)) return;
            const a2 = o2.paint.get("fill-emissive-strength"), l2 = t2.colorModeForDrapableLayerRenderPass(a2), c2 = o2.paint.get("fill-pattern"), h2 = t2.opaquePassEnabledForLayer() && !c2.constantOr(1) && 1 === r2.constantOr(e.am.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
            let d2 = "none";
            "none" !== o2.layout.get("fill-elevation-reference") ? d2 = "road" : 0 !== o2.paint.get("fill-z-offset").constantOr(1) && (d2 = "offset");
            const u5 = !(!t2.terrain || !t2.terrain.enabled), _2 = { painter: t2, sourceCache: i2, layer: o2, coords: s2, colorMode: l2, elevationType: d2, terrainEnabled: u5, pass: h2 };
            if ("shadow" !== t2.renderPass) if ("offset" !== d2) {
              if (Vr(_2, false), "road" === d2) {
                const e2 = !u5 && "translucent" === t2.renderPass;
                e2 && jr(t2, i2, o2, s2, "geometry"), Vr(_2, true, ji.disabled), e2 && function(e3) {
                  const { painter: t3, sourceCache: i3, layer: o3, coords: s3, colorMode: r3 } = e3, n3 = t3.context.gl, a3 = e3.painter.shadowRenderer, l3 = !!a3 && a3.enabled, c3 = new Ni(t3.context.gl.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D);
                  let h3 = [0, 0, 0];
                  if (l3) {
                    const e4 = t3.style.directionalLight, i4 = t3.style.ambientLight;
                    e4 && i4 && (h3 = ao(t3.style, e4, i4));
                  }
                  for (const e4 of s3) {
                    const s4 = i3.getTile(e4), d3 = s4.getBucket(o3);
                    if (!d3) continue;
                    const u6 = d3.elevatedStructures;
                    if (!u6 || !u6.renderableSegments || 0 === u6.renderableSegments.segments[0].primitiveLength) continue;
                    t3.prepareDrawTile();
                    const _3 = d3.bufferData.programConfigurations.get(o3.id), p2 = t3.isTileAffectedByFog(e4), f2 = [];
                    l3 && f2.push("RENDER_SHADOWS", "DEPTH_TEXTURE", "NORMAL_OFFSET");
                    const m2 = t3.getOrCreateProgram("elevatedStructures", { config: _3, overrideFog: p2, defines: f2 }), g2 = t3.translatePosMatrix(e4.projMatrix, s4, o3.paint.get("fill-translate"), o3.paint.get("fill-translate-anchor"));
                    l3 && a3.setupShadows(s4.tileID.toUnwrapped(), m2, "vector-tile", s4.tileID.overscaledZ);
                    const v3 = rr(g2, h3);
                    t3.uploadCommonUniforms(t3.context, m2, e4.toUnwrapped()), m2.draw(t3, n3.TRIANGLES, c3, ji.disabled, r3, qi.backCCW, v3, o3.id, u6.vertexBuffer, u6.indexBuffer, u6.renderableSegments, o3.paint, t3.transform.zoom, _3, [u6.vertexBufferNormal]);
                  }
                }(_2);
              }
            } else Vr(_2, false, t2.stencilModeFor3D());
            else t2.shadowRenderer && "road" === d2 && !u5 && function(e2) {
              const { painter: t3, sourceCache: i3, layer: o3, coords: s3 } = e2, r3 = t3.context.gl, n3 = e2.painter.shadowRenderer;
              for (const e3 of s3) {
                const s4 = i3.getTile(e3), a3 = s4.getBucket(o3);
                if (!a3) continue;
                const l3 = a3.elevatedStructures;
                if (!l3) continue;
                if (!l3.shadowCasterSegments || 0 === l3.shadowCasterSegments.segments[0].primitiveLength) continue;
                t3.prepareDrawTile();
                const c3 = a3.bufferData.programConfigurations.get(o3.id), h3 = t3.isTileAffectedByFog(e3), d3 = t3.getOrCreateProgram("elevatedStructuresDepth", { config: c3, overrideFog: h3 }), u6 = n3.calculateShadowPassMatrixFromTile(s4.tileID.toUnwrapped());
                t3.uploadCommonUniforms(t3.context, d3, e3.toUnwrapped());
                const _3 = { u_matrix: u6, u_depth_bias: 1e-3 };
                d3.draw(t3, r3.TRIANGLES, n3.getShadowPassDepthMode(), ji.disabled, n3.getShadowPassColorMode(), qi.disabled, _3, o3.id, l3.vertexBuffer, l3.indexBuffer, l3.shadowCasterSegments, o3.paint, t3.transform.zoom, c3);
              }
            }(_2);
          }, "fill-extrusion": function(t2, i2, o2, s2) {
            const r2 = o2.paint.get("fill-extrusion-opacity"), n2 = t2.context, a2 = n2.gl, l2 = t2.terrain, c2 = l2 && l2.renderingToTexture;
            if (0 === r2) return;
            const h2 = t2.conflationActive && t2.style.isLayerClipped(o2, i2.getSource()), d2 = t2.style.order.indexOf(o2.fqid);
            if (h2 && function(e2, t3, i3, o3, s3) {
              for (const r3 of o3) {
                const o4 = t3.getTile(r3).getBucket(i3);
                o4 && (o4.updateReplacement(r3, e2.replacementSource, s3), o4.uploadCentroid(e2.context));
              }
            }(t2, i2, o2, s2, d2), l2 || h2) for (const e2 of s2) {
              const s3 = i2.getTile(e2).getBucket(o2);
              s3 && Zr(t2.context, i2, e2, s3, o2, l2, h2);
            }
            if ("shadow" === t2.renderPass && t2.shadowRenderer) {
              const n3 = t2.shadowRenderer;
              if (l2 && r2 < 0.65 && o2._transitionablePaint._values["fill-extrusion-opacity"].value.expression instanceof e.ab) return;
              const a3 = n3.getShadowPassDepthMode(), c3 = n3.getShadowPassColorMode();
              Gr(t2, i2, o2, s2, a3, ji.disabled, c3, h2);
            } else if ("translucent" === t2.renderPass) {
              const d3 = !o2.paint.get("fill-extrusion-pattern").constantOr(1), u5 = o2.paint.get("fill-extrusion-color").constantOr(e.am.white);
              if (!c2 && 0 !== u5.a) {
                const e2 = new Ni(t2.context.gl.LEQUAL, Ni.ReadWrite, t2.depthRangeFor3D);
                1 === r2 && d3 ? Gr(t2, i2, o2, s2, e2, ji.disabled, ki.unblended, h2) : (Gr(t2, i2, o2, s2, e2, ji.disabled, ki.disabled, h2), Gr(t2, i2, o2, s2, e2, t2.stencilModeFor3D(), t2.colorModeForRenderPass(), h2), t2.resetStencilClippingMasks());
              }
              if (t2.style.enable3dLights() && d3 && (!l2 && "globe" !== t2.transform.projection.name || c2)) {
                const r3 = o2.paint.get("fill-extrusion-opacity"), d4 = o2.paint.get("fill-extrusion-ambient-occlusion-intensity"), u6 = o2.paint.get("fill-extrusion-ambient-occlusion-ground-radius"), _2 = o2.paint.get("fill-extrusion-flood-light-intensity"), p2 = "none" === o2.paint.get("fill-extrusion-flood-light-color-use-theme").constantOr("default"), f2 = o2.paint.get("fill-extrusion-flood-light-color").toRenderColor(p2 ? null : o2.lut).toArray01().slice(0, 3), m2 = d4 > 0 && u6 > 0, g2 = _2 > 0, v3 = (e2, t3, i3) => (1 - i3) * e2 + i3 * t3, y2 = (n3) => {
                  const l3 = t2.depthModeForSublayer(1, Ni.ReadOnly, a2.LEQUAL, true), c3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), p3 = v3(0.1, 3, c3), m3 = t2._showOverdrawInspector;
                  if (!m3) {
                    const c4 = new ji({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), m4 = new ki([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.am.transparent, [false, false, false, true], a2.MIN);
                    qr(t2, i2, o2, s2, l3, c4, m4, qi.disabled, n3, "sdf", r3, d4, u6, _2, f2, p3, h2, false);
                  }
                  {
                    const c4 = m3 ? ji.disabled : new ji({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), g3 = m3 ? t2.colorModeForRenderPass() : new ki([a2.ONE_MINUS_DST_ALPHA, a2.DST_ALPHA, a2.ONE, a2.ONE], e.am.transparent, [true, true, true, true]);
                    qr(t2, i2, o2, s2, l3, c4, g3, qi.disabled, n3, "color", r3, d4, u6, _2, f2, p3, h2, false);
                  }
                };
                if (c2) {
                  const c3 = (n3, l3, c4) => {
                    const p3 = t2.depthModeForSublayer(1, Ni.ReadOnly, a2.LEQUAL, false), m3 = o2.paint.get(n3 ? "fill-extrusion-ambient-occlusion-ground-attenuation" : "fill-extrusion-flood-light-ground-attenuation"), g3 = v3(0.1, 3, m3);
                    {
                      const c5 = new ki([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.am.transparent, [false, false, false, true]);
                      qr(t2, i2, o2, s2, p3, ji.disabled, c5, qi.disabled, n3, "clear", r3, d4, u6, _2, f2, g3, h2, l3);
                    }
                    {
                      const c5 = new ji({ func: a2.ALWAYS, mask: 255 }, 255, 255, a2.KEEP, a2.KEEP, a2.REPLACE), m4 = new ki([a2.ONE, a2.ONE, a2.ONE, a2.ONE], e.am.transparent, [false, false, false, true], a2.MIN);
                      qr(t2, i2, o2, s2, p3, c5, m4, qi.disabled, n3, "sdf", r3, d4, u6, _2, f2, g3, h2, l3);
                    }
                    {
                      const c5 = n3 ? a2.ZERO : a2.ONE_MINUS_DST_ALPHA, m4 = new ji({ func: a2.EQUAL, mask: 255 }, 255, 255, a2.KEEP, a2.DECR, a2.DECR), v4 = new ki([c5, a2.DST_ALPHA, a2.ONE_MINUS_DST_ALPHA, a2.ZERO], e.am.transparent, [true, true, true, true]);
                      qr(t2, i2, o2, s2, p3, m4, v4, qi.disabled, n3, "color", r3, d4, u6, _2, f2, g3, h2, l3);
                    }
                    {
                      const m4 = new ki([a2.ONE, a2.ONE, a2.ONE, n3 ? a2.ZERO : a2.ONE], e.am.transparent, [false, false, false, true], n3 ? a2.FUNC_ADD : a2.MAX);
                      qr(t2, i2, o2, s2, p3, ji.disabled, m4, qi.disabled, n3, "clear", r3, d4, u6, _2, f2, g3, h2, l3, c4);
                    }
                  };
                  if (m2 || g2) {
                    let i3;
                    if (t2.prepareDrawTile(), l2) {
                      const t3 = l2.drapeBufferSize[0], o3 = l2.drapeBufferSize[1];
                      i3 = l2.framebufferCopyTexture, i3 && (!i3 || i3.size[0] === t3 && i3.size[1] === o3) || (i3 && i3.destroy(), i3 = l2.framebufferCopyTexture = new e.T(n2, new e.r({ width: t3, height: o3 }), a2.RGBA8)), i3.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), a2.copyTexSubImage2D(a2.TEXTURE_2D, 0, 0, 0, 0, 0, t3, o3);
                    }
                    m2 && c3(true, false, i3), g2 && c3(false, true, i3);
                  }
                } else m2 && y2(true), g2 && y2(false), (m2 || g2) && t2.resetStencilClippingMasks();
              }
            }
          }, hillshade: function(e2, t2, i2, o2) {
            if ("offscreen" !== e2.renderPass && "translucent" !== e2.renderPass) return;
            if (e2.style.disableElevatedTerrain) return;
            const s2 = e2.context, r2 = e2.terrain && e2.terrain.renderingToTexture, [n2, a2] = "translucent" !== e2.renderPass || r2 ? [{}, o2] : e2.stencilConfigForOverlap(o2);
            for (const o3 of a2) {
              const s3 = t2.getTile(o3);
              if (s3.needsHillshadePrepare && "offscreen" === e2.renderPass) $o(e2, s3, i2);
              else if ("translucent" === e2.renderPass) {
                const t3 = e2.depthModeForSublayer(0, Ni.ReadOnly), a3 = i2.paint.get("hillshade-emissive-strength"), l2 = e2.colorModeForDrapableLayerRenderPass(a3), c2 = r2 && e2.terrain ? e2.terrain.stencilModeForRTTOverlap(o3) : n2[o3.overscaledZ];
                Ho(e2, o3, s3, i2, t3, c2, l2);
              }
            }
            s2.viewport.set([0, 0, e2.width, e2.height]), e2.resetStencilClippingMasks();
          }, raster: function(t2, i2, o2, s2, r2, n2) {
            if ("translucent" !== t2.renderPass) return;
            if (0 === o2.paint.get("raster-opacity")) return;
            const a2 = "globe" === t2.transform.projection.name, l2 = 0 !== o2.paint.get("raster-elevation"), c2 = l2 && a2;
            if (t2.renderElevatedRasterBackface && !c2) return;
            const h2 = t2.context, d2 = h2.gl, u5 = i2.getSource(), _2 = function(t3, i3, o3, s3) {
              const r3 = i3.paint.get("raster-color"), n3 = "raster-array" === t3.type, a3 = [], l3 = i3.paint.get("raster-resampling"), c3 = i3.paint.get("raster-color-mix");
              let h3 = i3.paint.get("raster-color-range");
              const d3 = [c3[0], c3[1], c3[2], 0], u6 = c3[3];
              let _3 = "nearest" === l3 ? s3.NEAREST : s3.LINEAR;
              if (n3 && (a3.push("RASTER_ARRAY"), r3 || a3.push("RASTER_COLOR"), "linear" === l3 && a3.push("RASTER_ARRAY_LINEAR"), _3 = s3.NEAREST, !h3 && t3.rasterLayers)) {
                const e2 = t3.rasterLayers.find(({ id: e3 }) => e3 === i3.sourceLayer);
                e2 && e2.fields && e2.fields.range && (h3 = e2.fields.range);
              }
              if (h3 = h3 || [0, 1], r3) {
                a3.push("RASTER_COLOR"), o3.activeTexture.set(s3.TEXTURE2), i3.updateColorRamp(h3);
                let t4 = i3.colorRampTexture;
                t4 || (t4 = i3.colorRampTexture = new e.T(o3, i3.colorRamp, s3.RGBA8)), t4.bind(s3.LINEAR, s3.CLAMP_TO_EDGE);
              }
              return { mix: d3, range: h3, offset: u6, defines: a3, resampling: _3 };
            }(u5, o2, h2, d2);
            if (u5 instanceof e.aP && !s2.length && !a2) return;
            const p2 = o2.paint.get("raster-emissive-strength"), f2 = t2.colorModeForDrapableLayerRenderPass(p2), m2 = t2.terrain && t2.terrain.renderingToTexture, g2 = !t2.options.moving, v3 = "nearest" === o2.paint.get("raster-resampling") ? d2.NEAREST : d2.LINEAR;
            if (u5 instanceof e.aP && !s2.length && (u5.onNorthPole || u5.onSouthPole)) {
              const e2 = l2 ? t2.stencilModeFor3D() : ji.disabled;
              return void Kr(!!u5.onNorthPole, null, t2, i2, o2, p2, _2, qi.disabled, e2);
            }
            if (!s2.length) return;
            const [y2, x2] = u5 instanceof e.aP || m2 ? [{}, s2] : t2.stencilConfigForOverlap(s2), b2 = x2[x2.length - 1].overscaledZ;
            c2 && _2.defines.push("PROJECTION_GLOBE_VIEW"), l2 && _2.defines.push("RENDER_CUTOFF");
            const w2 = (s3, r3, x3) => {
              for (const w3 of s3) {
                const s4 = w3.toUnwrapped(), T2 = i2.getTile(w3);
                if (m2 && (!T2 || !T2.hasData())) continue;
                h2.activeTexture.set(d2.TEXTURE0);
                const E2 = Qr(T2, u5, o2, _2);
                if (!E2 || !E2.texture) continue;
                const { texture: S2, mix: I2, offset: C3, tileSize: R2, buffer: D3 } = E2;
                let A2, L2;
                m2 ? (A2 = Ni.disabled, L2 = w3.projMatrix) : l2 ? (A2 = new Ni(d2.LEQUAL, Ni.ReadWrite, t2.depthRangeFor3D), L2 = a2 ? Float32Array.from(t2.transform.expandedFarZProjMatrix) : t2.transform.calculateProjMatrix(s4, g2)) : (A2 = t2.depthModeForSublayer(w3.overscaledZ - b2, 1 === o2.paint.get("raster-opacity") ? Ni.ReadWrite : Ni.ReadOnly, d2.LESS), L2 = t2.transform.calculateProjMatrix(s4, g2));
                const P2 = t2.terrain && m2 ? t2.terrain.stencilModeForRTTOverlap(w3) : y2[w3.overscaledZ], z2 = n2 ? 0 : o2.paint.get("raster-fade-duration");
                T2.registerFadeDuration(z2);
                const M2 = i2.findLoadedParent(w3, 0), O2 = Us(T2, M2, i2, t2.transform, z2);
                let F2, B3;
                t2.terrain && t2.terrain.prepareDrawTile(), h2.activeTexture.set(d2.TEXTURE0), S2.bind(v3, d2.CLAMP_TO_EDGE), h2.activeTexture.set(d2.TEXTURE1), M2 ? (M2.texture && M2.texture.bind(v3, d2.CLAMP_TO_EDGE), F2 = Math.pow(2, M2.tileID.overscaledZ - T2.tileID.overscaledZ), B3 = [T2.tileID.canonical.x * F2 % 1, T2.tileID.canonical.y * F2 % 1]) : S2.bind(v3, d2.CLAMP_TO_EDGE), "useMipmap" in S2 && h2.extTextureFilterAnisotropic && t2.transform.pitch > 20 && d2.texParameterf(d2.TEXTURE_2D, h2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, h2.extTextureFilterAnisotropicMax);
                const k2 = t2.transform;
                let N2;
                const U2 = l2 ? Jr(k2) : [0, 0, 0, 0];
                let j2, V2, G2, q2, Z2, H2 = 0;
                if (c2 && u5 instanceof e.aP && u5.coordinates.length > 3) j2 = Float32Array.from(e.bh(e.dr(new e.cp(0, 0, 0)))), V2 = Float32Array.from(k2.globeMatrix), G2 = Float32Array.from(e.dm(k2)), q2 = [e.ay(k2.center.lng), e.aH(k2.center.lat)], N2 = u5.elevatedGlobePerspectiveTransform, Z2 = u5.elevatedGlobeGridMatrix || new Float32Array(9);
                else if (c2) {
                  const t3 = e.dn(w3.canonical);
                  H2 = e.dp(t3.getCenter().lat), j2 = Float32Array.from(e.bh(e.dr(w3.canonical))), V2 = Float32Array.from(k2.globeMatrix), G2 = Float32Array.from(e.dm(k2)), q2 = [e.ay(k2.center.lng), e.aH(k2.center.lat)], N2 = [0, 0], Z2 = Float32Array.from(e.dq(w3.canonical, t3, H2, k2.worldSize / k2._pixelsPerMercatorPixel));
                } else N2 = u5 instanceof e.aP ? u5.perspectiveTransform : [0, 0], j2 = new Float32Array(16), V2 = new Float32Array(9), G2 = new Float32Array(16), q2 = [0, 0], Z2 = new Float32Array(9);
                const W2 = _r(L2, j2, V2, G2, Z2, B3 || [0, 0], e.ah(t2.transform.zoom), q2, U2, F2 || 1, O2, o2, N2, l2 ? o2.paint.get("raster-elevation") : 0, 2, I2, C3, _2.range, R2, D3, p2), $2 = t2.isTileAffectedByFog(w3), X2 = t2.getOrCreateProgram("raster", { defines: _2.defines, overrideFog: $2 });
                if (t2.uploadCommonUniforms(h2, X2, s4), u5 instanceof e.aP) {
                  const i3 = u5.elevatedGlobeVertexBuffer, s5 = u5.elevatedGlobeIndexBuffer;
                  if (m2 || !a2) u5.boundsBuffer && u5.boundsSegments && X2.draw(t2, d2.TRIANGLES, A2, ji.disabled, f2, qi.disabled, W2, o2.id, u5.boundsBuffer, t2.quadTriangleIndexBuffer, u5.boundsSegments);
                  else if (i3 && s5) {
                    const n3 = k2.zoom <= e.cL ? u5.elevatedGlobeSegments : u5.getSegmentsForLongitude(k2.center.lng);
                    n3 && X2.draw(t2, d2.TRIANGLES, A2, ji.disabled, f2, r3, W2, o2.id, i3, s5, n3);
                  }
                } else if (c2) {
                  A2 = new Ni(d2.LEQUAL, Ni.ReadOnly, t2.depthRangeFor3D);
                  const e2 = t2.globeSharedBuffers;
                  if (e2) {
                    const [i3, s5, n3] = e2.getGridBuffers(H2, false);
                    X2.draw(t2, d2.TRIANGLES, A2, x3 || P2, t2.colorModeForRenderPass(), r3, W2, o2.id, i3, s5, n3);
                  }
                } else {
                  const { tileBoundsBuffer: e2, tileBoundsIndexBuffer: i3, tileBoundsSegments: s5 } = t2.getTileBoundsBuffers(T2);
                  X2.draw(t2, d2.TRIANGLES, A2, P2, f2, qi.disabled, W2, o2.id, e2, i3, s5);
                }
              }
              if (!(u5 instanceof e.aP) && c2) for (const e2 of s3) {
                const s4 = e2.canonical.y === (1 << e2.canonical.z) - 1;
                0 === e2.canonical.y && Kr(true, e2, t2, i2, o2, p2, _2, r3, x3 || ji.disabled), s4 && Kr(false, e2, t2, i2, o2, p2, _2, r3 === qi.frontCW ? qi.backCW : qi.frontCW, x3 || ji.disabled);
              }
            };
            c2 ? w2(x2, t2.renderElevatedRasterBackface ? qi.backCW : qi.frontCW, t2.stencilModeFor3D()) : w2(x2, qi.disabled, void 0), t2.resetStencilClippingMasks();
          }, "raster-particle": function(t2, i2, o2, s2, r2, n2) {
            "offscreen" === t2.renderPass && function(t3, i3, o3, s3) {
              if (!s3.length) return;
              const r3 = t3.context, n3 = r3.gl, a2 = i3.getSource();
              if (!(a2 instanceof st)) return;
              const l2 = Math.ceil(Math.sqrt(o3.paint.get("raster-particle-count")));
              let c2 = o3.particlePositionRGBAImage;
              if (!c2 || c2.width !== l2) {
                const t4 = function(e2) {
                  const t5 = e2 * e2, i4 = new Uint8Array(4 * t5), o4 = function(e3) {
                    return e3 |= 0, e3 = Math.imul(2747636419 ^ e3, 2654435769), e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769), ((e3 = Math.imul(e3 ^ e3 >>> 16, 2654435769)) >>> 0) / 4294967296;
                  }, s4 = 1 / 1.1;
                  for (let e3 = 0; e3 < t5; e3++) {
                    const t6 = s4 * (o4(2 * e3 + 0) + fr), r4 = s4 * (o4(2 * e3 + 1) + fr), n4 = 255 * t6 % 1, a3 = 255 * r4 % 1, l3 = n4, c3 = r4 - a3 / 255, h3 = a3;
                    i4[4 * e3 + 0] = 255 * (t6 - n4 / 255), i4[4 * e3 + 1] = 255 * l3, i4[4 * e3 + 2] = 255 * c3, i4[4 * e3 + 3] = 255 * h3;
                  }
                  return i4;
                }(l2);
                c2 = o3.particlePositionRGBAImage = new e.r({ width: l2, height: l2 }, t4);
              }
              let h2 = o3.particleFramebuffer;
              h2 ? h2.width !== l2 && (h2.destroy(), h2 = o3.particleFramebuffer = r3.createFramebuffer(l2, l2, true, null)) : h2 = o3.particleFramebuffer = r3.createFramebuffer(l2, l2, true, null);
              const d2 = [];
              for (const e2 of s3) {
                const t4 = i3.getTile(e2);
                if (!(t4 instanceof Tt)) continue;
                const s4 = on(t4, a2, o3);
                if (!s4) continue;
                const n4 = [t4.tileSize, t4.tileSize];
                let h3 = o3.tileFramebuffer;
                h3 || (h3 = o3.tileFramebuffer = r3.createFramebuffer(n4[0], n4[1], true, null));
                let u6 = t4.rasterParticleState;
                u6 || (u6 = t4.rasterParticleState = new tn(r3, e2, n4, c2));
                const _3 = u6.update(o3.lastInvalidatedAt);
                u6.particleTextureDimension !== l2 && u6.updateParticleTexture(e2, c2);
                const p2 = u6.targetColorTexture;
                u6.targetColorTexture = u6.backgroundColorTexture, u6.backgroundColorTexture = p2;
                const f2 = u6.particleTexture0;
                u6.particleTexture0 = u6.particleTexture1, u6.particleTexture1 = f2, d2.push([e2, s4, u6, _3]);
              }
              if (0 === d2.length) return;
              const u5 = e.q.now(), _2 = o3.previousDrawTimestamp ? 1e-3 * (u5 - o3.previousDrawTimestamp) : 0.0167;
              if (o3.previousDrawTimestamp = u5, o3.hasColorMap()) {
                r3.activeTexture.set(n3.TEXTURE0 + 2);
                let t4 = o3.colorRampTexture;
                t4 || (t4 = o3.colorRampTexture = new e.T(r3, o3.colorRamp, n3.RGBA8)), t4.bind(n3.LINEAR, n3.CLAMP_TO_EDGE);
              }
              r3.bindFramebuffer.set(o3.tileFramebuffer.framebuffer), function(t4, i4, o4) {
                const s4 = t4.context, r4 = s4.gl, n4 = i4.tileFramebuffer;
                s4.activeTexture.set(r4.TEXTURE0);
                const a3 = { u_texture: 0, u_opacity: 1.05 * (c3 = i4.paint.get("raster-particle-fade-opacity-factor")) / (c3 + 0.05) }, l3 = t4.getOrCreateProgram("rasterParticleTexture", { defines: [], overrideFog: false });
                var c3;
                for (const c4 of o4) {
                  const [, , o5, h3] = c4;
                  n4.colorAttachment.set(o5.targetColorTexture.texture), s4.viewport.set([0, 0, n4.width, n4.height]), s4.clear({ color: e.am.transparent }), h3 && (o5.backgroundColorTexture.bind(r4.NEAREST, r4.CLAMP_TO_EDGE), l3.draw(t4, r4.TRIANGLES, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, a3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments));
                }
              }(t3, o3, d2), function(t4, i4, o4, s4) {
                const r4 = t4.context, n4 = r4.gl, a3 = o4.tileFramebuffer, l3 = "globe" === t4.transform.projection.name, c3 = o4.paint.get("raster-particle-max-speed");
                for (const h3 of s4) {
                  const [s5, d3, u6] = h3;
                  r4.activeTexture.set(n4.TEXTURE0 + 0), d3.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), a3.colorAttachment.set(u6.targetColorTexture.texture);
                  const _3 = t4.getOrCreateProgram("rasterParticleDraw", { defines: d3.defines, overrideFog: false });
                  r4.activeTexture.set(n4.TEXTURE0 + 1);
                  const p2 = d3.scalarData ? [] : [0, 1, 2, 3].map((t5) => e.dU[t5](s5));
                  p2.push(s5);
                  const f2 = s5.canonical.x, m2 = s5.canonical.y;
                  for (const e2 of p2) {
                    const r5 = i4.getTile(l3 ? e2.wrapped() : e2);
                    if (!r5) continue;
                    const a4 = r5.rasterParticleState;
                    if (!a4) continue;
                    const h4 = e2.canonical.x + (1 << e2.canonical.z) * (e2.wrap - s5.wrap), u7 = e2.canonical.y;
                    a4.particleTexture0.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
                    const p3 = gr(1, a4.particleTexture0.size[0], [h4 - f2, u7 - m2], 0, d3.texture.size, 2, c3, d3.textureOffset, d3.scale, d3.offset);
                    _3.draw(t4, n4.POINTS, Ni.disabled, ji.disabled, ki.alphaBlended, qi.disabled, p3, o4.id, a4.particleIndexBuffer, void 0, a4.particleSegment);
                  }
                }
              }(t3, i3, o3, d2), r3.bindFramebuffer.set(o3.particleFramebuffer.framebuffer), function(t4, i4, o4, s4) {
                const r4 = t4.context, n4 = r4.gl, a3 = i4.paint.get("raster-particle-max-speed"), l3 = s4 * i4.paint.get("raster-particle-speed-factor") * 0.15, c3 = function(e2) {
                  return Math.pow(e2, 6);
                }(0.01 + 1 * i4.paint.get("raster-particle-reset-rate-factor")), h3 = i4.particleFramebuffer;
                r4.viewport.set([0, 0, h3.width, h3.height]);
                for (const s5 of o4) {
                  const [, o5, d3] = s5;
                  r4.activeTexture.set(n4.TEXTURE0 + 0), o5.texture.bind(n4.LINEAR, n4.CLAMP_TO_EDGE), r4.activeTexture.set(n4.TEXTURE0 + 1);
                  const u6 = d3.particleTexture0;
                  u6.bind(n4.NEAREST, n4.CLAMP_TO_EDGE);
                  const _3 = vr(1, u6.size[0], 0, o5.texture.size, a3, l3, c3, o5.textureOffset, o5.scale, o5.offset);
                  h3.colorAttachment.set(d3.particleTexture1.texture), r4.clear({ color: e.am.transparent }), t4.getOrCreateProgram("rasterParticleUpdate", { defines: o5.defines }).draw(t4, n4.TRIANGLES, Ni.disabled, ji.disabled, ki.unblended, qi.disabled, _3, i4.id, t4.viewportBuffer, t4.quadTriangleIndexBuffer, t4.viewportSegments);
                }
              }(t3, o3, d2, _2);
            }(t2, i2, o2, s2), "translucent" === t2.renderPass && (function(t3, i3, o3, s3, r3) {
              const n3 = t3.context, a2 = n3.gl, l2 = i3.getSource().tileSize, c2 = 5 * (1 - e.af(e.cx, e.cx + 1, t3.transform.zoom)) * l2 + o3.paint.get("raster-particle-elevation"), h2 = !t3.options.moving, d2 = "globe" === t3.transform.projection.name;
              if (!s3.length) return;
              const [u5, _2] = t3.stencilConfigForOverlap(s3), p2 = [];
              d2 && p2.push("PROJECTION_GLOBE_VIEW");
              const f2 = t3.stencilModeFor3D();
              for (const s4 of _2) {
                const r4 = s4.toUnwrapped(), l3 = i3.getTile(s4);
                if (!l3.rasterParticleState) continue;
                const _3 = l3.rasterParticleState, m2 = 100;
                l3.registerFadeDuration(m2);
                const g2 = i3.findLoadedParent(s4, 0), v3 = Us(l3, g2, i3, t3.transform, m2);
                let y2, x2;
                t3.terrain && t3.terrain.prepareDrawTile(), n3.activeTexture.set(a2.TEXTURE0), _3.targetColorTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), n3.activeTexture.set(a2.TEXTURE1), g2 && g2.rasterParticleState ? (g2.rasterParticleState.targetColorTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), y2 = Math.pow(2, g2.tileID.overscaledZ - l3.tileID.overscaledZ), x2 = [l3.tileID.canonical.x * y2 % 1, l3.tileID.canonical.y * y2 % 1]) : _3.targetColorTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE);
                const b2 = d2 ? Float32Array.from(t3.transform.expandedFarZProjMatrix) : t3.transform.calculateProjMatrix(r4, h2), w2 = t3.transform, T2 = sn(w2), E2 = e.dn(s4.canonical), S2 = e.dp(E2.getCenter().lat);
                let I2, C3, R2, D3, A2;
                d2 ? (I2 = Float32Array.from(e.bh(e.dr(s4.canonical))), C3 = Float32Array.from(w2.globeMatrix), R2 = Float32Array.from(e.dm(w2)), D3 = [e.ay(w2.center.lng), e.aH(w2.center.lat)], A2 = Float32Array.from(e.dq(s4.canonical, E2, S2, w2.worldSize / w2._pixelsPerMercatorPixel))) : (I2 = new Float32Array(16), C3 = new Float32Array(9), R2 = new Float32Array(16), D3 = [0, 0], A2 = new Float32Array(9));
                const L2 = mr(b2, I2, C3, R2, A2, x2 || [0, 0], e.ah(t3.transform.zoom), D3, T2, y2 || 1, v3, c2), P2 = t3.isTileAffectedByFog(s4), z2 = t3.getOrCreateProgram("rasterParticle", { defines: p2, overrideFog: P2 });
                if (t3.uploadCommonUniforms(n3, z2, r4), d2) {
                  const e2 = new Ni(a2.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D), i4 = 0, s5 = t3.globeSharedBuffers;
                  if (s5) {
                    const [r5, n4, l4] = s5.getGridBuffers(S2, 0 !== i4);
                    z2.draw(t3, a2.TRIANGLES, e2, f2, ki.alphaBlended, t3.renderElevatedRasterBackface ? qi.frontCCW : qi.backCCW, L2, o3.id, r5, n4, l4);
                  }
                } else {
                  const e2 = t3.depthModeForSublayer(0, Ni.ReadOnly), i4 = u5[s4.overscaledZ], { tileBoundsBuffer: r5, tileBoundsIndexBuffer: n4, tileBoundsSegments: c3 } = t3.getTileBoundsBuffers(l3);
                  z2.draw(t3, a2.TRIANGLES, e2, i4, ki.alphaBlended, qi.disabled, L2, o3.id, r5, n4, c3);
                }
              }
              t3.resetStencilClippingMasks();
            }(t2, i2, o2, s2), t2.style.map.triggerRepaint());
          }, background: function(t2, i2, o2, s2) {
            const r2 = o2.paint.get("background-color"), n2 = "none" === o2.paint.get("background-color-use-theme").constantOr("default"), a2 = o2.paint.get("background-opacity"), l2 = o2.paint.get("background-emissive-strength"), c2 = "viewport" === o2.paint.get("background-pitch-alignment");
            if (0 === a2) return;
            const h2 = t2.context, d2 = h2.gl, u5 = t2.transform, _2 = u5.tileSize, p2 = o2.paint.get("background-pattern");
            let f2;
            if (void 0 !== p2) {
              if (null === p2) return;
              if (f2 = t2.imageManager.getPattern(e.I.from(p2.toString()), o2.scope, t2.style.getLut(o2.scope)), !f2) return;
            }
            const m2 = !p2 && 1 === r2.a && 1 === a2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
            if (t2.renderPass !== m2) return;
            const g2 = ji.disabled, v3 = t2.depthModeForSublayer(0, "opaque" === m2 ? Ni.ReadWrite : Ni.ReadOnly), y2 = t2.colorModeForDrapableLayerRenderPass(l2), x2 = p2 ? "backgroundPattern" : "background";
            let b2, w2 = s2;
            if (w2 || (b2 = t2.getBackgroundTiles(), w2 = Object.values(b2).map((e2) => e2.tileID)), p2 && (h2.activeTexture.set(d2.TEXTURE0), t2.imageManager.bind(t2.context, o2.scope)), c2) {
              const i3 = t2.getOrCreateProgram(x2, { overrideFog: false, overrideRtt: true }), s3 = new Float32Array(e.bx([])), h3 = new e.aM(0, 0, 0, 0, 0), u6 = p2 ? wr(s3, l2, a2, t2, 0, o2.scope, f2, c2, { tileID: h3, tileSize: _2 }) : br(s3, l2, a2, r2.toRenderColor(n2 ? null : o2.lut));
              i3.draw(t2, d2.TRIANGLES, v3, g2, y2, qi.disabled, u6, o2.id, t2.viewportBuffer, t2.quadTriangleIndexBuffer, t2.viewportSegments);
            } else for (const e2 of w2) {
              const m3 = t2.isTileAffectedByFog(e2), w3 = t2.getOrCreateProgram(x2, { overrideFog: m3 }), T2 = e2.toUnwrapped(), E2 = s2 ? e2.projMatrix : t2.transform.calculateProjMatrix(T2);
              t2.prepareDrawTile();
              const S2 = i2 ? i2.getTile(e2) : b2 ? b2[e2.key] : new wt(e2, _2, u5.zoom, t2), I2 = p2 ? wr(E2, l2, a2, t2, 0, o2.scope, f2, c2, { tileID: e2, tileSize: _2 }) : br(E2, l2, a2, r2.toRenderColor(n2 ? null : o2.lut));
              t2.uploadCommonUniforms(h2, w3, T2);
              const { tileBoundsBuffer: C3, tileBoundsIndexBuffer: R2, tileBoundsSegments: D3 } = t2.getTileBoundsBuffers(S2);
              w3.draw(t2, d2.TRIANGLES, v3, g2, y2, qi.disabled, I2, o2.id, C3, R2, D3);
            }
          }, sky: function(t2, i2, o2) {
            const s2 = t2._atmosphere ? e.ah(t2.transform.zoom) : 1, r2 = o2.paint.get("sky-opacity") * s2;
            if (0 === r2) return;
            const n2 = t2.context, a2 = o2.paint.get("sky-type"), l2 = new Ni(n2.gl.LEQUAL, Ni.ReadOnly, [0, 1]), c2 = t2.frameCounter / 1e3 % 1;
            "atmosphere" === a2 ? "offscreen" === t2.renderPass ? o2.needsSkyboxCapture(t2) && (function(t3, i3, o3, s3) {
              const r3 = t3.context, n3 = r3.gl;
              let a3 = i3.skyboxFbo;
              if (!a3) {
                a3 = i3.skyboxFbo = r3.createFramebuffer(32, 32, true, null), i3.skyboxGeometry = new gn(r3), i3.skyboxTexture = r3.gl.createTexture(), n3.bindTexture(n3.TEXTURE_CUBE_MAP, i3.skyboxTexture), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_S, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_WRAP_T, n3.CLAMP_TO_EDGE), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MIN_FILTER, n3.LINEAR), n3.texParameteri(n3.TEXTURE_CUBE_MAP, n3.TEXTURE_MAG_FILTER, n3.LINEAR);
                for (let e2 = 0; e2 < 6; ++e2) n3.texImage2D(n3.TEXTURE_CUBE_MAP_POSITIVE_X + e2, 0, n3.RGBA, 32, 32, 0, n3.RGBA, n3.UNSIGNED_BYTE, null);
              }
              r3.bindFramebuffer.set(a3.framebuffer), r3.viewport.set([0, 0, 32, 32]);
              const l3 = i3.getCenter(t3, true), c3 = t3.getOrCreateProgram("skyboxCapture"), h2 = new Float64Array(16);
              e.bx(h2), e.e3(h2, h2, 0.5 * -Math.PI), vn(t3, i3, c3, h2, l3, 0), e.bx(h2), e.e3(h2, h2, 0.5 * Math.PI), vn(t3, i3, c3, h2, l3, 1), e.bx(h2), e.cG(h2, h2, 0.5 * -Math.PI), vn(t3, i3, c3, h2, l3, 2), e.bx(h2), e.cG(h2, h2, 0.5 * Math.PI), vn(t3, i3, c3, h2, l3, 3), e.bx(h2), vn(t3, i3, c3, h2, l3, 4), e.bx(h2), e.e3(h2, h2, Math.PI), vn(t3, i3, c3, h2, l3, 5), r3.viewport.set([0, 0, t3.width, t3.height]);
            }(t2, o2), o2.markSkyboxValid(t2)) : "sky" === t2.renderPass && function(e2, t3, i3, o3, s3) {
              const r3 = e2.context, n3 = r3.gl, a3 = e2.transform, l3 = e2.getOrCreateProgram("skybox");
              r3.activeTexture.set(n3.TEXTURE0), n3.bindTexture(n3.TEXTURE_CUBE_MAP, t3.skyboxTexture);
              const c3 = /* @__PURE__ */ ((e3, t4, i4, o4, s4) => ({ u_matrix: e3, u_sun_direction: t4, u_cubemap: 0, u_opacity: o4, u_temporal_offset: s4 }))(a3.skyboxMatrix, t3.getCenter(e2, false), 0, o3, s3);
              e2.uploadCommonUniforms(r3, l3), l3.draw(e2, n3.TRIANGLES, i3, ji.disabled, e2.colorModeForRenderPass(), qi.backCW, c3, "skybox", t3.skyboxGeometry.vertexBuffer, t3.skyboxGeometry.indexBuffer, t3.skyboxGeometry.segment);
            }(t2, o2, l2, r2, c2) : "gradient" === a2 && "sky" === t2.renderPass && function(t3, i3, o3, s3, r3) {
              const n3 = t3.context, a3 = n3.gl, l3 = t3.transform, c3 = t3.getOrCreateProgram("skyboxGradient");
              i3.skyboxGeometry || (i3.skyboxGeometry = new gn(n3)), n3.activeTexture.set(a3.TEXTURE0);
              let h2 = i3.colorRampTexture;
              h2 || (h2 = i3.colorRampTexture = new e.T(n3, i3.colorRamp, a3.RGBA8)), h2.bind(a3.LINEAR, a3.CLAMP_TO_EDGE);
              const d2 = ((t4, i4, o4, s4, r4) => ({ u_matrix: t4, u_color_ramp: 0, u_center_direction: i4, u_radius: e.al(o4), u_opacity: s4, u_temporal_offset: r4 }))(l3.skyboxMatrix, i3.getCenter(t3, false), i3.paint.get("sky-gradient-radius"), s3, r3);
              t3.uploadCommonUniforms(n3, c3), c3.draw(t3, a3.TRIANGLES, o3, ji.disabled, t3.colorModeForRenderPass(), qi.backCW, d2, "skyboxGradient", i3.skyboxGeometry.vertexBuffer, i3.skyboxGeometry.indexBuffer, i3.skyboxGeometry.segment);
            }(t2, o2, l2, r2, c2);
          }, debug: function(t2, i2, o2, s2, r2, n2) {
            for (let a2 = 0; a2 < o2.length; a2++) if (r2) {
              const r3 = 1, l2 = 0.8, c2 = new e.am(s2.r * l2, s2.g * l2, s2.b * l2, 1);
              hn(t2, i2, o2[a2], s2, -r3, -r3, n2), hn(t2, i2, o2[a2], s2, -r3, r3, n2), hn(t2, i2, o2[a2], s2, r3, r3, n2), hn(t2, i2, o2[a2], s2, r3, -r3, n2), hn(t2, i2, o2[a2], c2, 0, 0, n2);
            } else hn(t2, i2, o2[a2], s2, 0, 0, n2);
          }, custom: function(t2, i2, o2, s2) {
            const r2 = t2.context, n2 = o2.implementation;
            if (!t2.transform.projection.unsupportedLayers || !t2.transform.projection.unsupportedLayers.includes("custom") || t2.terrain && (t2.terrain.renderingToTexture || "offscreen" === t2.renderPass) && o2.isDraped(i2)) {
              if ("offscreen" === t2.renderPass) {
                const i3 = n2.prerender;
                if (i3) {
                  if (t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), "globe" === t2.transform.projection.name) {
                    const o3 = t2.transform.pointMerc;
                    i3.call(n2, r2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.ah(t2.transform.zoom), [o3.x, o3.y], t2.transform.pixelsPerMeterRatio);
                  } else i3.call(n2, r2.gl, t2.transform.customLayerMatrix());
                  r2.setDirty(), t2.setBaseState();
                }
              } else if ("translucent" === t2.renderPass) {
                if (t2.terrain && t2.terrain.renderingToTexture) {
                  const e2 = n2.renderToTile;
                  if (e2) {
                    const i4 = s2[0].canonical, o3 = { x: i4.x + s2[0].wrap * (n2.wrapTileId ? 0 : 1 << i4.z), y: i4.y, z: i4.z };
                    r2.setDepthMode(Ni.disabled), r2.setStencilMode(ji.disabled), r2.setColorMode(t2.colorModeForRenderPass()), t2.setCustomLayerDefaults(), e2.call(n2, r2.gl, o3), r2.setDirty(), t2.setBaseState();
                  }
                  return;
                }
                t2.setCustomLayerDefaults(), r2.setColorMode(t2.colorModeForRenderPass()), r2.setStencilMode(ji.disabled);
                const i3 = "3d" === n2.renderingMode ? new Ni(t2.context.gl.LEQUAL, Ni.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, Ni.ReadOnly);
                if (r2.setDepthMode(i3), "globe" === t2.transform.projection.name) {
                  const i4 = t2.transform.pointMerc;
                  n2.render(r2.gl, t2.transform.customLayerMatrix(), t2.transform.getProjection(), t2.transform.globeToMercatorMatrix(), e.ah(t2.transform.zoom), [i4.x, i4.y], t2.transform.pixelsPerMeterRatio);
                } else n2.render(r2.gl, t2.transform.customLayerMatrix());
                r2.setDirty(), t2.setBaseState(), r2.bindFramebuffer.set(null);
              }
            } else e.w("Custom layers are not yet supported with this projection. Use mercator or globe to enable usage of custom layers.");
          }, model: function(t2, i2, o2, s2) {
            if ("opaque" === t2.renderPass) return;
            const r2 = o2.paint.get("model-opacity").constantOr(1);
            if (0 === r2) return;
            const n2 = o2.paint.get("model-cast-shadows");
            if ("shadow" === t2.renderPass) {
              if (!n2) return;
              if (t2.terrain && r2 < 0.65 && o2._transitionablePaint._values["model-opacity"].value.expression instanceof e.ab) return;
            }
            const a2 = t2.shadowRenderer, l2 = o2.paint.get("model-receive-shadows");
            a2 && (a2.useNormalOffset = true, l2 || (a2.enabled = false));
            const c2 = () => {
              a2 && (a2.useNormalOffset = true, l2 || (a2.enabled = true));
            }, h2 = i2.getSource();
            if ("light-beam" === t2.renderPass && "batched-model" !== h2.type) return;
            if ("vector" === h2.type || "geojson" === h2.type) return function(t3, i3, o3, s3, r3) {
              const n3 = t3.transform;
              if ("mercator" !== n3.projection.name) return void e.w(`Drawing 3D models for ${n3.projection.name} projection is not yet implemented`);
              const a3 = n3.getFreeCameraOptions().position;
              if (!t3.modelManager) return;
              const l3 = t3.modelManager;
              o3.modelManager = l3;
              const c3 = t3.shadowRenderer;
              if (!o3._unevaluatedLayout._values.hasOwnProperty("model-id")) return;
              const h3 = o3._unevaluatedLayout._values["model-id"], d3 = Object.assign({}, o3.layout.get("model-id").parameters), u6 = t3.style.order.indexOf(o3.fqid);
              for (const _3 of s3) {
                const s4 = i3.getTile(_3).getBucket(o3);
                if (!s4 || s4.projection.name !== n3.projection.name) continue;
                const p3 = s4.getModelUris();
                p3 && !s4.modelsRequested && (l3.addModelsFromBucket(p3, r3), s4.modelsRequested = true);
                const f3 = Ln(_3, n3);
                d3.zoom = f3;
                const m3 = h3.possiblyEvaluate(d3);
                if (Dn(t3, s4, _3), An.shadowUniformsInitialized = false, An.useSingleShadowCascade = !!c3 && 0 === c3.getMaxCascadeForTile(_3.toUnwrapped()), "shadow" === t3.renderPass && c3) {
                  if (1 === t3.currentShadowCascade && s4.isInsideFirstShadowMapFrustum) continue;
                  const i4 = n3.calculatePosMatrix(_3.toUnwrapped(), n3.worldSize);
                  if (An.tileMatrix.set(i4), An.shadowTileMatrix = Float32Array.from(c3.calculateShadowPassMatrixFromMatrix(i4)), An.aabb.min.fill(0), An.aabb.max[0] = An.aabb.max[1] = e.aj, An.aabb.max[2] = 0, Mn(s4, An, t3, o3.scope)) continue;
                }
                const g3 = 1 << _3.canonical.z, v3 = [((a3.x - _3.wrap) * g3 - _3.canonical.x) * e.aj, (a3.y * g3 - _3.canonical.y) * e.aj, a3.z * g3 * e.aj];
                t3.conflationActive && Object.keys(s4.instancesPerModel).length > 0 && t3.style.isLayerClipped(o3, i3.getSource()) && s4.updateReplacement(_3, t3.replacementSource, u6, r3) && (s4.uploaded = false, s4.upload(t3.context));
                for (let e2 in s4.instancesPerModel) {
                  const i4 = s4.instancesPerModel[e2];
                  i4.features.length > 0 && (e2 = m3.evaluate(i4.features[0].feature, {}));
                  const n4 = l3.getModel(e2, r3);
                  if (n4 || l3.hasURLBeenRequested(e2) || s4.modelUris.includes(e2) || (s4.modelUris.push(e2), s4.modelsRequested = false), n4 && n4.uploaded) for (const e3 of n4.nodes) Pn(t3, o3, e3, i4, v3, _3, An);
                }
              }
            }(t2, i2, o2, s2, "vector" === h2.type ? o2.scope : ""), void c2();
            if (!h2.loaded()) return;
            if ("batched-model" === h2.type) return function(t3, i3, o3, s3) {
              o3.resetLayerRenderingStats(t3);
              const r3 = t3.context, n3 = t3.transform, a3 = t3.style.fog, l3 = t3.shadowRenderer;
              if ("mercator" !== n3.projection.name) return void e.w(`Drawing 3D landmark models for ${n3.projection.name} projection is not yet implemented`);
              const c3 = t3.transform.getFreeCameraOptions().position, h3 = e.b$([], [c3.x, c3.y, c3.z], t3.transform.worldSize), d3 = e.eb([], h3), u6 = e.bx([]), _3 = e.ec(n3.center.lat, n3.zoom), p3 = e.bn([], [1, 1, 1 / _3]);
              e.bo(u6, u6, d3);
              const f3 = o3.paint.get("model-opacity").constantOr(1), m3 = new Ni(r3.gl.LEQUAL, Ni.ReadWrite, t3.depthRangeFor3D), g3 = new Ni(r3.gl.LEQUAL, Ni.ReadOnly, t3.depthRangeFor3D), v3 = new e.cV([1 / 0, 1 / 0, 1 / 0], [-1 / 0, -1 / 0, -1 / 0]), y2 = "shadow" === t3.renderPass, x2 = y2 && l3 ? l3.getCurrentCascadeFrustum() : n3.getFrustum(n3.scaleZoom(n3.worldSize)), b2 = o3.paint.get("model-front-cutoff"), w2 = b2[2] < 1, T2 = eo(t3, o3.paint.get("model-cutoff-fade-range")), E2 = o3.getLayerRenderingStats();
              (function(e2, t4, i4, o4) {
                const s4 = e2.terrain ? e2.terrain.exaggeration() : 0, r4 = e2.transform.zoom;
                for (const n4 of o4) {
                  const o5 = t4.getTile(n4).getBucket(i4);
                  o5 && (o5.setFilter(i4.filter), e2.conflationActive && o5.updateReplacement(n4, e2.replacementSource), o5.evaluateScale(e2, i4), e2.terrain && s4 > 0 && o5.elevationUpdate(e2.terrain, s4, n4, i4.source), o5.needsReEvaluation(e2, r4, i4) && o5.evaluate(i4));
                }
              })(t3, i3, o3, s3), function() {
                let c4, d4, S2;
                w2 ? (c4 = s3.length - 1, d4 = -1, S2 = -1) : (c4 = 0, d4 = s3.length, S2 = 1);
                const I2 = new Float64Array(16), C3 = e.eg(), R2 = new e.P(0, 0);
                for (let D3 = c4; D3 !== d4; D3 += S2) {
                  const c5 = s3[D3], d5 = i3.getTile(c5).getBucket(o3);
                  if (!d5 || !d5.uploaded) continue;
                  let S3 = false;
                  l3 && (S3 = 0 === l3.getMaxCascadeForTile(c5.toUnwrapped()));
                  const A2 = n3.calculatePosMatrix(c5.toUnwrapped(), n3.worldSize), L2 = d5.modelTraits;
                  !y2 && w2 && (e.bi(I2, A2), e.ad(C3, h3, I2), R2.x = C3[0], R2.y = C3[1]);
                  const P2 = [];
                  d5.setFilter(o3.filter);
                  for (const i4 of d5.getNodesInfo()) {
                    if (i4.hiddenByReplacement) continue;
                    if (!i4.node.meshes) continue;
                    const o4 = i4.node;
                    let s4 = 0;
                    t3.terrain && o4.elevation && (s4 = o4.elevation * t3.terrain.exaggeration());
                    const r4 = (() => {
                      const t4 = i4.aabb;
                      return v3.min = [...t4.min], v3.max = [...t4.max], v3.min[2] += s4, v3.max[2] += s4, e.ad(v3.min, v3.min, A2), e.ad(v3.max, v3.max, A2), v3;
                    })(), a4 = i4.evaluatedScale;
                    if (a4[0] <= 1 && a4[1] <= 1 && a4[2] <= 1 && 0 === r4.intersects(x2)) continue;
                    if (!y2 && w2) {
                      const t4 = 1 / 6;
                      i4.cameraCollisionOpacity = h3[0] > r4.min[0] && h3[0] < r4.max[0] && h3[1] > r4.min[1] && h3[1] < r4.max[1] && h3[2] * _3 < r4.max[2] && o4.footprint && e.bS(R2, o4.footprint) ? Math.max(i4.cameraCollisionOpacity - t4, 0) : Math.min(1, i4.cameraCollisionOpacity + t4);
                    }
                    const l4 = [...A2], c6 = o4.anchor ? o4.anchor[0] : 0, d6 = o4.anchor ? o4.anchor[1] : 0;
                    e.bo(l4, l4, [c6 * (a4[0] - 1), d6 * (a4[1] - 1), s4]), e.ci(a4, e.eh) || e.cE(l4, l4, a4);
                    const u7 = e.az([], l4, o4.matrix), p4 = e.az([], n3.expandedFarZProjMatrix, u7), m4 = e.az([], n3.expandedFarZProjMatrix, l4), g4 = e.aA([], [c6, d6, s4, 1], p4)[2];
                    o4.hidden = false;
                    let E3 = f3;
                    y2 || (w2 && (E3 *= i4.cameraCollisionOpacity, E3 *= Fn(l4, n3, i4.aabb, b2)), E3 *= On(T2, g4)), 0 !== E3 ? P2.push({ nodeInfo: i4, depth: g4, opacity: E3, wvpForNode: p4, wvpForTile: m4, nodeModelMatrix: u7, tileModelMatrix: l4 }) : o4.hidden = true;
                  }
                  y2 || P2.sort((e2, t4) => !w2 || 1 === e2.opacity && 1 === t4.opacity ? e2.depth < t4.depth ? -1 : 1 : 1 === e2.opacity ? -1 : 1 === t4.opacity ? 1 : e2.depth > t4.depth ? -1 : 1);
                  for (const i4 of P2) {
                    const s4 = i4.nodeInfo, c6 = s4.node;
                    let h4 = e.az([], p3, i4.tileModelMatrix);
                    e.az(h4, u6, h4);
                    const d6 = e.bi([], h4);
                    e.ee(d6, d6), e.cE(d6, d6, zn), h4 = e.az(h4, h4, c6.matrix);
                    const _4 = "light-beam" === t3.renderPass, f4 = "none" === o3.paint.get("model-color-use-theme").constantOr("default"), v4 = L2 & e.em.HasMapboxMeshFeatures, x3 = v4 ? 0 : s4.evaluatedRMEA[0][2];
                    for (let e2 = 0; e2 < c6.meshes.length; ++e2) {
                      const u7 = c6.meshes[e2], p4 = e2 === c6.lightMeshIndex;
                      let b3 = i4.wvpForNode;
                      if (p4) {
                        if (!_4 && !t3.terrain && t3.shadowRenderer) {
                          t3.currentLayer < t3.firstLightBeamLayer && (t3.firstLightBeamLayer = t3.currentLayer);
                          continue;
                        }
                        b3 = i4.wvpForTile;
                      } else if (_4) continue;
                      const w3 = { defines: [] }, T3 = [];
                      if (!y2 && l3 && (l3.useNormalOffset = !!u7.normalBuffer), Sn(w3.defines, T3, u7, t3, f4 ? null : o3.lut), v4 || w3.defines.push("DIFFUSE_SHADED"), S3 && w3.defines.push("SHADOWS_SINGLE_CASCADE"), E2 && (y2 ? E2.numRenderedVerticesInShadowPass += u7.vertexArray.length : E2.numRenderedVerticesInTransparentPass += u7.vertexArray.length), y2) {
                        Rn(u7, i4.nodeModelMatrix, t3, o3);
                        continue;
                      }
                      let I3 = null;
                      if (a3) {
                        const e3 = En(i4.nodeModelMatrix, t3.transform);
                        if (I3 = new Float32Array(e3), "globe" !== n3.projection.name) {
                          const t4 = u7.aabb.min, i5 = u7.aabb.max, [o4, s5] = a3.getOpacityForBounds(e3, t4[0], t4[1], i5[0], i5[1]);
                          w3.overrideFog = o4 >= Fe || s5 >= Fe;
                        }
                      }
                      const C4 = u7.material;
                      let R3;
                      C4.occlusionTexture && C4.occlusionTexture.offsetScale && (R3 = C4.occlusionTexture.offsetScale, w3.defines.push("OCCLUSION_TEXTURE_TRANSFORM"));
                      const D4 = t3.getOrCreateProgram("model", w3);
                      !y2 && l3 && l3.setupShadowsFromMatrix(i4.tileModelMatrix, D4, l3.useNormalOffset), t3.uploadCommonUniforms(r3, D4, null, I3);
                      const A3 = C4.pbrMetallicRoughness;
                      A3.metallicFactor = 0.9, A3.roughnessFactor = 0.5;
                      const L3 = Er(new Float32Array(b3), new Float32Array(h4), new Float32Array(d6), new Float32Array(c6.matrix), t3, i4.opacity, A3.baseColorFactor.toRenderColor(null), C4.emissiveFactor, A3.metallicFactor, A3.roughnessFactor, C4, x3, o3, [0, 0, 0], R3);
                      !p4 && (s4.hasTranslucentParts || i4.opacity < 1) && D4.draw(t3, r3.gl.TRIANGLES, m3, ji.disabled, ki.disabled, qi.backCCW, L3, o3.id, u7.vertexBuffer, u7.indexBuffer, u7.segments, o3.paint, t3.transform.zoom, void 0, T3), D4.draw(t3, r3.gl.TRIANGLES, p4 ? g3 : m3, ji.disabled, p4 || i4.opacity < 1 || s4.hasTranslucentParts ? ki.alphaBlended : ki.unblended, qi.backCCW, L3, o3.id, u7.vertexBuffer, u7.indexBuffer, u7.segments, o3.paint, t3.transform.zoom, void 0, T3);
                    }
                  }
                }
              }();
            }(t2, i2, o2, s2), void c2();
            if ("model" !== h2.type) return;
            const d2 = h2.getModels(), u5 = [], _2 = t2.transform.getFreeCameraOptions().position, p2 = e.b$([], [_2.x, _2.y, _2.z], t2.transform.worldSize);
            e.eb(p2, p2);
            const f2 = [], m2 = [];
            let g2 = 0;
            for (const i3 of d2) {
              const s3 = o2.paint.get("model-rotation").constantOr(null), r3 = o2.paint.get("model-scale").constantOr(null), n3 = o2.paint.get("model-translation").constantOr(null);
              i3.computeModelMatrix(t2, s3, r3, n3, true, true, false);
              const a3 = e.bx([]), l3 = e.ec(i3.position.lat, t2.transform.zoom), c3 = e.bn([], [1, 1, 1 / l3]);
              e.bo(a3, a3, p2), u5.push({ zScaleMatrix: c3, negCameraPosMatrix: a3 });
              for (const e2 of i3.nodes) Cn(t2.transform, e2, i3.matrix, t2.transform.expandedFarZProjMatrix, g2, f2, m2);
              g2++;
            }
            if (f2.sort((e2, t3) => t3.depth - e2.depth), "shadow" !== t2.renderPass) {
              if (1 === r2) for (const e2 of m2) In(e2, t2, o2, u5[e2.modelIndex], ji.disabled, t2.colorModeForRenderPass());
              else {
                for (const e2 of m2) In(e2, t2, o2, u5[e2.modelIndex], ji.disabled, ki.disabled);
                for (const e2 of m2) In(e2, t2, o2, u5[e2.modelIndex], t2.stencilModeFor3D(), t2.colorModeForRenderPass());
                t2.resetStencilClippingMasks();
              }
              for (const e2 of f2) In(e2, t2, o2, u5[e2.modelIndex], ji.disabled, t2.colorModeForRenderPass());
              c2();
            } else {
              for (const e2 of m2) Rn(e2.mesh, e2.nodeModelMatrix, t2, o2);
              for (const e2 of f2) Rn(e2.mesh, e2.nodeModelMatrix, t2, o2);
              c2();
            }
          } }, ea2 = { line: function(e2, t2, i2) {
            if (e2.hasElevatedBuckets = false, e2.hasNonElevatedBuckets = false, void 0 !== e2._unevaluatedLayout.getValue("line-elevation-reference") || void 0 !== e2._unevaluatedLayout.getValue("line-z-offset")) {
              if (t2) {
                const i3 = t2.getVisibleCoordinates();
                for (const o2 of i3) {
                  const i4 = t2.getTile(o2).getBucket(e2);
                  if (i4 && ("none" !== i4.elevationType ? e2.hasElevatedBuckets = true : e2.hasNonElevatedBuckets = true, e2.hasElevatedBuckets && e2.hasNonElevatedBuckets)) break;
                }
              }
            } else e2.hasNonElevatedBuckets = true;
          }, model: function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!o2.loaded()) return;
            if ("vector" === o2.type || "geojson" === o2.type) return void (i2.modelManager && i2.modelManager.upload(i2, "vector" === o2.type ? e2.scope : ""));
            if ("batched-model" === o2.type) return;
            if ("model" !== o2.type) return;
            const s2 = o2.getModels();
            for (const e3 of s2) e3.upload(i2.context);
          }, raster: function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!(o2 instanceof st && o2.loaded())) return;
            const s2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
            if (!s2) return;
            const r2 = e2.paint.get("raster-array-band") || o2.getInitialBand(s2);
            if (null == r2) return;
            const n2 = t2.getIds().map((e3) => t2.getTileByID(e3));
            for (const e3 of n2) e3.updateNeeded(s2, r2) && o2.prepareTile(e3, s2, r2);
          }, "raster-particle": function(e2, t2, i2) {
            const o2 = t2.getSource();
            if (!(o2 instanceof st && o2.loaded())) return;
            const s2 = e2.sourceLayer || o2.rasterLayerIds && o2.rasterLayerIds[0];
            if (!s2) return;
            const r2 = e2.paint.get("raster-particle-array-band") || o2.getInitialBand(s2);
            if (null == r2) return;
            const n2 = t2.getIds().map((e3) => t2.getTileByID(e3));
            for (const e3 of n2) e3.updateNeeded(s2, r2) && o2.prepareTile(e3, s2, r2);
          } }, ta = { fill: jr };
          class ia {
            constructor(t2, i2, o2, s2, r2) {
              this.context = new Lr(t2, i2), this.transform = o2, this._tileTextures = {}, this.frameCopies = [], this.loadTimeStamps = [], this.tp = r2, this._timeStamp = e.q.now(), this._averageFPS = 0, this._fpsHistory = [], this._dt = 0, this._debugParams = { forceEnablePrecipitation: false, showTerrainProxyTiles: false, fpsWindow: 30, continousRedraw: false, enabledLayers: {} };
              const n2 = ["fill", "line", "symbol", "circle", "heatmap", "fill-extrusion", "raster", "raster-particle", "hillshade", "model", "background", "sky"];
              for (const e2 of n2) this._debugParams.enabledLayers[e2] = true;
              r2.registerParameter(this._debugParams, ["Terrain"], "showTerrainProxyTiles", {}, () => {
                this.style.map.triggerRepaint();
              }), r2.registerParameter(this._debugParams, ["Precipitation"], "forceEnablePrecipitation"), r2.registerParameter(this._debugParams, ["FPS"], "fpsWindow", { min: 1, max: 100, step: 1 }), r2.registerBinding(this._debugParams, ["FPS"], "continousRedraw", { readonly: true, label: "continuous redraw" }), r2.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "value" }), r2.registerBinding(this, ["FPS"], "_averageFPS", { readonly: true, label: "graph", view: "graph", min: 0, max: 200 });
              for (const e2 of n2) r2.registerParameter(this._debugParams.enabledLayers, ["Debug", "Layers"], e2);
              this.occlusionParams = new Nn(r2), this.setup(), this.numSublayers = It.maxUnderzooming + It.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.deferredRenderGpuTimeQueries = [], this.gpuTimers = {}, this.frameCounter = 0, this._backgroundTiles = {}, this.conflationActive = false, this.replacementSource = new e.et(), this.longestCutoffRange = 0, this.minCutoffZoom = 0, this._fogVisible = false, this._cachedTileFogOpacities = {}, this._shadowRenderer = new so(this), this._wireframeDebugCache = new kn(), this.renderDefaultNorthPole = true, this.renderDefaultSouthPole = true, this.layersWithOcclusionOpacity = [];
              const a2 = new e.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0));
              this.emptyDepthTexture = new e.T(this.context, a2, t2.RGBA8), this._clippingActiveLastFrame = false, this.scaleFactor = s2;
            }
            updateTerrain(e2, t2) {
              const i2 = !!e2 && !!e2.terrain && this.transform.projection.supportsTerrain;
              if (!(i2 || this._terrain && this._terrain.enabled)) return;
              this._terrain || (this._terrain = new qs(this, e2));
              const o2 = this._terrain;
              this.transform.elevation = i2 ? o2 : null, o2.update(e2, this.transform, t2), this.transform.elevation && !o2.enabled && (this.transform.elevation = null);
            }
            _updateFog(e2) {
              const t2 = e2.fog;
              if (!t2 || "globe" === this.transform.projection.name || t2.getOpacity(this.transform.pitch) < 1 || t2.properties.get("horizon-blend") < 0.03) return void (this.transform.fogCullDistSq = null);
              const [i2, o2] = t2.getFovAdjustedRange(this.transform._fov);
              if (i2 > o2) return void (this.transform.fogCullDistSq = null);
              const s2 = i2 + 0.78 * (o2 - i2);
              this.transform.fogCullDistSq = s2 * s2;
            }
            get terrain() {
              return this.transform._terrainEnabled() && this._terrain && this._terrain.enabled || this._forceTerrainMode ? this._terrain : null;
            }
            get forceTerrainMode() {
              return this._forceTerrainMode;
            }
            set forceTerrainMode(e2) {
              e2 && !this._terrain && (this._terrain = new qs(this, this.style)), this._forceTerrainMode = e2;
            }
            get shadowRenderer() {
              return this._shadowRenderer && this._shadowRenderer.enabled ? this._shadowRenderer : null;
            }
            get wireframeDebugCache() {
              return this._wireframeDebugCache;
            }
            resize(t2, i2) {
              if (this.width = t2 * e.q.devicePixelRatio, this.height = i2 * e.q.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style) for (const e2 of this.style.order) this.style._mergedLayers[e2].resize();
            }
            setup() {
              const t2 = this.context, i2 = new e.ba();
              i2.emplaceBack(0, 0), i2.emplaceBack(e.aj, 0), i2.emplaceBack(0, e.aj), i2.emplaceBack(e.aj, e.aj), this.tileExtentBuffer = t2.createVertexBuffer(i2, e.bc.members), this.tileExtentSegments = e.bd.simpleSegment(0, 0, 4, 2);
              const o2 = new e.ba();
              o2.emplaceBack(0, 0), o2.emplaceBack(e.aj, 0), o2.emplaceBack(0, e.aj), o2.emplaceBack(e.aj, e.aj), this.debugBuffer = t2.createVertexBuffer(o2, e.bc.members), this.debugSegments = e.bd.simpleSegment(0, 0, 4, 5);
              const s2 = new e.ba();
              s2.emplaceBack(-1, -1), s2.emplaceBack(1, -1), s2.emplaceBack(-1, 1), s2.emplaceBack(1, 1), this.viewportBuffer = t2.createVertexBuffer(s2, e.bc.members), this.viewportSegments = e.bd.simpleSegment(0, 0, 4, 2);
              const r2 = new e.aZ();
              r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(e.aj, 0, e.aj, 0), r2.emplaceBack(0, e.aj, 0, e.aj), r2.emplaceBack(e.aj, e.aj, e.aj, e.aj), this.mercatorBoundsBuffer = t2.createVertexBuffer(r2, e.bf.members), this.mercatorBoundsSegments = e.bd.simpleSegment(0, 0, 4, 2);
              const n2 = new e.a_();
              n2.emplaceBack(0, 1, 2), n2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = t2.createIndexBuffer(n2);
              const a2 = new e.bb();
              for (const e2 of [0, 1, 3, 2, 0]) a2.emplaceBack(e2);
              this.debugIndexBuffer = t2.createIndexBuffer(a2), this.emptyTexture = new e.T(t2, new e.r({ width: 1, height: 1 }, Uint8Array.of(0, 0, 0, 0)), t2.gl.RGBA8), this.identityMat = e.bz();
              const l2 = this.context.gl;
              this.stencilClearMode = new ji({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO), this.loadTimeStamps.push(performance.now());
            }
            getMercatorTileBoundsBuffers() {
              return { tileBoundsBuffer: this.mercatorBoundsBuffer, tileBoundsIndexBuffer: this.quadTriangleIndexBuffer, tileBoundsSegments: this.mercatorBoundsSegments };
            }
            getTileBoundsBuffers(e2) {
              return e2._makeTileBoundsBuffers(this.context, this.transform.projection), e2._tileBoundsBuffer ? { tileBoundsBuffer: e2._tileBoundsBuffer, tileBoundsIndexBuffer: e2._tileBoundsIndexBuffer, tileBoundsSegments: e2._tileBoundsSegments } : this.getMercatorTileBoundsBuffers();
            }
            clearStencil() {
              const e2 = this.context.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0, this._tileClippingMaskIDs = {}, this.getOrCreateProgram("clippingMask").draw(this, e2.TRIANGLES, Ni.disabled, this.stencilClearMode, ki.disabled, qi.disabled, Ns(this.identityMat), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            resetStencilClippingMasks() {
              this.terrain || (this.currentStencilSource = void 0, this._tileClippingMaskIDs = {});
            }
            _renderTileClippingMasks(e2, t2, i2) {
              if (!t2 || this.currentStencilSource === t2.id || !e2.isTileClipped() || !i2 || 0 === i2.length) return;
              if (this._tileClippingMaskIDs && !this.terrain) {
                let e3 = false;
                for (const t3 of i2) if (void 0 === this._tileClippingMaskIDs[t3.key]) {
                  e3 = true;
                  break;
                }
                if (!e3) return;
              }
              this.currentStencilSource = t2.id;
              const o2 = this.context, s2 = o2.gl;
              this.nextStencilID + i2.length > 256 && this.clearStencil(), o2.setColorMode(ki.disabled), o2.setDepthMode(Ni.disabled);
              const r2 = this.getOrCreateProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const e3 of i2) {
                const i3 = t2.getTile(e3), o3 = this._tileClippingMaskIDs[e3.key] = this.nextStencilID++, { tileBoundsBuffer: n2, tileBoundsIndexBuffer: a2, tileBoundsSegments: l2 } = this.getTileBoundsBuffers(i3);
                r2.draw(this, s2.TRIANGLES, Ni.disabled, new ji({ func: s2.ALWAYS, mask: 0 }, o3, 255, s2.KEEP, s2.KEEP, s2.REPLACE), ki.disabled, qi.disabled, Ns(e3.projMatrix), "$clipping", n2, a2, l2);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const e2 = this.nextStencilID++, t2 = this.context.gl;
              return new ji({ func: t2.NOTEQUAL, mask: 255 }, e2, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            stencilModeForClipping(e2) {
              if (this.terrain) return this.terrain.stencilModeForRTTOverlap(e2);
              const t2 = this.context.gl;
              return new ji({ func: t2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[e2.key], 0, t2.KEEP, t2.KEEP, t2.REPLACE);
            }
            stencilConfigForOverlap(e2) {
              const t2 = this.context.gl, i2 = e2.sort((e3, t3) => t3.overscaledZ - e3.overscaledZ), o2 = i2[i2.length - 1].overscaledZ, s2 = i2[0].overscaledZ - o2 + 1;
              if (s2 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + s2 > 256 && this.clearStencil();
                const e3 = {};
                for (let i3 = 0; i3 < s2; i3++) e3[i3 + o2] = new ji({ func: t2.GEQUAL, mask: 255 }, i3 + this.nextStencilID, 255, t2.KEEP, t2.KEEP, t2.REPLACE);
                return this.nextStencilID += s2, [e3, i2];
              }
              return [{ [o2]: ji.disabled }, i2];
            }
            colorModeForRenderPass() {
              const t2 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i2 = 1 / 8;
                return new ki([t2.CONSTANT_COLOR, t2.ONE, t2.CONSTANT_COLOR, t2.ONE], new e.am(i2, i2, i2, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? ki.unblended : ki.alphaBlended;
            }
            colorModeForDrapableLayerRenderPass(t2) {
              const i2 = this.context.gl;
              return (() => this.style && this.style.enable3dLights() && this.terrain && this.terrain.renderingToTexture)() && "translucent" === this.renderPass ? new ki([i2.ONE, i2.ONE_MINUS_SRC_ALPHA, i2.CONSTANT_ALPHA, i2.ONE_MINUS_SRC_ALPHA], new e.am(0, 0, 0, void 0 === t2 ? 0 : t2), [true, true, true, true]) : this.colorModeForRenderPass();
            }
            depthModeForSublayer(e2, t2, i2, o2 = false) {
              if (this.depthOcclusion) return new Ni(this.context.gl.GREATER, Ni.ReadOnly, this.depthRangeFor3D);
              if (!this.opaquePassEnabledForLayer() && !o2) return Ni.disabled;
              const s2 = 1 - ((1 + this.currentLayer) * this.numSublayers + e2) * this.depthEpsilon;
              return new Ni(i2 || this.context.gl.LEQUAL, t2, [s2, s2]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            blitDepth() {
              const t2 = this.context.gl, i2 = Math.ceil(this.width), o2 = Math.ceil(this.height), s2 = this.context.bindFramebuffer.get(), r2 = t2.getParameter(t2.TEXTURE_BINDING_2D);
              this.depthFBO && this.depthFBO.width === i2 && this.depthFBO.height === o2 || (this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), 0 !== i2 && 0 !== o2 && (this.depthFBO = new Ar(this.context, i2, o2, false, "texture"), this.depthTexture = new e.T(this.context, { width: i2, height: o2, data: null }, t2.DEPTH24_STENCIL8), this.depthFBO.depthAttachment.set(this.depthTexture.texture))), this.context.bindFramebuffer.set(s2), t2.bindTexture(t2.TEXTURE_2D, r2), this.depthFBO && (t2.bindFramebuffer(t2.READ_FRAMEBUFFER, null), t2.bindFramebuffer(t2.DRAW_FRAMEBUFFER, this.depthFBO.framebuffer), t2.blitFramebuffer(0, 0, i2, o2, 0, 0, i2, o2, t2.DEPTH_BUFFER_BIT, t2.NEAREST), t2.bindFramebuffer(t2.FRAMEBUFFER, this.context.bindFramebuffer.current));
            }
            updateAverageFPS() {
              this._fpsHistory.push(0 === this._dt ? 0 : 1e3 / this._dt), this._fpsHistory.length > this._debugParams.fpsWindow && this._fpsHistory.splice(0, this._fpsHistory.length - this._debugParams.fpsWindow), this._averageFPS = Math.round(this._fpsHistory.reduce((e2, t2) => e2 + t2 / this._fpsHistory.length, 0));
            }
            render(t2, i2) {
              const o2 = e.q.now();
              this._dt = o2 - this._timeStamp, this._timeStamp = o2, this._wireframeDebugCache.update(this.frameCounter), this._debugParams.continousRedraw = t2.map.repaint, this.style = t2, this.options = i2;
              const s2 = this.style._mergedLayers, r2 = !(!this.terrain || !this.terrain.enabled), n2 = () => this.style._getOrder(r2).filter((e2) => {
                const t3 = s2[e2];
                return !(t3.type in this._debugParams.enabledLayers) || this._debugParams.enabledLayers[t3.type];
              });
              let a2 = n2(), l2 = false, c2 = false;
              for (const e2 of a2) {
                const t3 = s2[e2];
                "circle" === t3.type && (l2 = true), "symbol" === t3.type && (t3.hasInitialOcclusionOpacityProperties ? c2 = true : l2 = true);
              }
              let h2 = a2.map((e2) => s2[e2]);
              const d2 = this.style._mergedSourceCaches;
              this.imageManager = t2.imageManager, this.modelManager = t2.modelManager, this.symbolFadeChange = t2.placement.symbolFadeChange(e.q.now()), this.imageManager.beginFrame();
              let u5 = 0, _2 = false;
              for (const e2 in d2) {
                const t3 = d2[e2];
                t3.used && (t3.prepare(this.context), t3.getSource().usedInConflation && ++u5);
              }
              let p2 = false;
              for (const e2 of h2) e2.isHidden(this.transform.zoom) || ("clip" === e2.type && (p2 = true), this.prepareLayer(e2));
              const f2 = {}, m2 = {}, g2 = {}, v3 = {}, y2 = {};
              for (const e2 in d2) {
                const t3 = d2[e2];
                f2[e2] = t3.getVisibleCoordinates(), m2[e2] = f2[e2].slice().reverse(), g2[e2] = t3.getVisibleCoordinates(true).reverse(), v3[e2] = t3.getShadowCasterCoordinates(), y2[e2] = t3.sortCoordinatesByDistance(f2[e2]);
              }
              const x2 = (e2) => {
                const t3 = this.style.getLayerSourceCache(e2);
                return t3 && t3.used ? t3.getSource() : null;
              };
              if (u5 || p2 || this._clippingActiveLastFrame) {
                const t3 = [], i3 = [];
                let o3 = 0;
                for (const e2 of h2) this.isSourceForClippingOrConflation(e2, x2(e2)) && (t3.push(e2), i3.push(o3)), o3++;
                if (t3 && (p2 || t3.length > 1) || this._clippingActiveLastFrame) {
                  p2 = false;
                  const o4 = [];
                  for (let s3 = 0; s3 < t3.length; s3++) {
                    const r3 = t3[s3], n3 = i3[s3], a3 = this.style.getLayerSourceCache(r3);
                    if (!a3 || !a3.used || !a3.getSource().usedInConflation && "clip" !== r3.type) continue;
                    let l3 = e.ev, c3 = e.bQ.None;
                    const h3 = [];
                    let d3 = true;
                    if ("clip" === r3.type) {
                      l3 = n3;
                      for (const t4 of r3.layout.get("clip-layer-types")) c3 |= "model" === t4 ? e.bQ.Model : "symbol" === t4 ? e.bQ.Symbol : e.bQ.FillExtrusion;
                      for (const e2 of r3.layout.get("clip-layer-scope")) h3.push(e2);
                      r3.isHidden(this.transform.zoom) ? d3 = false : p2 = true;
                    }
                    d3 && o4.push({ layer: r3.fqid, cache: a3, order: l3, clipMask: c3, clipScope: h3 });
                  }
                  this.replacementSource.setSources(o4), _2 = true;
                }
              }
              this._clippingActiveLastFrame = p2, _2 || this.replacementSource.clear(), this.conflationActive = _2, this.minCutoffZoom = 0, this.longestCutoffRange = 0, this.opaquePassCutoff = 1 / 0, this._lastOcclusionLayer = -1, this.layersWithOcclusionOpacity = [];
              for (let e2 = 0; e2 < h2.length; e2++) {
                const t3 = h2[e2], i3 = t3.cutoffRange();
                if (this.longestCutoffRange = Math.max(i3, this.longestCutoffRange), i3 > 0) {
                  const e3 = x2(t3);
                  e3 && (this.minCutoffZoom = Math.max(e3.minzoom, this.minCutoffZoom)), t3.minzoom && (this.minCutoffZoom = Math.max(t3.minzoom, this.minCutoffZoom));
                }
                t3.is3D(r2) && (this.opaquePassCutoff === 1 / 0 && (this.opaquePassCutoff = e2), this._lastOcclusionLayer = e2);
              }
              const b2 = this.style && this.style.fog;
              b2 ? (this._fogVisible = 0 !== b2.getOpacity(this.transform.pitch), this._fogVisible && "globe" !== this.transform.projection.name && (this._fogVisible = b2.isVisibleOnFrustum(this.transform.cameraFrustum))) : this._fogVisible = false, this._cachedTileFogOpacities = {}, this.terrain && (this.terrain.updateTileBinding(g2), this.opaquePassCutoff = 0, a2 = n2(), h2 = a2.map((e2) => s2[e2]));
              const w2 = this._shadowRenderer;
              if (w2) {
                w2.updateShadowParameters(this.transform, this.style.directionalLight);
                for (const e2 in d2) for (const t3 of f2[e2]) {
                  let e3 = { min: 0, max: 0 };
                  this.terrain && (e3 = this.terrain.getMinMaxForTile(t3) || e3), w2.addShadowReceiver(t3.toUnwrapped(), e3.min, e3.max);
                }
              }
              "globe" !== this.transform.projection.name || this.globeSharedBuffers || (this.globeSharedBuffers = new e.eu(this.context)), this.style.fog && this.transform.projection.supportsFog ? (this._atmosphere || (this._atmosphere = new Tn(this)), this._atmosphere.update(this)) : this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0);
              const T2 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.snow), E2 = this._debugParams.forceEnablePrecipitation || !(!this.style || !this.style.rain);
              if (T2 && !this._snow && (this._snow = new Jn(this)), !T2 && this._snow && (this._snow.destroy(), delete this._snow), E2 && !this._rain && (this._rain = new Yn(this)), !E2 && this._rain && (this._rain.destroy(), delete this._rain), this._snow && this._snow.update(this), this._rain && this._rain.update(this), !U.has(this.context.gl)) return;
              this.renderPass = "offscreen";
              for (const e2 of h2) {
                const i3 = t2.getLayerSourceCache(e2);
                if (!e2.hasOffscreenPass() || e2.isHidden(this.transform.zoom)) continue;
                const o3 = i3 ? m2[i3.id] : void 0;
                ("custom" === e2.type || "raster" === e2.type || "raster-particle" === e2.type || e2.isSky() || o3 && o3.length) && this.renderLayer(this, i3, e2, o3);
              }
              this.depthRangeFor3D = [0, 1 - (h2.length + 2) * this.numSublayers * this.depthEpsilon], this._shadowRenderer && (this.renderPass = "shadow", this._shadowRenderer.drawShadowPass(this.style, v3)), this.context.bindFramebuffer.set(null), this.context.viewport.set([0, 0, this.width, this.height]);
              const S2 = "globe" === this.transform.projection.name || this.transform.isHorizonVisible(), I2 = (() => {
                if (i2.showOverdrawInspector) return e.am.black;
                const t3 = this.style.fog;
                if (t3 && this.transform.projection.supportsFog) {
                  const i3 = this.style.getLut(t3.scope);
                  if (!S2) {
                    const o3 = "none" === t3.properties.get("color-use-theme"), s3 = t3.properties.get("color").toRenderColor(o3 ? null : i3).toArray01();
                    return new e.am(...s3);
                  }
                  if (S2) {
                    const o3 = "none" === t3.properties.get("space-color-use-theme"), s3 = t3.properties.get("space-color").toRenderColor(o3 ? null : i3).toArray01();
                    return new e.am(...s3);
                  }
                }
                return e.am.transparent;
              })();
              if (this.context.clear({ color: I2, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.renderPass = "opaque", this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S2 && this._atmosphere.drawStars(this, this.style.fog), !this.terrain) for (this.currentLayer = a2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                const e2 = h2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                if (e2.isSky()) continue;
                const o3 = i3 ? (e2.is3D(r2) ? y2 : m2)[i3.id] : void 0;
                this._renderTileClippingMasks(e2, i3, o3), this.renderLayer(this, i3, e2, o3);
              }
              if (this.style.fog && this.transform.projection.supportsFog && this._atmosphere && !this._showOverdrawInspector && S2 && this._atmosphere.drawAtmosphereGlow(this, this.style.fog), this.renderPass = "sky", (!this._atmosphere || e.ah(this.transform.zoom) > 0) && ("globe" === this.transform.projection.name || this.transform.isHorizonVisible())) for (this.currentLayer = 0; this.currentLayer < a2.length; this.currentLayer++) {
                const e2 = h2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                e2.isSky() && this.renderLayer(this, i3, e2, i3 ? m2[i3.id] : void 0);
              }
              function C3(e2, t3) {
                let i3;
                return t3 && (i3 = ("symbol" === e2.type ? g2 : e2.is3D(r2) ? y2 : m2)[t3.id]), i3;
              }
              if (this.renderPass = "translucent", "globe" === this.transform.projection.name) {
                for (this.renderElevatedRasterBackface = true, this.currentLayer = 0; this.currentLayer < a2.length; ) {
                  const e2 = h2[this.currentLayer];
                  if ("raster" === e2.type || "raster-particle" === e2.type) {
                    const i3 = t2.getLayerSourceCache(e2);
                    this.renderLayer(this, i3, e2, C3(e2, i3));
                  }
                  ++this.currentLayer;
                }
                this.renderElevatedRasterBackface = false;
              }
              this.currentLayer = 0, this.firstLightBeamLayer = Number.MAX_SAFE_INTEGER;
              let R2 = 0;
              w2 && (R2 = w2.getShadowCastingLayerCount());
              let D3 = false, A2 = -1;
              for (let e2 = 0; e2 < a2.length; ++e2) {
                const t3 = h2[e2];
                t3.isHidden(this.transform.zoom) || t3.is3D(r2) && (A2 = e2);
              }
              c2 && -1 === A2 && (l2 = true);
              let L2 = false;
              for (; this.currentLayer < a2.length; ) {
                const e2 = h2[this.currentLayer], i3 = t2.getLayerSourceCache(e2);
                if (e2.isSky()) ++this.currentLayer;
                else if (this.terrain && this.style.isLayerDraped(e2)) {
                  if (e2.isHidden(this.transform.zoom)) {
                    ++this.currentLayer;
                    continue;
                  }
                  this.currentLayer = this.terrain.renderBatch(this.currentLayer), this._lastOcclusionLayer = Math.max(this.currentLayer, this._lastOcclusionLayer);
                } else {
                  if (!L2 && e2.is3D(r2) && !r2) {
                    const e3 = this.currentLayer, t3 = (e4) => {
                      for (this.currentLayer = 0; this.currentLayer < h2.length; this.currentLayer++) {
                        const t4 = h2[this.currentLayer];
                        if (ta[t4.type]) {
                          const i4 = this.style.getLayerSourceCache(t4);
                          ta[t4.type](this, i4, t4, C3(t4, i4), e4);
                        }
                      }
                    };
                    t3("initialize"), t3("reset"), this.currentLayer = e3, L2 = true;
                  }
                  if (l2 && !D3 && this.terrain && !this.transform.isOrthographic && (D3 = true, this.blitDepth()), c2 && -1 !== A2 && this.currentLayer === A2 + 1 && !this.transform.isOrthographic && this.blitDepth(), this.terrain || this._renderTileClippingMasks(e2, i3, i3 ? f2[i3.id] : void 0), this.renderLayer(this, i3, e2, C3(e2, i3)), !this.terrain && w2 && R2 > 0 && e2.hasShadowPass() && 0 == --R2 && (w2.drawGroundShadows(), this.firstLightBeamLayer <= this.currentLayer)) {
                    const e3 = this.currentLayer;
                    for (this.renderPass = "light-beam", this.currentLayer = this.firstLightBeamLayer; this.currentLayer <= e3; this.currentLayer++) {
                      const e4 = h2[this.currentLayer];
                      if (!e4.hasLightBeamPass()) continue;
                      const i4 = t2.getLayerSourceCache(e4);
                      this.renderLayer(this, i4, e4, i4 ? m2[i4.id] : void 0);
                    }
                    this.currentLayer = e3, this.renderPass = "translucent";
                  }
                  if (this.currentLayer >= this._lastOcclusionLayer && this.layersWithOcclusionOpacity.length > 0) {
                    const e3 = this.currentLayer;
                    this.depthOcclusion = true;
                    for (const e4 of this.layersWithOcclusionOpacity) {
                      this.currentLayer = e4;
                      const i4 = h2[this.currentLayer], o3 = t2.getLayerSourceCache(i4), s3 = o3 ? m2[o3.id] : void 0;
                      this.terrain || this._renderTileClippingMasks(i4, o3, o3 ? f2[o3.id] : void 0), this.renderLayer(this, o3, i4, s3);
                    }
                    this.depthOcclusion = false, this.currentLayer = e3, this.renderPass = "translucent", this.layersWithOcclusionOpacity = [];
                  }
                  ++this.currentLayer;
                }
              }
              if (this.terrain && this.terrain.postRender(), this._snow && this._snow.draw(this), this._rain && this._rain.draw(this), this.options.showTileBoundaries || this.options.showQueryGeometry || this.options.showTileAABBs) {
                let i3 = null;
                h2.forEach((e2) => {
                  const o3 = t2.getLayerSourceCache(e2);
                  o3 && !e2.isHidden(this.transform.zoom) && o3.getVisibleCoordinates().length && (!i3 || i3.getSource().maxzoom < o3.getSource().maxzoom) && (i3 = o3);
                }), i3 && this.options.showTileBoundaries && Qn.debug(this, i3, i3.getVisibleCoordinates(), e.am.red, false, this.options.showParseStatus);
              }
              this.terrain && this._debugParams.showTerrainProxyTiles && Qn.debug(this, this.terrain.proxySourceCache, this.terrain.proxyCoords, new e.am(1, 0.8, 0.1, 1), true, this.options.showParseStatus), this.options.showPadding && function(e2) {
                const t3 = e2.transform.padding;
                dn(e2, e2.transform.height - (t3.top || 0), 3, rn), dn(e2, t3.bottom || 0, 3, nn), un(e2, t3.left || 0, 3, an), un(e2, e2.transform.width - (t3.right || 0), 3, ln);
                const i3 = e2.transform.centerPoint;
                !function(e3, t4, i4, o3) {
                  _n(e3, t4 - 1, i4 - 10, 2, 20, o3), _n(e3, t4 - 10, i4 - 1, 20, 2, o3);
                }(e2, i3.x, e2.transform.height - i3.y, cn);
              }(this), this.context.setDefault(), this.frameCounter = (this.frameCounter + 1) % Number.MAX_SAFE_INTEGER, this.tileLoaded && this.options.speedIndexTiming && (this.loadTimeStamps.push(performance.now()), this.saveCanvasCopy()), _2 || (this.conflationActive = false);
            }
            prepareLayer(e2) {
              this.gpuTimingStart(e2);
              const { unsupportedLayers: t2 } = this.transform.projection, i2 = !t2 || !t2.includes(e2.type);
              if (ea2[e2.type] && (i2 || this.terrain && "custom" === e2.type)) {
                const t3 = this.style.getLayerSourceCache(e2);
                ea2[e2.type](e2, t3, this);
              }
              this.gpuTimingEnd();
            }
            renderLayer(e2, t2, i2, o2) {
              i2.isHidden(this.transform.zoom) || ("background" === i2.type || "sky" === i2.type || "custom" === i2.type || "model" === i2.type || "raster" === i2.type || "raster-particle" === i2.type || o2 && o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), e2.transform.projection.unsupportedLayers && e2.transform.projection.unsupportedLayers.includes(i2.type) && (!e2.terrain || "custom" !== i2.type) || "clip" === i2.type || Qn[i2.type](e2, t2, i2, o2, this.style.placement.variableOffsets, this.options.isInitialLoad), this.gpuTimingEnd());
            }
            gpuTimingStart(e2) {
              if (!this.options.gpuTiming) return;
              const t2 = this.context.extTimerQuery, i2 = this.context.gl;
              let o2 = this.gpuTimers[e2.id];
              o2 || (o2 = this.gpuTimers[e2.id] = { calls: 0, cpuTime: 0, query: i2.createQuery() }), o2.calls++, i2.beginQuery(t2.TIME_ELAPSED_EXT, o2.query);
            }
            gpuTimingDeferredRenderStart() {
              if (this.options.gpuTimingDeferredRender) {
                const e2 = this.context.extTimerQuery, t2 = this.context.gl, i2 = t2.createQuery();
                this.deferredRenderGpuTimeQueries.push(i2), t2.beginQuery(e2.TIME_ELAPSED_EXT, i2);
              }
            }
            gpuTimingDeferredRenderEnd() {
              this.options.gpuTimingDeferredRender && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            gpuTimingEnd() {
              this.options.gpuTiming && this.context.gl.endQuery(this.context.extTimerQuery.TIME_ELAPSED_EXT);
            }
            collectGpuTimers() {
              const e2 = this.gpuTimers;
              return this.gpuTimers = {}, e2;
            }
            collectDeferredRenderGpuQueries() {
              const e2 = this.deferredRenderGpuTimeQueries;
              return this.deferredRenderGpuTimeQueries = [], e2;
            }
            queryGpuTimers(e2) {
              const t2 = {};
              for (const i2 in e2) {
                const o2 = e2[i2], s2 = this.context.extTimerQuery, r2 = s2.getQueryParameter(o2.query, this.context.gl.QUERY_RESULT) / 1e6;
                s2.deleteQueryEXT(o2.query), t2[i2] = r2;
              }
              return t2;
            }
            queryGpuTimeDeferredRender(e2) {
              if (!this.options.gpuTimingDeferredRender) return 0;
              const t2 = this.context.gl;
              let i2 = 0;
              for (const o2 of e2) i2 += t2.getQueryParameter(o2, t2.QUERY_RESULT) / 1e6, t2.deleteQuery(o2);
              return i2;
            }
            translatePosMatrix(t2, i2, o2, s2, r2) {
              if (!o2[0] && !o2[1]) return t2;
              const n2 = r2 ? "map" === s2 ? this.transform.angle : 0 : "viewport" === s2 ? -this.transform.angle : 0;
              if (n2) {
                const e2 = Math.sin(n2), t3 = Math.cos(n2);
                o2 = [o2[0] * t3 - o2[1] * e2, o2[0] * e2 + o2[1] * t3];
              }
              const a2 = [r2 ? o2[0] : e.aw(i2, o2[0], this.transform.zoom), r2 ? o2[1] : e.aw(i2, o2[1], this.transform.zoom), 0], l2 = new Float32Array(16);
              return e.bo(l2, t2, a2), l2;
            }
            saveTileTexture(e2) {
              const t2 = e2.size[0], i2 = this._tileTextures[t2];
              i2 ? i2.push(e2) : this._tileTextures[t2] = [e2];
            }
            getTileTexture(e2) {
              const t2 = this._tileTextures[e2];
              return t2 && t2.length > 0 ? t2.pop() : null;
            }
            terrainRenderModeElevated() {
              return this.style && !!this.style.getTerrain() && !!this.terrain && !this.terrain.renderingToTexture || this.forceTerrainMode;
            }
            linearFloatFilteringSupported() {
              return null != this.context.extTextureFloatLinear;
            }
            currentGlobalDefines(e2, t2, i2) {
              const o2 = void 0 === i2 ? this.terrain && this.terrain.renderingToTexture : i2, s2 = [];
              return this.style && this.style.enable3dLights() && ("globeRaster" === e2 || "terrainRaster" === e2 ? (s2.push("LIGHTING_3D_MODE"), s2.push("LIGHTING_3D_ALPHA_EMISSIVENESS")) : o2 || s2.push("LIGHTING_3D_MODE")), "shadow" === this.renderPass && (this._shadowMapDebug || s2.push("DEPTH_TEXTURE")), this.terrainRenderModeElevated() && (s2.push("TERRAIN"), this.linearFloatFilteringSupported() && s2.push("TERRAIN_DEM_FLOAT_FORMAT")), "globe" === this.transform.projection.name && s2.push("GLOBE"), !this._fogVisible || o2 || void 0 !== t2 && !t2 || s2.push("FOG", "FOG_DITHERING"), o2 && s2.push("RENDER_TO_TEXTURE"), this._showOverdrawInspector && s2.push("OVERDRAW_INSPECTOR"), s2;
            }
            getOrCreateProgram(e2, t2) {
              this.cache = this.cache || {};
              const i2 = t2 && t2.defines || [], o2 = t2 && t2.config, s2 = this.currentGlobalDefines(e2, t2 && t2.overrideFog, t2 && t2.overrideRtt).concat(i2), r2 = $s.cacheKey(jo[e2], e2, s2, o2);
              return this.cache[r2] || (this.cache[r2] = new $s(this.context, e2, jo[e2], o2, Ir[e2], s2)), this.cache[r2];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.frontFace.setDefault(), this.context.cullFaceSide.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const e2 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(e2.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new e.T(this.context, this.debugOverlayCanvas, this.context.gl.RGBA8));
            }
            destroy() {
              this._terrain && this._terrain.destroy(), this._atmosphere && (this._atmosphere.destroy(), this._atmosphere = void 0), this.globeSharedBuffers && this.globeSharedBuffers.destroy(), this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy(), this._wireframeDebugCache.destroy(), this.depthFBO && (this.depthFBO.destroy(), this.depthFBO = void 0, this.depthTexture = void 0), this.emptyDepthTexture && this.emptyDepthTexture.destroy();
            }
            prepareDrawTile() {
              this.terrain && this.terrain.prepareDrawTile();
            }
            uploadCommonLightUniforms(t2, i2) {
              if (this.style.enable3dLights()) {
                const o2 = this.style.directionalLight, s2 = this.style.ambientLight;
                if (o2 && s2) {
                  const r2 = ((t3, i3, o3) => {
                    const s3 = t3.properties.get("direction"), r3 = "none" === t3.properties.get("color-use-theme"), n2 = t3.properties.get("color").toRenderColor(r3 ? null : o3.getLut(t3.scope)).toArray01(), a2 = t3.properties.get("intensity"), l2 = "none" === i3.properties.get("color-use-theme"), c2 = i3.properties.get("color").toRenderColor(l2 ? null : o3.getLut(i3.scope)).toArray01(), h2 = i3.properties.get("intensity"), d2 = [s3.x, s3.y, s3.z], u5 = e.dw(c2, h2), _2 = e.dw(n2, a2);
                    return { u_lighting_ambient_color: u5, u_lighting_directional_dir: d2, u_lighting_directional_color: _2, u_ground_radiance: Zs(d2, _2, u5) };
                  })(o2, s2, this.style);
                  i2.setLightsUniformValues(t2, r2);
                }
              }
            }
            uploadCommonUniforms(t2, i2, o2, s2, r2) {
              if (this.uploadCommonLightUniforms(t2, i2), this.terrain && this.terrain.renderingToTexture) return;
              const n2 = this.style.fog;
              if (n2) {
                const r3 = n2.getOpacity(this.transform.pitch), a2 = ((t3, i3, o3, s3, r4, n3, a3, l2, c2, h2, d2, u5) => {
                  const _2 = t3.transform, p2 = "none" === i3.properties.get("color-use-theme"), f2 = i3.properties.get("color").toRenderColor(p2 ? null : t3.style.getLut(i3.scope)).toArray01();
                  f2[3] = s3;
                  const m2 = t3.frameCounter / 1e3 % 1, [g2, v3] = i3.properties.get("vertical-range");
                  return { u_fog_matrix: o3 ? _2.calculateFogTileMatrix(o3) : u5 || t3.identityMat, u_fog_range: i3.getFovAdjustedRange(_2._fov), u_fog_color: f2, u_fog_horizon_blend: i3.properties.get("horizon-blend"), u_fog_vertical_limit: [Math.min(g2, v3), v3], u_fog_temporal_offset: m2, u_frustum_tl: r4, u_frustum_tr: n3, u_frustum_br: a3, u_frustum_bl: l2, u_globe_pos: c2, u_globe_radius: h2, u_viewport: d2, u_globe_transition: e.ah(_2.zoom), u_is_globe: +("globe" === _2.projection.name) };
                })(this, n2, o2, r3, this.transform.frustumCorners.TL, this.transform.frustumCorners.TR, this.transform.frustumCorners.BR, this.transform.frustumCorners.BL, this.transform.globeCenterInViewSpace, this.transform.globeRadius, [this.transform.width * e.q.devicePixelRatio, this.transform.height * e.q.devicePixelRatio], s2);
                i2.setFogUniformValues(t2, a2);
              }
              r2 && i2.setCutoffUniformValues(t2, r2.uniformValues);
            }
            setTileLoadedFlag(e2) {
              this.tileLoaded = e2;
            }
            saveCanvasCopy() {
              const e2 = this.canvasCopy();
              e2 && (this.frameCopies.push(e2), this.tileLoaded = false);
            }
            canvasCopy() {
              const e2 = this.context.gl, t2 = e2.createTexture();
              return e2.bindTexture(e2.TEXTURE_2D, t2), e2.copyTexImage2D(e2.TEXTURE_2D, 0, e2.RGBA, 0, 0, e2.drawingBufferWidth, e2.drawingBufferHeight, 0), t2;
            }
            getCanvasCopiesAndTimestamps() {
              return { canvasCopies: this.frameCopies, timeStamps: this.loadTimeStamps };
            }
            averageElevationNeedsEasing() {
              if (!this.transform._elevation) return false;
              const e2 = this.style && this.style.fog;
              return !!e2 && 0 !== e2.getOpacity(this.transform.pitch);
            }
            getBackgroundTiles() {
              const e2 = this._backgroundTiles, t2 = this._backgroundTiles = {}, i2 = this.transform.coveringTiles({ tileSize: 512 });
              for (const o2 of i2) t2[o2.key] = e2[o2.key] || new wt(o2, 512, this.transform.tileZoom, this);
              return t2;
            }
            clearBackgroundTiles() {
              this._backgroundTiles = {};
            }
            isSourceForClippingOrConflation(e2, t2) {
              return !(!e2.is3D(!(!this.terrain || !this.terrain.enabled)) || "clip" !== e2.type && (e2.minzoom && e2.minzoom > this.transform.zoom || (this.style._clipLayerPresent || "building" !== e2.sourceLayer) && (!t2 || "batched-model" !== t2.type)));
            }
            isTileAffectedByFog(e2) {
              if (!this.style || !this.style.fog) return false;
              if ("globe" === this.transform.projection.name) return true;
              let t2 = this._cachedTileFogOpacities[e2.key];
              return t2 || (this._cachedTileFogOpacities[e2.key] = t2 = this.style.fog.getOpacityForTile(e2)), t2[0] >= Fe || t2[1] >= Fe;
            }
            setupDepthForOcclusion(e2, t2, i2) {
              const o2 = this.context, s2 = o2.gl, r2 = !!i2;
              var n2;
              i2 || (i2 = { u_dem: 2, u_dem_prev: 4, u_dem_tl: [0, 0], u_dem_tl_prev: [0, 0], u_dem_scale: 0, u_dem_scale_prev: 0, u_dem_size: 0, u_dem_lerp: 1, u_depth: 3, u_depth_size_inv: [0, 0], u_depth_range_unpack: [0, 1], u_occluder_half_size: 16, u_occlusion_depth_offset: -1e-4, u_exaggeration: 0 }), o2.activeTexture.set(s2.TEXTURE3), e2 && this.depthFBO && this.depthTexture ? (this.depthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), i2.u_depth_size_inv = [1 / this.depthFBO.width, 1 / this.depthFBO.height], i2.u_depth_range_unpack = [2 / ((n2 = this.depthRangeFor3D)[1] - n2[0]), -1 - 2 * n2[0] / (n2[1] - n2[0])], i2.u_occluder_half_size = 0.5 * this.occlusionParams.occluderSize, i2.u_occlusion_depth_offset = this.occlusionParams.depthOffset) : this.emptyDepthTexture.bind(s2.NEAREST, s2.CLAMP_TO_EDGE), o2.activeTexture.set(s2.TEXTURE0), r2 || t2.setTerrainUniformValues(o2, i2);
            }
          }
          function oa(e2, t2) {
            let i2 = false, o2 = null;
            const s2 = () => {
              o2 = null, i2 && (e2(), o2 = setTimeout(s2, t2), i2 = false);
            };
            return () => (i2 = true, o2 || s2(), o2);
          }
          class sa {
            constructor(t2) {
              this._hashName = t2 && encodeURIComponent(t2), e.aV(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = oa(this._updateHashUnthrottled.bind(this), 300);
            }
            addTo(e2) {
              return this._map = e2, window.addEventListener("hashchange", this._onHashChange, false), e2.on("moveend", this._updateHash), this;
            }
            remove() {
              return this._map ? (this._map.off("moveend", this._updateHash), window.removeEventListener("hashchange", this._onHashChange, false), clearTimeout(this._updateHash()), this._map = void 0, this) : this;
            }
            getHashString() {
              const e2 = this._map;
              if (!e2) return "";
              const t2 = ra(e2);
              if (this._hashName) {
                const e3 = this._hashName;
                let i2 = false;
                const o2 = location.hash.slice(1).split("&").map((o3) => {
                  const s2 = o3.split("=")[0];
                  return s2 === e3 ? (i2 = true, `${s2}=${t2}`) : o3;
                }).filter((e4) => e4);
                return i2 || o2.push(`${e3}=${t2}`), `#${o2.join("&")}`;
              }
              return `#${t2}`;
            }
            _getCurrentHash() {
              const e2 = location.hash.replace("#", "");
              if (this._hashName) {
                let t2;
                return e2.split("&").map((e3) => e3.split("=")).forEach((e3) => {
                  e3[0] === this._hashName && (t2 = e3);
                }), (t2 && t2[1] || "").split("/");
              }
              return e2.split("/");
            }
            _onHashChange() {
              const e2 = this._map;
              if (!e2) return false;
              const t2 = this._getCurrentHash();
              if (t2.length >= 3 && !t2.some((e3) => isNaN(Number(e3)))) {
                const i2 = e2.dragRotate.isEnabled() && e2.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : e2.getBearing();
                return e2.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: i2, pitch: +(t2[4] || 0) }), true;
              }
              return false;
            }
            _updateHashUnthrottled() {
              history.replaceState(history.state, "", location.href.replace(/(#.+)?$/, this.getHashString()));
            }
          }
          function ra(e2, t2) {
            const i2 = e2.getCenter(), o2 = Math.round(100 * e2.getZoom()) / 100, s2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), r2 = Math.pow(10, s2), n2 = Math.round(i2.lng * r2) / r2, a2 = Math.round(i2.lat * r2) / r2, l2 = e2.getBearing(), c2 = e2.getPitch();
            let h2 = t2 ? `/${n2}/${a2}/${o2}` : `${o2}/${a2}/${n2}`;
            return (l2 || c2) && (h2 += "/" + Math.round(10 * l2) / 10), c2 && (h2 += `/${Math.round(c2)}`), h2;
          }
          const na = { linearity: 0.3, easing: e.ew(0, 0, 0.3, 1) }, aa2 = e.l({ deceleration: 2500, maxSpeed: 1400 }, na), la = e.l({ deceleration: 20, maxSpeed: 1400 }, na), ca3 = e.l({ deceleration: 1e3, maxSpeed: 360 }, na), ha = e.l({ deceleration: 1e3, maxSpeed: 90 }, na);
          class da2 {
            constructor(e2) {
              this._map = e2, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(t2) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: e.q.now(), settings: t2 });
            }
            _drainInertiaBuffer() {
              const t2 = this._inertiaBuffer, i2 = e.q.now();
              for (; t2.length > 0 && i2 - t2[0].time > 160; ) t2.shift();
            }
            _onMoveEnd(t2) {
              if (this._map._prefersReducedMotion()) return;
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2) return;
              const i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new e.P(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: e2 } of this._inertiaBuffer) i2.zoom += e2.zoomDelta || 0, i2.bearing += e2.bearingDelta || 0, i2.pitch += e2.pitchDelta || 0, e2.panDelta && i2.pan._add(e2.panDelta), e2.around && (i2.around = e2.around), e2.pinchAround && (i2.pinchAround = e2.pinchAround);
              const o2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
              if (i2.pan.mag()) {
                const r2 = _a(i2.pan.mag(), o2, e.l({}, aa2, t2 || {}));
                s2.offset = i2.pan.mult(r2.amount / i2.pan.mag()), s2.center = this._map.transform.center, ua(s2, r2);
              }
              if (i2.zoom) {
                const e2 = _a(i2.zoom, o2, la);
                s2.zoom = this._map.transform.zoom + e2.amount, ua(s2, e2);
              }
              if (i2.bearing) {
                const t3 = _a(i2.bearing, o2, ca3);
                s2.bearing = this._map.transform.bearing + e.aD(t3.amount, -179, 179), ua(s2, t3);
              }
              if (i2.pitch) {
                const e2 = _a(i2.pitch, o2, ha);
                s2.pitch = this._map.transform.pitch + e2.amount, ua(s2, e2);
              }
              if (s2.zoom || s2.bearing) {
                const e2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                s2.around = e2 ? this._map.unproject(e2) : this._map.getCenter();
              }
              return this.clear(), s2.noMoveStart = true, s2;
            }
          }
          function ua(e2, t2) {
            (!e2.duration || e2.duration < t2.duration) && (e2.duration = t2.duration, e2.easing = t2.easing);
          }
          function _a(t2, i2, o2) {
            const { maxSpeed: s2, linearity: r2, deceleration: n2 } = o2, a2 = e.aD(t2 * r2 / (i2 / 1e3), -s2, s2), l2 = Math.abs(a2) / (n2 * r2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: a2 * (l2 / 2) };
          }
          class pa extends e.A {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2, s2 = {}) {
              const r2 = g(i2.getCanvasContainer(), o2), n2 = i2.unproject(r2);
              super(t2, e.l({ point: r2, lngLat: n2, originalEvent: o2 }, s2)), this._defaultPrevented = false, this.target = i2;
            }
          }
          class fa extends e.A {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t2, i2, o2) {
              const s2 = "touchend" === t2 ? o2.changedTouches : o2.touches, r2 = v2(i2.getCanvasContainer(), s2), n2 = r2.map((e2) => i2.unproject(e2)), a2 = r2.reduce((e2, t3, i3, o3) => e2.add(t3.div(o3.length)), new e.P(0, 0));
              super(t2, { points: r2, point: a2, lngLats: n2, lngLat: i2.unproject(a2), originalEvent: o2 }), this._defaultPrevented = false;
            }
          }
          class ma extends e.A {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e2, t2) {
              super("wheel", { originalEvent: t2 }), this._defaultPrevented = false;
            }
          }
          class ga {
            constructor(e2, t2) {
              this._map = e2, this._clickTolerance = t2.clickTolerance;
            }
            reset() {
              this._mousedownPos = void 0;
            }
            wheel(e2) {
              return this._firePreventable(new ma(this._map, e2));
            }
            mousedown(e2, t2) {
              return this._mousedownPos = t2, this._firePreventable(new pa(e2.type, this._map, e2));
            }
            mouseup(e2) {
              this._map.fire(new pa(e2.type, this._map, e2));
            }
            preclick(t2) {
              const i2 = e.l({}, t2);
              i2.type = "preclick", this._map.fire(new pa(i2.type, this._map, i2));
            }
            click(e2, t2) {
              this._mousedownPos && this._mousedownPos.dist(t2) >= this._clickTolerance || (this.preclick(e2), this._map.fire(new pa(e2.type, this._map, e2)));
            }
            dblclick(e2) {
              return this._firePreventable(new pa(e2.type, this._map, e2));
            }
            mouseover(e2) {
              this._map.fire(new pa(e2.type, this._map, e2));
            }
            mouseout(e2) {
              this._map.fire(new pa(e2.type, this._map, e2));
            }
            touchstart(e2) {
              return this._firePreventable(new fa(e2.type, this._map, e2));
            }
            touchmove(e2) {
              this._map.fire(new fa(e2.type, this._map, e2));
            }
            touchend(e2) {
              this._map.fire(new fa(e2.type, this._map, e2));
            }
            touchcancel(e2) {
              this._map.fire(new fa(e2.type, this._map, e2));
            }
            _firePreventable(e2) {
              if (this._map.fire(e2), e2.defaultPrevented) return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class va {
            constructor(e2) {
              this._map = e2;
            }
            reset() {
              this._delayContextMenu = false, this._contextMenuEvent = void 0;
            }
            mousemove(e2) {
              this._map.fire(new pa(e2.type, this._map, e2));
            }
            mousedown() {
              this._delayContextMenu = true;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new pa("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(e2) {
              this._delayContextMenu ? this._contextMenuEvent = e2 : this._map.fire(new pa(e2.type, this._map, e2)), this._map.listens("contextmenu") && e2.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class ya {
            constructor(e2, t2) {
              this._map = e2, this._el = e2.getCanvasContainer(), this._container = e2.getContainer(), this._clickTolerance = t2.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(e2, t2) {
              this.isEnabled() && e2.shiftKey && 0 === e2.button && (_(), this._startPos = this._lastPos = t2, this._active = true);
            }
            mousemoveWindow(e2, t2) {
              if (!this._active) return;
              const i2 = t2, o2 = this._startPos, s2 = this._lastPos;
              if (!o2 || !s2 || s2.equals(i2) || !this._box && i2.dist(o2) < this._clickTolerance) return;
              this._lastPos = i2, this._box || (this._box = l("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", e2));
              const r2 = Math.min(o2.x, i2.x), n2 = Math.max(o2.x, i2.x), a2 = Math.min(o2.y, i2.y), c2 = Math.max(o2.y, i2.y);
              this._map._requestDomTask(() => {
                this._box && (this._box.style.transform = `translate(${r2}px,${a2}px)`, this._box.style.width = n2 - r2 + "px", this._box.style.height = c2 - a2 + "px");
              });
            }
            mouseupWindow(t2, i2) {
              if (!this._active) return;
              const o2 = this._startPos, s2 = i2;
              if (o2 && 0 === t2.button) {
                if (this.reset(), m(), o2.x !== s2.x || o2.y !== s2.y) return this._map.fire(new e.A("boxzoomend", { originalEvent: t2 })), { cameraAnimation: (e2) => e2.fitScreenCoordinates(o2, s2, this._map.getBearing(), { linear: false }) };
                this._fireEvent("boxzoomcancel", t2);
              }
            }
            keydown(e2) {
              this._active && 27 === e2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", e2));
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (this._box.remove(), this._box = null), p(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(t2, i2) {
              return this._map.fire(new e.A(t2, { originalEvent: i2 }));
            }
          }
          function xa(e2, t2) {
            const i2 = {};
            for (let o2 = 0; o2 < e2.length; o2++) i2[e2[o2].identifier] = t2[o2];
            return i2;
          }
          class ba {
            constructor(e2) {
              this.reset(), this.numTouches = e2.numTouches;
            }
            reset() {
              this.centroid = void 0, this.startTime = 0, this.touches = {}, this.aborted = false;
            }
            touchstart(t2, i2, o2) {
              (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (0 === this.startTime && (this.startTime = t2.timeStamp), o2.length === this.numTouches && (this.centroid = function(t3) {
                const i3 = new e.P(0, 0);
                for (const e2 of t3) i3._add(e2);
                return i3.div(t3.length);
              }(i2), this.touches = xa(o2, i2)));
            }
            touchmove(e2, t2, i2) {
              if (this.aborted || !this.centroid) return;
              const o2 = xa(i2, t2);
              for (const e3 in this.touches) {
                const t3 = o2[e3];
                (!t3 || t3.dist(this.touches[e3]) > 30) && (this.aborted = true);
              }
            }
            touchend(e2, t2, i2) {
              if ((!this.centroid || e2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
                const e3 = !this.aborted && this.centroid;
                if (this.reset(), e3) return e3;
              }
            }
          }
          class wa {
            constructor(e2) {
              this.singleTap = new ba(e2), this.numTaps = e2.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, this.lastTap = void 0, this.count = 0, this.singleTap.reset();
            }
            touchstart(e2, t2, i2) {
              this.singleTap.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this.singleTap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this.singleTap.touchend(e2, t2, i2);
              if (o2) {
                const t3 = e2.timeStamp - this.lastTime < 500, i3 = !this.lastTap || this.lastTap.dist(o2) < 30;
                if (t3 && i3 || this.reset(), this.count++, this.lastTime = e2.timeStamp, this.lastTap = o2, this.count === this.numTaps) return this.reset(), o2;
              }
            }
          }
          class Ta {
            constructor() {
              this._zoomIn = new wa({ numTouches: 1, numTaps: 2 }), this._zoomOut = new wa({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(e2, t2, i2) {
              this._zoomIn.touchstart(e2, t2, i2), this._zoomOut.touchstart(e2, t2, i2);
            }
            touchmove(e2, t2, i2) {
              this._zoomIn.touchmove(e2, t2, i2), this._zoomOut.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              const o2 = this._zoomIn.touchend(e2, t2, i2), s2 = this._zoomOut.touchend(e2, t2, i2);
              return o2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() + 1, around: t3.unproject(o2) }, { originalEvent: e2 }) }) : s2 ? (this._active = true, e2.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (t3) => t3.easeTo({ duration: 300, zoom: t3.getZoom() - 1, around: t3.unproject(s2) }, { originalEvent: e2 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          const Ea = { 0: 1, 2: 2 }, Sa = { Control: "ctrlKey", Alt: "altKey", Shift: "shiftKey", Meta: "metaKey" };
          class Ia {
            constructor(e2) {
              this.reset(), this._clickTolerance = e2.clickTolerance || 1;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false, this._moved = false, this._lastPoint = void 0, this._eventButton = void 0;
            }
            _correctButton(e2, t2) {
              return false;
            }
            _move(e2, t2) {
              return {};
            }
            mousedown(e2, t2) {
              if (this._lastPoint) return;
              const i2 = y(e2);
              this._correctButton(e2, i2) && (this._lastPoint = t2, this._eventButton = i2);
            }
            mousemoveWindow(e2, t2) {
              const i2 = this._lastPoint;
              if (i2) {
                if (e2.preventDefault(), null != this._eventButton && function(e3, t3) {
                  const i3 = Ea[t3];
                  return void 0 === e3.buttons || (e3.buttons & i3) !== i3;
                }(e2, this._eventButton)) this.reset();
                else if (this._moved || !(t2.dist(i2) < this._clickTolerance)) return this._moved = true, this._lastPoint = t2, this._move(i2, t2);
              }
            }
            mouseupWindow(e2) {
              this._lastPoint && y(e2) === this._eventButton && (this._moved && m(), this.reset());
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ca extends Ia {
            mousedown(e2, t2) {
              super.mousedown(e2, t2), this._lastPoint && (this._active = true);
            }
            _correctButton(e2, t2) {
              return 0 === t2 && !e2.ctrlKey;
            }
            _move(e2, t2) {
              return { around: t2, panDelta: t2.sub(e2) };
            }
          }
          class Ra extends Ia {
            constructor(e2) {
              super(e2), this._pitchRotateKey = e2.pitchRotateKey ? Sa[e2.pitchRotateKey] : void 0;
            }
            _correctButton(e2, t2) {
              return this._pitchRotateKey ? 0 === t2 && e2[this._pitchRotateKey] : 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = 0.8 * (t2.x - e2.x);
              if (i2) return this._active = true, { bearingDelta: i2 };
            }
            contextmenu(e2) {
              this._pitchRotateKey || e2.preventDefault();
            }
          }
          class Da extends Ia {
            constructor(e2) {
              super(e2), this._pitchRotateKey = e2.pitchRotateKey ? Sa[e2.pitchRotateKey] : void 0;
            }
            _correctButton(e2, t2) {
              return this._pitchRotateKey ? 0 === t2 && e2[this._pitchRotateKey] : 0 === t2 && e2.ctrlKey || 2 === t2;
            }
            _move(e2, t2) {
              const i2 = -0.5 * (t2.y - e2.y);
              if (i2) return this._active = true, { pitchDelta: i2 };
            }
            contextmenu(e2) {
              this._pitchRotateKey || e2.preventDefault();
            }
          }
          class Aa {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._minTouches = 1, this._clickTolerance = i2.clickTolerance || 1, this.reset(), e.aV(["_addTouchPanBlocker", "_showTouchPanBlockerAlert"], this);
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new e.P(0, 0);
            }
            touchstart(e2, t2, i2) {
              return this._calculateTransform(e2, t2, i2);
            }
            touchmove(t2, i2, o2) {
              if (this._active && !(o2.length < this._minTouches)) {
                if (this._map._cooperativeGestures && !this._map.isMoving()) {
                  if (1 === o2.length && !e.ex()) return void this._showTouchPanBlockerAlert();
                  "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
                }
                return t2.cancelable && t2.preventDefault(), this._calculateTransform(t2, i2, o2);
              }
            }
            touchend(e2, t2, i2) {
              this._calculateTransform(e2, t2, i2), this._active && i2.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(t2, i2, o2) {
              o2.length > 0 && (this._active = true);
              const s2 = xa(o2, i2), r2 = new e.P(0, 0), n2 = new e.P(0, 0);
              let a2 = 0;
              for (const e2 in s2) {
                const t3 = s2[e2], i3 = this._touches[e2];
                i3 && (r2._add(t3), n2._add(t3.sub(i3)), a2++, s2[e2] = t3);
              }
              if (this._touches = s2, a2 < this._minTouches || !n2.mag()) return;
              const l2 = n2.div(a2);
              return this._sum._add(l2), this._sum.mag() < this._clickTolerance ? void 0 : { around: r2.div(a2), panDelta: l2 };
            }
            enable() {
              this._enabled = true, this._map._cooperativeGestures && (this._addTouchPanBlocker(), this._el.classList.add("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page"));
            }
            disable() {
              this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove(), this._el.classList.remove("mapboxgl-touch-pan-blocker-override", "mapboxgl-scrollable-page")), this.reset();
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            _addTouchPanBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-touch-pan-blocker", this._map._container), this._alertContainer.textContent = this._map._getUIString("TouchPanBlocker.Message"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showTouchPanBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-touch-pan-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-touch-pan-blocker-show"), this._alertContainer.removeAttribute("role");
              }, 500);
            }
          }
          class La {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, this._firstTwoTouches = void 0;
            }
            _start(e2) {
            }
            _move(e2, t2, i2) {
              return {};
            }
            touchstart(e2, t2, i2) {
              this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([t2[0], t2[1]]));
            }
            touchmove(e2, t2, i2) {
              const o2 = this._firstTwoTouches;
              if (!o2) return;
              e2.preventDefault();
              const [s2, r2] = o2, n2 = Pa(i2, t2, s2), a2 = Pa(i2, t2, r2);
              if (!n2 || !a2) return;
              const l2 = this._aroundCenter ? null : n2.add(a2).div(2);
              return this._move([n2, a2], l2, e2);
            }
            touchend(e2, t2, i2) {
              if (!this._firstTwoTouches) return;
              const [o2, s2] = this._firstTwoTouches, r2 = Pa(i2, t2, o2), n2 = Pa(i2, t2, s2);
              r2 && n2 || (this._active && m(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(e2) {
              this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Pa(e2, t2, i2) {
            for (let o2 = 0; o2 < e2.length; o2++) if (e2[o2].identifier === i2) return t2[o2];
          }
          function za(e2, t2) {
            return Math.log(e2 / t2) / Math.LN2;
          }
          class Ma extends La {
            reset() {
              super.reset(), this._distance = 0, this._startDistance = 0;
            }
            _start(e2) {
              this._startDistance = this._distance = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._distance;
              if (this._distance = e2[0].dist(e2[1]), this._active || !(Math.abs(za(this._distance, this._startDistance)) < 0.1)) return this._active = true, { zoomDelta: za(this._distance, i2), pinchAround: t2 };
            }
          }
          function Oa(e2, t2) {
            return 180 * e2.angleWith(t2) / Math.PI;
          }
          class Fa extends La {
            reset() {
              super.reset(), this._minDiameter = 0, this._startVector = void 0, this._vector = void 0;
            }
            _start(e2) {
              this._startVector = this._vector = e2[0].sub(e2[1]), this._minDiameter = e2[0].dist(e2[1]);
            }
            _move(e2, t2) {
              const i2 = this._vector;
              if (this._vector = e2[0].sub(e2[1]), i2 && (this._active || !this._isBelowThreshold(this._vector))) return this._active = true, { bearingDelta: Oa(this._vector, i2), pinchAround: t2 };
            }
            _isBelowThreshold(e2) {
              this._minDiameter = Math.min(this._minDiameter, e2.mag());
              const t2 = 25 / (Math.PI * this._minDiameter) * 360, i2 = this._startVector;
              if (!i2) return false;
              const o2 = Oa(e2, i2);
              return Math.abs(o2) < t2;
            }
          }
          function Ba(e2) {
            return Math.abs(e2.y) > Math.abs(e2.x);
          }
          class ka extends La {
            constructor(e2) {
              super(), this._map = e2;
            }
            reset() {
              super.reset(), this._valid = void 0, this._firstMove = void 0, this._lastPoints = void 0;
            }
            _start(e2) {
              this._lastPoints = e2, Ba(e2[0].sub(e2[1])) && (this._valid = false);
            }
            _move(t2, i2, o2) {
              const s2 = this._lastPoints;
              if (!s2) return;
              const r2 = t2[0].sub(s2[0]), n2 = t2[1].sub(s2[1]);
              return this._map._cooperativeGestures && !e.ex() && o2.touches.length < 3 || (this._valid = this.gestureBeginsVertically(r2, n2, o2.timeStamp), !this._valid) ? void 0 : (this._lastPoints = t2, this._active = true, { pitchDelta: (r2.y + n2.y) / 2 * -0.5 });
            }
            gestureBeginsVertically(e2, t2, i2) {
              if (void 0 !== this._valid) return this._valid;
              const o2 = e2.mag() >= 2, s2 = t2.mag() >= 2;
              if (!o2 && !s2) return;
              if (!o2 || !s2) return null == this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
              const r2 = e2.y > 0 == t2.y > 0;
              return Ba(e2) && Ba(t2) && r2;
            }
          }
          const Na = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class Ua {
            constructor() {
              const e2 = Na;
              this._panStep = e2.panStep, this._bearingStep = e2.bearingStep, this._pitchStep = e2.pitchStep, this._rotationDisabled = false;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            keydown(e2) {
              if (e2.altKey || e2.ctrlKey || e2.metaKey) return;
              let t2 = 0, i2 = 0, o2 = 0, s2 = 0, r2 = 0;
              switch (e2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  t2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  t2 = -1;
                  break;
                case 37:
                  e2.shiftKey ? i2 = -1 : (e2.preventDefault(), s2 = -1);
                  break;
                case 39:
                  e2.shiftKey ? i2 = 1 : (e2.preventDefault(), s2 = 1);
                  break;
                case 38:
                  e2.shiftKey ? o2 = 1 : (e2.preventDefault(), r2 = -1);
                  break;
                case 40:
                  e2.shiftKey ? o2 = -1 : (e2.preventDefault(), r2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i2 = 0, o2 = 0), { cameraAnimation: (n2) => {
                const a2 = n2.getZoom();
                n2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: ja, zoom: t2 ? Math.round(a2) + t2 * (e2.shiftKey ? 2 : 1) : a2, bearing: n2.getBearing() + i2 * this._bearingStep, pitch: n2.getPitch() + o2 * this._pitchStep, offset: [-s2 * this._panStep, -r2 * this._panStep], center: n2.getCenter() }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function ja(e2) {
            return e2 * (2 - e2);
          }
          const Va = 4.000244140625, Ga = 1 / 450;
          class qa {
            constructor(t2, i2) {
              this._map = t2, this._el = t2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._lastDelta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = Ga, e.aV(["_onTimeout", "_addScrollZoomBlocker", "_showBlockerAlert"], this);
            }
            setZoomRate(e2) {
              this._defaultZoomRate = e2;
            }
            setWheelZoomRate(e2) {
              this._wheelZoomRate = e2;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(e2) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!e2 && "center" === e2.around, this._map._cooperativeGestures && this._addScrollZoomBlocker());
            }
            disable() {
              this.isEnabled() && (this._enabled = false, this._map._cooperativeGestures && (clearTimeout(this._alertTimer), this._alertContainer.remove()));
            }
            wheel(t2) {
              if (!this.isEnabled()) return;
              if (this._map._cooperativeGestures) {
                if (!(t2.ctrlKey || t2.metaKey || this.isZooming() || e.ex())) return void this._showBlockerAlert();
                "hidden" !== this._alertContainer.style.visibility && (this._alertContainer.style.visibility = "hidden", clearTimeout(this._alertTimer));
              }
              let i2 = t2.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * t2.deltaY : t2.deltaY;
              const o2 = e.q.now(), s2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, 0 !== i2 && i2 % Va == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : s2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = window.setTimeout(this._onTimeout, 40, t2)) : this._type || (this._type = Math.abs(s2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), t2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = t2, this._delta -= i2, this._active || this._start(t2)), t2.preventDefault();
            }
            _onTimeout(e2) {
              this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(e2);
            }
            _start(e2) {
              if (!this._delta) return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const t2 = g(this._el, e2);
              this._aroundPoint = this._aroundCenter ? this._map.transform.centerPoint : t2, this._aroundCoord = this._map.transform.pointCoordinate3D(this._aroundPoint), this._targetZoom = void 0, this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId) return;
              if (this._frameId = null, !this.isActive()) return;
              const t2 = this._map.transform;
              "wheel" === this._type && t2.projection.wrap && (t2._center.lng >= 180 || t2._center.lng <= -180) && (this._prevEase = null, this._easing = null, this._lastWheelEvent = null, this._lastWheelEventTime = 0);
              const i2 = () => t2._terrainEnabled() && this._aroundCoord ? t2.computeZoomRelativeTo(this._aroundCoord) : t2.zoom;
              if (0 !== this._delta) {
                const e2 = "wheel" === this._type && Math.abs(this._delta) > Va ? this._wheelZoomRate : this._defaultZoomRate;
                let o3 = 2 / (1 + Math.exp(-Math.abs(this._delta * e2)));
                this._delta < 0 && 0 !== o3 && (o3 = 1 / o3);
                const s3 = i2(), r3 = Math.pow(2, s3), n3 = "number" == typeof this._targetZoom ? t2.zoomScale(this._targetZoom) : r3;
                this._targetZoom = Math.min(t2.maxZoom, Math.max(t2.minZoom, t2.scaleZoom(n3 * o3))), "wheel" === this._type && (this._startZoom = s3, this._easing = this._smoothOutEasing(200)), this._lastDelta = this._delta, this._delta = 0;
              }
              const o2 = "number" == typeof this._targetZoom ? this._targetZoom : i2(), s2 = this._startZoom, r2 = this._easing;
              let n2, a2 = false;
              if ("wheel" === this._type && s2 && r2) {
                const t3 = Math.min((e.q.now() - this._lastWheelEventTime) / 200, 1), i3 = r2(t3);
                n2 = e.ai(s2, o2, i3), t3 < 1 ? this._frameId || (this._frameId = true) : a2 = true;
              } else n2 = o2, a2 = true;
              this._active = true, a2 && (this._active = false, this._finishTimeout = window.setTimeout(() => {
                this._zooming = false, this._handler._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200));
              let l2 = n2 - i2();
              return l2 * this._lastDelta < 0 && (l2 = 0), { noInertia: true, needsRenderFrame: !a2, zoomDelta: l2, around: this._aroundPoint, aroundCoord: this._aroundCoord, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(t2) {
              let i2 = e.ey;
              if (this._prevEase) {
                const t3 = this._prevEase, o2 = (e.q.now() - t3.start) / t3.duration, s2 = t3.easing(o2 + 0.01) - t3.easing(o2), r2 = 0.27 / Math.sqrt(s2 * s2 + 1e-4) * 0.01, n2 = Math.sqrt(0.0729 - r2 * r2);
                i2 = e.ew(r2, n2, 0.25, 1);
              }
              return this._prevEase = { start: e.q.now(), duration: t2, easing: i2 }, i2;
            }
            blur() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            _addScrollZoomBlocker() {
              this._map && !this._alertContainer && (this._alertContainer = l("div", "mapboxgl-scroll-zoom-blocker", this._map._container), this._alertContainer.textContent = /(Mac|iPad)/i.test(navigator.userAgent) ? this._map._getUIString("ScrollZoomBlocker.CmdMessage") : this._map._getUIString("ScrollZoomBlocker.CtrlMessage"), this._alertContainer.style.fontSize = `${Math.max(10, Math.min(24, Math.floor(0.05 * this._el.clientWidth)))}px`);
            }
            _showBlockerAlert() {
              this._alertContainer.style.visibility = "visible", this._alertContainer.classList.add("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.setAttribute("role", "alert"), clearTimeout(this._alertTimer), this._alertTimer = window.setTimeout(() => {
                this._alertContainer.classList.remove("mapboxgl-scroll-zoom-blocker-show"), this._alertContainer.removeAttribute("role");
              }, 200);
            }
          }
          class Za {
            constructor(e2, t2) {
              this._clickZoom = e2, this._tapZoom = t2;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class Ha {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false;
            }
            blur() {
              this.reset();
            }
            dblclick(e2, t2) {
              return e2.preventDefault(), { cameraAnimation: (i2) => {
                i2.easeTo({ duration: 300, zoom: i2.getZoom() + (e2.shiftKey ? -1 : 1), around: i2.unproject(t2) }, { originalEvent: e2 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Wa {
            constructor() {
              this._tap = new wa({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._swipePoint = void 0, this._swipeTouch = 0, this._tapTime = 0, this._tap.reset();
            }
            touchstart(e2, t2, i2) {
              this._swipePoint || (this._tapTime && e2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = t2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(e2, t2, i2));
            }
            touchmove(e2, t2, i2) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i2[0].identifier !== this._swipeTouch) return;
                  const o2 = t2[0], s2 = o2.y - this._swipePoint.y;
                  return this._swipePoint = o2, e2.preventDefault(), this._active = true, { zoomDelta: s2 / 128 };
                }
              } else this._tap.touchmove(e2, t2, i2);
            }
            touchend(e2, t2, i2) {
              this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(e2, t2, i2) && (this._tapTime = e2.timeStamp);
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class $a {
            constructor(e2, t2, i2) {
              this._el = e2, this._mousePan = t2, this._touchPan = i2;
            }
            enable(e2) {
              this._inertiaOptions = e2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class Xa {
            constructor(e2, t2, i2) {
              this._pitchWithRotate = e2.pitchWithRotate, this._mouseRotate = t2, this._mousePitch = i2;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class Ya {
            constructor(e2, t2, i2, o2) {
              this._el = e2, this._touchZoom = t2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
            }
            enable(e2) {
              this._touchZoom.enable(e2), this._rotationDisabled || this._touchRotate.enable(e2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const Ka = (e2) => e2.zoom || e2.drag || e2.pitch || e2.rotate;
          class Ja extends e.A {
          }
          class Qa {
            constructor() {
              this.constants = [1, 1, 0.01], this.radius = 0;
            }
            setup(t2, i2) {
              const o2 = e.at([], i2, t2);
              this.radius = e.ae(o2[2] < 0 ? e.eA([], o2, this.constants) : [o2[0], o2[1], 0]);
            }
            projectRay(t2) {
              e.eA(t2, t2, this.constants), e.au(t2, t2), e.eB(t2, t2, this.constants);
              const i2 = e.b$([], t2, this.radius);
              if (i2[2] > 0) {
                const t3 = e.b$([], [0, 0, 1], e.bE(i2, [0, 0, 1])), o2 = e.b$([], e.au([], [i2[0], i2[1], 0]), this.radius), s2 = e.cU([], i2, e.b$([], e.at([], e.cU([], o2, t3), i2), 2));
                i2[0] = s2[0], i2[1] = s2[1];
              }
              return i2;
            }
          }
          function el(e2) {
            return e2.panDelta && e2.panDelta.mag() || e2.zoomDelta || e2.bearingDelta || e2.pitchDelta;
          }
          class tl {
            constructor(t2, i2) {
              this._map = t2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new da2(t2), this._bearingSnap = i2.bearingSnap, this._previousActiveHandlers = {}, this._trackingEllipsoid = new Qa(), this._dragOrigin = null, this._eventsInProgress = {}, this._addDefaultHandlers(i2), e.aV(["handleEvent", "handleWindowEvent"], this);
              const o2 = this._el;
              this._listeners = [[o2, "touchstart", { passive: true }], [o2, "touchmove", { passive: false }], [o2, "touchend", void 0], [o2, "touchcancel", void 0], [o2, "mousedown", void 0], [o2, "mousemove", void 0], [o2, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [o2, "mouseover", void 0], [o2, "mouseout", void 0], [o2, "dblclick", void 0], [o2, "click", void 0], [o2, "keydown", { capture: false }], [o2, "keyup", void 0], [o2, "wheel", { passive: false }], [o2, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [e2, t3, i3] of this._listeners) {
                const o3 = e2 === document ? this.handleWindowEvent : this.handleEvent;
                e2.addEventListener(t3, o3, i3);
              }
            }
            destroy() {
              for (const [e2, t2, i2] of this._listeners) {
                const o2 = e2 === document ? this.handleWindowEvent : this.handleEvent;
                e2.removeEventListener(t2, o2, i2);
              }
            }
            _addDefaultHandlers(e2) {
              const t2 = this._map, i2 = t2.getCanvasContainer();
              this._add("mapEvent", new ga(t2, e2));
              const o2 = t2.boxZoom = new ya(t2, e2);
              this._add("boxZoom", o2);
              const s2 = new Ta(), r2 = new Ha();
              t2.doubleClickZoom = new Za(r2, s2), this._add("tapZoom", s2), this._add("clickZoom", r2);
              const n2 = new Wa();
              this._add("tapDragZoom", n2);
              const a2 = t2.touchPitch = new ka(t2);
              this._add("touchPitch", a2);
              const l2 = new Ra(e2), c2 = new Da(e2);
              t2.dragRotate = new Xa(e2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
              const h2 = new Ca(e2), d2 = new Aa(t2, e2);
              t2.dragPan = new $a(i2, h2, d2), this._add("mousePan", h2), this._add("touchPan", d2, ["touchZoom", "touchRotate"]);
              const u5 = new Fa(), _2 = new Ma();
              t2.touchZoomRotate = new Ya(i2, _2, u5, n2), this._add("touchRotate", u5, ["touchPan", "touchZoom"]), this._add("touchZoom", _2, ["touchPan", "touchRotate"]), this._add("blockableMapEvent", new va(t2));
              const p2 = t2.scrollZoom = new qa(t2, this);
              this._add("scrollZoom", p2, ["mousePan"]);
              const f2 = t2.keyboard = new Ua();
              this._add("keyboard", f2);
              for (const i3 of ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]) e2.interactive && e2[i3] && t2[i3].enable(e2[i3]);
            }
            _add(e2, t2, i2) {
              this._handlers.push({ handlerName: e2, handler: t2, allowed: i2 }), this._handlersById[e2] = t2;
            }
            stop(e2) {
              if (!this._updatingCamera) {
                for (const { handler: e3 } of this._handlers) e3.reset();
                this._inertia.clear(), this._fireEvents({}, {}, e2), this._changes = [], this._originalZoom = void 0;
              }
            }
            isActive() {
              for (const { handler: e2 } of this._handlers) if (e2.isActive()) return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return !!Ka(this._eventsInProgress) || this.isZooming();
            }
            _isDragging() {
              return !!this._eventsInProgress.drag;
            }
            _blockedByActive(e2, t2, i2) {
              for (const o2 in e2) if (o2 !== i2 && (!t2 || t2.indexOf(o2) < 0)) return true;
              return false;
            }
            handleWindowEvent(e2) {
              this.handleEvent(e2, `${e2.type}Window`);
            }
            _getMapTouches(e2) {
              const t2 = [];
              for (const i2 of e2) this._el.contains(i2.target) && t2.push(i2);
              return t2;
            }
            handleEvent(e2, t2) {
              this._updatingCamera = true;
              const i2 = "renderFrame" === e2.type, o2 = i2 ? void 0 : e2, s2 = { needsRenderFrame: false }, r2 = {}, n2 = {}, a2 = e2.touches ? this._getMapTouches(e2.touches) : void 0, l2 = a2 ? v2(this._el, a2) : i2 ? void 0 : g(this._el, e2);
              for (const { handlerName: i3, handler: c3, allowed: h3 } of this._handlers) {
                if (!c3.isEnabled()) continue;
                let d2;
                this._blockedByActive(n2, h3, i3) ? c3.reset() : c3[t2 || e2.type] && (d2 = c3[t2 || e2.type](e2, l2, a2), this.mergeHandlerResult(s2, r2, d2, i3, o2), d2 && d2.needsRenderFrame && this._triggerRenderFrame()), (d2 || c3.isActive()) && (n2[i3] = c3);
              }
              const c2 = {};
              for (const e3 in this._previousActiveHandlers) n2[e3] || (c2[e3] = o2);
              this._previousActiveHandlers = n2, (Object.keys(c2).length || el(s2)) && (this._changes.push([s2, r2, c2]), this._triggerRenderFrame()), (Object.keys(n2).length || el(s2)) && this._map._stop(true), this._updatingCamera = false;
              const { cameraAnimation: h2 } = s2;
              h2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], h2(this._map));
            }
            mergeHandlerResult(t2, i2, o2, s2, r2) {
              if (!o2) return;
              e.l(t2, o2);
              const n2 = { handlerName: s2, originalEvent: o2.originalEvent || r2 };
              void 0 !== o2.zoomDelta && (i2.zoom = n2), void 0 !== o2.panDelta && (i2.drag = n2), void 0 !== o2.pitchDelta && (i2.pitch = n2), void 0 !== o2.bearingDelta && (i2.rotate = n2);
            }
            _applyChanges() {
              const t2 = {}, i2 = {}, o2 = {};
              for (const [s2, r2, n2] of this._changes) s2.panDelta && (t2.panDelta = (t2.panDelta || new e.P(0, 0))._add(s2.panDelta)), s2.zoomDelta && (t2.zoomDelta = (t2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (t2.bearingDelta = (t2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (t2.pitchDelta = (t2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (t2.around = s2.around), void 0 !== s2.aroundCoord && (t2.aroundCoord = s2.aroundCoord), void 0 !== s2.pinchAround && (t2.pinchAround = s2.pinchAround), s2.noInertia && (t2.noInertia = s2.noInertia), e.l(i2, r2), e.l(o2, n2);
              this._updateMapTransform(t2, i2, o2), this._changes = [];
            }
            _updateMapTransform(t2, i2, o2) {
              const s2 = this._map, r2 = s2.transform, n2 = (e2) => [e2.x, e2.y, e2.z];
              if (((e2) => {
                const t3 = this._eventsInProgress.drag;
                return t3 && !this._handlersById[t3.handlerName].isActive();
              })() && !el(t2)) {
                const e2 = r2.zoom;
                r2.cameraElevationReference = "sea", null != this._originalZoom && r2._orthographicProjectionAtLowPitch && "globe" !== r2.projection.name && 0 === r2.pitch ? (r2.cameraElevationReference = "ground", r2.zoom = this._originalZoom) : (r2.recenterOnTerrain(), r2.cameraElevationReference = "ground"), e2 !== r2.zoom && this._map._update(true);
              }
              if (r2._isCameraConstrained && s2._stop(true), !el(t2)) return void this._fireEvents(i2, o2, true);
              let { panDelta: a2, zoomDelta: l2, bearingDelta: c2, pitchDelta: h2, around: d2, aroundCoord: u5, pinchAround: _2 } = t2;
              r2._isCameraConstrained && (l2 > 0 && (l2 = 0), r2._isCameraConstrained = false), void 0 !== _2 && (d2 = _2), (l2 || ((e2) => i2[e2] && !this._eventsInProgress[e2])("drag")) && d2 && (this._dragOrigin = n2(r2.pointCoordinate3D(d2)), this._originalZoom = r2.zoom, this._trackingEllipsoid.setup(r2._camera.position, this._dragOrigin)), r2.cameraElevationReference = "sea", s2._stop(true), d2 = d2 || s2.transform.centerPoint, c2 && (r2.bearing += c2), h2 && (r2.pitch += h2), r2._updateCameraState();
              const p2 = [0, 0, 0];
              if (a2) if ("mercator" === r2.projection.name) {
                const e2 = this._trackingEllipsoid.projectRay(r2.screenPointToMercatorRay(d2).dir), t3 = this._trackingEllipsoid.projectRay(r2.screenPointToMercatorRay(d2.sub(a2)).dir);
                p2[0] = t3[0] - e2[0], p2[1] = t3[1] - e2[1];
              } else {
                const t3 = r2.pointCoordinate(d2);
                if ("globe" === r2.projection.name) {
                  a2 = a2.rotate(-r2.angle);
                  const i3 = r2._pixelsPerMercatorPixel / r2.worldSize;
                  p2[0] = -a2.x * e.ez(e.aY(t3.y)) * i3, p2[1] = -a2.y * e.ez(r2.center.lat) * i3;
                } else {
                  const e2 = r2.pointCoordinate(d2.sub(a2));
                  t3 && e2 && (p2[0] = e2.x - t3.x, p2[1] = e2.y - t3.y);
                }
              }
              const f2 = r2.zoom, m2 = [0, 0, 0];
              if (l2) {
                const t3 = n2(u5 || r2.pointCoordinate3D(d2)), i3 = { dir: e.au([], e.at([], t3, r2._camera.position)) };
                if (i3.dir[2] < 0) {
                  const o3 = r2.zoomDeltaToMovement(t3, l2);
                  e.b$(m2, i3.dir, o3);
                }
              }
              const g2 = e.cU(p2, p2, m2);
              r2._translateCameraConstrained(g2), l2 && Math.abs(r2.zoom - f2) > 1e-4 && r2.recenterOnTerrain(), r2.cameraElevationReference = "ground", this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(i2, o2, true);
            }
            _fireEvents(t2, i2, o2) {
              const s2 = Ka(this._eventsInProgress), r2 = Ka(t2), n2 = {};
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._eventsInProgress[e2] || (n2[`${e2}start`] = i3), this._eventsInProgress[e2] = t2[e2];
              }
              !s2 && r2 && this._fireEvent("movestart", r2.originalEvent);
              for (const e2 in n2) this._fireEvent(e2, n2[e2]);
              r2 && this._fireEvent("move", r2.originalEvent);
              for (const e2 in t2) {
                const { originalEvent: i3 } = t2[e2];
                this._fireEvent(e2, i3);
              }
              const a2 = {};
              let l2;
              for (const e2 in this._eventsInProgress) {
                const { handlerName: t3, originalEvent: o3 } = this._eventsInProgress[e2];
                this._handlersById[t3].isActive() || (delete this._eventsInProgress[e2], l2 = i2[t3] || o3, a2[`${e2}end`] = l2);
              }
              for (const e2 in a2) this._fireEvent(e2, a2[e2]);
              const c2 = Ka(this._eventsInProgress);
              if (o2 && (s2 || r2) && !c2) {
                this._updatingCamera = true;
                const t3 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i3 = (e2) => 0 !== e2 && -this._bearingSnap < e2 && e2 < this._bearingSnap;
                t3 ? (i3(t3.bearing || this._map.getBearing()) && (t3.bearing = 0), this._map.easeTo(t3, { originalEvent: l2 })) : (this._map.fire(new e.A("moveend", { originalEvent: l2 })), i3(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
              }
            }
            _fireEvent(t2, i2) {
              this._map.fire(new e.A(t2, i2 ? { originalEvent: i2 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((e2) => {
                this._frameId = void 0, this.handleEvent(new Ja("renderFrame", { timeStamp: e2 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          const il = "map.setFreeCameraOptions(...) and map.getFreeCameraOptions() are not yet supported for non-mercator projections.";
          class ol extends e.E {
            constructor(t2, i2) {
              super(), this._moving = false, this._zooming = false, this.transform = t2, this._bearingSnap = i2.bearingSnap, this._respectPrefersReducedMotion = false !== i2.respectPrefersReducedMotion, e.aV(["_renderFrameCallback"], this);
            }
            getCenter() {
              return new e.cd(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(e2, t2) {
              return this.jumpTo({ center: e2 }, t2);
            }
            panBy(t2, i2, o2) {
              return t2 = e.P.convert(t2).mult(-1), this.panTo(this.transform.center, e.l({ offset: t2 }, i2), o2);
            }
            panTo(t2, i2, o2) {
              return this.easeTo(e.l({ center: t2 }, i2), o2);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(e2, t2) {
              return this.jumpTo({ zoom: e2 }, t2), this;
            }
            zoomTo(t2, i2, o2) {
              return this.easeTo(e.l({ zoom: t2 }, i2), o2);
            }
            zoomIn(e2, t2) {
              return this.zoomTo(this.getZoom() + 1, e2, t2), this;
            }
            zoomOut(e2, t2) {
              return this.zoomTo(this.getZoom() - 1, e2, t2), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(e2, t2) {
              return this.jumpTo({ bearing: e2 }, t2), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(e2, t2) {
              return this.jumpTo({ padding: e2 }, t2), this;
            }
            rotateTo(t2, i2, o2) {
              return this.easeTo(e.l({ bearing: t2 }, i2), o2);
            }
            resetNorth(t2, i2) {
              return this.rotateTo(0, e.l({ duration: 1e3 }, t2), i2), this;
            }
            resetNorthPitch(t2, i2) {
              return this.easeTo(e.l({ bearing: 0, pitch: 0, duration: 1e3 }, t2), i2), this;
            }
            snapToNorth(e2, t2) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e2, t2) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(e2, t2) {
              return this.jumpTo({ pitch: e2 }, t2), this;
            }
            cameraForBounds(t2, i2) {
              t2 = e.aG.convert(t2);
              const o2 = i2 && i2.bearing || 0, s2 = i2 && i2.pitch || 0, r2 = t2.getNorthWest(), n2 = t2.getSouthEast();
              return this._cameraForBounds(this.transform, r2, n2, o2, s2, i2);
            }
            _extendPadding(t2) {
              const i2 = { top: 0, right: 0, bottom: 0, left: 0 };
              return null == t2 ? e.l({}, i2, this.transform.padding) : "number" == typeof t2 ? { top: t2, bottom: t2, right: t2, left: t2 } : e.l({}, i2, t2);
            }
            _extendCameraOptions(t2) {
              return (t2 = e.l({ offset: [0, 0], maxZoom: this.transform.maxZoom }, t2)).padding = this._extendPadding(t2.padding), t2;
            }
            _minimumAABBFrustumDistance(e2, t2) {
              const i2 = t2.max[0] - t2.min[0], o2 = t2.max[1] - t2.min[1];
              return i2 / o2 > e2.aspect ? i2 / (2 * Math.tan(0.5 * e2.fovX) * e2.aspect) : o2 / (2 * Math.tan(0.5 * e2.fovY) * e2.aspect);
            }
            _cameraForBoundsOnGlobe(t2, i2, o2, s2, r2, n2) {
              const a2 = t2.clone(), l2 = this._extendCameraOptions(n2);
              a2.bearing = s2, a2.pitch = r2;
              const c2 = e.cd.convert(i2), h2 = e.cd.convert(o2), d2 = 0.5 * (c2.lat + h2.lat), u5 = 0.5 * (c2.lng + h2.lng), _2 = e.eC(d2, u5), p2 = e.au([], _2), f2 = e.au([], e.bG([], p2, [0, 1, 0])), m2 = e.bG([], f2, p2), g2 = [f2[0], f2[1], f2[2], 0, m2[0], m2[1], m2[2], 0, p2[0], p2[1], p2[2], 0, 0, 0, 0, 1], v3 = [_2, e.eC(c2.lat, c2.lng), e.eC(h2.lat, c2.lng), e.eC(h2.lat, h2.lng), e.eC(c2.lat, h2.lng), e.eC(d2, c2.lng), e.eC(d2, h2.lng), e.eC(c2.lat, u5), e.eC(h2.lat, u5)];
              let y2 = e.cV.fromPoints(v3.map((t3) => [e.bE(f2, t3), e.bE(m2, t3), e.bE(p2, t3)]));
              const x2 = e.ad([], y2.center, g2);
              0 === e.eD(x2) && e.eE(x2, 0, 0, 1), e.au(x2, x2), e.b$(x2, x2, e.aE), a2.center = e.eF(x2);
              const b2 = a2.getWorldToCameraMatrix(), w2 = e.bi(new Float64Array(16), b2);
              y2 = e.cV.applyTransform(y2, e.az([], b2, g2));
              const T2 = this._extendAABB(y2, a2, l2, s2);
              if (!T2) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              y2 = T2, e.ad(x2, x2, b2);
              const E2 = 0.5 * (y2.max[2] - y2.min[2]), S2 = this._minimumAABBFrustumDistance(a2, y2), I2 = e.b$([], [0, 0, 1], E2), C3 = e.cU(I2, x2, I2), R2 = S2 + (0 === a2.pitch ? 0 : e.bD(x2, C3)), D3 = a2.globeCenterInViewSpace, A2 = e.at([], x2, [D3[0], D3[1], D3[2]]);
              e.au(A2, A2), e.b$(A2, A2, R2);
              const L2 = e.cU([], x2, A2);
              e.ad(L2, L2, w2);
              const P2 = e.eq / e.aE, z2 = e.ae(L2), M2 = e.c6(Math.max(z2 * P2 - e.eq, Number.EPSILON), 0), O2 = Math.min(a2.zoomFromMercatorZAdjusted(M2), l2.maxZoom);
              return O2 > 0.5 * (e.cL + e.cx) ? (a2.setProjection({ name: "mercator" }), a2.zoom = O2, this._cameraForBounds(a2, i2, o2, s2, r2, n2)) : { center: a2.center, zoom: O2, bearing: s2, pitch: r2 };
            }
            _extendAABB(t2, i2, o2, s2) {
              const r2 = 0.5 * ((o2.padding.left || 0) + (o2.padding.right || 0)), n2 = 0.5 * ((o2.padding.top || 0) + (o2.padding.bottom || 0)), a2 = n2, l2 = r2, c2 = r2, h2 = n2, d2 = i2.width - (l2 + c2), u5 = i2.height - (a2 + h2), _2 = e.at([], t2.max, t2.min), p2 = Math.min(d2 / _2[0], u5 / _2[1]), f2 = Math.min(i2.scaleZoom(i2.scale * p2), o2.maxZoom);
              if (isNaN(f2)) return null;
              const m2 = i2.scale / i2.zoomScale(f2), g2 = new e.cV([t2.min[0] - l2 * m2, t2.min[1] - h2 * m2, t2.min[2]], [t2.max[0] + c2 * m2, t2.max[1] + a2 * m2, t2.max[2]]), v3 = ("number" == typeof o2.offset.x && "number" == typeof o2.offset.y ? new e.P(o2.offset.x, o2.offset.y) : e.P.convert(o2.offset)).rotate(-e.al(s2));
              return g2.center[0] -= v3.x * m2, g2.center[1] += v3.y * m2, g2;
            }
            queryTerrainElevation(t2, i2) {
              const o2 = this.transform.elevation;
              return o2 ? (i2 = e.l({}, { exaggerated: true }, i2), o2.getAtPoint(e.ac.fromLngLat(t2), null, i2.exaggerated)) : null;
            }
            _cameraForBounds(t2, i2, o2, s2, r2, n2) {
              if ("globe" === t2.projection.name) return this._cameraForBoundsOnGlobe(t2, i2, o2, s2, r2, n2);
              const a2 = t2.clone(), l2 = this._extendCameraOptions(n2);
              a2.bearing = s2, a2.pitch = r2;
              const c2 = e.cd.convert(i2), h2 = e.cd.convert(o2), d2 = new e.cd(c2.lng, h2.lat), u5 = new e.cd(h2.lng, c2.lat), _2 = a2.project(c2), p2 = a2.project(h2), f2 = this.queryTerrainElevation(c2), m2 = this.queryTerrainElevation(h2), g2 = this.queryTerrainElevation(d2), v3 = this.queryTerrainElevation(u5), y2 = [[_2.x, _2.y, Math.min(f2 || 0, m2 || 0, g2 || 0, v3 || 0)], [p2.x, p2.y, Math.max(f2 || 0, m2 || 0, g2 || 0, v3 || 0)]];
              let x2 = e.cV.fromPoints(y2);
              const b2 = a2.getWorldToCameraMatrix(), w2 = e.bi(new Float64Array(16), b2);
              x2 = e.cV.applyTransform(x2, b2);
              const T2 = this._extendAABB(x2, a2, l2, s2);
              if (!T2) return void e.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              x2 = T2;
              const E2 = 0.5 * e.at([], x2.max, x2.min)[2], S2 = this._minimumAABBFrustumDistance(a2, x2), I2 = [0, 0, 1, 0];
              e.aA(I2, I2, b2), e.eG(I2, I2);
              const C3 = e.b$([], I2, S2 + E2), R2 = e.cU([], x2.center, C3);
              e.ad(x2.center, x2.center, w2), e.ad(R2, R2, w2);
              const D3 = a2.unproject(new e.P(x2.center[0], x2.center[1])), A2 = e.eH(a2.projection, D3), L2 = Math.pow(2, A2), P2 = Math.min(a2._zoomFromMercatorZ(R2[2] * a2.pixelsPerMeter * L2 / a2.worldSize), l2.maxZoom);
              return a2.mercatorFromTransition && P2 < 0.5 * (e.cL + e.cx) ? (a2.setProjection({ name: "globe" }), a2.zoom = P2, this._cameraForBounds(a2, i2, o2, s2, r2, n2)) : { center: D3, zoom: P2, bearing: s2, pitch: r2 };
            }
            fitBounds(e2, t2, i2) {
              const o2 = this.cameraForBounds(e2, t2);
              return this._fitInternal(o2, t2, i2);
            }
            fitScreenCoordinates(t2, i2, o2, s2, r2) {
              const n2 = e.P.convert(t2), a2 = e.P.convert(i2), l2 = new e.P(Math.min(n2.x, a2.x), Math.min(n2.y, a2.y)), c2 = new e.P(Math.max(n2.x, a2.x), Math.max(n2.y, a2.y));
              if ("mercator" === this.transform.projection.name && this.transform.anyCornerOffEdge(n2, a2)) return this;
              const h2 = this.transform.pointLocation3D(l2), d2 = this.transform.pointLocation3D(c2), u5 = this.transform.pointLocation3D(new e.P(l2.x, c2.y)), _2 = this.transform.pointLocation3D(new e.P(c2.x, l2.y)), p2 = [Math.min(h2.lng, d2.lng, u5.lng, _2.lng), Math.min(h2.lat, d2.lat, u5.lat, _2.lat)], f2 = [Math.max(h2.lng, d2.lng, u5.lng, _2.lng), Math.max(h2.lat, d2.lat, u5.lat, _2.lat)], m2 = s2 && s2.pitch ? s2.pitch : this.getPitch(), g2 = this._cameraForBounds(this.transform, p2, f2, o2, m2, s2);
              return this._fitInternal(g2, s2, r2);
            }
            _fitInternal(t2, i2, o2) {
              return t2 ? (i2 = e.l(t2, i2)).linear ? this.easeTo(i2, o2) : this.flyTo(i2, o2) : this;
            }
            jumpTo(t2, i2) {
              this.stop();
              const o2 = t2.preloadOnly ? this.transform.clone() : this.transform;
              let s2 = false, r2 = false, n2 = false;
              "zoom" in t2 && o2.zoom !== +t2.zoom && (s2 = true, o2.zoom = +t2.zoom), void 0 !== t2.center && (o2.center = e.cd.convert(t2.center)), "bearing" in t2 && o2.bearing !== +t2.bearing && (r2 = true, o2.bearing = +t2.bearing), "pitch" in t2 && o2.pitch !== +t2.pitch && (n2 = true, o2.pitch = +t2.pitch);
              const a2 = "number" == typeof t2.padding ? this._extendPadding(t2.padding) : t2.padding;
              if (null != t2.padding && !o2.isPaddingEqual(a2)) if (false === t2.retainPadding) {
                const e2 = o2.clone();
                e2.padding = a2, o2.setLocationAtPoint(o2.center, e2.centerPoint);
              } else o2.padding = a2;
              return t2.preloadOnly ? (this._preloadTiles(o2), this) : (this.fire(new e.A("movestart", i2)).fire(new e.A("move", i2)), s2 && this.fire(new e.A("zoomstart", i2)).fire(new e.A("zoom", i2)).fire(new e.A("zoomend", i2)), r2 && this.fire(new e.A("rotatestart", i2)).fire(new e.A("rotate", i2)).fire(new e.A("rotateend", i2)), n2 && this.fire(new e.A("pitchstart", i2)).fire(new e.A("pitch", i2)).fire(new e.A("pitchend", i2)), this.fire(new e.A("moveend", i2)));
            }
            getFreeCameraOptions() {
              return this.transform.projection.supportsFreeCamera || e.w(il), this.transform.getFreeCameraOptions();
            }
            setFreeCameraOptions(t2, i2) {
              const o2 = this.transform;
              if (!o2.projection.supportsFreeCamera) return e.w(il), this;
              this.stop();
              const s2 = o2.zoom, r2 = o2.pitch, n2 = o2.bearing;
              o2.setFreeCameraOptions(t2);
              const a2 = s2 !== o2.zoom, l2 = r2 !== o2.pitch, c2 = n2 !== o2.bearing;
              return this.fire(new e.A("movestart", i2)).fire(new e.A("move", i2)), a2 && this.fire(new e.A("zoomstart", i2)).fire(new e.A("zoom", i2)).fire(new e.A("zoomend", i2)), c2 && this.fire(new e.A("rotatestart", i2)).fire(new e.A("rotate", i2)).fire(new e.A("rotateend", i2)), l2 && this.fire(new e.A("pitchstart", i2)).fire(new e.A("pitch", i2)).fire(new e.A("pitchend", i2)), this.fire(new e.A("moveend", i2)), this;
            }
            easeTo(t2, i2) {
              this._stop(false, t2.easeId), (false === (t2 = e.l({ offset: [0, 0], duration: 500, easing: e.ey }, t2)).animate || this._prefersReducedMotion(t2)) && (t2.duration = 0);
              const o2 = this.transform, s2 = this.getZoom(), r2 = this.getBearing(), n2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? +t2.zoom : s2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, r2) : r2, h2 = "pitch" in t2 ? +t2.pitch : n2, d2 = this._extendPadding(t2.padding), u5 = e.P.convert(t2.offset);
              let _2, p2, f2;
              if ("globe" === o2.projection.name) {
                const i3 = e.ac.fromLngLat(o2.center), s3 = u5.rotate(-o2.angle);
                i3.x += s3.x / o2.worldSize, i3.y += s3.y / o2.worldSize;
                const r3 = i3.toLngLat(), n3 = e.cd.convert(t2.center || r3);
                this._normalizeCenter(n3), _2 = o2.centerPoint.add(s3), p2 = new e.P(i3.x, i3.y).mult(o2.worldSize), f2 = new e.P(e.ay(n3.lng), e.aH(n3.lat)).mult(o2.worldSize).sub(p2);
              } else {
                _2 = o2.centerPoint.add(u5);
                const i3 = o2.pointLocation(_2), s3 = e.cd.convert(t2.center || i3);
                this._normalizeCenter(s3), p2 = o2.project(i3), f2 = o2.project(s3).sub(p2);
              }
              const m2 = o2.zoomScale(l2 - s2);
              let g2, v3;
              t2.around && (g2 = e.cd.convert(t2.around), v3 = o2.locationPoint(g2));
              const y2 = this._zooming || l2 !== s2, x2 = this._rotating || r2 !== c2, b2 = this._pitching || h2 !== n2, w2 = !o2.isPaddingEqual(d2), T2 = false === t2.retainPadding ? o2.clone() : o2, E2 = (o3) => (E3) => {
                if (y2 && (o3.zoom = e.ai(s2, l2, E3)), x2 && (o3.bearing = e.ai(r2, c2, E3)), b2 && (o3.pitch = e.ai(n2, h2, E3)), w2 && (T2.interpolatePadding(a2, d2, E3), _2 = T2.centerPoint.add(u5)), g2) o3.setLocationAtPoint(g2, v3);
                else {
                  const e2 = o3.zoomScale(o3.zoom - s2), t3 = l2 > s2 ? Math.min(2, m2) : Math.max(0.5, m2), i3 = Math.pow(t3, 1 - E3), r3 = o3.unproject(p2.add(f2.mult(E3 * i3)).mult(e2));
                  o3.setLocationAtPoint(o3.renderWorldCopies ? r3.wrap() : r3, _2);
                }
                return t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(E2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              const S2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = y2, this._rotating = x2, this._pitching = b2, this._padding = w2, this._easeId = t2.easeId, this._prepareEase(i2, t2.noMoveStart, S2), this._ease(E2(o2), (e2) => {
                "sea" === o2.cameraElevationReference && o2.recenterOnTerrain(), this._afterEase(i2, e2);
              }, t2), this;
            }
            _prepareEase(t2, i2, o2 = {}) {
              this._moving = true, this.transform.cameraElevationReference = "sea", this.transform._orthographicProjectionAtLowPitch && 0 === this.transform.pitch && "globe" !== this.transform.projection.name && (this.transform.cameraElevationReference = "ground"), i2 || o2.moving || this.fire(new e.A("movestart", t2)), this._zooming && !o2.zooming && this.fire(new e.A("zoomstart", t2)), this._rotating && !o2.rotating && this.fire(new e.A("rotatestart", t2)), this._pitching && !o2.pitching && this.fire(new e.A("pitchstart", t2));
            }
            _fireMoveEvents(t2) {
              this.fire(new e.A("move", t2)), this._zooming && this.fire(new e.A("zoom", t2)), this._rotating && this.fire(new e.A("rotate", t2)), this._pitching && this.fire(new e.A("pitch", t2));
            }
            _afterEase(t2, i2) {
              if (this._easeId && i2 && this._easeId === i2) return;
              this._easeId = void 0, this.transform.cameraElevationReference = "ground";
              const o2 = this._zooming, s2 = this._rotating, r2 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new e.A("zoomend", t2)), s2 && this.fire(new e.A("rotateend", t2)), r2 && this.fire(new e.A("pitchend", t2)), this.fire(new e.A("moveend", t2));
            }
            flyTo(t2, i2) {
              if (this._prefersReducedMotion(t2)) {
                const o3 = e.aF(t2, ["center", "zoom", "bearing", "pitch", "around", "padding", "retainPadding"]);
                return this.jumpTo(o3, i2);
              }
              this.stop(), t2 = e.l({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: e.ey }, t2);
              const o2 = this.transform, s2 = this.getZoom(), r2 = this.getBearing(), n2 = this.getPitch(), a2 = this.getPadding(), l2 = "zoom" in t2 ? e.aD(+t2.zoom, o2.minZoom, o2.maxZoom) : s2, c2 = "bearing" in t2 ? this._normalizeBearing(t2.bearing, r2) : r2, h2 = "pitch" in t2 ? +t2.pitch : n2, d2 = this._extendPadding(t2.padding), u5 = o2.zoomScale(l2 - s2), _2 = e.P.convert(t2.offset);
              let p2 = o2.centerPoint.add(_2);
              const f2 = o2.pointLocation(p2), m2 = e.cd.convert(t2.center || f2);
              this._normalizeCenter(m2);
              const g2 = o2.project(f2), v3 = o2.project(m2).sub(g2);
              let y2 = t2.curve;
              const x2 = Math.max(o2.width, o2.height), b2 = x2 / u5, w2 = v3.mag();
              if ("minZoom" in t2) {
                const i3 = e.aD(Math.min(t2.minZoom, s2, l2), o2.minZoom, o2.maxZoom), r3 = x2 / o2.zoomScale(i3 - s2);
                y2 = Math.sqrt(r3 / w2 * 2);
              }
              const T2 = y2 * y2;
              function E2(e2) {
                const t3 = (b2 * b2 - x2 * x2 + (e2 ? -1 : 1) * T2 * T2 * w2 * w2) / (2 * (e2 ? b2 : x2) * T2 * w2);
                return Math.log(Math.sqrt(t3 * t3 + 1) - t3);
              }
              function S2(e2) {
                return (Math.exp(e2) - Math.exp(-e2)) / 2;
              }
              function I2(e2) {
                return (Math.exp(e2) + Math.exp(-e2)) / 2;
              }
              const C3 = E2(0);
              let R2 = function(e2) {
                return I2(C3) / I2(C3 + y2 * e2);
              }, D3 = function(e2) {
                return x2 * ((I2(C3) * (S2(t3 = C3 + y2 * e2) / I2(t3)) - S2(C3)) / T2) / w2;
                var t3;
              }, A2 = (E2(1) - C3) / y2;
              if (Math.abs(w2) < 1e-6 || !isFinite(A2)) {
                if (Math.abs(x2 - b2) < 1e-6) return this.easeTo(t2, i2);
                const e2 = b2 < x2 ? -1 : 1;
                A2 = Math.abs(Math.log(b2 / x2)) / y2, D3 = function() {
                  return 0;
                }, R2 = function(t3) {
                  return Math.exp(e2 * y2 * t3);
                };
              }
              t2.duration = "duration" in t2 ? +t2.duration : 1e3 * A2 / ("screenSpeed" in t2 ? +t2.screenSpeed / y2 : +t2.speed), t2.maxDuration && t2.duration > t2.maxDuration && (t2.duration = 0);
              const L2 = r2 !== c2, P2 = h2 !== n2, z2 = !o2.isPaddingEqual(d2), M2 = false === t2.retainPadding ? o2.clone() : o2, O2 = (o3) => (u6) => {
                const f3 = u6 * A2, y3 = 1 / R2(f3);
                o3.zoom = 1 === u6 ? l2 : s2 + o3.scaleZoom(y3), L2 && (o3.bearing = e.ai(r2, c2, u6)), P2 && (o3.pitch = e.ai(n2, h2, u6)), z2 && (M2.interpolatePadding(a2, d2, u6), p2 = M2.centerPoint.add(_2));
                const x3 = 1 === u6 ? m2 : o3.unproject(g2.add(v3.mult(D3(f3))).mult(y3));
                return o3.setLocationAtPoint(o3.renderWorldCopies ? x3.wrap() : x3, p2), o3._updateCameraOnTerrain(), t2.preloadOnly || this._fireMoveEvents(i2), o3;
              };
              if (t2.preloadOnly) {
                const e2 = this._emulate(O2, t2.duration, o2);
                return this._preloadTiles(e2), this;
              }
              return this._zooming = true, this._rotating = L2, this._pitching = P2, this._padding = z2, this._prepareEase(i2, false), this._ease(O2(o2), () => this._afterEase(i2), t2), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _requestRenderFrame(e2) {
            }
            _cancelRenderFrame(e2) {
            }
            _stop(e2, t2) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), this._easeFrameId = void 0, this._onEaseFrame = void 0), this._onEaseEnd) {
                const e3 = this._onEaseEnd;
                this._onEaseEnd = void 0, e3.call(this, t2);
              }
              if (!e2) {
                const e3 = this.handlers;
                e3 && e3.stop(false);
              }
              return this;
            }
            _ease(t2, i2, o2) {
              false === o2.animate || 0 === o2.duration ? (t2(1), i2()) : (this._easeStart = e.q.now(), this._easeOptions = o2, this._onEaseFrame = t2, this._onEaseEnd = i2, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _renderFrameCallback() {
              const t2 = Math.min((e.q.now() - this._easeStart) / this._easeOptions.duration, 1), i2 = this._onEaseFrame;
              i2 && i2(this._easeOptions.easing(t2)), t2 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }
            _normalizeBearing(t2, i2) {
              t2 = e.bX(t2, -180, 180);
              const o2 = Math.abs(t2 - i2);
              return Math.abs(t2 - 360 - i2) < o2 && (t2 -= 360), Math.abs(t2 + 360 - i2) < o2 && (t2 += 360), t2;
            }
            _normalizeCenter(e2) {
              const t2 = this.transform;
              if (t2.maxBounds) return;
              if ("globe" !== t2.projection.name && !t2.renderWorldCopies) return;
              const i2 = e2.lng - t2.center.lng;
              e2.lng += i2 > 180 ? -360 : i2 < -180 ? 360 : 0;
            }
            _prefersReducedMotion(t2) {
              return this._respectPrefersReducedMotion && e.q.prefersReducedMotion && !(t2 && t2.essential);
            }
            _emulate(e2, t2, i2) {
              const o2 = Math.ceil(15 * t2 / 1e3), s2 = [], r2 = e2(i2.clone());
              for (let e3 = 0; e3 <= o2; e3++) {
                const t3 = r2(e3 / o2);
                s2.push(t3.clone());
              }
              return s2;
            }
            _preloadTiles(e2, t2) {
            }
          }
          class sl {
            constructor(t2 = {}) {
              this.options = t2, e.aV(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(e2) {
              const t2 = this.options && this.options.compact, i2 = e2._getUIString("AttributionControl.ToggleAttribution");
              this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = l("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.type = "button", this._compactButton.addEventListener("click", this._toggleAttribution), this._compactButton.setAttribute("aria-label", i2);
              const o2 = l("span", "mapboxgl-ctrl-icon", this._compactButton);
              return o2.setAttribute("aria-hidden", "true"), o2.setAttribute("title", i2), this._innerContainer = l("div", "mapboxgl-ctrl-attrib-inner", this._container), t2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === t2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
            }
            _toggleAttribution() {
              this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-expanded", "true"));
            }
            _updateEditLink() {
              let t2 = this._editLink;
              t2 || (t2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
              const i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || e.e.ACCESS_TOKEN }];
              if (t2) {
                const o2 = i2.reduce((e2, t3, o3) => (t3.value && (e2 += `${t3.key}=${t3.value}${o3 < i2.length - 1 ? "&" : ""}`), e2), "?");
                t2.href = `${e.e.FEEDBACK_URL}/${o2}#${ra(this._map, true)}`, t2.rel = "noopener nofollow";
              }
            }
            _updateData(e2) {
              !e2 || "metadata" !== e2.sourceDataType && "visibility" !== e2.sourceDataType && "style" !== e2.dataType || (this._updateAttributions(), this._updateEditLink());
            }
            _updateAttributions() {
              if (!this._map.style) return;
              let e2 = [];
              if (this._map.style.stylesheet) {
                const e3 = this._map.style.stylesheet;
                this.styleOwner = e3.owner, this.styleId = e3.id;
              }
              const t2 = this._map.style._mergedSourceCaches;
              for (const i3 in t2) {
                const o2 = t2[i3];
                if (o2.used) {
                  const t3 = o2.getSource();
                  t3.attribution && e2.indexOf(t3.attribution) < 0 && e2.push(t3.attribution);
                }
              }
              e2.sort((e3, t3) => e3.length - t3.length), e2 = e2.filter((t3, i3) => {
                for (let o2 = i3 + 1; o2 < e2.length; o2++) if (e2[o2].indexOf(t3) >= 0) return false;
                return true;
              }), this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e2 = [...this.options.customAttribution, ...e2] : e2.unshift(this.options.customAttribution));
              const i2 = e2.join(" | ");
              i2 !== this._attribHTML && (this._attribHTML = i2, e2.length ? (this._innerContainer.innerHTML = i2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
            _updateCompact() {
              this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
            }
          }
          class rl {
            constructor() {
              e.aV(["_updateLogo", "_updateCompact"], this);
            }
            onAdd(e2) {
              this._map = e2, this._container = l("div", "mapboxgl-ctrl");
              const t2 = l("a", "mapboxgl-ctrl-logo");
              return t2.target = "_blank", t2.rel = "noopener nofollow", t2.href = "https://www.mapbox.com/", t2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), t2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(t2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _updateLogo(e2) {
              e2 && "metadata" !== e2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
            }
            _logoRequired() {
              if (!this._map.style) return true;
              const e2 = this._map.style._sourceCaches;
              if (0 === Object.entries(e2).length) return true;
              for (const t2 in e2) {
                const i2 = e2[t2].getSource();
                if (i2.hasOwnProperty("mapbox_logo") && !i2.mapbox_logo) return false;
              }
              return true;
            }
            _updateCompact() {
              const e2 = this._container.children;
              if (e2.length) {
                const t2 = e2[0];
                this._map.getCanvasContainer().offsetWidth < 250 ? t2.classList.add("mapboxgl-compact") : t2.classList.remove("mapboxgl-compact");
              }
            }
          }
          class nl {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(e2) {
              const t2 = ++this._id;
              return this._queue.push({ callback: e2, id: t2, cancelled: false }), t2;
            }
            remove(e2) {
              const t2 = this._currentlyRunning, i2 = t2 ? this._queue.concat(t2) : this._queue;
              for (const t3 of i2) if (t3.id === e2) return void (t3.cancelled = true);
            }
            run(e2 = 0) {
              const t2 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i2 of t2) if (!i2.cancelled && (i2.callback(e2), this._cleared)) break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          class al {
            constructor(e2) {
              this.jumpTo(e2);
            }
            getValue(t2) {
              if (t2 <= this._startTime) return this._start;
              if (t2 >= this._endTime) return this._end;
              const i2 = e.dk((t2 - this._startTime) / (this._endTime - this._startTime));
              return this._start * (1 - i2) + this._end * i2;
            }
            isEasing(e2) {
              return e2 >= this._startTime && e2 <= this._endTime;
            }
            jumpTo(e2) {
              this._startTime = -1 / 0, this._endTime = -1 / 0, this._start = e2, this._end = e2;
            }
            easeTo(e2, t2, i2) {
              this._start = this.getValue(t2), this._end = e2, this._startTime = t2, this._endTime = t2 + i2;
            }
          }
          const ll = { "AttributionControl.ToggleAttribution": "Toggle attribution", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox homepage", "Map.Title": "Map", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScrollZoomBlocker.CtrlMessage": "Use ctrl + scroll to zoom the map", "ScrollZoomBlocker.CmdMessage": "Use \u2318 + scroll to zoom the map", "TouchPanBlocker.Message": "Use two fingers to move the map" };
          class cl extends e.A {
            constructor(e2, t2, i2, o2) {
              const { point: s2, lngLat: r2, originalEvent: n2, target: a2 } = e2;
              super(e2.type, { point: s2, lngLat: r2, originalEvent: n2, target: a2 }), this.preventDefault = () => {
                e2.preventDefault();
              }, this.id = t2, this.interaction = i2, this.feature = o2;
            }
          }
          class hl {
            constructor(e2) {
              this.map = e2, this.interactionsByType = /* @__PURE__ */ new Map(), this.delegatedInteractions = /* @__PURE__ */ new Map(), this.typeById = /* @__PURE__ */ new Map(), this.filters = /* @__PURE__ */ new Map(), this.handleType = this.handleType.bind(this), this.handleMove = this.handleMove.bind(this), this.handleOut = this.handleOut.bind(this), this.hoveredFeatures = /* @__PURE__ */ new Map(), this.prevHoveredFeatures = /* @__PURE__ */ new Map();
            }
            add(t2, i2) {
              if (this.typeById.has(t2)) throw new Error(`Interaction id "${t2}" already exists.`);
              const o2 = i2.filter;
              let s2 = i2.type;
              o2 && this.filters.set(t2, e.b3(o2)), "mouseover" === s2 && (s2 = "mouseenter"), "mouseout" === s2 && (s2 = "mouseleave");
              const r2 = this.interactionsByType.get(s2) || /* @__PURE__ */ new Map();
              "mouseenter" === s2 || "mouseleave" === s2 ? (0 === this.delegatedInteractions.size && (this.map.on("mousemove", this.handleMove), this.map.on("mouseout", this.handleOut)), this.delegatedInteractions.set(t2, i2)) : 0 === r2.size && this.map.on(s2, this.handleType), 0 === r2.size && this.interactionsByType.set(s2, r2), r2.set(t2, i2), this.typeById.set(t2, s2);
            }
            get(e2) {
              const t2 = this.typeById.get(e2);
              if (!t2) return;
              const i2 = this.interactionsByType.get(t2);
              return i2 ? i2.get(e2) : void 0;
            }
            remove(e2) {
              const t2 = this.typeById.get(e2);
              if (!t2) return;
              this.typeById.delete(e2), this.filters.delete(e2);
              const i2 = this.interactionsByType.get(t2);
              i2 && (i2.delete(e2), "mouseenter" === t2 || "mouseleave" === t2 ? (this.delegatedInteractions.delete(e2), 0 === this.delegatedInteractions.size && (this.map.off("mousemove", this.handleMove), this.map.off("mouseout", this.handleOut))) : 0 === i2.size && this.map.off(t2, this.handleType));
            }
            queryTargets(e2, t2) {
              const i2 = [];
              for (const [e3, o2] of t2) o2.target && i2.push({ targetId: e3, target: o2.target, filter: this.filters.get(e3) });
              return this.map.style.queryRenderedTargets(e2, i2, this.map.transform);
            }
            handleMove(e2) {
              this.prevHoveredFeatures = this.hoveredFeatures, this.hoveredFeatures = /* @__PURE__ */ new Map();
              const t2 = this.queryTargets(e2.point, Array.from(this.delegatedInteractions).reverse());
              t2.length && (e2.type = "mouseenter", this.handleType(e2, t2));
              const i2 = /* @__PURE__ */ new Map();
              for (const [e3, { feature: t3 }] of this.prevHoveredFeatures) this.hoveredFeatures.has(e3) || i2.set(t3.id, t3);
              i2.size && (e2.type = "mouseleave", this.handleType(e2, Array.from(i2.values())));
            }
            handleOut(e2) {
              const t2 = Array.from(this.hoveredFeatures.values()).map(({ feature: e3 }) => e3);
              t2.length && (e2.type = "mouseleave", this.handleType(e2, t2)), this.hoveredFeatures.clear();
            }
            handleType(t2, i2) {
              const o2 = Array.from(this.interactionsByType.get(t2.type)).reverse(), s2 = !!i2;
              i2 = i2 || this.queryTargets(t2.point, o2);
              const r2 = "mouseenter" === t2.type;
              let n2 = false;
              const a2 = /* @__PURE__ */ new Set();
              for (const l2 of i2) {
                for (const [i3, c2] of o2) {
                  if (!c2.target) continue;
                  const o3 = l2.variants ? l2.variants[i3] : null;
                  if (o3) {
                    for (const h2 of o3) {
                      if (lt(h2, l2, a2, i3)) continue;
                      const o4 = new e.df(l2, h2), d2 = at(h2, l2, i3);
                      s2 && (o4.state = this.map.getFeatureState(o4));
                      const u5 = r2 ? this.prevHoveredFeatures.get(d2) : null, _2 = new cl(t2, i3, c2, o4), p2 = u5 ? u5.stop : c2.handler(_2);
                      if (r2 && this.hoveredFeatures.set(d2, { feature: l2, stop: p2 }), false !== p2) {
                        n2 = true;
                        break;
                      }
                    }
                    if (n2) break;
                  }
                }
                if (n2) break;
              }
              if (!n2) for (const [e2, i3] of o2) {
                const { handler: o3, target: s3 } = i3;
                if (!s3 && false !== o3(new cl(t2, e2, i3, null))) break;
              }
            }
          }
          function dl(t2, i2) {
            if (Array.isArray(t2) && Array.isArray(i2)) {
              const e2 = new Set(t2), o2 = new Set(i2);
              return e2.size === o2.size && t2.every((e3) => o2.has(e3));
            }
            return e.bv(t2, i2);
          }
          const ul = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 85, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: false, performanceMetricsCollection: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, minTileCacheSize: null, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", localFontFamily: null, transformRequest: null, accessToken: null, fadeDuration: 300, respectPrefersReducedMotion: true, crossSourceCollisions: true, collectResourceTiming: false, testMode: false, precompilePrograms: true, scaleFactor: 1, spriteFormat: "auto" }, _l = { showCompass: true, showZoom: true, visualizePitch: false };
          class pl {
            constructor(t2, i2, o2 = false) {
              this._clickTolerance = 10, this.element = i2, this.mouseRotate = new Ra({ clickTolerance: t2.dragRotate._mouseRotate._clickTolerance }), this.map = t2, o2 && (this.mousePitch = new Da({ clickTolerance: t2.dragRotate._mousePitch._clickTolerance })), e.aV(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i2.addEventListener("mousedown", this.mousedown), i2.addEventListener("touchstart", this.touchstart, { passive: false }), i2.addEventListener("touchmove", this.touchmove), i2.addEventListener("touchend", this.touchend), i2.addEventListener("touchcancel", this.reset);
            }
            down(e2, t2) {
              this.mouseRotate.mousedown(e2, t2), this.mousePitch && this.mousePitch.mousedown(e2, t2), _();
            }
            move(e2, t2) {
              const i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(e2, t2), s2 = o2 && o2.bearingDelta;
              if (s2 && i2.setBearing(i2.getBearing() + s2), this.mousePitch) {
                const o3 = this.mousePitch.mousemoveWindow(e2, t2), s3 = o3 && o3.pitchDelta;
                s3 && i2.setPitch(i2.getPitch() + s3);
              }
            }
            off() {
              const e2 = this.element;
              e2.removeEventListener("mousedown", this.mousedown), e2.removeEventListener("touchstart", this.touchstart), e2.removeEventListener("touchmove", this.touchmove), e2.removeEventListener("touchend", this.touchend), e2.removeEventListener("touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              p(), window.removeEventListener("mousemove", this.mousemove), window.removeEventListener("mouseup", this.mouseup);
            }
            mousedown(t2) {
              this.down(e.l({}, t2, { ctrlKey: true, preventDefault: () => t2.preventDefault() }), g(this.element, t2)), window.addEventListener("mousemove", this.mousemove), window.addEventListener("mouseup", this.mouseup);
            }
            mousemove(e2) {
              this.move(e2, g(this.element, e2));
            }
            mouseup(e2) {
              this.mouseRotate.mouseupWindow(e2), this.mousePitch && this.mousePitch.mouseupWindow(e2), this.offTemp();
            }
            touchstart(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = v2(this.element, e2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: () => e2.preventDefault() }, this._startPos));
            }
            touchmove(e2) {
              1 !== e2.targetTouches.length ? this.reset() : (this._lastPos = v2(this.element, e2.targetTouches)[0], this.move({ preventDefault: () => e2.preventDefault() }, this._lastPos));
            }
            touchend(e2) {
              0 === e2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
            }
            reset() {
              this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
            }
          }
          function fl(t2, i2, o2) {
            if (t2 = new e.cd(t2.lng, t2.lat), i2) {
              const s2 = new e.cd(t2.lng - 360, t2.lat), r2 = new e.cd(t2.lng + 360, t2.lat), n2 = 360 * Math.ceil(Math.abs(t2.lng - o2.center.lng) / 360), a2 = o2.locationPoint3D(t2).distSqr(i2), l2 = i2.x < 0 || i2.y < 0 || i2.x > o2.width || i2.y > o2.height;
              o2.locationPoint3D(s2).distSqr(i2) < a2 && (l2 || Math.abs(s2.lng - o2.center.lng) < n2) ? t2 = s2 : o2.locationPoint3D(r2).distSqr(i2) < a2 && (l2 || Math.abs(r2.lng - o2.center.lng) < n2) && (t2 = r2);
            }
            for (; Math.abs(t2.lng - o2.center.lng) > 180; ) {
              const e2 = o2.locationPoint3D(t2);
              if (e2.x >= 0 && e2.y >= 0 && e2.x <= o2.width && e2.y <= o2.height) break;
              t2.lng > o2.center.lng ? t2.lng -= 360 : t2.lng += 360;
            }
            return t2;
          }
          const ml = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" }, gl = { rotation: 0, rotationAlignment: "auto", pitchAlignment: "auto", occludedOpacity: 0.2, altitude: 0 };
          class vl extends e.E {
            constructor(t2, i2) {
              super(), (t2 instanceof HTMLElement || i2) && (t2 = e.l({ element: t2 }, i2)), e.aV(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress", "_clearFadeTimer"], this);
              const { anchor: o2 = "center", color: s2 = "#3FB1CE", scale: r2 = 1, draggable: n2 = false, clickTolerance: a2 = 0, rotation: l2 = gl.rotation, rotationAlignment: c2 = gl.rotationAlignment, pitchAlignment: h2 = gl.pitchAlignment, occludedOpacity: d2 = gl.occludedOpacity, altitude: u5 = gl.altitude } = t2 || {};
              this._anchor = o2, this._color = s2, this._scale = r2, this._draggable = n2, this._clickTolerance = a2, this._rotation = l2, this._rotationAlignment = c2, this._pitchAlignment = h2, this._occludedOpacity = d2, this._altitude = u5, this._state = "inactive", this._isDragging = false, this._updateMoving = () => this._update(true), t2 && t2.element ? (this._element = t2.element, this._offset = e.P.convert(t2 && t2.offset || [0, 0])) : (this._defaultMarker = true, this._element = this._createDefaultMarker(), this._offset = e.P.convert(t2 && t2.offset || [0, -14])), this._element.hasAttribute("aria-label") || this._element.setAttribute("aria-label", "Map marker"), this._element.hasAttribute("role") || this._element.setAttribute("role", "img"), this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", (e2) => {
                e2.preventDefault();
              }), this._element.addEventListener("mousedown", (e2) => {
                e2.preventDefault();
              });
              const _2 = this._element.classList;
              for (const e2 in ml) _2.remove(`mapboxgl-marker-anchor-${e2}`);
              _2.add(`mapboxgl-marker-anchor-${this._anchor}`);
              const p2 = t2 && t2.className ? t2.className.trim().split(/\s+/) : [];
              _2.add(...p2), this._popup = null;
            }
            _createDefaultMarker() {
              const e2 = l("div"), t2 = c("svg", { display: "block", height: 41 * this._scale + "px", width: 27 * this._scale + "px", viewBox: "0 0 27 41" }, e2);
              if (0 === this._altitude) {
                const e3 = c("radialGradient", { id: "shadowGradient" }, c("defs", {}, t2));
                c("stop", { offset: "10%", "stop-opacity": 0.4 }, e3), c("stop", { offset: "100%", "stop-opacity": 0.05 }, e3), c("ellipse", { cx: 13.5, cy: 34.8, rx: 10.5, ry: 5.25, fill: "url(#shadowGradient)" }, t2);
              }
              return c("path", { fill: this._color, d: "M27,13.5C27,19.07 20.25,27 14.75,34.5C14.02,35.5 12.98,35.5 12.25,34.5C6.75,27 0,19.22 0,13.5C0,6.04 6.04,0 13.5,0C20.96,0 27,6.04 27,13.5Z" }, t2), c("path", { opacity: 0.25, d: "M13.5,0C6.04,0 0,6.04 0,13.5C0,19.22 6.75,27 12.25,34.5C13,35.52 14.02,35.5 14.75,34.5C20.25,27 27,19.07 27,13.5C27,6.04 20.96,0 13.5,0ZM13.5,1C20.42,1 26,6.58 26,13.5C26,15.9 24.5,19.18 22.22,22.74C19.95,26.3 16.71,30.14 13.94,33.91C13.74,34.18 13.61,34.32 13.5,34.44C13.39,34.32 13.26,34.18 13.06,33.91C10.28,30.13 7.41,26.31 5.02,22.77C2.62,19.23 1,15.95 1,13.5C1,6.58 6.58,1 13.5,1Z" }, t2), c("circle", { fill: "white", cx: 13.5, cy: 13.5, r: 5.5 }, t2), e2;
            }
            addTo(e2) {
              return e2 === this._map || (this.remove(), this._map = e2, e2.getCanvasContainer().appendChild(this._element), e2.on("move", this._updateMoving), e2.on("moveend", this._update), e2.on("remove", this._clearFadeTimer), e2._addMarker(this), this.setDraggable(this._draggable), this._update(), e2.on("click", this._onMapClick)), this;
            }
            remove() {
              const e2 = this._map;
              return e2 && (e2.off("click", this._onMapClick), e2.off("move", this._updateMoving), e2.off("moveend", this._update), e2.off("mousedown", this._addDragHandler), e2.off("touchstart", this._addDragHandler), e2.off("mouseup", this._onUp), e2.off("touchend", this._onUp), e2.off("mousemove", this._onMove), e2.off("touchmove", this._onMove), e2.off("remove", this._clearFadeTimer), e2._removeMarker(this), this._map = void 0), this._clearFadeTimer(), this._element.remove(), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              return this._lngLat = e.cd.convert(t2), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(true), this;
            }
            setAltitude(e2) {
              return e2 === this._altitude || (this._defaultMarker && (0 === this._altitude && 0 !== e2 || 0 !== this._altitude && 0 === e2) && (this._element = this._createDefaultMarker()), this._altitude = e2 || gl.altitude, this._update()), this;
            }
            getAltitude() {
              return this._altitude;
            }
            getElement() {
              return this._element;
            }
            setPopup(e2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeAttribute("role"), this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), e2) {
                if (!("offset" in e2.options)) {
                  const t2 = 38.1, i2 = 13.5, o2 = Math.sqrt(Math.pow(i2, 2) / 2);
                  e2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -t2], "bottom-left": [o2, -1 * (t2 - i2 + o2)], "bottom-right": [-o2, -1 * (t2 - i2 + o2)], left: [i2, -1 * (t2 - i2)], right: [-i2, -1 * (t2 - i2)] } : this._offset;
                }
                this._popup = e2, e2._marker = this, e2._altitude = this._altitude, this._lngLat && this._popup.setLngLat(this._lngLat), this._element.setAttribute("role", "button"), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress), this._element.setAttribute("aria-expanded", "false");
              }
              return this;
            }
            _onKeyPress(e2) {
              const t2 = e2.code, i2 = e2.charCode || e2.keyCode;
              "Space" !== t2 && "Enter" !== t2 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }
            _onMapClick(e2) {
              const t2 = e2.originalEvent.target, i2 = this._element;
              this._popup && (t2 === i2 || i2.contains(t2)) && this.togglePopup();
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const e2 = this._popup;
              return e2 ? (e2.isOpen() ? (e2.remove(), this._element.setAttribute("aria-expanded", "false")) : this._map && (e2.addTo(this._map), this._element.setAttribute("aria-expanded", "true")), this) : this;
            }
            _behindTerrain() {
              const e2 = this._map, t2 = this._pos;
              if (!e2 || !t2) return false;
              const i2 = e2.unproject(t2, this._altitude), o2 = e2.getFreeCameraOptions();
              if (!o2.position) return false;
              const s2 = o2.position.toLngLat();
              return s2.distanceTo(i2) < 0.9 * s2.distanceTo(this._lngLat);
            }
            _evaluateOpacity() {
              const t2 = this._map;
              if (!t2) return;
              const i2 = this._pos;
              if (!i2 || i2.x < 0 || i2.x > t2.transform.width || i2.y < 0 || i2.y > t2.transform.height) return void this._clearFadeTimer();
              const o2 = t2.unproject(i2, this._altitude);
              let s2;
              t2._showingGlobe() && e.eK(t2.transform, this._lngLat) ? s2 = 0 : (s2 = 1 - t2._queryFogOpacity(o2), t2.transform._terrainEnabled() && t2.getTerrain() && this._behindTerrain() && (s2 *= this._occludedOpacity)), this._element.style.opacity = `${s2}`, this._element.style.pointerEvents = s2 > 0 ? "auto" : "none", this._popup && this._popup._setOpacity(s2), this._fadeTimer = null;
            }
            _clearFadeTimer() {
              this._fadeTimer && (clearTimeout(this._fadeTimer), this._fadeTimer = null);
            }
            _updateDOM() {
              const e2 = this._pos;
              if (!e2 || !this._map) return;
              const t2 = this._offset.mult(this._scale);
              this._element.style.transform = `
            translate(${e2.x}px,${e2.y}px)
            ${ml[this._anchor]}
            ${this._calculateXYTransform()} ${this._calculateZTransform()}
            translate(${t2.x}px,${t2.y}px)
        `;
            }
            _calculateXYTransform() {
              const t2 = this._pos, i2 = this._map, o2 = this.getPitchAlignment();
              if (!i2 || !t2 || "map" !== o2) return "";
              if (!i2._showingGlobe()) {
                const e2 = i2.getPitch();
                return e2 ? `rotateX(${e2}deg)` : "";
              }
              const s2 = e.cJ(e.eL(i2.transform, this._lngLat)), r2 = t2.sub(e.eM(i2.transform)), n2 = Math.abs(r2.x) + Math.abs(r2.y);
              if (0 === n2) return "";
              const a2 = s2 / n2;
              return `rotateX(${-r2.y * a2}deg) rotateY(${r2.x * a2}deg)`;
            }
            _calculateZTransform() {
              const t2 = this._pos, i2 = this._map;
              if (!i2 || !t2) return "";
              let o2 = 0;
              const s2 = this.getRotationAlignment();
              if ("map" === s2) if (i2._showingGlobe()) {
                const t3 = i2.project(new e.cd(this._lngLat.lng, this._lngLat.lat + 1e-3), this._altitude), s3 = i2.project(new e.cd(this._lngLat.lng, this._lngLat.lat - 1e-3), this._altitude).sub(t3);
                o2 = e.cJ(Math.atan2(s3.y, s3.x)) - 90;
              } else o2 = -i2.getBearing();
              else if ("horizon" === s2) {
                const s3 = e.af(4, 6, i2.getZoom()), r2 = e.eM(i2.transform);
                r2.y += s3 * i2.transform.height;
                const n2 = t2.sub(r2), a2 = e.cJ(Math.atan2(n2.y, n2.x));
                o2 = (a2 > 90 ? a2 - 270 : a2 + 90) * (1 - s3);
              }
              return o2 += this._rotation, o2 ? `rotateZ(${o2}deg)` : "";
            }
            _update(e2) {
              cancelAnimationFrame(this._updateFrameId);
              const t2 = this._map;
              t2 && (t2.transform.renderWorldCopies && (this._lngLat = fl(this._lngLat, this._pos, t2.transform)), this._pos = t2.project(this._lngLat, this._altitude), true === e2 ? this._updateFrameId = requestAnimationFrame(() => {
                this._element && this._pos && this._anchor && (this._pos = this._pos.round(), this._updateDOM());
              }) : this._pos = this._pos.round(), t2._requestDomTask(() => {
                this._map && (this._element && this._pos && this._anchor && this._updateDOM(), (t2._showingGlobe() || t2.getTerrain() || t2.getFog()) && !this._fadeTimer && (this._fadeTimer = window.setTimeout(this._evaluateOpacity.bind(this), 60)));
              }));
            }
            getOffset() {
              return this._offset;
            }
            setOffset(t2) {
              return this._offset = e.P.convert(t2), this._update(), this;
            }
            addClassName(e2) {
              return this._element.classList.add(e2), this;
            }
            removeClassName(e2) {
              return this._element.classList.remove(e2), this;
            }
            toggleClassName(e2) {
              return this._element.classList.toggle(e2);
            }
            _onMove(t2) {
              const i2 = this._map;
              if (!i2) return;
              const o2 = this._pointerdownPos, s2 = this._positionDelta;
              if (o2 && s2) {
                if (!this._isDragging) {
                  const e2 = this._clickTolerance || i2._clickTolerance;
                  if (t2.point.dist(o2) < e2) return;
                  this._isDragging = true;
                }
                this._pos = t2.point.sub(s2), this._lngLat = i2.unproject(this._pos, this._altitude), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new e.A("dragstart"))), this.fire(new e.A("drag"));
              }
            }
            _onUp() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false;
              const t2 = this._map;
              t2 && (t2.off("mousemove", this._onMove), t2.off("touchmove", this._onMove)), "active" === this._state && this.fire(new e.A("dragend")), this._state = "inactive";
            }
            _addDragHandler(e2) {
              const t2 = this._map, i2 = this._pos;
              t2 && i2 && this._element.contains(e2.originalEvent.target) && (e2.preventDefault(), this._positionDelta = e2.point.sub(i2), this._pointerdownPos = e2.point, this._state = "pending", t2.on("mousemove", this._onMove), t2.on("touchmove", this._onMove), t2.once("mouseup", this._onUp), t2.once("touchend", this._onUp));
            }
            setDraggable(e2) {
              this._draggable = !!e2;
              const t2 = this._map;
              return t2 && (e2 ? (t2.on("mousedown", this._addDragHandler), t2.on("touchstart", this._addDragHandler)) : (t2.off("mousedown", this._addDragHandler), t2.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(e2) {
              return this._rotation = e2 || gl.rotation, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(e2) {
              return this._rotationAlignment = e2 || gl.rotationAlignment, this._update(), this;
            }
            getRotationAlignment() {
              return "auto" === this._rotationAlignment || "horizon" === this._rotationAlignment && this._map && !this._map._showingGlobe() ? "viewport" : this._rotationAlignment;
            }
            setPitchAlignment(e2) {
              return this._pitchAlignment = e2 || gl.pitchAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return "auto" === this._pitchAlignment ? this.getRotationAlignment() : this._pitchAlignment;
            }
            setOccludedOpacity(e2) {
              return this._occludedOpacity = e2 || gl.occludedOpacity, this._update(), this;
            }
            getOccludedOpacity() {
              return this._occludedOpacity;
            }
          }
          const yl = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true, showUserHeading: false }, xl = { maxWidth: 100, unit: "metric" }, bl = { kilometer: "km", meter: "m", mile: "mi", foot: "ft", "nautical-mile": "nm" }, wl = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px", altitude: 0 }, Tl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function El(t2 = new e.P(0, 0), i2 = "bottom") {
            if ("number" == typeof t2) {
              const o2 = Math.round(Math.sqrt(0.5 * Math.pow(t2, 2)));
              switch (i2) {
                case "top":
                  return new e.P(0, t2);
                case "top-left":
                  return new e.P(o2, o2);
                case "top-right":
                  return new e.P(-o2, o2);
                case "bottom":
                  return new e.P(0, -t2);
                case "bottom-left":
                  return new e.P(o2, -o2);
                case "bottom-right":
                  return new e.P(-o2, -o2);
                case "left":
                  return new e.P(t2, 0);
                case "right":
                  return new e.P(-t2, 0);
              }
              return new e.P(0, 0);
            }
            return t2 instanceof e.P || Array.isArray(t2) ? e.P.convert(t2) : e.P.convert(t2[i2] || [0, 0]);
          }
          const Sl = { version: t, supported: a.supported, setRTLTextPlugin: e.eN, getRTLTextPluginStatus: e.eO, Map: class extends ol {
            constructor(t2) {
              o.mark(i.create);
              const s2 = t2;
              if (null != (t2 = e.l({}, ul, t2)).minZoom && null != t2.maxZoom && t2.minZoom > t2.maxZoom) throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != t2.minPitch && null != t2.maxPitch && t2.minPitch > t2.maxPitch) throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != t2.minPitch && t2.minPitch < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (null != t2.maxPitch && t2.maxPitch > 85) throw new Error("maxPitch must be less than or equal to 85");
              if (t2.antialias && e.eI(window) && (t2.antialias = false, e.w("Antialiasing is disabled for this WebGL context to avoid browser bug: https://github.com/mapbox/mapbox-gl-js/issues/11609")), super(new Qi(t2.minZoom, t2.maxZoom, t2.minPitch, t2.maxPitch, t2.renderWorldCopies, null, null), t2), this._repaint = !!t2.repaint, this._interactive = t2.interactive, this._minTileCacheSize = t2.minTileCacheSize, this._maxTileCacheSize = t2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = t2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = t2.preserveDrawingBuffer, this._antialias = t2.antialias, this._trackResize = t2.trackResize, this._bearingSnap = t2.bearingSnap, this._refreshExpiredTiles = t2.refreshExpiredTiles, this._fadeDuration = t2.fadeDuration, this._isInitialLoad = true, this._crossSourceCollisions = t2.crossSourceCollisions, this._collectResourceTiming = t2.collectResourceTiming, this._language = this._parseLanguage(t2.language), this._worldview = t2.worldview, this._renderTaskQueue = new nl(), this._domRenderTaskQueue = new nl(), this._controls = [], this._markers = [], this._popups = [], this._mapId = e.a$(), this._locale = e.l({}, ll, t2.locale), this._clickTolerance = t2.clickTolerance, this._cooperativeGestures = t2.cooperativeGestures, this._performanceMetricsCollection = t2.performanceMetricsCollection, this._tessellationStep = t2.tessellationStep, this._containerWidth = 0, this._containerHeight = 0, this._showParseStatus = true, this._precompilePrograms = t2.precompilePrograms, this._scaleFactorChanged = false, this._averageElevationLastSampledAt = -1 / 0, this._averageElevationExaggeration = 0, this._averageElevation = new al(0), this._interactionRange = [1 / 0, -1 / 0], this._visibilityHidden = 0, this._useExplicitProjection = false, this._frameId = 0, this._scaleFactor = t2.scaleFactor, this._requestManager = new T(t2.transformRequest, t2.accessToken, t2.testMode), this._silenceAuthErrors = !!t2.testMode, this._contextCreateOptions = t2.contextCreateOptions ? Object.assign({}, t2.contextCreateOptions) : {}, "string" == typeof t2.container) {
                const e2 = document.getElementById(t2.container);
                if (!e2) throw new Error(`Container '${t2.container.toString()}' not found.`);
                this._container = e2;
              } else {
                if (!(t2.container instanceof HTMLElement)) throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = t2.container;
              }
              if (this._container.childNodes.length > 0 && e.w("The map container element should be empty, otherwise the map's interactivity will be negatively impacted. If you want to display a message when WebGL is not supported, use the Mapbox GL Supported plugin instead."), t2.maxBounds && this.setMaxBounds(t2.maxBounds), this._spriteFormat = t2.spriteFormat, e.aV(["_onWindowOnline", "_onWindowResize", "_onVisibilityChange", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._tp || (this._tp = new jn()), this._tp.registerParameter(this, ["Debug"], "showOverdrawInspector"), this._tp.registerParameter(this, ["Debug"], "showTileBoundaries"), this._tp.registerParameter(this, ["Debug"], "showParseStatus"), this._tp.registerParameter(this, ["Debug"], "repaint"), this._tp.registerParameter(this, ["Debug"], "showTileAABBs"), this._tp.registerParameter(this, ["Debug"], "showPadding"), this._tp.registerParameter(this, ["Debug"], "showCollisionBoxes", { noSave: true }), this._tp.registerParameter(this.transform, ["Debug"], "freezeTileCoverage", { noSave: true }, () => {
                this._update();
              }), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showTerrainWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers2DWireframe"), this._tp.registerParameter(this, ["Debug", "Wireframe"], "showLayers3DWireframe"), this._tp.registerParameter(this, ["Scaling"], "_scaleFactor", { min: 0.1, max: 10, step: 0.1 }, () => {
                this.setScaleFactor(this._scaleFactor);
              }), this._setupPainter(), void 0 === this.painter) throw new Error("Failed to initialize WebGL.");
              if (this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this._fullscreenchangeEvent = "onfullscreenchange" in document ? "fullscreenchange" : "webkitfullscreenchange", window.addEventListener("online", this._onWindowOnline, false), window.addEventListener("resize", this._onWindowResize, false), window.addEventListener("orientationchange", this._onWindowResize, false), window.addEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.addEventListener("visibilitychange", this._onVisibilityChange, false), this.handlers = new tl(this, t2), this._localFontFamily = t2.localFontFamily, this._localIdeographFontFamily = t2.localIdeographFontFamily, (t2.style || !t2.testMode) && this.setStyle(t2.style || e.e.DEFAULT_STYLE, { config: t2.config, localFontFamily: this._localFontFamily, localIdeographFontFamily: this._localIdeographFontFamily }), t2.projection && this.setProjection(t2.projection), this.indoor = new po(this), t2.hash && (this._hash = new sa("string" == typeof t2.hash && t2.hash || void 0).addTo(this)), !this._hash || !this._hash._onHashChange()) {
                null == s2.center && null == s2.zoom || (this.transform._unmodified = false), this.jumpTo({ center: t2.center, zoom: t2.zoom, bearing: t2.bearing, pitch: t2.pitch });
                const i2 = t2.bounds;
                i2 && (this.resize(), this.fitBounds(i2, e.l({}, t2.fitBoundsOptions, { duration: 0 })));
              }
              this.resize(), t2.attributionControl && this.addControl(new sl({ customAttribution: t2.customAttribution })), this._logoControl = new rl(), this.addControl(this._logoControl, t2.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet), this._postStyleLoadEvent();
              }), this.on("data", (t3) => {
                this._update("style" === t3.dataType), this.fire(new e.A(`${t3.dataType}data`, t3));
              }), this.on("dataloading", (t3) => {
                this.fire(new e.A(`${t3.dataType}dataloading`, t3));
              }), this._interactions = new hl(this);
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(t2, i2) {
              if (void 0 === i2 && (i2 = t2.getDefaultPosition ? t2.getDefaultPosition() : "top-right"), !t2 || !t2.onAdd) return this.fire(new e.z(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const o2 = t2.onAdd(this);
              this._controls.push(t2);
              const s2 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? s2.insertBefore(o2, s2.firstChild) : s2.appendChild(o2), this;
            }
            removeControl(t2) {
              if (!t2 || !t2.onRemove) return this.fire(new e.z(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i2 = this._controls.indexOf(t2);
              return i2 > -1 && this._controls.splice(i2, 1), t2.onRemove(this), this;
            }
            hasControl(e2) {
              return this._controls.indexOf(e2) > -1;
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            resize(t2) {
              if (this._updateContainerDimensions(), this._containerWidth === this.transform.width && this._containerHeight === this.transform.height) return this;
              this._resizeCanvas(this._containerWidth, this._containerHeight), this.transform.resize(this._containerWidth, this._containerHeight), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight));
              const i2 = !this._moving;
              return i2 && this.fire(new e.A("movestart", t2)).fire(new e.A("move", t2)), this.fire(new e.A("resize", t2)), i2 && this.fire(new e.A("moveend", t2)), this;
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds() || null;
            }
            setMaxBounds(t2) {
              return this.transform.setMaxBounds(e.aG.convert(t2)), this._update();
            }
            setMinZoom(t2) {
              if ((t2 = t2 ?? -2) >= -2 && t2 <= this.transform.maxZoom) return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 ? this.setZoom(t2) : this.fire(new e.A("zoomstart")).fire(new e.A("zoom")).fire(new e.A("zoomend")), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t2) {
              if ((t2 = t2 ?? 22) >= this.transform.minZoom) return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 ? this.setZoom(t2) : this.fire(new e.A("zoomstart")).fire(new e.A("zoom")).fire(new e.A("zoomend")), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t2) {
              if ((t2 = t2 ?? 0) < 0) throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch) return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 ? this.setPitch(t2) : this.fire(new e.A("pitchstart")).fire(new e.A("pitch")).fire(new e.A("pitchend")), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t2) {
              if ((t2 = t2 ?? 85) > 85) throw new Error("maxPitch must be less than or equal to 85");
              if (t2 >= this.transform.minPitch) return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 ? this.setPitch(t2) : this.fire(new e.A("pitchstart")).fire(new e.A("pitch")).fire(new e.A("pitchend")), this;
              throw new Error("maxPitch must be greater than or equal to minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getScaleFactor() {
              return this._scaleFactor;
            }
            setScaleFactor(e2) {
              return this._scaleFactor = e2, this.painter.scaleFactor = e2, this._tp.refreshUI(), this._scaleFactorChanged = true, this.style._updateFilteredLayers((e3) => "symbol" === e3.type), this._update(true), this;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(e2) {
              return this.transform.renderWorldCopies = e2, this.transform.renderWorldCopies || this._forceMarkerAndPopupUpdate(true), this._update();
            }
            getLanguage() {
              return this._language;
            }
            _parseLanguage(e2) {
              return "auto" === e2 ? navigator.language : Array.isArray(e2) ? 0 === e2.length ? void 0 : e2.map((e3) => "auto" === e3 ? navigator.language : e3) : e2;
            }
            setLanguage(e2) {
              const t2 = this._parseLanguage(e2);
              if (!this.style || t2 === this._language) return this;
              this._language = t2, this.style.reloadSources();
              for (const e3 of this._controls) e3._setLanguage && e3._setLanguage(this._language);
              return this;
            }
            getWorldview() {
              return this._worldview;
            }
            setWorldview(e2) {
              return this.style && e2 !== this._worldview ? (this._worldview = e2, this.style.reloadSources(), this) : this;
            }
            getProjection() {
              return this.transform.mercatorFromTransition ? { name: "globe", center: [0, 0] } : this.transform.getProjection();
            }
            _showingGlobe() {
              return "globe" === this.transform.projection.name;
            }
            setProjection(e2) {
              return this._lazyInitEmptyStyle(), e2 ? "string" == typeof e2 && (e2 = { name: e2 }) : e2 = null, this._useExplicitProjection = !!e2, this._prioritizeAndUpdateProjection(e2, this.style.projection);
            }
            _updateProjectionTransition() {
              if ("globe" !== this.getProjection().name) return;
              const t2 = this.transform, i2 = t2.projection.name;
              let o2;
              "globe" === i2 && t2.zoom >= e.cx ? (t2.setMercatorFromTransition(), o2 = true) : "mercator" === i2 && t2.zoom < e.cx && (t2.setProjection({ name: "globe" }), o2 = true), o2 && (this.style.applyProjectionUpdate(), this.style._forceSymbolLayerUpdate());
            }
            _prioritizeAndUpdateProjection(e2, t2) {
              return this._updateProjection(e2 || t2 || { name: "mercator" });
            }
            _updateProjection(t2) {
              let i2;
              return i2 = "globe" === t2.name && this.transform.zoom >= e.cx ? this.transform.setMercatorFromTransition() : this.transform.setProjection(t2), this.style.applyProjectionUpdate(), i2 && (this.painter.clearBackgroundTiles(), this.style.clearSources(), this._update(true), this._forceMarkerAndPopupUpdate(true)), this;
            }
            project(t2, i2) {
              return this.transform.locationPoint3D(e.cd.convert(t2), i2);
            }
            unproject(t2, i2) {
              return this.transform.pointLocation3D(e.P.convert(t2), i2);
            }
            isMoving() {
              return this._moving || this.handlers && this.handlers.isMoving() || false;
            }
            isZooming() {
              return this._zooming || this.handlers && this.handlers.isZooming() || false;
            }
            isRotating() {
              return this._rotating || this.handlers && this.handlers.isRotating() || false;
            }
            _isDragging() {
              return this.handlers && this.handlers._isDragging() || false;
            }
            _createDelegatedListener(e2, t2, i2) {
              const o2 = (e3) => {
                let i3 = [];
                if (Array.isArray(t2)) {
                  const o3 = t2.filter((e4) => this.getLayer(e4));
                  i3 = o3.length ? this.queryRenderedFeatures(e3, { layers: o3 }) : [];
                } else i3 = this.queryRenderedFeatures(e3, { target: t2 });
                return i3;
              };
              if ("mouseenter" === e2 || "mouseover" === e2) {
                let s2 = false;
                const r2 = (t3) => {
                  const r3 = o2(t3.point);
                  r3.length ? s2 || (s2 = true, i2.call(this, new pa(e2, this, t3.originalEvent, { features: r3 }))) : s2 = false;
                };
                return { listener: i2, targets: t2, delegates: { mousemove: r2, mouseout: () => {
                  s2 = false;
                } } };
              }
              if ("mouseleave" === e2 || "mouseout" === e2) {
                let s2 = false;
                const r2 = (t3) => {
                  o2(t3.point).length ? s2 = true : s2 && (s2 = false, i2.call(this, new pa(e2, this, t3.originalEvent)));
                }, n2 = (t3) => {
                  s2 && (s2 = false, i2.call(this, new pa(e2, this, t3.originalEvent)));
                };
                return { listener: i2, targets: t2, delegates: { mousemove: r2, mouseout: n2 } };
              }
              {
                const s2 = (e3) => {
                  const t3 = o2(e3.point);
                  t3.length && (e3.features = t3, i2.call(this, e3), delete e3.features);
                };
                return { listener: i2, targets: t2, delegates: { [e2]: s2 } };
              }
            }
            on(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2) return super.on(e2, t2);
              if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
              const o2 = this._createDelegatedListener(e2, t2, i2);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[e2] = this._delegatedListeners[e2] || [], this._delegatedListeners[e2].push(o2);
              for (const e3 in o2.delegates) this.on(e3, o2.delegates[e3]);
              return this;
            }
            once(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2) return super.once(e2, t2);
              if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
              const o2 = this._createDelegatedListener(e2, t2, i2);
              for (const e3 in o2.delegates) this.once(e3, o2.delegates[e3]);
              return this;
            }
            off(e2, t2, i2) {
              if ("function" == typeof t2 || void 0 === i2) return super.off(e2, t2);
              if ("string" == typeof t2 && (t2 = [t2]), !this._areTargetsValid(t2)) return this;
              const o2 = this._delegatedListeners ? this._delegatedListeners[e2] : void 0;
              return o2 && ((e3) => {
                for (let o3 = 0; o3 < e3.length; o3++) {
                  const s2 = e3[o3];
                  if (s2.listener === i2 && dl(s2.targets, t2)) {
                    for (const e4 in s2.delegates) this.off(e4, s2.delegates[e4]);
                    return e3.splice(o3, 1), this;
                  }
                }
              })(o2), this;
            }
            queryRenderedFeatures(t2, i2) {
              if (!this.style) return [];
              if (void 0 === t2 || t2 instanceof e.P || Array.isArray(t2) || void 0 !== i2 || (i2 = t2, t2 = void 0), t2 = t2 || [[0, 0], [this.transform.width, this.transform.height]], !i2) {
                const e2 = this.style.queryRenderedFeatures(t2, void 0, this.transform), i3 = this.style.queryRenderedFeatureset(t2, void 0, this.transform);
                return e2.concat(i3);
              }
              let o2 = true;
              if (i2.target && (o2 = this._isTargetValid(i2.target), o2 && !i2.layers)) return this.style.queryRenderedFeatureset(t2, i2, this.transform);
              let s2 = true;
              if (i2.layers && Array.isArray(i2.layers)) {
                for (const e2 of i2.layers) if (!this._isValidId(e2)) {
                  s2 = false;
                  break;
                }
                if (s2 && !i2.target) return this.style.queryRenderedFeatures(t2, i2, this.transform);
              }
              let r2 = [];
              return s2 && (r2 = r2.concat(this.style.queryRenderedFeatures(t2, i2, this.transform))), o2 && (r2 = r2.concat(this.style.queryRenderedFeatureset(t2, i2, this.transform))), r2;
            }
            querySourceFeatures(e2, t2) {
              return !e2 || "string" == typeof e2 && !this._isValidId(e2) ? [] : this.style.querySourceFeatures(e2, t2);
            }
            isPointOnSurface(t2) {
              const { name: i2 } = this.transform.projection;
              return "globe" !== i2 && "mercator" !== i2 && e.w(`${i2} projection does not support isPointOnSurface, this API may behave unexpectedly.`), this.transform.isPointOnSurface(e.P.convert(t2));
            }
            addInteraction(e2, t2) {
              return this._interactions.add(e2, t2), this;
            }
            removeInteraction(e2) {
              return this._interactions.remove(e2), this;
            }
            getCooperativeGestures() {
              return this._cooperativeGestures;
            }
            setCooperativeGestures(e2) {
              return this._cooperativeGestures = e2, this;
            }
            setStyle(t2, i2) {
              return i2 = e.l({}, { localIdeographFontFamily: this._localIdeographFontFamily, localFontFamily: this._localFontFamily }, i2), this.style && t2 && false !== i2.diff && i2.localFontFamily === this._localFontFamily && i2.localIdeographFontFamily === this._localIdeographFontFamily && !i2.config ? (this.style._diffStyle(t2, (o2, s2) => {
                if (o2) {
                  const s3 = "string" == typeof o2 ? o2 : o2 instanceof Error ? o2.message : o2.error;
                  e.w(`Unable to perform style diff: ${s3}. Rebuilding the style from scratch.`), this._updateStyle(t2, i2);
                } else s2 && this._update(true);
              }, () => this._postStyleLoadEvent()), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._localFontFamily = i2.localFontFamily, this._updateStyle(t2, i2));
            }
            _getUIString(e2) {
              const t2 = this._locale[e2];
              if (null == t2) throw new Error(`Missing UI string '${e2}'`);
              return t2;
            }
            _updateStyle(t2, i2) {
              if (this.style && (this.style.setEventedParent(null), this.style._remove(), this.style = void 0), t2) {
                const o2 = e.l({}, i2);
                i2 && i2.config && (o2.initialConfig = i2.config, delete o2.config), this.style = new Eo(this, o2).load(t2), this.style.setEventedParent(this, { style: this.style });
              }
              return this._updateTerrain(), this;
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new Eo(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            getStyle() {
              if (this.style) return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : (e.w("There is no style added to the map."), false);
            }
            _isValidId(t2) {
              return null == t2 ? (this.fire(new e.z(new Error("IDs can't be empty."))), false) : !e.d9(t2) || (this.fire(new e.z(new Error(`IDs can't contain special symbols: "${t2}".`))), false);
            }
            _isTargetValid(e2) {
              return "featuresetId" in e2 ? this._isValidId("importId" in e2 ? e2.importId : e2.featuresetId) : "layerId" in e2 && this._isValidId(e2.layerId);
            }
            _areTargetsValid(e2) {
              if (Array.isArray(e2)) {
                for (const t2 of e2) if (!this._isValidId(t2)) return false;
                return true;
              }
              return this._isTargetValid(e2);
            }
            addSource(e2, t2) {
              return this._isValidId(e2) ? (this._lazyInitEmptyStyle(), this.style.addSource(e2, t2), this._update(true)) : this;
            }
            isSourceLoaded(e2) {
              return !!this._isValidId(e2) && !!this.style && this.style._isSourceCacheLoaded(e2);
            }
            areTilesLoaded() {
              return this.style.areTilesLoaded();
            }
            addSourceType(e2, t2, i2) {
              this._lazyInitEmptyStyle(), this.style.addSourceType(e2, t2, i2);
            }
            removeSource(e2) {
              return this._isValidId(e2) ? (this.style.removeSource(e2), this._updateTerrain(), this._update(true)) : this;
            }
            getSource(e2) {
              return this._isValidId(e2) ? this.style.getOwnSource(e2) : null;
            }
            addImage(t2, i2, { pixelRatio: o2 = 1, sdf: s2 = false, stretchX: r2, stretchY: n2, content: a2 } = {}) {
              this._lazyInitEmptyStyle();
              const l2 = e.I.from(t2);
              if (i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap) {
                const { width: t3, height: c2, data: h2 } = e.q.getImageData(i2);
                this.style.addImage(l2, { data: new e.r({ width: t3, height: c2 }, h2), pixelRatio: o2, stretchX: r2, stretchY: n2, content: a2, sdf: s2, version: 0, usvg: false });
              } else if (void 0 === i2.width || void 0 === i2.height) this.fire(new e.z(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              else {
                const { width: c2, height: h2 } = i2, d2 = i2;
                this.style.addImage(l2, { data: new e.r({ width: c2, height: h2 }, new Uint8Array(d2.data)), pixelRatio: o2, stretchX: r2, stretchY: n2, content: a2, sdf: s2, usvg: false, version: 0, userImage: d2 }), d2.onAdd && d2.onAdd(this, t2);
              }
            }
            updateImage(t2, i2) {
              this._lazyInitEmptyStyle();
              const o2 = e.I.from(t2), s2 = this.style.getImage(o2);
              if (!s2) return void this.fire(new e.z(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const r2 = i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap ? e.q.getImageData(i2) : i2, { width: n2, height: a2, data: l2 } = r2;
              if (void 0 === n2 || void 0 === a2) return void this.fire(new e.z(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (n2 !== (s2.usvg ? s2.icon.usvg_tree.width : s2.data.width) || a2 !== (s2.usvg ? s2.icon.usvg_tree.height : s2.data.height)) return void this.fire(new e.z(new Error(`The width and height of the updated image (${n2}, ${a2})
                must be that same as the previous version of the image
                (${s2.data.width}, ${s2.data.height})`)));
              const c2 = !(i2 instanceof HTMLImageElement || ImageBitmap && i2 instanceof ImageBitmap);
              let h2 = false;
              s2.usvg ? (s2.data = new e.r({ width: n2, height: a2 }, new Uint8Array(l2)), s2.usvg = false, s2.icon = void 0, h2 = true) : s2.data.replace(l2, c2), this.style.updateImage(o2, s2, h2);
            }
            hasImage(t2) {
              return t2 ? !!this.style && !!this.style.getImage(e.I.from(t2)) : (this.fire(new e.z(new Error("Missing required image id"))), false);
            }
            removeImage(t2) {
              this.style.removeImage(e.I.from(t2));
            }
            loadImage(t2, i2) {
              e.o(this._requestManager.transformRequest(t2, e.R.Image), (t3, o2) => {
                i2(t3, o2 instanceof HTMLImageElement ? e.q.getImageData(o2) : o2);
              });
            }
            listImages() {
              return this.style.listImages().map((e2) => e2.name);
            }
            addModel(e2, t2) {
              this._lazyInitEmptyStyle(), this.style.addModel(e2, t2);
            }
            hasModel(t2) {
              return t2 ? this.style.hasModel(t2) : (this.fire(new e.z(new Error("Missing required model id"))), false);
            }
            removeModel(e2) {
              this.style.removeModel(e2);
            }
            listModels() {
              return this.style.listModels();
            }
            addLayer(e2, t2) {
              return this._isValidId(e2.id) ? (this._lazyInitEmptyStyle(), this.style.addLayer(e2, t2), this._update(true)) : this;
            }
            getSlot(e2) {
              const t2 = this.getLayer(e2);
              return t2 && t2.slot || null;
            }
            setSlot(e2, t2) {
              return this.style.setSlot(e2, t2), this.style.mergeLayers(), this._update(true);
            }
            addImport(t2, i2) {
              return this.style.addImport(t2, i2).catch((t3) => this.fire(new e.z(new Error("Failed to add import", t3)))), this;
            }
            updateImport(e2, t2) {
              return "string" != typeof t2 && t2.id !== e2 ? (this.removeImport(e2), this.addImport(t2)) : (this.style.updateImport(e2, t2), this._update(true));
            }
            removeImport(e2) {
              return this.style.removeImport(e2), this;
            }
            moveImport(e2, t2) {
              return this.style.moveImport(e2, t2), this._update(true);
            }
            moveLayer(e2, t2) {
              return this._isValidId(e2) ? (this.style.moveLayer(e2, t2), this._update(true)) : this;
            }
            removeLayer(e2) {
              return this._isValidId(e2) ? (this.style.removeLayer(e2), this._update(true)) : this;
            }
            getLayer(e2) {
              if (!this._isValidId(e2)) return null;
              const t2 = this.style.getOwnLayer(e2);
              return t2 ? "custom" === t2.type ? t2.implementation : t2.serialize() : void 0;
            }
            getSlots() {
              return this.style.getSlots();
            }
            setLayerZoomRange(e2, t2, i2) {
              return this._isValidId(e2) ? (this.style.setLayerZoomRange(e2, t2, i2), this._update(true)) : this;
            }
            setFilter(e2, t2, i2 = {}) {
              return this._isValidId(e2) ? (this.style.setFilter(e2, t2, i2), this._update(true)) : this;
            }
            getFilter(e2) {
              return this._isValidId(e2) ? this.style.getFilter(e2) : null;
            }
            setPaintProperty(e2, t2, i2, o2 = {}) {
              return this._isValidId(e2) ? (this.style.setPaintProperty(e2, t2, i2, o2), this._update(true)) : this;
            }
            getPaintProperty(e2, t2) {
              return this._isValidId(e2) ? this.style.getPaintProperty(e2, t2) : null;
            }
            setLayoutProperty(e2, t2, i2, o2 = {}) {
              return this._isValidId(e2) ? (this.style.setLayoutProperty(e2, t2, i2, o2), this._update(true)) : this;
            }
            getLayoutProperty(e2, t2) {
              return this._isValidId(e2) ? this.style.getLayoutProperty(e2, t2) : null;
            }
            getGlyphsUrl() {
              return this.style.getGlyphsUrl();
            }
            setGlyphsUrl(e2) {
              return this.style.setGlyphsUrl(e2), this._update(true);
            }
            getSchema(e2) {
              return this.style.getSchema(e2);
            }
            setSchema(e2, t2) {
              return this.style.setSchema(e2, t2), this._update(true);
            }
            getConfig(e2) {
              return this.style.getConfig(e2);
            }
            setConfig(e2, t2) {
              return this.style.setConfig(e2, t2), this._update(true);
            }
            getConfigProperty(e2, t2) {
              return this.style.getConfigProperty(e2, t2);
            }
            setConfigProperty(e2, t2, i2) {
              return this.style.setConfigProperty(e2, t2, i2), this._update(true);
            }
            getFeaturesetDescriptors(e2) {
              return this.style.getFeaturesetDescriptors(e2);
            }
            setLights(e2) {
              if (this._lazyInitEmptyStyle(), e2 && 1 === e2.length && "flat" === e2[0].type) {
                const t2 = e2[0];
                t2.properties ? this.style.setFlatLight(t2.properties, t2.id, {}) : this.style.setFlatLight({}, "flat");
              } else this.style.setLights(e2), this.painter.terrain && (this.painter.terrain.invalidateRenderCache = true);
              return this._update(true);
            }
            getLights() {
              const e2 = this.style.getLights() || [];
              return 0 === e2.length && e2.push({ id: this.style.light.id, type: "flat", properties: this.style.getFlatLight() }), e2;
            }
            setLight(e2, t2 = {}) {
              return console.log("The `map.setLight` function is deprecated, prefer using `map.setLights` with `flat` light type instead."), this.setLights([{ id: "flat", type: "flat", properties: e2 }]);
            }
            getLight() {
              return console.log("The `map.getLight` function is deprecated, prefer using `map.getLights` instead."), this.style.getFlatLight();
            }
            setTerrain(e2) {
              return this._lazyInitEmptyStyle(), !e2 && this.transform.projection.requiresDraping ? this.style.setTerrainForDraping() : this.style.setTerrain(e2), this._averageElevationLastSampledAt = -1 / 0, this._update(true);
            }
            getTerrain() {
              return this.style ? this.style.getTerrain() : null;
            }
            setFog(e2) {
              return this._lazyInitEmptyStyle(), this.style.setFog(e2), this._update(true);
            }
            getFog() {
              return this.style ? this.style.getFog() : null;
            }
            setSnow(e2) {
              return this._lazyInitEmptyStyle(), this.style.setSnow(e2), this._update(true);
            }
            getSnow() {
              return this.style ? this.style.getSnow() : null;
            }
            setRain(e2) {
              return this._lazyInitEmptyStyle(), this.style.setRain(e2), this._update(true);
            }
            getRain() {
              return this.style ? this.style.getRain() : null;
            }
            setColorTheme(e2) {
              return this._lazyInitEmptyStyle(), this.style.setColorTheme(e2), this._update(true);
            }
            setImportColorTheme(e2, t2) {
              return this._lazyInitEmptyStyle(), this.style.setImportColorTheme(e2, t2), this._update(true);
            }
            setCamera(e2) {
              return this.style.setCamera(e2), this._triggerCameraUpdate(e2);
            }
            _triggerCameraUpdate(e2) {
              return this._update(this.transform.setOrthographicProjectionAtLowPitch("orthographic" === e2["camera-projection"]));
            }
            getCamera() {
              return this.style.camera;
            }
            _queryFogOpacity(t2) {
              return this.style && this.style.fog ? this.style.fog.getOpacityAtLatLng(e.cd.convert(t2), this.transform) : 0;
            }
            setFeatureState(e2, t2) {
              return e2.source && !this._isValidId(e2.source) ? this : (this.style.setFeatureState(e2, t2), this._update());
            }
            removeFeatureState(e2, t2) {
              return e2.source && !this._isValidId(e2.source) ? this : (this.style.removeFeatureState(e2, t2), this._update());
            }
            getFeatureState(e2) {
              return e2.source && !this._isValidId(e2.source) ? null : this.style.getFeatureState(e2);
            }
            _updateContainerDimensions() {
              if (!this._container) return;
              const e2 = this._container.getBoundingClientRect().width || 400, t2 = this._container.getBoundingClientRect().height || 300;
              let i2, o2, s2, r2 = this._container;
              for (; r2 && (!o2 || !s2); ) {
                const e3 = window.getComputedStyle(r2).transform;
                e3 && "none" !== e3 && (i2 = e3.match(/matrix.*\((.+)\)/)[1].split(", "), i2[0] && "0" !== i2[0] && "1" !== i2[0] && (o2 = i2[0]), i2[3] && "0" !== i2[3] && "1" !== i2[3] && (s2 = i2[3])), r2 = r2.parentElement;
              }
              this._containerWidth = o2 ? Math.abs(e2 / o2) : e2, this._containerHeight = s2 ? Math.abs(t2 / s2) : t2;
            }
            _detectMissingCSS() {
              "rgb(250, 128, 114)" !== window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && e.w("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
            }
            _setupContainer() {
              const e2 = this._container;
              e2.classList.add("mapboxgl-map"), (this._missingCSSCanary = l("div", "mapboxgl-canary", e2)).style.visibility = "hidden", this._detectMissingCSS();
              const t2 = this._canvasContainer = l("div", "mapboxgl-canvas-container", e2);
              this._canvas = l("canvas", "mapboxgl-canvas", t2), this._interactive && (t2.classList.add("mapboxgl-interactive"), this._canvas.setAttribute("tabindex", "0")), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")), this._canvas.setAttribute("role", "region"), this._updateContainerDimensions(), this._resizeCanvas(this._containerWidth, this._containerHeight);
              const i2 = this._controlContainer = l("div", "mapboxgl-control-container", e2), o2 = this._controlPositions = {};
              ["top-left", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left"].forEach((e3) => {
                o2[e3] = l("div", `mapboxgl-ctrl-${e3}`, i2);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _resizeCanvas(t2, i2) {
              const o2 = e.q.devicePixelRatio || 1;
              this._canvas.width = o2 * Math.ceil(t2), this._canvas.height = o2 * Math.ceil(i2), this._canvas.style.width = `${t2}px`, this._canvas.style.height = `${i2}px`;
            }
            _addMarker(e2) {
              this._markers.push(e2);
            }
            _removeMarker(e2) {
              const t2 = this._markers.indexOf(e2);
              -1 !== t2 && this._markers.splice(t2, 1);
            }
            _addPopup(e2) {
              this._popups.push(e2);
            }
            _removePopup(e2) {
              const t2 = this._popups.indexOf(e2);
              -1 !== t2 && this._popups.splice(t2, 1);
            }
            _setupPainter() {
              const t2 = e.l({}, a.supported.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), i2 = this._canvas.getContext("webgl2", t2);
              i2 ? (j(i2, true), this.painter = new ia(i2, this._contextCreateOptions, this.transform, this._scaleFactor, this._tp), this.on("data", (e2) => {
                "source" === e2.dataType && this.painter.setTileLoadedFlag(true);
              }), e.m.testSupport(i2)) : this.fire(new e.z(new Error("Failed to initialize WebGL")));
            }
            _contextLost(t2) {
              t2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new e.A("webglcontextlost", { originalEvent: t2 }));
            }
            _contextRestored(t2) {
              this._setupPainter(), this.painter.resize(Math.ceil(this._containerWidth), Math.ceil(this._containerHeight)), this._updateTerrain(), this.style && (this.style.reloadModels(), this.style.clearSources()), this._update(), this.fire(new e.A("webglcontextrestored", { originalEvent: t2 }));
            }
            _onMapScroll(e2) {
              if (e2.target === this._container) return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }
            idle() {
              return !this.isMoving() && this.loaded();
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            frameReady() {
              return this.loaded() && !this._placementDirty;
            }
            _update(e2) {
              return this.style ? (this._styleDirty = this._styleDirty || e2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(e2) {
              return this._update(), this._renderTaskQueue.add(e2);
            }
            _cancelRenderFrame(e2) {
              this._renderTaskQueue.remove(e2);
            }
            _requestDomTask(e2) {
              !this.loaded() || this.loaded() && !this.isMoving() ? e2() : this._domRenderTaskQueue.add(e2);
            }
            _render(t2) {
              let s2;
              this.fire(new e.A("renderstart")), ++this._frameId;
              const r2 = this.painter.context.extTimerQuery, n2 = e.q.now(), a2 = this.painter.context.gl;
              if (this.listens("gpu-timing-frame") && (s2 = a2.createQuery(), a2.beginQuery(r2.TIME_ELAPSED_EXT, s2)), this.painter.context.setDirty(), this.painter.setBaseState(), (this.isMoving() || this.isRotating() || this.isZooming()) && (this._interactionRange[0] = Math.min(this._interactionRange[0], performance.now()), this._interactionRange[1] = Math.max(this._interactionRange[1], performance.now())), this._renderTaskQueue.run(t2), this._domRenderTaskQueue.run(t2), this._removed) return;
              this._updateProjectionTransition();
              const l2 = this._isInitialLoad ? 0 : this._fadeDuration;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const t3 = this.transform.zoom, i2 = this.transform.pitch, o2 = e.q.now(), s3 = new e.aa(t3, { now: o2, fadeDuration: l2, pitch: i2, transition: this.style.transition });
                this.style.update(s3);
              }
              this.style && this.style.hasFogTransition() && (this.style._markersNeedUpdate = true, this._sourcesDirty = true);
              let c2 = false;
              this.style && this._sourcesDirty ? (this._sourcesDirty = false, this.painter._updateFog(this.style), this._updateTerrain(), c2 = this._updateAverageElevation(n2), this.style.updateSources(this.transform), this.style.updateImageProviders(), this.isMoving() || this._forceMarkerAndPopupUpdate()) : c2 = this._updateAverageElevation(n2);
              const h2 = this.style && this.style._updatePlacement(this.painter, this.painter.transform, this.showCollisionBoxes, l2, this._crossSourceCollisions, this.painter.replacementSource, this._scaleFactorChanged);
              if (this._scaleFactorChanged && (this._scaleFactorChanged = false), h2 && (this._placementDirty = h2.needsRerender), this.style && this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showParseStatus: this.showParseStatus, wireframe: { terrain: this.showTerrainWireframe, layers2D: this.showLayers2DWireframe, layers3D: this.showLayers3DWireframe }, showOverdrawInspector: this._showOverdrawInspector, showQueryGeometry: !!this._showQueryGeometry, showTileAABBs: this.showTileAABBs, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: l2, isInitialLoad: this._isInitialLoad, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer"), gpuTimingDeferredRender: !!this.listens("gpu-timing-deferred-render"), speedIndexTiming: this.speedIndexTiming }), this.fire(new e.A("render")), this.loaded() && !this._loaded && (this._loaded = true, o.mark(i.load), this.fire(new e.A("load"))), this.style && this.style.hasTransitions() && (this._styleDirty = true), this.style && (this.style.snow || this.style.rain) && (this._styleDirty = true), this.style && this.style.imageManager.hasPatternsInFlight() && (this._styleDirty = true), this.style && !this.style.modelManager.isLoaded() && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), s2) {
                const t3 = e.q.now() - n2;
                a2.endQuery(r2.TIME_ELAPSED_EXT), setTimeout(() => {
                  const i2 = a2.getQueryParameter(s2, a2.QUERY_RESULT) / 1e6;
                  a2.deleteQuery(s2), this.fire(new e.A("gpu-timing-frame", { cpuTime: t3, gpuTime: i2 }));
                }, 50);
              }
              if (this.listens("gpu-timing-layer")) {
                const t3 = this.painter.collectGpuTimers();
                setTimeout(() => {
                  const i2 = this.painter.queryGpuTimers(t3);
                  this.fire(new e.A("gpu-timing-layer", { layerTimes: i2 }));
                }, 50);
              }
              if (this.listens("gpu-timing-deferred-render")) {
                const t3 = this.painter.collectDeferredRenderGpuQueries();
                setTimeout(() => {
                  const i2 = this.painter.queryGpuTimeDeferredRender(t3);
                  this.fire(new e.A("gpu-timing-deferred-render", { gpuTime: i2 }));
                }, 50);
              }
              const d2 = this._sourcesDirty || this._styleDirty || this._placementDirty || c2;
              if (d2 || this._repaint) this.triggerRepaint();
              else {
                const t3 = this.idle();
                if (t3 && (c2 = this._updateAverageElevation(n2, true)), c2) this.triggerRepaint();
                else if (this._triggerFrame(false), t3 && (this.fire(new e.A("idle")), this._isInitialLoad = false, this.speedIndexTiming)) {
                  const t4 = this._calculateSpeedIndex();
                  this.fire(new e.A("speedindexcompleted", { speedIndex: t4 })), this.speedIndexTiming = false;
                }
              }
              !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true, o.mark(i.fullLoad), this._performanceMetricsCollection && B2(this._requestManager._customAccessToken, { width: this.painter.width, height: this.painter.height, interactionRange: this._interactionRange, visibilityHidden: this._visibilityHidden, terrainEnabled: !!this.painter.style.getTerrain(), fogEnabled: !!this.painter.style.getFog(), projection: this.getProjection().name, zoom: this.transform.zoom, renderer: this.painter.context.renderer, vendor: this.painter.context.vendor }), this._authenticate());
            }
            _forceMarkerAndPopupUpdate(e2) {
              for (const t2 of this._markers) e2 && !this.getRenderWorldCopies() && (t2._lngLat = t2._lngLat.wrap()), t2._update();
              for (const t2 of this._popups) !e2 || this.getRenderWorldCopies() || t2._trackPointer || (t2._lngLat = t2._lngLat.wrap()), t2._update();
            }
            _updateAverageElevation(e2, t2 = false) {
              const i2 = (e3) => (this.transform.averageElevation = e3, this._update(false), true);
              if (!this.painter.averageElevationNeedsEasing()) return 0 !== this.transform.averageElevation && i2(0);
              const o2 = this.transform.elevation && this.transform.elevation.exaggeration() !== this._averageElevationExaggeration;
              if (o2 || (t2 || e2 - this._averageElevationLastSampledAt > 500) && !this._averageElevation.isEasing(e2)) {
                const t3 = this.transform.averageElevation;
                let s2 = this.transform.sampleAverageElevation();
                null != this.transform.elevation && (this._averageElevationExaggeration = this.transform.elevation.exaggeration()), isNaN(s2) ? s2 = 0 : this._averageElevationLastSampledAt = e2;
                const r2 = Math.abs(t3 - s2);
                if (r2 > 1) {
                  if (this._isInitialLoad || o2) return this._averageElevation.jumpTo(s2), i2(s2);
                  this._averageElevation.easeTo(s2, e2, 300);
                } else if (r2 > 1e-4) return this._averageElevation.jumpTo(s2), i2(s2);
              }
              return !!this._averageElevation.isEasing(e2) && i2(this._averageElevation.getValue(e2));
            }
            _authenticate() {
              N(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, (t2) => {
                if (t2 && (t2.message === w || 401 === t2.status)) {
                  const t3 = this.painter.context.gl;
                  j(t3, false), this._logoControl instanceof rl && this._logoControl._updateLogo(), t3 && t3.clear(t3.DEPTH_BUFFER_BIT | t3.COLOR_BUFFER_BIT | t3.STENCIL_BUFFER_BIT), this._silenceAuthErrors || this.fire(new e.z(new Error("A valid Mapbox access token is required to use Mapbox GL JS. To create an account or a new access token, visit https://account.mapbox.com/")));
                }
              }), z(this._getMapId(), this._requestManager._skuToken, this._requestManager._customAccessToken, () => {
              });
            }
            _postStyleLoadEvent() {
              this.style.globalId && O(this._requestManager._customAccessToken, { map: this, style: this.style.globalId, importedStyles: this.style.getImportGlobalIds() });
            }
            _updateTerrain() {
              const e2 = this._isDragging();
              this.painter.updateTerrain(this.style, e2);
            }
            _calculateSpeedIndex() {
              const e2 = this.painter.canvasCopy(), t2 = this.painter.getCanvasCopiesAndTimestamps();
              t2.timeStamps.push(performance.now());
              const i2 = this.painter.context.gl, o2 = i2.createFramebuffer();
              function s2(e3) {
                i2.framebufferTexture2D(i2.FRAMEBUFFER, i2.COLOR_ATTACHMENT0, i2.TEXTURE_2D, e3, 0);
                const t3 = new Uint8Array(i2.drawingBufferWidth * i2.drawingBufferHeight * 4);
                return i2.readPixels(0, 0, i2.drawingBufferWidth, i2.drawingBufferHeight, i2.RGBA, i2.UNSIGNED_BYTE, t3), t3;
              }
              return i2.bindFramebuffer(i2.FRAMEBUFFER, o2), this._canvasPixelComparison(s2(e2), t2.canvasCopies.map(s2), t2.timeStamps);
            }
            _canvasPixelComparison(e2, t2, i2) {
              let o2 = i2[1] - i2[0];
              const s2 = e2.length / 4;
              for (let r2 = 0; r2 < t2.length; r2++) {
                const n2 = t2[r2];
                let a2 = 0;
                for (let t3 = 0; t3 < n2.length; t3 += 4) n2[t3] === e2[t3] && n2[t3 + 1] === e2[t3 + 1] && n2[t3 + 2] === e2[t3 + 2] && n2[t3 + 3] === e2[t3 + 3] && (a2 += 1);
                o2 += (i2[r2 + 2] - i2[r2 + 1]) * (1 - a2 / s2);
              }
              return o2;
            }
            remove() {
              this._hash && this._hash.remove();
              for (const e2 of this._controls) e2.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this._domRenderTaskQueue.clear(), this.style && this.style.destroy(), this.indoor.destroy(), this.painter.destroy(), this.handlers && this.handlers.destroy(), this.handlers = void 0, this.setStyle(null), window.removeEventListener("resize", this._onWindowResize, false), window.removeEventListener("orientationchange", this._onWindowResize, false), window.removeEventListener(this._fullscreenchangeEvent, this._onWindowResize, false), window.removeEventListener("online", this._onWindowOnline, false), window.removeEventListener("visibilitychange", this._onVisibilityChange, false);
              const t2 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              t2 && t2.loseContext(), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvasContainer.remove(), this._controlContainer.remove(), this._missingCSSCanary.remove(), this._canvas = void 0, this._canvasContainer = void 0, this._controlContainer = void 0, this._missingCSSCanary = void 0, this._container.classList.remove("mapboxgl-map"), this._container.removeEventListener("scroll", this._onMapScroll, false), U.delete(this.painter.context.gl), k.remove(), P.remove(), this._removed = true, this.fire(new e.A("remove"));
            }
            triggerRepaint() {
              this._triggerFrame(true);
            }
            _triggerFrame(t2) {
              this._renderNextFrame = this._renderNextFrame || t2, this.style && !this._frame && (this._frame = e.q.frame((e2) => {
                const t3 = !!this._renderNextFrame;
                this._frame = null, this._renderNextFrame = null, t3 && this._render(e2);
              }));
            }
            _preloadTiles(t2) {
              const i2 = this.style ? this.style.getSourceCaches() : [];
              return e.bt(i2, (e2, i3) => e2._preloadTiles(t2, i3), () => {
                this.triggerRepaint();
              }), this;
            }
            _onWindowOnline() {
              this._update();
            }
            _onWindowResize(e2) {
              this._trackResize && this.resize({ originalEvent: e2 })._update();
            }
            _onVisibilityChange() {
              "hidden" === document.visibilityState && this._visibilityHidden++;
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(e2) {
              this._showTileBoundaries !== e2 && (this._showTileBoundaries = e2, this._tp.refreshUI(), this._update());
            }
            get showParseStatus() {
              return !!this._showParseStatus;
            }
            set showParseStatus(e2) {
              this._showParseStatus !== e2 && (this._showParseStatus = e2, this._tp.refreshUI(), this._update());
            }
            get showTerrainWireframe() {
              return !!this._showTerrainWireframe;
            }
            set showTerrainWireframe(e2) {
              this._showTerrainWireframe !== e2 && (this._showTerrainWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get showLayers2DWireframe() {
              return !!this._showLayers2DWireframe;
            }
            set showLayers2DWireframe(e2) {
              this._showLayers2DWireframe !== e2 && (this._showLayers2DWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get showLayers3DWireframe() {
              return !!this._showLayers3DWireframe;
            }
            set showLayers3DWireframe(e2) {
              this._showLayers3DWireframe !== e2 && (this._showLayers3DWireframe = e2, this._tp.refreshUI(), this._update());
            }
            get speedIndexTiming() {
              return !!this._speedIndexTiming;
            }
            set speedIndexTiming(e2) {
              this._speedIndexTiming !== e2 && (this._speedIndexTiming = e2, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(e2) {
              this._showPadding !== e2 && (this._showPadding = e2, this._tp.refreshUI(), this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(e2) {
              this._showCollisionBoxes !== e2 && (this._showCollisionBoxes = e2, this._tp.refreshUI(), e2 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(e2) {
              this._showOverdrawInspector !== e2 && (this._showOverdrawInspector = e2, this._tp.refreshUI(), this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(e2) {
              this._repaint !== e2 && (this._repaint = e2, this._tp.refreshUI(), this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(e2) {
              this._vertices = e2, this._update();
            }
            get showTileAABBs() {
              return !!this._showTileAABBs;
            }
            set showTileAABBs(e2) {
              this._showTileAABBs !== e2 && (this._showTileAABBs = e2, this._tp.refreshUI(), e2 && this._update());
            }
            _setCacheLimits(t2, i2) {
              e.eJ(t2, i2);
            }
            get version() {
              return t;
            }
          }, NavigationControl: class {
            constructor(t2 = {}) {
              this.options = e.l({}, _l, t2), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this.options.showZoom && (e.aV(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", (e2) => {
                this._map && this._map.zoomIn({}, { originalEvent: e2 });
              }), l("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", (e2) => {
                this._map && this._map.zoomOut({}, { originalEvent: e2 });
              }), l("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (e.aV(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", (e2) => {
                const t3 = this._map;
                t3 && (this.options.visualizePitch ? t3.resetNorthPitch({}, { originalEvent: e2 }) : t3.resetNorth({}, { originalEvent: e2 }));
              }), this._compassIcon = l("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            _updateZoomButtons() {
              const e2 = this._map;
              if (!e2) return;
              const t2 = e2.getZoom(), i2 = t2 === e2.getMaxZoom(), o2 = t2 === e2.getMinZoom();
              this._zoomInButton.disabled = i2, this._zoomOutButton.disabled = o2, this._zoomInButton.setAttribute("aria-disabled", i2.toString()), this._zoomOutButton.setAttribute("aria-disabled", o2.toString());
            }
            _rotateCompassArrow() {
              const e2 = this._map;
              if (!e2) return;
              const t2 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(e2.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${e2.transform.pitch}deg) rotateZ(${e2.transform.angle * (180 / Math.PI)}deg)` : `rotate(${e2.transform.angle * (180 / Math.PI)}deg)`;
              e2._requestDomTask(() => {
                this._compassIcon && (this._compassIcon.style.transform = t2);
              });
            }
            onAdd(e2) {
              return this._map = e2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), e2.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && e2.on("pitch", this._rotateCompassArrow), e2.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new pl(e2, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              const e2 = this._map;
              e2 && (this._container.remove(), this.options.showZoom && e2.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && e2.off("pitch", this._rotateCompassArrow), e2.off("rotate", this._rotateCompassArrow), this._handler && this._handler.off(), this._handler = void 0), this._map = void 0);
            }
            _createButton(e2, t2) {
              const i2 = l("button", e2, this._container);
              return i2.type = "button", i2.addEventListener("click", t2), i2;
            }
            _setButtonTitle(e2, t2) {
              if (!this._map) return;
              const i2 = this._map._getUIString(`NavigationControl.${t2}`);
              e2.setAttribute("aria-label", i2), e2.firstElementChild && e2.firstElementChild.setAttribute("title", i2);
            }
          }, GeolocateControl: class extends e.E {
            constructor(t2 = {}) {
              super();
              const i2 = navigator.geolocation;
              this.options = e.l({ geolocation: i2 }, yl, t2), e.aV(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker", "_updateMarkerRotation", "_onDeviceOrientation"], this), this._updateMarkerRotationThrottled = oa(this._updateMarkerRotation, 20), this._numberOfWatches = 0;
            }
            onAdd(e2) {
              return this._map = e2, this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkGeolocationSupport(this._setupUI), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (this.options.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), this._container.remove(), this._map.off("zoom", this._onZoom), this._map = void 0, this._numberOfWatches = 0, this._noTimeout = false;
            }
            _checkGeolocationSupport(e2) {
              const t2 = (t3 = !!this.options.geolocation) => {
                this._supportsGeolocation = t3, e2(t3);
              };
              void 0 !== this._supportsGeolocation ? e2(this._supportsGeolocation) : void 0 !== navigator.permissions ? navigator.permissions.query({ name: "geolocation" }).then((e3) => t2("denied" !== e3.state)).catch(() => t2()) : t2();
            }
            _isOutOfMapMaxBounds(e2) {
              const t2 = this._map.getMaxBounds(), i2 = e2.coords;
              return !!t2 && (i2.longitude < t2.getWest() || i2.longitude > t2.getEast() || i2.latitude < t2.getSouth() || i2.latitude > t2.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              }
            }
            _onSuccess(t2) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(t2)) return this._setErrorState(), this.fire(new e.A("outofmaxbounds", t2)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation) switch (this._lastKnownPosition = t2, this._watchState) {
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "BACKGROUND":
                  case "BACKGROUND_ERROR":
                    this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(t2), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(t2), this.options.showUserLocation && this._userLocationDotMarker.removeClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.A("geolocate", t2)), this._finish();
              }
            }
            _updateCamera(t2) {
              const i2 = new e.cd(t2.coords.longitude, t2.coords.latitude), o2 = t2.coords.accuracy, s2 = this._map.getBearing(), r2 = e.l({ bearing: s2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o2), r2, { geolocateSource: true });
            }
            _updateMarker(t2) {
              if (t2) {
                const i2 = new e.cd(t2.coords.longitude, t2.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = t2.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }
            _updateCircleRadius() {
              const t2 = this._map.transform, i2 = e.c6(1, t2._center.lat) * t2.worldSize, o2 = Math.ceil(2 * this._accuracy * i2);
              this._circleElement.style.width = `${o2}px`, this._circleElement.style.height = `${o2}px`;
            }
            _onZoom() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }
            _updateMarkerRotation() {
              this._userLocationDotMarker && "number" == typeof this._heading ? (this._userLocationDotMarker.setRotation(this._heading), this._userLocationDotMarker.addClassName("mapboxgl-user-location-show-heading")) : (this._userLocationDotMarker.removeClassName("mapboxgl-user-location-show-heading"), this._userLocationDotMarker.setRotation(0));
            }
            _onError(t2) {
              if (this._map) {
                if (this.options.trackUserLocation) if (1 === t2.code) {
                  this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                  const e2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2), void 0 !== this._geolocationWatchID && this._clearWatch();
                } else {
                  if (3 === t2.code && this._noTimeout) return;
                  this._setErrorState();
                }
                "OFF" !== this._watchState && this.options.showUserLocation && this._userLocationDotMarker.addClassName("mapboxgl-user-location-dot-stale"), this.fire(new e.A("error", t2)), this._finish();
              }
            }
            _finish() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }
            _setupUI(t2) {
              if (void 0 !== this._map) {
                if (this._container.addEventListener("contextmenu", (e2) => e2.preventDefault()), this._geolocateButton = l("button", "mapboxgl-ctrl-geolocate", this._container), l("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === t2) {
                  e.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                  const t3 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                  this._geolocateButton.disabled = true, this._geolocateButton.setAttribute("aria-label", t3), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", t3);
                } else {
                  const e2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                  this._geolocateButton.setAttribute("aria-label", e2), this._geolocateButton.firstElementChild && this._geolocateButton.firstElementChild.setAttribute("title", e2);
                }
                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = l("div", "mapboxgl-user-location"), this._dotElement.appendChild(l("div", "mapboxgl-user-location-dot")), this._dotElement.appendChild(l("div", "mapboxgl-user-location-heading")), this._userLocationDotMarker = new vl({ element: this._dotElement, rotationAlignment: "map", pitchAlignment: "map" }), this._circleElement = l("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new vl({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (t3) => {
                  t3.geolocateSource || "ACTIVE_LOCK" !== this._watchState || t3.originalEvent && "resize" === t3.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this.fire(new e.A("trackuserlocationend")));
                });
              }
            }
            _onDeviceOrientation(e2) {
              this._userLocationDotMarker && (e2.webkitCompassHeading ? this._heading = e2.webkitCompassHeading : true === e2.absolute && (this._heading = -1 * e2.alpha), this._updateMarkerRotationThrottled());
            }
            trigger() {
              if (!this._setup) return e.w("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new e.A("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    this._numberOfWatches--, this._noTimeout = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new e.A("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new e.A("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                    break;
                  case "BACKGROUND":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                    break;
                  case "BACKGROUND_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID) this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let e2;
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), this._numberOfWatches++, this._numberOfWatches > 1 ? (e2 = { maximumAge: 6e5, timeout: 0 }, this._noTimeout = true) : (e2 = this.options.positionOptions, this._noTimeout = false), this._geolocationWatchID = this.options.geolocation.watchPosition(this._onSuccess, this._onError, e2), this.options.showUserHeading && this._addDeviceOrientationListener();
                }
              } else this.options.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = window.setTimeout(this._finish, 1e4);
              return true;
            }
            _addDeviceOrientationListener() {
              const e2 = () => {
                "ondeviceorientationabsolute" in window ? window.addEventListener("deviceorientationabsolute", this._onDeviceOrientation) : window.addEventListener("deviceorientation", this._onDeviceOrientation);
              };
              "undefined" != typeof DeviceMotionEvent && "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then((t2) => {
                "granted" === t2 && e2();
              }).catch(console.error) : e2();
            }
            _clearWatch() {
              this.options.geolocation.clearWatch(this._geolocationWatchID), window.removeEventListener("deviceorientation", this._onDeviceOrientation), window.removeEventListener("deviceorientationabsolute", this._onDeviceOrientation), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, AttributionControl: sl, ScaleControl: class {
            constructor(t2 = {}) {
              this.options = e.l({}, xl, t2), this._isNumberFormatSupported = function() {
                try {
                  return new Intl.NumberFormat("en", { style: "unit", unitDisplay: "short", unit: "meter" }), true;
                } catch (e2) {
                  return false;
                }
              }(), e.aV(["_update", "_setScale", "setUnit"], this);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            _update() {
              const e2 = this.options.maxWidth || 100, t2 = this._map, i2 = t2._containerHeight / 2, o2 = t2._containerWidth / 2 - e2 / 2, s2 = t2.unproject([o2, i2]), r2 = t2.unproject([o2 + e2, i2]), n2 = s2.distanceTo(r2);
              if ("imperial" === this.options.unit) {
                const t3 = 3.2808 * n2;
                t3 > 5280 ? this._setScale(e2, t3 / 5280, "mile") : this._setScale(e2, t3, "foot");
              } else "nautical" === this.options.unit ? this._setScale(e2, n2 / 1852, "nautical-mile") : n2 >= 1e3 ? this._setScale(e2, n2 / 1e3, "kilometer") : this._setScale(e2, n2, "meter");
            }
            _setScale(e2, t2, i2) {
              this._map._requestDomTask(() => {
                const o2 = function(e3) {
                  const t3 = Math.pow(10, `${Math.floor(e3)}`.length - 1);
                  let i3 = e3 / t3;
                  return i3 = i3 >= 10 ? 10 : i3 >= 5 ? 5 : i3 >= 3 ? 3 : i3 >= 2 ? 2 : i3 >= 1 ? 1 : function(e4) {
                    const t4 = Math.pow(10, Math.ceil(-Math.log(e4) / Math.LN10));
                    return Math.round(e4 * t4) / t4;
                  }(i3), t3 * i3;
                }(t2), s2 = o2 / t2;
                this._container.innerHTML = this._isNumberFormatSupported && "nautical-mile" !== i2 ? new Intl.NumberFormat(this._language, { style: "unit", unitDisplay: "short", unit: i2 }).format(o2) : `${o2}&nbsp;${bl[i2]}`, this._container.style.width = e2 * s2 + "px";
              });
            }
            onAdd(e2) {
              return this._map = e2, this._language = e2.getLanguage(), this._container = l("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", e2.getContainer()), this._container.dir = "auto", this._map.on("move", this._update), this._update(), this._container;
            }
            onRemove() {
              this._container.remove(), this._map.off("move", this._update), this._map = void 0;
            }
            _setLanguage(e2) {
              this._language = e2, this._update();
            }
            setUnit(e2) {
              this.options.unit = e2, this._update();
            }
          }, FullscreenControl: class {
            constructor(t2 = {}) {
              this._fullscreen = false, t2 && t2.container && (t2.container instanceof HTMLElement ? this._container = t2.container : e.w("Full screen control 'container' must be a DOM element.")), e.aV(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onwebkitfullscreenchange" in document && (this._fullscreenchange = "webkitfullscreenchange");
            }
            onAdd(t2) {
              return this._map = t2, this._container || (this._container = this._map.getContainer()), this._controlContainer = l("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", e.w("This device does not support fullscreen mode.")), this._controlContainer;
            }
            onRemove() {
              this._controlContainer.remove(), this._map = null, document.removeEventListener(this._fullscreenchange, this._changeIcon);
            }
            _checkFullscreenSupport() {
              return !(!document.fullscreenEnabled && !document.webkitFullscreenEnabled);
            }
            _setupUI() {
              const e2 = this._fullscreenButton = l("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
              l("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", "true"), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), document.addEventListener(this._fullscreenchange, this._changeIcon);
            }
            _updateTitle() {
              const e2 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", e2), this._fullscreenButton.firstElementChild && this._fullscreenButton.firstElementChild.setAttribute("title", e2);
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _changeIcon() {
              (document.fullscreenElement || document.webkitFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
            }
            _onClickFullscreen() {
              this._isFullscreen() ? document.exitFullscreen ? document.exitFullscreen() : document.webkitCancelFullScreen && document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
            }
          }, Popup: class extends e.E {
            constructor(t2) {
              super(), this.options = e.l(Object.create(wl), t2), this._altitude = this.options.altitude, e.aV(["_update", "_onClose", "remove", "_onMouseEvent"], this), this._classList = new Set(t2 && t2.className ? t2.className.trim().split(/\s+/) : []);
            }
            addTo(t2) {
              return this._map && this.remove(), this._map = t2, this.options.closeOnClick && t2.on("preclick", this._onClose), this.options.closeOnMove && t2.on("move", this._onClose), t2.on("remove", this.remove), this._update(), t2._addPopup(this), this._focusFirstElement(), this._trackPointer ? (t2.on("mousemove", this._onMouseEvent), t2.on("mouseup", this._onMouseEvent), t2._canvasContainer.classList.add("mapboxgl-track-pointer")) : t2.on("move", this._update), this.fire(new e.A("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            remove() {
              this._content && this._content.remove(), this._container && (this._container.remove(), this._container = void 0);
              const t2 = this._map;
              return t2 && (t2.off("move", this._update), t2.off("move", this._onClose), t2.off("preclick", this._onClose), t2.off("click", this._onClose), t2.off("remove", this.remove), t2.off("mousemove", this._onMouseEvent), t2.off("mouseup", this._onMouseEvent), t2.off("drag", this._onMouseEvent), t2._canvasContainer && t2._canvasContainer.classList.remove("mapboxgl-track-pointer"), t2._removePopup(this), this._map = void 0), this.fire(new e.A("close")), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(t2) {
              this._lngLat = e.cd.convert(t2), this._pos = null, this._trackPointer = false, this._update();
              const i2 = this._map;
              return i2 && (i2.on("move", this._update), i2.off("mousemove", this._onMouseEvent), i2._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
            }
            getAltitude() {
              return this._altitude;
            }
            setAltitude(e2) {
              return this._altitude = e2, this._update(), this;
            }
            trackPointer() {
              this._trackPointer = true, this._pos = null, this._update();
              const e2 = this._map;
              return e2 && (e2.off("move", this._update), e2.on("mousemove", this._onMouseEvent), e2.on("drag", this._onMouseEvent), e2._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(e2) {
              return this.setDOMContent(document.createTextNode(e2));
            }
            setHTML(e2) {
              const t2 = document.createDocumentFragment(), i2 = document.createElement("body");
              let o2;
              for (i2.innerHTML = e2; o2 = i2.firstChild, o2; ) t2.appendChild(o2);
              return this.setDOMContent(t2);
            }
            getMaxWidth() {
              return this._container && this._container.style.maxWidth;
            }
            setMaxWidth(e2) {
              return this.options.maxWidth = e2, this._update(), this;
            }
            setDOMContent(e2) {
              let t2 = this._content;
              if (t2) for (; t2.hasChildNodes(); ) t2.firstChild && t2.removeChild(t2.firstChild);
              else t2 = this._content = l("div", "mapboxgl-popup-content", this._container || void 0);
              if (t2.appendChild(e2), this.options.closeButton) {
                const e3 = this._closeButton = l("button", "mapboxgl-popup-close-button", t2);
                e3.type = "button", e3.setAttribute("aria-label", "Close popup"), e3.innerHTML = '<span aria-hidden="true">&#215;</span>', e3.addEventListener("click", this._onClose);
              }
              return this._update(), this._focusFirstElement(), this;
            }
            addClassName(e2) {
              return this._classList.add(e2), this._updateClassList(), this;
            }
            removeClassName(e2) {
              return this._classList.delete(e2), this._updateClassList(), this;
            }
            setOffset(e2) {
              return this.options.offset = e2, this._update(), this;
            }
            toggleClassName(e2) {
              let t2;
              return this._classList.delete(e2) ? t2 = false : (this._classList.add(e2), t2 = true), this._updateClassList(), t2;
            }
            _onMouseEvent(e2) {
              this._update(e2.point);
            }
            _getAnchor(e2) {
              if (this.options.anchor) return this.options.anchor;
              const t2 = this._map, i2 = this._container, o2 = this._pos;
              if (!t2 || !i2 || !o2) return "bottom";
              const s2 = i2.offsetWidth, r2 = i2.offsetHeight, n2 = o2.x < s2 / 2, a2 = o2.x > t2.transform.width - s2 / 2;
              if (o2.y + e2 < r2) return n2 ? "top-left" : a2 ? "top-right" : "top";
              if (o2.y > t2.transform.height - r2) {
                if (n2) return "bottom-left";
                if (a2) return "bottom-right";
              }
              return n2 ? "left" : a2 ? "right" : "bottom";
            }
            _updateClassList() {
              const e2 = this._container;
              if (!e2) return;
              const t2 = [...this._classList];
              t2.push("mapboxgl-popup"), this._anchor && t2.push(`mapboxgl-popup-anchor-${this._anchor}`), this._trackPointer && t2.push("mapboxgl-popup-track-pointer"), e2.className = t2.join(" ");
            }
            _update(t2) {
              const i2 = this._map, o2 = this._content;
              if (!i2 || !this._lngLat && !this._trackPointer || !o2) return;
              let s2 = this._container;
              if (s2 || (s2 = this._container = l("div", "mapboxgl-popup", i2.getContainer()), this._tip = l("div", "mapboxgl-popup-tip", s2), s2.appendChild(o2)), this.options.maxWidth && s2.style.maxWidth !== this.options.maxWidth && (s2.style.maxWidth = this.options.maxWidth), i2.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = fl(this._lngLat, this._pos, i2.transform)), !this._trackPointer || t2) {
                const o3 = this._pos = this._trackPointer && t2 instanceof e.P ? t2 : i2.project(this._lngLat, this._altitude), s3 = El(this.options.offset), r2 = this._anchor = this._getAnchor(s3.y), n2 = El(this.options.offset, r2), a2 = o3.add(n2).round();
                i2._requestDomTask(() => {
                  this._container && r2 && (this._container.style.transform = `${ml[r2]} translate(${a2.x}px,${a2.y}px)`);
                });
              }
              if (!this._marker && i2._showingGlobe()) {
                const t3 = e.eK(i2.transform, this._lngLat) ? 0 : 1;
                this._setOpacity(t3);
              }
              this._updateClassList();
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container) return;
              const e2 = this._container.querySelector(Tl);
              e2 && e2.focus();
            }
            _onClose() {
              this.remove();
            }
            _setOpacity(e2) {
              this._container && (this._container.style.opacity = `${e2}`), this._content && (this._content.style.pointerEvents = e2 ? "auto" : "none");
            }
          }, Marker: vl, Style: Eo, LngLat: e.cd, LngLatBounds: e.aG, Point: e.P, MercatorCoordinate: e.ac, FreeCameraOptions: $i, Evented: e.E, config: e.e, prewarm: e.eP, clearPrewarmedResources: e.eQ, get accessToken() {
            return e.e.ACCESS_TOKEN;
          }, set accessToken(t2) {
            e.e.ACCESS_TOKEN = t2;
          }, get baseApiUrl() {
            return e.e.API_URL;
          }, set baseApiUrl(t2) {
            e.e.API_URL = t2;
          }, get workerCount() {
            return e.eR.workerCount;
          }, set workerCount(t2) {
            e.eR.workerCount = t2;
          }, get maxParallelImageRequests() {
            return e.e.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(t2) {
            e.e.MAX_PARALLEL_IMAGE_REQUESTS = t2;
          }, clearStorage(t2) {
            e.eS(t2);
          }, get workerUrl() {
            return e.eT.workerUrl;
          }, set workerUrl(t2) {
            e.eT.workerUrl = t2;
          }, get workerClass() {
            return e.eT.workerClass;
          }, set workerClass(t2) {
            e.eT.workerClass = t2;
          }, get workerParams() {
            return e.eT.workerParams;
          }, set workerParams(t2) {
            e.eT.workerParams = t2;
          }, get dracoUrl() {
            return e.eU();
          }, set dracoUrl(t2) {
            e.eV(t2);
          }, get meshoptUrl() {
            return e.eW();
          }, set meshoptUrl(t2) {
            e.eX(t2);
          }, setNow: e.q.setNow, restoreNow: e.q.restoreNow };
          return Sl;
        });
        var mapboxgl$1 = mapboxgl2;
        return mapboxgl$1;
      });
    }
  });

  // src/build-map-filters.js
  init_live_reload();

  // src/modules/maploader.js
  init_live_reload();
  var import_mapbox_gl = __toESM(require_mapbox_gl(), 1);
  function renderMap() {
    import_mapbox_gl.default.accessToken = "pk.eyJ1IjoicXVudGh1bm5hbiIsImEiOiJjbWJzM3Rzd20wZ2FlMmxzZGJkbzdwM3Y5In0.7Ky0O0gD9e29XIKjMNmB6g";
    const map2 = new import_mapbox_gl.default.Map({
      container: "viewport",
      projection: "mercator",
      // style: 'mapbox://styles/mapbox/streets-v12',
      style: "mapbox://styles/qunthunnan/cmdwyk067007601sdc7yjgf3x",
      center: [-72.61177, 42.58554],
      zoom: 6.3,
      attributionControl: false,
      pixelRatio: window.devicePixelRatio || 1,
      cooperativeGestures: true
    });
    return map2;
  }
  var map = renderMap();
  map.addControl(new import_mapbox_gl.default.AttributionControl(), "top-right");
  map.addControl(new import_mapbox_gl.default.NavigationControl(), "top-right");
  map.addControl(new import_mapbox_gl.default.FullscreenControl(), "top-right");
  var bottomControlls = document.querySelectorAll(".mapboxgl-ctrl-bottom-left");
  bottomControlls.forEach((control) => {
    control.classList.replace("mapboxgl-ctrl-bottom-left", "mapboxgl-ctrl-top-left");
  });
  var mapCanvas = map.getCanvas();
  mapCanvas.style.position = "relative";

  // src/modules/icons-loader.js
  init_live_reload();
  var icons = /* @__PURE__ */ new Map();
  function generateCircleSvg(mainColor = "#ED332F", strokeColor = "white", sizeMultiplier = 1, strokeWidth = 2) {
    const baseDiameter = 10;
    const diameter = baseDiameter * sizeMultiplier;
    const radius = diameter / 2;
    const svg = `
    <svg width="${diameter}px" height="${diameter}px" viewBox="0 0 ${diameter} ${diameter}" xmlns="http://www.w3.org/2000/svg">
      <circle 
        cx="${radius}" 
        cy="${radius}" 
        r="${radius - strokeWidth / 2}" 
        fill="${mainColor}" 
        stroke="${strokeColor}" 
        stroke-width="${strokeWidth}" />
    </svg>
  `;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  function generateMarkerSvg(mainColor = "#ED332F", strokeColor = "white", sizeMulitplier = 1, centerColor = "#ffffffff") {
    const width = 18;
    const heigh = 25;
    const svg = `
    <svg width="${width * sizeMulitplier}px" height="${heigh * sizeMulitplier}" viewBox="0 0 18 25" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" clip-rule="evenodd"
        d="M8.75 1C12.48 1 15.51 4.03 15.51 7.76C15.51 11.05 13.81 12.86 12 15.79L8.75 21L5.51 15.79C3.7 12.86 2 11.05 2 7.76C2 4.03 5.03 1 8.75 1ZM8.75 3.77C10.83 3.77 12.48 5.47 12.48 7.49C12.48 9.56 10.83 11.21 8.75 11.21C6.68 11.21 5.03 9.56 5.03 7.49C5.03 5.47 6.68 3.77 8.75 3.77Z"
        fill="${mainColor}" />
      <path
        d="M8.75 0.5C12.75 0.5 16 3.76 16 7.75C16 11.24 14.18 13.21 12.43 16.05L9.18 21.26L8.75 21.95L8.33 21.26L5.08 16.05C3.33 13.21 1.5 11.24 1.5 7.75C1.5 3.76 4.76 0.5 8.75 0.5ZM8.75 4.27C6.96 4.27 5.53 5.74 5.53 7.49C5.53 9.29 6.96 10.71 8.75 10.71C10.55 10.71 11.98 9.29 11.98 7.49C11.98 5.74 10.55 4.27 8.75 4.27Z"
        stroke="${strokeColor}" stroke-width="1" fill="none"/>
        <circle cx="8.75" cy="7.5" r="3.5" fill="${centerColor}" />
    </svg>
  `;
    return `data:image/svg+xml;base64,${btoa(svg)}`;
  }
  function generateAllMarkerIcons() {
    const qualities = ["clean", "boat", "notClean"];
    const relevances = ["month", "year", "old"];
    const colorMap = {
      clean: "#1E90FF",
      boat: "#FFBB00",
      notClean: "#ED332F"
    };
    const colorMapAccess = {
      clean: "#0000FF",
      boat: "#FFBB00",
      notClean: "#FF0000"
    };
    for (const quality of qualities) {
      for (const relevance of relevances) {
        for (const isAccess of [false, true]) {
          const suffix = isAccess ? "-access" : "";
          const id = `marker-${quality}-${relevance}${suffix}`;
          const baseColor = isAccess ? colorMapAccess[quality] : colorMap[quality];
          let fill = baseColor;
          let stroke = "white";
          let strokeWidth = 1;
          let isCircle = false;
          let centerColor = "#ffffffff";
          if (relevance === "month") {
            isCircle = false;
          } else if (relevance === "year") {
            fill = "white";
            stroke = baseColor;
            strokeWidth = 2;
            isCircle = false;
            centerColor = baseColor;
          } else if (relevance === "old") {
            fill = baseColor;
            stroke = "white";
            strokeWidth = 1.5;
            isCircle = true;
          }
          const svg = isCircle ? generateCircleSvg(fill, stroke, 1, strokeWidth) : generateMarkerSvg(fill, stroke, 1, centerColor);
          const highlightedSvg = isCircle ? generateCircleSvg(fill, stroke, 1.5, strokeWidth) : generateMarkerSvg(fill, stroke, 1.5, centerColor);
          icons.set(id, svg);
          icons.set(`${id}-hightlighted`, highlightedSvg);
        }
      }
    }
  }

  // src/modules/filters-handlers.js
  init_live_reload();

  // src/store/filters-store.js
  init_live_reload();

  // node_modules/zustand/esm/vanilla.mjs
  init_live_reload();
  var createStoreImpl = (createState) => {
    let state;
    const listeners = /* @__PURE__ */ new Set();
    const setState = (partial, replace) => {
      const nextState = typeof partial === "function" ? partial(state) : partial;
      if (!Object.is(nextState, state)) {
        const previousState = state;
        state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
        listeners.forEach((listener) => listener(state, previousState));
      }
    };
    const getState = () => state;
    const getInitialState = () => initialState;
    const subscribe = (listener) => {
      listeners.add(listener);
      return () => listeners.delete(listener);
    };
    const api = { setState, getState, getInitialState, subscribe };
    const initialState = state = createState(setState, getState, api);
    return api;
  };
  var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

  // src/store/filters-store.js
  var initialFiltersState = {
    state: "",
    county: "",
    town: "",
    watershed: "",
    waterbody: "",
    organization: "",
    site: "",
    clean: false,
    boating: false,
    notClean: false,
    month: false,
    year: false,
    old: false
  };
  if (!window.__GLOBAL_FILTERS_STORE__) {
    window.__GLOBAL_FILTERS_STORE__ = createStore((set2, get2) => ({
      selectedFilters: { ...initialFiltersState },
      selectedInputLevel: void 0,
      inputHandlers: [],
      // This will be used to track the currently selected filter level and provide dependency logic
      setStateFilter: (stateFilter) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, state: stateFilter } })),
      setCountyFilter: (county) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, county } })),
      setTownFilter: (town) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, town } })),
      setWaterShedFilter: (watershed) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, watershed } })),
      setWaterBodyFilter: (waterbody) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, waterbody } })),
      setOrganizationFilter: (organization) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, organization } })),
      setSiteFilter: (site) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, site } })),
      setCleanFilter: (clean) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, clean } })),
      setBoatingFilter: (boating) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, boating } })),
      setNotCleanFilter: (notClean) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, notClean } })),
      setYearFilter: (year) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, year } })),
      setMonthFilter: (month) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, month } })),
      setOldFilter: (old) => set2((state) => ({ selectedFilters: { ...state.selectedFilters, old } })),
      setSelectedInputLevel: (level) => set2((state) => ({ selectedFilters: state.selectedFilters, selectedInputLevel: level })),
      pushInputHandler: (handler) => set2((state) => ({ inputHandlers: [...state.inputHandlers, handler] })),
      clearInputHandlers: () => set2(() => ({ inputHandlers: [] })),
      clearWaterFilters: () => set2((state) => ({
        selectedFilters: { ...state.selectedFilters, watershed: "", waterbody: "" }
      })),
      clearAdminFilters: () => set2((state) => ({
        selectedFilters: { ...state.selectedFilters, state: "", county: "", town: "" }
      })),
      getStateFilter: () => get2().selectedFilters.state,
      getCountyFilter: () => get2().selectedFilters.county,
      getTownFilter: () => get2().selectedFilters.town,
      getWaterShedFilter: () => get2().selectedFilters.watershed,
      getWaterBodyFilter: () => get2().selectedFilters.waterbody,
      getOrganizationFilter: () => get2().selectedFilters.organization,
      getSiteFilter: () => get2().selectedFilters.site,
      getCleanFilter: () => get2().selectedFilters.clean,
      getBoatingFilter: () => get2().selectedFilters.boating,
      getNotCleanFilter: () => get2().selectedFilters.notClean,
      getYearFilter: () => get2().selectedFilters.year,
      getMonthFilter: () => get2().selectedFilters.month,
      getSelectedInputLevel: () => get2().selectedInputLevel,
      getOldFilter: () => get2().selectedFilters.old,
      getAllFilters: () => get2().selectedFilters,
      getInputHandlers: () => get2().inputHandlers
    }));
  }
  var useFiltersStore = window.__GLOBAL_FILTERS_STORE__;

  // src/modules/filter.js
  init_live_reload();

  // src/store/data-store.js
  init_live_reload();
  if (!window.__GLOBAL_DATA_STORE__) {
    window.__GLOBAL_DATA_STORE__ = createStore((set2, get2) => ({
      sites: [],
      watersheds: [],
      waterbodies: [],
      organizations: [],
      states: [],
      counties: [],
      towns: [],
      boudaries: {},
      query: {},
      isBoundariesLoaded: false,
      lang: "en",
      initialized: false,
      accessibility: false,
      setSites: (sites) => set2(() => ({ sites })),
      setQuery: (query) => set2(() => ({ query })),
      setStates: (states) => set2(() => ({ states })),
      setCounties: (counties) => set2(() => ({ counties })),
      setTowns: (towns) => set2(() => ({ towns })),
      setWaterSheds: (watersheds) => set2(() => ({ watersheds })),
      setWaterBodies: (waterbodies) => set2(() => ({ waterbodies })),
      setOrganizations: (organizations) => set2(() => ({ organizations })),
      setBoundaries: (boudaries) => set2(() => ({ boudaries })),
      setIsBoundariesLoaded: (isBoundariesLoaded) => set2(() => ({ isBoundariesLoaded })),
      setLang: (lang) => set2(() => ({ lang })),
      setInitialized: (initialized) => set2(() => ({ initialized })),
      setAccessibility: (accessibility) => set2(() => ({ accessibility })),
      toggleAccessibility: () => set2((state) => ({ accessibility: !state.accessibility })),
      getSites: () => get2().sites,
      getWaterSheds: () => get2().watersheds,
      getWaterBodies: () => get2().waterbodies,
      getStates: () => get2().states,
      getCounties: () => get2().counties,
      getTowns: () => get2().towns,
      getOrganizations: () => get2().organizations,
      getBoundaries: () => get2().boudaries,
      getIsBoundariesLoaded: () => get2().isBoundariesLoaded,
      getLang: () => get2().lang,
      getQuery: () => get2().query,
      getInitialized: () => get2().initialized,
      getAccessibility: () => get2().accessibility
    }));
  }
  var useDataStore = window.__GLOBAL_DATA_STORE__;

  // src/store/tabs-store.js
  init_live_reload();
  var initialTabsState = {
    isAdministrative: true,
    isOutlook: true
  };
  if (!window.__GLOBAL_TABS_STORE__) {
    window.__GLOBAL_TABS_STORE__ = createStore((set2, get2) => ({
      tabsState: { ...initialTabsState },
      tabsHandlers: [],
      // This will be used to track the currently selected tab and provide filters logic
      isInitialized: false,
      setIsAdministrative: (isAdministrative) => set2((state) => ({ tabsState: { ...state.tabsState, isAdministrative } })),
      setIsOutlook: (isOutlook) => set2((state) => ({ tabsState: { ...state.tabsState, isOutlook } })),
      pushTabHandler: (handler) => set2((state) => ({ tabsHandlers: [...state.tabsHandlers, handler] })),
      clearTabsHandlers: () => set2(() => ({ tabsHandlers: [] })),
      setIsInitialized: (isInitialized) => set2((state) => ({ isInitialized })),
      getIsAdministrative: () => get2().tabsState.isAdministrative,
      getIsOutlook: () => get2().tabsState.isOutlook,
      getTabsState: () => get2().tabsState,
      getTabsHandlers: () => get2().tabsHandlers,
      getIsInitialized: () => get2().isInitialized
    }));
  }
  var useTabsStore = window.__GLOBAL_TABS_STORE__;

  // src/modules/markers.js
  init_live_reload();

  // node_modules/@turf/bbox/dist/esm/index.js
  init_live_reload();

  // node_modules/@turf/meta/dist/esm/index.js
  init_live_reload();

  // node_modules/@turf/helpers/dist/esm/index.js
  init_live_reload();
  var earthRadius = 63710088e-1;
  var factors = {
    centimeters: earthRadius * 100,
    centimetres: earthRadius * 100,
    degrees: 360 / (2 * Math.PI),
    feet: earthRadius * 3.28084,
    inches: earthRadius * 39.37,
    kilometers: earthRadius / 1e3,
    kilometres: earthRadius / 1e3,
    meters: earthRadius,
    metres: earthRadius,
    miles: earthRadius / 1609.344,
    millimeters: earthRadius * 1e3,
    millimetres: earthRadius * 1e3,
    nauticalmiles: earthRadius / 1852,
    radians: 1,
    yards: earthRadius * 1.0936
  };
  function feature(geom, properties, options = {}) {
    const feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
      feat.id = options.id;
    }
    if (options.bbox) {
      feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
  }
  function point(coordinates, properties, options = {}) {
    if (!coordinates) {
      throw new Error("coordinates is required");
    }
    if (!Array.isArray(coordinates)) {
      throw new Error("coordinates must be an Array");
    }
    if (coordinates.length < 2) {
      throw new Error("coordinates must be at least 2 numbers long");
    }
    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {
      throw new Error("coordinates must contain numbers");
    }
    const geom = {
      type: "Point",
      coordinates
    };
    return feature(geom, properties, options);
  }
  function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  // node_modules/@turf/meta/dist/esm/index.js
  function coordEach(geojson, callback, excludeWrapCoord) {
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords, geometryMaybeCollection, wrapShrink = 0, coordIndex = 0, isGeometryCollection, type = geojson.type, isFeatureCollection = type === "FeatureCollection", isFeature = type === "Feature", stop = isFeatureCollection ? geojson.features.length : 1;
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
      geometryMaybeCollection = isFeatureCollection ? geojson.features[featureIndex].geometry : isFeature ? geojson.geometry : geojson;
      isGeometryCollection = geometryMaybeCollection ? geometryMaybeCollection.type === "GeometryCollection" : false;
      stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;
      for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
        var multiFeatureIndex = 0;
        var geometryIndex = 0;
        geometry = isGeometryCollection ? geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;
        if (geometry === null) continue;
        coords = geometry.coordinates;
        var geomType = geometry.type;
        wrapShrink = excludeWrapCoord && (geomType === "Polygon" || geomType === "MultiPolygon") ? 1 : 0;
        switch (geomType) {
          case null:
            break;
          case "Point":
            if (callback(
              coords,
              coordIndex,
              featureIndex,
              multiFeatureIndex,
              geometryIndex
            ) === false)
              return false;
            coordIndex++;
            multiFeatureIndex++;
            break;
          case "LineString":
          case "MultiPoint":
            for (j = 0; j < coords.length; j++) {
              if (callback(
                coords[j],
                coordIndex,
                featureIndex,
                multiFeatureIndex,
                geometryIndex
              ) === false)
                return false;
              coordIndex++;
              if (geomType === "MultiPoint") multiFeatureIndex++;
            }
            if (geomType === "LineString") multiFeatureIndex++;
            break;
          case "Polygon":
          case "MultiLineString":
            for (j = 0; j < coords.length; j++) {
              for (k = 0; k < coords[j].length - wrapShrink; k++) {
                if (callback(
                  coords[j][k],
                  coordIndex,
                  featureIndex,
                  multiFeatureIndex,
                  geometryIndex
                ) === false)
                  return false;
                coordIndex++;
              }
              if (geomType === "MultiLineString") multiFeatureIndex++;
              if (geomType === "Polygon") geometryIndex++;
            }
            if (geomType === "Polygon") multiFeatureIndex++;
            break;
          case "MultiPolygon":
            for (j = 0; j < coords.length; j++) {
              geometryIndex = 0;
              for (k = 0; k < coords[j].length; k++) {
                for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                  if (callback(
                    coords[j][k][l],
                    coordIndex,
                    featureIndex,
                    multiFeatureIndex,
                    geometryIndex
                  ) === false)
                    return false;
                  coordIndex++;
                }
                geometryIndex++;
              }
              multiFeatureIndex++;
            }
            break;
          case "GeometryCollection":
            for (j = 0; j < geometry.geometries.length; j++)
              if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false)
                return false;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      }
    }
  }

  // node_modules/@turf/bbox/dist/esm/index.js
  function bbox(geojson, options = {}) {
    if (geojson.bbox != null && true !== options.recompute) {
      return geojson.bbox;
    }
    const result = [Infinity, Infinity, -Infinity, -Infinity];
    coordEach(geojson, (coord) => {
      if (result[0] > coord[0]) {
        result[0] = coord[0];
      }
      if (result[1] > coord[1]) {
        result[1] = coord[1];
      }
      if (result[2] < coord[0]) {
        result[2] = coord[0];
      }
      if (result[3] < coord[1]) {
        result[3] = coord[1];
      }
    });
    return result;
  }
  var turf_bbox_default = bbox;

  // src/modules/gsap-loader.js
  init_live_reload();

  // node_modules/gsap/index.js
  init_live_reload();

  // node_modules/gsap/gsap-core.js
  init_live_reload();
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    subClass.__proto__ = superClass;
  }
  var _config = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: {
      lineHeight: ""
    }
  };
  var _defaults = {
    duration: 0.5,
    overwrite: false,
    delay: 0
  };
  var _suppressOverwrites;
  var _reverting;
  var _context;
  var _bigNum = 1e8;
  var _tinyNum = 1 / _bigNum;
  var _2PI = Math.PI * 2;
  var _HALF_PI = _2PI / 4;
  var _gsID = 0;
  var _sqrt = Math.sqrt;
  var _cos = Math.cos;
  var _sin = Math.sin;
  var _isString = function _isString2(value) {
    return typeof value === "string";
  };
  var _isFunction = function _isFunction2(value) {
    return typeof value === "function";
  };
  var _isNumber = function _isNumber2(value) {
    return typeof value === "number";
  };
  var _isUndefined = function _isUndefined2(value) {
    return typeof value === "undefined";
  };
  var _isObject = function _isObject2(value) {
    return typeof value === "object";
  };
  var _isNotFalse = function _isNotFalse2(value) {
    return value !== false;
  };
  var _windowExists = function _windowExists2() {
    return typeof window !== "undefined";
  };
  var _isFuncOrString = function _isFuncOrString2(value) {
    return _isFunction(value) || _isString(value);
  };
  var _isTypedArray = typeof ArrayBuffer === "function" && ArrayBuffer.isView || function() {
  };
  var _isArray = Array.isArray;
  var _strictNumExp = /(?:-?\.?\d|\.)+/gi;
  var _numExp = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g;
  var _numWithUnitExp = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g;
  var _complexStringNumExp = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi;
  var _relExp = /[+-]=-?[.\d]+/;
  var _delimitedValueExp = /[^,'"\[\]\s]+/gi;
  var _unitExp = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i;
  var _globalTimeline;
  var _win;
  var _coreInitted;
  var _doc;
  var _globals = {};
  var _installScope = {};
  var _coreReady;
  var _install = function _install2(scope) {
    return (_installScope = _merge(scope, _globals)) && gsap;
  };
  var _missingPlugin = function _missingPlugin2(property, value) {
    return console.warn("Invalid property", property, "set to", value, "Missing plugin? gsap.registerPlugin()");
  };
  var _warn = function _warn2(message, suppress) {
    return !suppress && console.warn(message);
  };
  var _addGlobal = function _addGlobal2(name, obj) {
    return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
  };
  var _emptyFunc = function _emptyFunc2() {
    return 0;
  };
  var _startAtRevertConfig = {
    suppressEvents: true,
    isStart: true,
    kill: false
  };
  var _revertConfigNoKill = {
    suppressEvents: true,
    kill: false
  };
  var _revertConfig = {
    suppressEvents: true
  };
  var _reservedProps = {};
  var _lazyTweens = [];
  var _lazyLookup = {};
  var _lastRenderedFrame;
  var _plugins = {};
  var _effects = {};
  var _nextGCFrame = 30;
  var _harnessPlugins = [];
  var _callbackNames = "";
  var _harness = function _harness2(targets) {
    var target = targets[0], harnessPlugin, i;
    _isObject(target) || _isFunction(target) || (targets = [targets]);
    if (!(harnessPlugin = (target._gsap || {}).harness)) {
      i = _harnessPlugins.length;
      while (i-- && !_harnessPlugins[i].targetTest(target)) {
      }
      harnessPlugin = _harnessPlugins[i];
    }
    i = targets.length;
    while (i--) {
      targets[i] && (targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin))) || targets.splice(i, 1);
    }
    return targets;
  };
  var _getCache = function _getCache2(target) {
    return target._gsap || _harness(toArray(target))[0]._gsap;
  };
  var _getProperty = function _getProperty2(target, property, v2) {
    return (v2 = target[property]) && _isFunction(v2) ? target[property]() : _isUndefined(v2) && target.getAttribute && target.getAttribute(property) || v2;
  };
  var _forEachName = function _forEachName2(names, func) {
    return (names = names.split(",")).forEach(func) || names;
  };
  var _round = function _round2(value) {
    return Math.round(value * 1e5) / 1e5 || 0;
  };
  var _roundPrecise = function _roundPrecise2(value) {
    return Math.round(value * 1e7) / 1e7 || 0;
  };
  var _parseRelative = function _parseRelative2(start, value) {
    var operator = value.charAt(0), end = parseFloat(value.substr(2));
    start = parseFloat(start);
    return operator === "+" ? start + end : operator === "-" ? start - end : operator === "*" ? start * end : start / end;
  };
  var _arrayContainsAny = function _arrayContainsAny2(toSearch, toFind) {
    var l = toFind.length, i = 0;
    for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l; ) {
    }
    return i < l;
  };
  var _lazyRender = function _lazyRender2() {
    var l = _lazyTweens.length, a = _lazyTweens.slice(0), i, tween;
    _lazyLookup = {};
    _lazyTweens.length = 0;
    for (i = 0; i < l; i++) {
      tween = a[i];
      tween && tween._lazy && (tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0);
    }
  };
  var _isRevertWorthy = function _isRevertWorthy2(animation) {
    return !!(animation._initted || animation._startAt || animation.add);
  };
  var _lazySafeRender = function _lazySafeRender2(animation, time, suppressEvents, force) {
    _lazyTweens.length && !_reverting && _lazyRender();
    animation.render(time, suppressEvents, force || !!(_reverting && time < 0 && _isRevertWorthy(animation)));
    _lazyTweens.length && !_reverting && _lazyRender();
  };
  var _numericIfPossible = function _numericIfPossible2(value) {
    var n = parseFloat(value);
    return (n || n === 0) && (value + "").match(_delimitedValueExp).length < 2 ? n : _isString(value) ? value.trim() : value;
  };
  var _passThrough = function _passThrough2(p) {
    return p;
  };
  var _setDefaults = function _setDefaults2(obj, defaults2) {
    for (var p in defaults2) {
      p in obj || (obj[p] = defaults2[p]);
    }
    return obj;
  };
  var _setKeyframeDefaults = function _setKeyframeDefaults2(excludeDuration) {
    return function(obj, defaults2) {
      for (var p in defaults2) {
        p in obj || p === "duration" && excludeDuration || p === "ease" || (obj[p] = defaults2[p]);
      }
    };
  };
  var _merge = function _merge2(base, toMerge) {
    for (var p in toMerge) {
      base[p] = toMerge[p];
    }
    return base;
  };
  var _mergeDeep = function _mergeDeep2(base, toMerge) {
    for (var p in toMerge) {
      p !== "__proto__" && p !== "constructor" && p !== "prototype" && (base[p] = _isObject(toMerge[p]) ? _mergeDeep2(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p]);
    }
    return base;
  };
  var _copyExcluding = function _copyExcluding2(obj, excluding) {
    var copy = {}, p;
    for (p in obj) {
      p in excluding || (copy[p] = obj[p]);
    }
    return copy;
  };
  var _inheritDefaults = function _inheritDefaults2(vars) {
    var parent2 = vars.parent || _globalTimeline, func = vars.keyframes ? _setKeyframeDefaults(_isArray(vars.keyframes)) : _setDefaults;
    if (_isNotFalse(vars.inherit)) {
      while (parent2) {
        func(vars, parent2.vars.defaults);
        parent2 = parent2.parent || parent2._dp;
      }
    }
    return vars;
  };
  var _arraysMatch = function _arraysMatch2(a1, a2) {
    var i = a1.length, match = i === a2.length;
    while (match && i-- && a1[i] === a2[i]) {
    }
    return i < 0;
  };
  var _addLinkedListItem = function _addLinkedListItem2(parent2, child, firstProp, lastProp, sortBy) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = parent2[lastProp], t;
    if (sortBy) {
      t = child[sortBy];
      while (prev && prev[sortBy] > t) {
        prev = prev._prev;
      }
    }
    if (prev) {
      child._next = prev._next;
      prev._next = child;
    } else {
      child._next = parent2[firstProp];
      parent2[firstProp] = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      parent2[lastProp] = child;
    }
    child._prev = prev;
    child.parent = child._dp = parent2;
    return child;
  };
  var _removeLinkedListItem = function _removeLinkedListItem2(parent2, child, firstProp, lastProp) {
    if (firstProp === void 0) {
      firstProp = "_first";
    }
    if (lastProp === void 0) {
      lastProp = "_last";
    }
    var prev = child._prev, next = child._next;
    if (prev) {
      prev._next = next;
    } else if (parent2[firstProp] === child) {
      parent2[firstProp] = next;
    }
    if (next) {
      next._prev = prev;
    } else if (parent2[lastProp] === child) {
      parent2[lastProp] = prev;
    }
    child._next = child._prev = child.parent = null;
  };
  var _removeFromParent = function _removeFromParent2(child, onlyIfParentHasAutoRemove) {
    child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren) && child.parent.remove && child.parent.remove(child);
    child._act = 0;
  };
  var _uncache = function _uncache2(animation, child) {
    if (animation && (!child || child._end > animation._dur || child._start < 0)) {
      var a = animation;
      while (a) {
        a._dirty = 1;
        a = a.parent;
      }
    }
    return animation;
  };
  var _recacheAncestors = function _recacheAncestors2(animation) {
    var parent2 = animation.parent;
    while (parent2 && parent2.parent) {
      parent2._dirty = 1;
      parent2.totalDuration();
      parent2 = parent2.parent;
    }
    return animation;
  };
  var _rewindStartAt = function _rewindStartAt2(tween, totalTime, suppressEvents, force) {
    return tween._startAt && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween.vars.immediateRender && !tween.vars.autoRevert || tween._startAt.render(totalTime, true, force));
  };
  var _hasNoPausedAncestors = function _hasNoPausedAncestors2(animation) {
    return !animation || animation._ts && _hasNoPausedAncestors2(animation.parent);
  };
  var _elapsedCycleDuration = function _elapsedCycleDuration2(animation) {
    return animation._repeat ? _animationCycle(animation._tTime, animation = animation.duration() + animation._rDelay) * animation : 0;
  };
  var _animationCycle = function _animationCycle2(tTime, cycleDuration) {
    var whole = Math.floor(tTime = _roundPrecise(tTime / cycleDuration));
    return tTime && whole === tTime ? whole - 1 : whole;
  };
  var _parentToChildTotalTime = function _parentToChildTotalTime2(parentTime, child) {
    return (parentTime - child._start) * child._ts + (child._ts >= 0 ? 0 : child._dirty ? child.totalDuration() : child._tDur);
  };
  var _setEnd = function _setEnd2(animation) {
    return animation._end = _roundPrecise(animation._start + (animation._tDur / Math.abs(animation._ts || animation._rts || _tinyNum) || 0));
  };
  var _alignPlayhead = function _alignPlayhead2(animation, totalTime) {
    var parent2 = animation._dp;
    if (parent2 && parent2.smoothChildTiming && animation._ts) {
      animation._start = _roundPrecise(parent2._time - (animation._ts > 0 ? totalTime / animation._ts : ((animation._dirty ? animation.totalDuration() : animation._tDur) - totalTime) / -animation._ts));
      _setEnd(animation);
      parent2._dirty || _uncache(parent2, animation);
    }
    return animation;
  };
  var _postAddChecks = function _postAddChecks2(timeline2, child) {
    var t;
    if (child._time || !child._dur && child._initted || child._start < timeline2._time && (child._dur || !child.add)) {
      t = _parentToChildTotalTime(timeline2.rawTime(), child);
      if (!child._dur || _clamp(0, child.totalDuration(), t) - child._tTime > _tinyNum) {
        child.render(t, true);
      }
    }
    if (_uncache(timeline2, child)._dp && timeline2._initted && timeline2._time >= timeline2._dur && timeline2._ts) {
      if (timeline2._dur < timeline2.duration()) {
        t = timeline2;
        while (t._dp) {
          t.rawTime() >= 0 && t.totalTime(t._tTime);
          t = t._dp;
        }
      }
      timeline2._zTime = -_tinyNum;
    }
  };
  var _addToTimeline = function _addToTimeline2(timeline2, child, position, skipChecks) {
    child.parent && _removeFromParent(child);
    child._start = _roundPrecise((_isNumber(position) ? position : position || timeline2 !== _globalTimeline ? _parsePosition(timeline2, position, child) : timeline2._time) + child._delay);
    child._end = _roundPrecise(child._start + (child.totalDuration() / Math.abs(child.timeScale()) || 0));
    _addLinkedListItem(timeline2, child, "_first", "_last", timeline2._sort ? "_start" : 0);
    _isFromOrFromStart(child) || (timeline2._recent = child);
    skipChecks || _postAddChecks(timeline2, child);
    timeline2._ts < 0 && _alignPlayhead(timeline2, timeline2._tTime);
    return timeline2;
  };
  var _scrollTrigger = function _scrollTrigger2(animation, trigger) {
    return (_globals.ScrollTrigger || _missingPlugin("scrollTrigger", trigger)) && _globals.ScrollTrigger.create(trigger, animation);
  };
  var _attemptInitTween = function _attemptInitTween2(tween, time, force, suppressEvents, tTime) {
    _initTween(tween, time, tTime);
    if (!tween._initted) {
      return 1;
    }
    if (!force && tween._pt && !_reverting && (tween._dur && tween.vars.lazy !== false || !tween._dur && tween.vars.lazy) && _lastRenderedFrame !== _ticker.frame) {
      _lazyTweens.push(tween);
      tween._lazy = [tTime, suppressEvents];
      return 1;
    }
  };
  var _parentPlayheadIsBeforeStart = function _parentPlayheadIsBeforeStart2(_ref) {
    var parent2 = _ref.parent;
    return parent2 && parent2._ts && parent2._initted && !parent2._lock && (parent2.rawTime() < 0 || _parentPlayheadIsBeforeStart2(parent2));
  };
  var _isFromOrFromStart = function _isFromOrFromStart2(_ref2) {
    var data = _ref2.data;
    return data === "isFromStart" || data === "isStart";
  };
  var _renderZeroDurationTween = function _renderZeroDurationTween2(tween, totalTime, suppressEvents, force) {
    var prevRatio = tween.ratio, ratio = totalTime < 0 || !totalTime && (!tween._start && _parentPlayheadIsBeforeStart(tween) && !(!tween._initted && _isFromOrFromStart(tween)) || (tween._ts < 0 || tween._dp._ts < 0) && !_isFromOrFromStart(tween)) ? 0 : 1, repeatDelay = tween._rDelay, tTime = 0, pt, iteration, prevIteration;
    if (repeatDelay && tween._repeat) {
      tTime = _clamp(0, tween._tDur, totalTime);
      iteration = _animationCycle(tTime, repeatDelay);
      tween._yoyo && iteration & 1 && (ratio = 1 - ratio);
      if (iteration !== _animationCycle(tween._tTime, repeatDelay)) {
        prevRatio = 1 - ratio;
        tween.vars.repeatRefresh && tween._initted && tween.invalidate();
      }
    }
    if (ratio !== prevRatio || _reverting || force || tween._zTime === _tinyNum || !totalTime && tween._zTime) {
      if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents, tTime)) {
        return;
      }
      prevIteration = tween._zTime;
      tween._zTime = totalTime || (suppressEvents ? _tinyNum : 0);
      suppressEvents || (suppressEvents = totalTime && !prevIteration);
      tween.ratio = ratio;
      tween._from && (ratio = 1 - ratio);
      tween._time = 0;
      tween._tTime = tTime;
      pt = tween._pt;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      totalTime < 0 && _rewindStartAt(tween, totalTime, suppressEvents, true);
      tween._onUpdate && !suppressEvents && _callback(tween, "onUpdate");
      tTime && tween._repeat && !suppressEvents && tween.parent && _callback(tween, "onRepeat");
      if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
        ratio && _removeFromParent(tween, 1);
        if (!suppressEvents && !_reverting) {
          _callback(tween, ratio ? "onComplete" : "onReverseComplete", true);
          tween._prom && tween._prom();
        }
      }
    } else if (!tween._zTime) {
      tween._zTime = totalTime;
    }
  };
  var _findNextPauseTween = function _findNextPauseTween2(animation, prevTime, time) {
    var child;
    if (time > prevTime) {
      child = animation._first;
      while (child && child._start <= time) {
        if (child.data === "isPause" && child._start > prevTime) {
          return child;
        }
        child = child._next;
      }
    } else {
      child = animation._last;
      while (child && child._start >= time) {
        if (child.data === "isPause" && child._start < prevTime) {
          return child;
        }
        child = child._prev;
      }
    }
  };
  var _setDuration = function _setDuration2(animation, duration, skipUncache, leavePlayhead) {
    var repeat = animation._repeat, dur = _roundPrecise(duration) || 0, totalProgress = animation._tTime / animation._tDur;
    totalProgress && !leavePlayhead && (animation._time *= dur / animation._dur);
    animation._dur = dur;
    animation._tDur = !repeat ? dur : repeat < 0 ? 1e10 : _roundPrecise(dur * (repeat + 1) + animation._rDelay * repeat);
    totalProgress > 0 && !leavePlayhead && _alignPlayhead(animation, animation._tTime = animation._tDur * totalProgress);
    animation.parent && _setEnd(animation);
    skipUncache || _uncache(animation.parent, animation);
    return animation;
  };
  var _onUpdateTotalDuration = function _onUpdateTotalDuration2(animation) {
    return animation instanceof Timeline ? _uncache(animation) : _setDuration(animation, animation._dur);
  };
  var _zeroPosition = {
    _start: 0,
    endTime: _emptyFunc,
    totalDuration: _emptyFunc
  };
  var _parsePosition = function _parsePosition2(animation, position, percentAnimation) {
    var labels = animation.labels, recent = animation._recent || _zeroPosition, clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur, i, offset, isPercent;
    if (_isString(position) && (isNaN(position) || position in labels)) {
      offset = position.charAt(0);
      isPercent = position.substr(-1) === "%";
      i = position.indexOf("=");
      if (offset === "<" || offset === ">") {
        i >= 0 && (position = position.replace(/=/, ""));
        return (offset === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0) * (isPercent ? (i < 0 ? recent : percentAnimation).totalDuration() / 100 : 1);
      }
      if (i < 0) {
        position in labels || (labels[position] = clippedDuration);
        return labels[position];
      }
      offset = parseFloat(position.charAt(i - 1) + position.substr(i + 1));
      if (isPercent && percentAnimation) {
        offset = offset / 100 * (_isArray(percentAnimation) ? percentAnimation[0] : percentAnimation).totalDuration();
      }
      return i > 1 ? _parsePosition2(animation, position.substr(0, i - 1), percentAnimation) + offset : clippedDuration + offset;
    }
    return position == null ? clippedDuration : +position;
  };
  var _createTweenType = function _createTweenType2(type, params, timeline2) {
    var isLegacy = _isNumber(params[1]), varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1), vars = params[varsIndex], irVars, parent2;
    isLegacy && (vars.duration = params[1]);
    vars.parent = timeline2;
    if (type) {
      irVars = vars;
      parent2 = timeline2;
      while (parent2 && !("immediateRender" in irVars)) {
        irVars = parent2.vars.defaults || {};
        parent2 = _isNotFalse(parent2.vars.inherit) && parent2.parent;
      }
      vars.immediateRender = _isNotFalse(irVars.immediateRender);
      type < 2 ? vars.runBackwards = 1 : vars.startAt = params[varsIndex - 1];
    }
    return new Tween(params[0], vars, params[varsIndex + 1]);
  };
  var _conditionalReturn = function _conditionalReturn2(value, func) {
    return value || value === 0 ? func(value) : func;
  };
  var _clamp = function _clamp2(min, max, value) {
    return value < min ? min : value > max ? max : value;
  };
  var getUnit = function getUnit2(value, v2) {
    return !_isString(value) || !(v2 = _unitExp.exec(value)) ? "" : v2[1];
  };
  var clamp = function clamp2(min, max, value) {
    return _conditionalReturn(value, function(v2) {
      return _clamp(min, max, v2);
    });
  };
  var _slice = [].slice;
  var _isArrayLike = function _isArrayLike2(value, nonEmpty) {
    return value && _isObject(value) && "length" in value && (!nonEmpty && !value.length || value.length - 1 in value && _isObject(value[0])) && !value.nodeType && value !== _win;
  };
  var _flatten = function _flatten2(ar, leaveStrings, accumulator) {
    if (accumulator === void 0) {
      accumulator = [];
    }
    return ar.forEach(function(value) {
      var _accumulator;
      return _isString(value) && !leaveStrings || _isArrayLike(value, 1) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
    }) || accumulator;
  };
  var toArray = function toArray2(value, scope, leaveStrings) {
    return _context && !scope && _context.selector ? _context.selector(value) : _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call((scope || _doc).querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
  };
  var selector = function selector2(value) {
    value = toArray(value)[0] || _warn("Invalid scope") || {};
    return function(v2) {
      var el = value.current || value.nativeElement || value;
      return toArray(v2, el.querySelectorAll ? el : el === value ? _warn("Invalid scope") || _doc.createElement("div") : value);
    };
  };
  var shuffle = function shuffle2(a) {
    return a.sort(function() {
      return 0.5 - Math.random();
    });
  };
  var distribute = function distribute2(v2) {
    if (_isFunction(v2)) {
      return v2;
    }
    var vars = _isObject(v2) ? v2 : {
      each: v2
    }, ease = _parseEase(vars.ease), from = vars.from || 0, base = parseFloat(vars.base) || 0, cache = {}, isDecimal = from > 0 && from < 1, ratios = isNaN(from) || isDecimal, axis = vars.axis, ratioX = from, ratioY = from;
    if (_isString(from)) {
      ratioX = ratioY = {
        center: 0.5,
        edges: 0.5,
        end: 1
      }[from] || 0;
    } else if (!isDecimal && ratios) {
      ratioX = from[0];
      ratioY = from[1];
    }
    return function(i, target, a) {
      var l = (a || vars).length, distances = cache[l], originX, originY, x, y, d, j, max, min, wrapAt;
      if (!distances) {
        wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];
        if (!wrapAt) {
          max = -_bigNum;
          while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {
          }
          wrapAt < l && wrapAt--;
        }
        distances = cache[l] = [];
        originX = ratios ? Math.min(wrapAt, l) * ratioX - 0.5 : from % wrapAt;
        originY = wrapAt === _bigNum ? 0 : ratios ? l * ratioY / wrapAt - 0.5 : from / wrapAt | 0;
        max = 0;
        min = _bigNum;
        for (j = 0; j < l; j++) {
          x = j % wrapAt - originX;
          y = originY - (j / wrapAt | 0);
          distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);
          d > max && (max = d);
          d < min && (min = d);
        }
        from === "random" && shuffle(distances);
        distances.max = max - min;
        distances.min = min;
        distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
        distances.b = l < 0 ? base - l : base;
        distances.u = getUnit(vars.amount || vars.each) || 0;
        ease = ease && l < 0 ? _invertEase(ease) : ease;
      }
      l = (distances[i] - distances.min) / distances.max || 0;
      return _roundPrecise(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u;
    };
  };
  var _roundModifier = function _roundModifier2(v2) {
    var p = Math.pow(10, ((v2 + "").split(".")[1] || "").length);
    return function(raw) {
      var n = _roundPrecise(Math.round(parseFloat(raw) / v2) * v2 * p);
      return (n - n % 1) / p + (_isNumber(raw) ? 0 : getUnit(raw));
    };
  };
  var snap = function snap2(snapTo, value) {
    var isArray = _isArray(snapTo), radius, is2D;
    if (!isArray && _isObject(snapTo)) {
      radius = isArray = snapTo.radius || _bigNum;
      if (snapTo.values) {
        snapTo = toArray(snapTo.values);
        if (is2D = !_isNumber(snapTo[0])) {
          radius *= radius;
        }
      } else {
        snapTo = _roundModifier(snapTo.increment);
      }
    }
    return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : _isFunction(snapTo) ? function(raw) {
      is2D = snapTo(raw);
      return Math.abs(is2D - raw) <= radius ? is2D : raw;
    } : function(raw) {
      var x = parseFloat(is2D ? raw.x : raw), y = parseFloat(is2D ? raw.y : 0), min = _bigNum, closest = 0, i = snapTo.length, dx, dy;
      while (i--) {
        if (is2D) {
          dx = snapTo[i].x - x;
          dy = snapTo[i].y - y;
          dx = dx * dx + dy * dy;
        } else {
          dx = Math.abs(snapTo[i] - x);
        }
        if (dx < min) {
          min = dx;
          closest = i;
        }
      }
      closest = !radius || min <= radius ? snapTo[closest] : raw;
      return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
    });
  };
  var random = function random2(min, max, roundingIncrement, returnFunction) {
    return _conditionalReturn(_isArray(min) ? !max : roundingIncrement === true ? !!(roundingIncrement = 0) : !returnFunction, function() {
      return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && Math.floor(Math.round((min - roundingIncrement / 2 + Math.random() * (max - min + roundingIncrement * 0.99)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
    });
  };
  var pipe = function pipe2() {
    for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
      functions[_key] = arguments[_key];
    }
    return function(value) {
      return functions.reduce(function(v2, f) {
        return f(v2);
      }, value);
    };
  };
  var unitize = function unitize2(func, unit) {
    return function(value) {
      return func(parseFloat(value)) + (unit || getUnit(value));
    };
  };
  var normalize = function normalize2(min, max, value) {
    return mapRange(min, max, 0, 1, value);
  };
  var _wrapArray = function _wrapArray2(a, wrapper, value) {
    return _conditionalReturn(value, function(index) {
      return a[~~wrapper(index)];
    });
  };
  var wrap = function wrap2(min, max, value) {
    var range = max - min;
    return _isArray(min) ? _wrapArray(min, wrap2(0, min.length), max) : _conditionalReturn(value, function(value2) {
      return (range + (value2 - min) % range) % range + min;
    });
  };
  var wrapYoyo = function wrapYoyo2(min, max, value) {
    var range = max - min, total = range * 2;
    return _isArray(min) ? _wrapArray(min, wrapYoyo2(0, min.length - 1), max) : _conditionalReturn(value, function(value2) {
      value2 = (total + (value2 - min) % total) % total || 0;
      return min + (value2 > range ? total - value2 : value2);
    });
  };
  var _replaceRandom = function _replaceRandom2(value) {
    var prev = 0, s = "", i, nums, end, isArray;
    while (~(i = value.indexOf("random(", prev))) {
      end = value.indexOf(")", i);
      isArray = value.charAt(i + 7) === "[";
      nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
      s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], isArray ? 0 : +nums[1], +nums[2] || 1e-5);
      prev = end + 1;
    }
    return s + value.substr(prev, value.length - prev);
  };
  var mapRange = function mapRange2(inMin, inMax, outMin, outMax, value) {
    var inRange = inMax - inMin, outRange = outMax - outMin;
    return _conditionalReturn(value, function(value2) {
      return outMin + ((value2 - inMin) / inRange * outRange || 0);
    });
  };
  var interpolate = function interpolate2(start, end, progress, mutate) {
    var func = isNaN(start + end) ? 0 : function(p2) {
      return (1 - p2) * start + p2 * end;
    };
    if (!func) {
      var isString = _isString(start), master = {}, p, i, interpolators, l, il;
      progress === true && (mutate = 1) && (progress = null);
      if (isString) {
        start = {
          p: start
        };
        end = {
          p: end
        };
      } else if (_isArray(start) && !_isArray(end)) {
        interpolators = [];
        l = start.length;
        il = l - 2;
        for (i = 1; i < l; i++) {
          interpolators.push(interpolate2(start[i - 1], start[i]));
        }
        l--;
        func = function func2(p2) {
          p2 *= l;
          var i2 = Math.min(il, ~~p2);
          return interpolators[i2](p2 - i2);
        };
        progress = end;
      } else if (!mutate) {
        start = _merge(_isArray(start) ? [] : {}, start);
      }
      if (!interpolators) {
        for (p in end) {
          _addPropTween.call(master, start, p, "get", end[p]);
        }
        func = function func2(p2) {
          return _renderPropTweens(p2, master) || (isString ? start.p : start);
        };
      }
    }
    return _conditionalReturn(progress, func);
  };
  var _getLabelInDirection = function _getLabelInDirection2(timeline2, fromTime, backward) {
    var labels = timeline2.labels, min = _bigNum, p, distance, label;
    for (p in labels) {
      distance = labels[p] - fromTime;
      if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
        label = p;
        min = distance;
      }
    }
    return label;
  };
  var _callback = function _callback2(animation, type, executeLazyFirst) {
    var v2 = animation.vars, callback = v2[type], prevContext = _context, context3 = animation._ctx, params, scope, result;
    if (!callback) {
      return;
    }
    params = v2[type + "Params"];
    scope = v2.callbackScope || animation;
    executeLazyFirst && _lazyTweens.length && _lazyRender();
    context3 && (_context = context3);
    result = params ? callback.apply(scope, params) : callback.call(scope);
    _context = prevContext;
    return result;
  };
  var _interrupt = function _interrupt2(animation) {
    _removeFromParent(animation);
    animation.scrollTrigger && animation.scrollTrigger.kill(!!_reverting);
    animation.progress() < 1 && _callback(animation, "onInterrupt");
    return animation;
  };
  var _quickTween;
  var _registerPluginQueue = [];
  var _createPlugin = function _createPlugin2(config3) {
    if (!config3) return;
    config3 = !config3.name && config3["default"] || config3;
    if (_windowExists() || config3.headless) {
      var name = config3.name, isFunc = _isFunction(config3), Plugin = name && !isFunc && config3.init ? function() {
        this._props = [];
      } : config3, instanceDefaults = {
        init: _emptyFunc,
        render: _renderPropTweens,
        add: _addPropTween,
        kill: _killPropTweensOf,
        modifier: _addPluginModifier,
        rawVars: 0
      }, statics = {
        targetTest: 0,
        get: 0,
        getSetter: _getSetter,
        aliases: {},
        register: 0
      };
      _wake();
      if (config3 !== Plugin) {
        if (_plugins[name]) {
          return;
        }
        _setDefaults(Plugin, _setDefaults(_copyExcluding(config3, instanceDefaults), statics));
        _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config3, statics)));
        _plugins[Plugin.prop = name] = Plugin;
        if (config3.targetTest) {
          _harnessPlugins.push(Plugin);
          _reservedProps[name] = 1;
        }
        name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin";
      }
      _addGlobal(name, Plugin);
      config3.register && config3.register(gsap, Plugin, PropTween);
    } else {
      _registerPluginQueue.push(config3);
    }
  };
  var _255 = 255;
  var _colorLookup = {
    aqua: [0, _255, _255],
    lime: [0, _255, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, _255],
    navy: [0, 0, 128],
    white: [_255, _255, _255],
    olive: [128, 128, 0],
    yellow: [_255, _255, 0],
    orange: [_255, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [_255, 0, 0],
    pink: [_255, 192, 203],
    cyan: [0, _255, _255],
    transparent: [_255, _255, _255, 0]
  };
  var _hue = function _hue2(h, m1, m2) {
    h += h < 0 ? 1 : h > 1 ? -1 : 0;
    return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + 0.5 | 0;
  };
  var splitColor = function splitColor2(v2, toHSL, forceAlpha) {
    var a = !v2 ? _colorLookup.black : _isNumber(v2) ? [v2 >> 16, v2 >> 8 & _255, v2 & _255] : 0, r, g, b, h, s, l, max, min, d, wasHSL;
    if (!a) {
      if (v2.substr(-1) === ",") {
        v2 = v2.substr(0, v2.length - 1);
      }
      if (_colorLookup[v2]) {
        a = _colorLookup[v2];
      } else if (v2.charAt(0) === "#") {
        if (v2.length < 6) {
          r = v2.charAt(1);
          g = v2.charAt(2);
          b = v2.charAt(3);
          v2 = "#" + r + r + g + g + b + b + (v2.length === 5 ? v2.charAt(4) + v2.charAt(4) : "");
        }
        if (v2.length === 9) {
          a = parseInt(v2.substr(1, 6), 16);
          return [a >> 16, a >> 8 & _255, a & _255, parseInt(v2.substr(7), 16) / 255];
        }
        v2 = parseInt(v2.substr(1), 16);
        a = [v2 >> 16, v2 >> 8 & _255, v2 & _255];
      } else if (v2.substr(0, 3) === "hsl") {
        a = wasHSL = v2.match(_strictNumExp);
        if (!toHSL) {
          h = +a[0] % 360 / 360;
          s = +a[1] / 100;
          l = +a[2] / 100;
          g = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          r = l * 2 - g;
          a.length > 3 && (a[3] *= 1);
          a[0] = _hue(h + 1 / 3, r, g);
          a[1] = _hue(h, r, g);
          a[2] = _hue(h - 1 / 3, r, g);
        } else if (~v2.indexOf("=")) {
          a = v2.match(_numExp);
          forceAlpha && a.length < 4 && (a[3] = 1);
          return a;
        }
      } else {
        a = v2.match(_strictNumExp) || _colorLookup.transparent;
      }
      a = a.map(Number);
    }
    if (toHSL && !wasHSL) {
      r = a[0] / _255;
      g = a[1] / _255;
      b = a[2] / _255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      l = (max + min) / 2;
      if (max === min) {
        h = s = 0;
      } else {
        d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
        h *= 60;
      }
      a[0] = ~~(h + 0.5);
      a[1] = ~~(s * 100 + 0.5);
      a[2] = ~~(l * 100 + 0.5);
    }
    forceAlpha && a.length < 4 && (a[3] = 1);
    return a;
  };
  var _colorOrderData = function _colorOrderData2(v2) {
    var values = [], c = [], i = -1;
    v2.split(_colorExp).forEach(function(v3) {
      var a = v3.match(_numWithUnitExp) || [];
      values.push.apply(values, a);
      c.push(i += a.length + 1);
    });
    values.c = c;
    return values;
  };
  var _formatColors = function _formatColors2(s, toHSL, orderMatchData) {
    var result = "", colors = (s + result).match(_colorExp), type = toHSL ? "hsla(" : "rgba(", i = 0, c, shell, d, l;
    if (!colors) {
      return s;
    }
    colors = colors.map(function(color) {
      return (color = splitColor(color, toHSL, 1)) && type + (toHSL ? color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : color.join(",")) + ")";
    });
    if (orderMatchData) {
      d = _colorOrderData(s);
      c = orderMatchData.c;
      if (c.join(result) !== d.c.join(result)) {
        shell = s.replace(_colorExp, "1").split(_numWithUnitExp);
        l = shell.length - 1;
        for (; i < l; i++) {
          result += shell[i] + (~c.indexOf(i) ? colors.shift() || type + "0,0,0,0)" : (d.length ? d : colors.length ? colors : orderMatchData).shift());
        }
      }
    }
    if (!shell) {
      shell = s.split(_colorExp);
      l = shell.length - 1;
      for (; i < l; i++) {
        result += shell[i] + colors[i];
      }
    }
    return result + shell[l];
  };
  var _colorExp = function() {
    var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", p;
    for (p in _colorLookup) {
      s += "|" + p + "\\b";
    }
    return new RegExp(s + ")", "gi");
  }();
  var _hslExp = /hsl[a]?\(/;
  var _colorStringFilter = function _colorStringFilter2(a) {
    var combined = a.join(" "), toHSL;
    _colorExp.lastIndex = 0;
    if (_colorExp.test(combined)) {
      toHSL = _hslExp.test(combined);
      a[1] = _formatColors(a[1], toHSL);
      a[0] = _formatColors(a[0], toHSL, _colorOrderData(a[1]));
      return true;
    }
  };
  var _tickerActive;
  var _ticker = function() {
    var _getTime = Date.now, _lagThreshold = 500, _adjustedLag = 33, _startTime = _getTime(), _lastUpdate = _startTime, _gap = 1e3 / 240, _nextTime = _gap, _listeners2 = [], _id, _req, _raf, _self, _delta, _i, _tick = function _tick2(v2) {
      var elapsed = _getTime() - _lastUpdate, manual = v2 === true, overlap, dispatch2, time, frame;
      (elapsed > _lagThreshold || elapsed < 0) && (_startTime += elapsed - _adjustedLag);
      _lastUpdate += elapsed;
      time = _lastUpdate - _startTime;
      overlap = time - _nextTime;
      if (overlap > 0 || manual) {
        frame = ++_self.frame;
        _delta = time - _self.time * 1e3;
        _self.time = time = time / 1e3;
        _nextTime += overlap + (overlap >= _gap ? 4 : _gap - overlap);
        dispatch2 = 1;
      }
      manual || (_id = _req(_tick2));
      if (dispatch2) {
        for (_i = 0; _i < _listeners2.length; _i++) {
          _listeners2[_i](time, _delta, frame, v2);
        }
      }
    };
    _self = {
      time: 0,
      frame: 0,
      tick: function tick() {
        _tick(true);
      },
      deltaRatio: function deltaRatio(fps) {
        return _delta / (1e3 / (fps || 60));
      },
      wake: function wake() {
        if (_coreReady) {
          if (!_coreInitted && _windowExists()) {
            _win = _coreInitted = window;
            _doc = _win.document || {};
            _globals.gsap = gsap;
            (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);
            _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});
            _registerPluginQueue.forEach(_createPlugin);
          }
          _raf = typeof requestAnimationFrame !== "undefined" && requestAnimationFrame;
          _id && _self.sleep();
          _req = _raf || function(f) {
            return setTimeout(f, _nextTime - _self.time * 1e3 + 1 | 0);
          };
          _tickerActive = 1;
          _tick(2);
        }
      },
      sleep: function sleep2() {
        (_raf ? cancelAnimationFrame : clearTimeout)(_id);
        _tickerActive = 0;
        _req = _emptyFunc;
      },
      lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
        _lagThreshold = threshold || Infinity;
        _adjustedLag = Math.min(adjustedLag || 33, _lagThreshold);
      },
      fps: function fps(_fps) {
        _gap = 1e3 / (_fps || 240);
        _nextTime = _self.time * 1e3 + _gap;
      },
      add: function add(callback, once, prioritize) {
        var func = once ? function(t, d, f, v2) {
          callback(t, d, f, v2);
          _self.remove(func);
        } : callback;
        _self.remove(callback);
        _listeners2[prioritize ? "unshift" : "push"](func);
        _wake();
        return func;
      },
      remove: function remove(callback, i) {
        ~(i = _listeners2.indexOf(callback)) && _listeners2.splice(i, 1) && _i >= i && _i--;
      },
      _listeners: _listeners2
    };
    return _self;
  }();
  var _wake = function _wake2() {
    return !_tickerActive && _ticker.wake();
  };
  var _easeMap = {};
  var _customEaseExp = /^[\d.\-M][\d.\-,\s]/;
  var _quotesExp = /["']/g;
  var _parseObjectInString = function _parseObjectInString2(value) {
    var obj = {}, split = value.substr(1, value.length - 3).split(":"), key = split[0], i = 1, l = split.length, index, val, parsedVal;
    for (; i < l; i++) {
      val = split[i];
      index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
      parsedVal = val.substr(0, index);
      obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
      key = val.substr(index + 1).trim();
    }
    return obj;
  };
  var _valueInParentheses = function _valueInParentheses2(value) {
    var open = value.indexOf("(") + 1, close = value.indexOf(")"), nested = value.indexOf("(", open);
    return value.substring(open, ~nested && nested < close ? value.indexOf(")", close + 1) : close);
  };
  var _configEaseFromString = function _configEaseFromString2(name) {
    var split = (name + "").split("("), ease = _easeMap[split[0]];
    return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _valueInParentheses(name).split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
  };
  var _invertEase = function _invertEase2(ease) {
    return function(p) {
      return 1 - ease(1 - p);
    };
  };
  var _propagateYoyoEase = function _propagateYoyoEase2(timeline2, isYoyo) {
    var child = timeline2._first, ease;
    while (child) {
      if (child instanceof Timeline) {
        _propagateYoyoEase2(child, isYoyo);
      } else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
        if (child.timeline) {
          _propagateYoyoEase2(child.timeline, isYoyo);
        } else {
          ease = child._ease;
          child._ease = child._yEase;
          child._yEase = ease;
          child._yoyo = isYoyo;
        }
      }
      child = child._next;
    }
  };
  var _parseEase = function _parseEase2(ease, defaultEase) {
    return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
  };
  var _insertEase = function _insertEase2(names, easeIn, easeOut, easeInOut) {
    if (easeOut === void 0) {
      easeOut = function easeOut2(p) {
        return 1 - easeIn(1 - p);
      };
    }
    if (easeInOut === void 0) {
      easeInOut = function easeInOut2(p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
      };
    }
    var ease = {
      easeIn,
      easeOut,
      easeInOut
    }, lowercaseName;
    _forEachName(names, function(name) {
      _easeMap[name] = _globals[name] = ease;
      _easeMap[lowercaseName = name.toLowerCase()] = easeOut;
      for (var p in ease) {
        _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
      }
    });
    return ease;
  };
  var _easeInOutFromOut = function _easeInOutFromOut2(easeOut) {
    return function(p) {
      return p < 0.5 ? (1 - easeOut(1 - p * 2)) / 2 : 0.5 + easeOut((p - 0.5) * 2) / 2;
    };
  };
  var _configElastic = function _configElastic2(type, amplitude, period) {
    var p1 = amplitude >= 1 ? amplitude : 1, p2 = (period || (type ? 0.3 : 0.45)) / (amplitude < 1 ? amplitude : 1), p3 = p2 / _2PI * (Math.asin(1 / p1) || 0), easeOut = function easeOut2(p) {
      return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    p2 = _2PI / p2;
    ease.config = function(amplitude2, period2) {
      return _configElastic2(type, amplitude2, period2);
    };
    return ease;
  };
  var _configBack = function _configBack2(type, overshoot) {
    if (overshoot === void 0) {
      overshoot = 1.70158;
    }
    var easeOut = function easeOut2(p) {
      return p ? --p * p * ((overshoot + 1) * p + overshoot) + 1 : 0;
    }, ease = type === "out" ? easeOut : type === "in" ? function(p) {
      return 1 - easeOut(1 - p);
    } : _easeInOutFromOut(easeOut);
    ease.config = function(overshoot2) {
      return _configBack2(type, overshoot2);
    };
    return ease;
  };
  _forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function(name, i) {
    var power = i < 5 ? i + 1 : i;
    _insertEase(name + ",Power" + (power - 1), i ? function(p) {
      return Math.pow(p, power);
    } : function(p) {
      return p;
    }, function(p) {
      return 1 - Math.pow(1 - p, power);
    }, function(p) {
      return p < 0.5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
    });
  });
  _easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;
  _insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());
  (function(n, c) {
    var n1 = 1 / c, n2 = 2 * n1, n3 = 2.5 * n1, easeOut = function easeOut2(p) {
      return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + 0.75 : p < n3 ? n * (p -= 2.25 / c) * p + 0.9375 : n * Math.pow(p - 2.625 / c, 2) + 0.984375;
    };
    _insertEase("Bounce", function(p) {
      return 1 - easeOut(1 - p);
    }, easeOut);
  })(7.5625, 2.75);
  _insertEase("Expo", function(p) {
    return Math.pow(2, 10 * (p - 1)) * p + p * p * p * p * p * p * (1 - p);
  });
  _insertEase("Circ", function(p) {
    return -(_sqrt(1 - p * p) - 1);
  });
  _insertEase("Sine", function(p) {
    return p === 1 ? 1 : -_cos(p * _HALF_PI) + 1;
  });
  _insertEase("Back", _configBack("in"), _configBack("out"), _configBack());
  _easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
    config: function config(steps, immediateStart) {
      if (steps === void 0) {
        steps = 1;
      }
      var p1 = 1 / steps, p2 = steps + (immediateStart ? 0 : 1), p3 = immediateStart ? 1 : 0, max = 1 - _tinyNum;
      return function(p) {
        return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
      };
    }
  };
  _defaults.ease = _easeMap["quad.out"];
  _forEachName("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(name) {
    return _callbackNames += name + "," + name + "Params,";
  });
  var GSCache = function GSCache2(target, harness) {
    this.id = _gsID++;
    target._gsap = this;
    this.target = target;
    this.harness = harness;
    this.get = harness ? harness.get : _getProperty;
    this.set = harness ? harness.getSetter : _getSetter;
  };
  var Animation = /* @__PURE__ */ function() {
    function Animation2(vars) {
      this.vars = vars;
      this._delay = +vars.delay || 0;
      if (this._repeat = vars.repeat === Infinity ? -2 : vars.repeat || 0) {
        this._rDelay = vars.repeatDelay || 0;
        this._yoyo = !!vars.yoyo || !!vars.yoyoEase;
      }
      this._ts = 1;
      _setDuration(this, +vars.duration, 1, 1);
      this.data = vars.data;
      if (_context) {
        this._ctx = _context;
        _context.data.push(this);
      }
      _tickerActive || _ticker.wake();
    }
    var _proto = Animation2.prototype;
    _proto.delay = function delay(value) {
      if (value || value === 0) {
        this.parent && this.parent.smoothChildTiming && this.startTime(this._start + value - this._delay);
        this._delay = value;
        return this;
      }
      return this._delay;
    };
    _proto.duration = function duration(value) {
      return arguments.length ? this.totalDuration(this._repeat > 0 ? value + (value + this._rDelay) * this._repeat : value) : this.totalDuration() && this._dur;
    };
    _proto.totalDuration = function totalDuration(value) {
      if (!arguments.length) {
        return this._tDur;
      }
      this._dirty = 0;
      return _setDuration(this, this._repeat < 0 ? value : (value - this._repeat * this._rDelay) / (this._repeat + 1));
    };
    _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
      _wake();
      if (!arguments.length) {
        return this._tTime;
      }
      var parent2 = this._dp;
      if (parent2 && parent2.smoothChildTiming && this._ts) {
        _alignPlayhead(this, _totalTime);
        !parent2._dp || parent2.parent || _postAddChecks(parent2, this);
        while (parent2 && parent2.parent) {
          if (parent2.parent._time !== parent2._start + (parent2._ts >= 0 ? parent2._tTime / parent2._ts : (parent2.totalDuration() - parent2._tTime) / -parent2._ts)) {
            parent2.totalTime(parent2._tTime, true);
          }
          parent2 = parent2.parent;
        }
        if (!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && _totalTime < this._tDur || this._ts < 0 && _totalTime > 0 || !this._tDur && !_totalTime)) {
          _addToTimeline(this._dp, this, this._start - this._delay);
        }
      }
      if (this._tTime !== _totalTime || !this._dur && !suppressEvents || this._initted && Math.abs(this._zTime) === _tinyNum || !_totalTime && !this._initted && (this.add || this._ptLookup)) {
        this._ts || (this._pTime = _totalTime);
        _lazySafeRender(this, _totalTime, suppressEvents);
      }
      return this;
    };
    _proto.time = function time(value, suppressEvents) {
      return arguments.length ? this.totalTime(Math.min(this.totalDuration(), value + _elapsedCycleDuration(this)) % (this._dur + this._rDelay) || (value ? this._dur : 0), suppressEvents) : this._time;
    };
    _proto.totalProgress = function totalProgress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0;
    };
    _proto.progress = function progress(value, suppressEvents) {
      return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - value : value) + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0;
    };
    _proto.iteration = function iteration(value, suppressEvents) {
      var cycleDuration = this.duration() + this._rDelay;
      return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? _animationCycle(this._tTime, cycleDuration) + 1 : 1;
    };
    _proto.timeScale = function timeScale(value, suppressEvents) {
      if (!arguments.length) {
        return this._rts === -_tinyNum ? 0 : this._rts;
      }
      if (this._rts === value) {
        return this;
      }
      var tTime = this.parent && this._ts ? _parentToChildTotalTime(this.parent._time, this) : this._tTime;
      this._rts = +value || 0;
      this._ts = this._ps || value === -_tinyNum ? 0 : this._rts;
      this.totalTime(_clamp(-Math.abs(this._delay), this.totalDuration(), tTime), suppressEvents !== false);
      _setEnd(this);
      return _recacheAncestors(this);
    };
    _proto.paused = function paused(value) {
      if (!arguments.length) {
        return this._ps;
      }
      if (this._ps !== value) {
        this._ps = value;
        if (value) {
          this._pTime = this._tTime || Math.max(-this._delay, this.rawTime());
          this._ts = this._act = 0;
        } else {
          _wake();
          this._ts = this._rts;
          this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== _tinyNum && (this._tTime -= _tinyNum));
        }
      }
      return this;
    };
    _proto.startTime = function startTime(value) {
      if (arguments.length) {
        this._start = value;
        var parent2 = this.parent || this._dp;
        parent2 && (parent2._sort || !this.parent) && _addToTimeline(parent2, this, value - this._delay);
        return this;
      }
      return this._start;
    };
    _proto.endTime = function endTime(includeRepeats) {
      return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1);
    };
    _proto.rawTime = function rawTime(wrapRepeats) {
      var parent2 = this.parent || this._dp;
      return !parent2 ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent2.rawTime(wrapRepeats), this);
    };
    _proto.revert = function revert(config3) {
      if (config3 === void 0) {
        config3 = _revertConfig;
      }
      var prevIsReverting = _reverting;
      _reverting = config3;
      if (_isRevertWorthy(this)) {
        this.timeline && this.timeline.revert(config3);
        this.totalTime(-0.01, config3.suppressEvents);
      }
      this.data !== "nested" && config3.kill !== false && this.kill();
      _reverting = prevIsReverting;
      return this;
    };
    _proto.globalTime = function globalTime(rawTime) {
      var animation = this, time = arguments.length ? rawTime : animation.rawTime();
      while (animation) {
        time = animation._start + time / (Math.abs(animation._ts) || 1);
        animation = animation._dp;
      }
      return !this.parent && this._sat ? this._sat.globalTime(rawTime) : time;
    };
    _proto.repeat = function repeat(value) {
      if (arguments.length) {
        this._repeat = value === Infinity ? -2 : value;
        return _onUpdateTotalDuration(this);
      }
      return this._repeat === -2 ? Infinity : this._repeat;
    };
    _proto.repeatDelay = function repeatDelay(value) {
      if (arguments.length) {
        var time = this._time;
        this._rDelay = value;
        _onUpdateTotalDuration(this);
        return time ? this.time(time) : this;
      }
      return this._rDelay;
    };
    _proto.yoyo = function yoyo(value) {
      if (arguments.length) {
        this._yoyo = value;
        return this;
      }
      return this._yoyo;
    };
    _proto.seek = function seek(position, suppressEvents) {
      return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
    };
    _proto.restart = function restart(includeDelay, suppressEvents) {
      this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
      this._dur || (this._zTime = -_tinyNum);
      return this;
    };
    _proto.play = function play(from, suppressEvents) {
      from != null && this.seek(from, suppressEvents);
      return this.reversed(false).paused(false);
    };
    _proto.reverse = function reverse(from, suppressEvents) {
      from != null && this.seek(from || this.totalDuration(), suppressEvents);
      return this.reversed(true).paused(false);
    };
    _proto.pause = function pause(atTime, suppressEvents) {
      atTime != null && this.seek(atTime, suppressEvents);
      return this.paused(true);
    };
    _proto.resume = function resume() {
      return this.paused(false);
    };
    _proto.reversed = function reversed(value) {
      if (arguments.length) {
        !!value !== this.reversed() && this.timeScale(-this._rts || (value ? -_tinyNum : 0));
        return this;
      }
      return this._rts < 0;
    };
    _proto.invalidate = function invalidate() {
      this._initted = this._act = 0;
      this._zTime = -_tinyNum;
      return this;
    };
    _proto.isActive = function isActive() {
      var parent2 = this.parent || this._dp, start = this._start, rawTime;
      return !!(!parent2 || this._ts && this._initted && parent2.isActive() && (rawTime = parent2.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum);
    };
    _proto.eventCallback = function eventCallback(type, callback, params) {
      var vars = this.vars;
      if (arguments.length > 1) {
        if (!callback) {
          delete vars[type];
        } else {
          vars[type] = callback;
          params && (vars[type + "Params"] = params);
          type === "onUpdate" && (this._onUpdate = callback);
        }
        return this;
      }
      return vars[type];
    };
    _proto.then = function then(onFulfilled) {
      var self2 = this;
      return new Promise(function(resolve) {
        var f = _isFunction(onFulfilled) ? onFulfilled : _passThrough, _resolve = function _resolve2() {
          var _then = self2.then;
          self2.then = null;
          _isFunction(f) && (f = f(self2)) && (f.then || f === self2) && (self2.then = _then);
          resolve(f);
          self2.then = _then;
        };
        if (self2._initted && self2.totalProgress() === 1 && self2._ts >= 0 || !self2._tTime && self2._ts < 0) {
          _resolve();
        } else {
          self2._prom = _resolve;
        }
      });
    };
    _proto.kill = function kill2() {
      _interrupt(this);
    };
    return Animation2;
  }();
  _setDefaults(Animation.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: false,
    parent: null,
    _initted: false,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -_tinyNum,
    _prom: 0,
    _ps: false,
    _rts: 1
  });
  var Timeline = /* @__PURE__ */ function(_Animation) {
    _inheritsLoose(Timeline2, _Animation);
    function Timeline2(vars, position) {
      var _this;
      if (vars === void 0) {
        vars = {};
      }
      _this = _Animation.call(this, vars) || this;
      _this.labels = {};
      _this.smoothChildTiming = !!vars.smoothChildTiming;
      _this.autoRemoveChildren = !!vars.autoRemoveChildren;
      _this._sort = _isNotFalse(vars.sortChildren);
      _globalTimeline && _addToTimeline(vars.parent || _globalTimeline, _assertThisInitialized(_this), position);
      vars.reversed && _this.reverse();
      vars.paused && _this.paused(true);
      vars.scrollTrigger && _scrollTrigger(_assertThisInitialized(_this), vars.scrollTrigger);
      return _this;
    }
    var _proto2 = Timeline2.prototype;
    _proto2.to = function to(targets, vars, position) {
      _createTweenType(0, arguments, this);
      return this;
    };
    _proto2.from = function from(targets, vars, position) {
      _createTweenType(1, arguments, this);
      return this;
    };
    _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
      _createTweenType(2, arguments, this);
      return this;
    };
    _proto2.set = function set2(targets, vars, position) {
      vars.duration = 0;
      vars.parent = this;
      _inheritDefaults(vars).repeatDelay || (vars.repeat = 0);
      vars.immediateRender = !!vars.immediateRender;
      new Tween(targets, vars, _parsePosition(this, position), 1);
      return this;
    };
    _proto2.call = function call(callback, params, position) {
      return _addToTimeline(this, Tween.delayedCall(0, callback, params), position);
    };
    _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.duration = duration;
      vars.stagger = vars.stagger || stagger;
      vars.onComplete = onCompleteAll;
      vars.onCompleteParams = onCompleteAllParams;
      vars.parent = this;
      new Tween(targets, vars, _parsePosition(this, position));
      return this;
    };
    _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
      vars.runBackwards = 1;
      _inheritDefaults(vars).immediateRender = _isNotFalse(vars.immediateRender);
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
      toVars.startAt = fromVars;
      _inheritDefaults(toVars).immediateRender = _isNotFalse(toVars.immediateRender);
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
    };
    _proto2.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._dirty ? this.totalDuration() : this._tDur, dur = this._dur, tTime = totalTime <= 0 ? 0 : _roundPrecise(totalTime), crossingStart = this._zTime < 0 !== totalTime < 0 && (this._initted || !dur), time, child, next, iteration, cycleDuration, prevPaused, pauseTween, timeScale, prevStart, prevIteration, yoyo, isYoyo;
      this !== _globalTimeline && tTime > tDur && totalTime >= 0 && (tTime = tDur);
      if (tTime !== this._tTime || force || crossingStart) {
        if (prevTime !== this._time && dur) {
          tTime += this._time - prevTime;
          totalTime += this._time - prevTime;
        }
        time = tTime;
        prevStart = this._start;
        timeScale = this._ts;
        prevPaused = !timeScale;
        if (crossingStart) {
          dur || (prevTime = this._zTime);
          (totalTime || !suppressEvents) && (this._zTime = totalTime);
        }
        if (this._repeat) {
          yoyo = this._yoyo;
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && totalTime < 0) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            }
            time > dur && (time = dur);
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          !prevTime && this._tTime && prevIteration !== iteration && this._tTime - prevIteration * cycleDuration - this._dur <= 0 && (prevIteration = iteration);
          if (yoyo && iteration & 1) {
            time = dur - time;
            isYoyo = 1;
          }
          if (iteration !== prevIteration && !this._lock) {
            var rewinding = yoyo && prevIteration & 1, doesWrap = rewinding === (yoyo && iteration & 1);
            iteration < prevIteration && (rewinding = !rewinding);
            prevTime = rewinding ? 0 : tTime % dur ? dur : tTime;
            this._lock = 1;
            this.render(prevTime || (isYoyo ? 0 : _roundPrecise(iteration * cycleDuration)), suppressEvents, !dur)._lock = 0;
            this._tTime = tTime;
            !suppressEvents && this.parent && _callback(this, "onRepeat");
            this.vars.repeatRefresh && !isYoyo && (this.invalidate()._lock = 1);
            if (prevTime && prevTime !== this._time || prevPaused !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) {
              return this;
            }
            dur = this._dur;
            tDur = this._tDur;
            if (doesWrap) {
              this._lock = 2;
              prevTime = rewinding ? dur : -1e-4;
              this.render(prevTime, true);
              this.vars.repeatRefresh && !isYoyo && this.invalidate();
            }
            this._lock = 0;
            if (!this._ts && !prevPaused) {
              return this;
            }
            _propagateYoyoEase(this, isYoyo);
          }
        }
        if (this._hasPause && !this._forcing && this._lock < 2) {
          pauseTween = _findNextPauseTween(this, _roundPrecise(prevTime), _roundPrecise(time));
          if (pauseTween) {
            tTime -= time - (time = pauseTween._start);
          }
        }
        this._tTime = tTime;
        this._time = time;
        this._act = !timeScale;
        if (!this._initted) {
          this._onUpdate = this.vars.onUpdate;
          this._initted = 1;
          this._zTime = totalTime;
          prevTime = 0;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        if (time >= prevTime && totalTime >= 0) {
          child = this._first;
          while (child) {
            next = child._next;
            if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = -_tinyNum);
                break;
              }
            }
            child = next;
          }
        } else {
          child = this._last;
          var adjustedTime = totalTime < 0 ? totalTime : time;
          while (child) {
            next = child._prev;
            if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
              if (child.parent !== this) {
                return this.render(totalTime, suppressEvents, force);
              }
              child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force || _reverting && _isRevertWorthy(child));
              if (time !== this._time || !this._ts && !prevPaused) {
                pauseTween = 0;
                next && (tTime += this._zTime = adjustedTime ? -_tinyNum : _tinyNum);
                break;
              }
            }
            child = next;
          }
        }
        if (pauseTween && !suppressEvents) {
          this.pause();
          pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;
          if (this._ts) {
            this._start = prevStart;
            _setEnd(this);
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._onUpdate && !suppressEvents && _callback(this, "onUpdate", true);
        if (tTime === tDur && this._tTime >= this.totalDuration() || !tTime && prevTime) {
          if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) {
            if (!this._lock) {
              (totalTime || !dur) && (tTime === tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
              if (!suppressEvents && !(totalTime < 0 && !prevTime) && (tTime || prevTime || !tDur)) {
                _callback(this, tTime === tDur && totalTime >= 0 ? "onComplete" : "onReverseComplete", true);
                this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
              }
            }
          }
        }
      }
      return this;
    };
    _proto2.add = function add(child, position) {
      var _this2 = this;
      _isNumber(position) || (position = _parsePosition(this, position, child));
      if (!(child instanceof Animation)) {
        if (_isArray(child)) {
          child.forEach(function(obj) {
            return _this2.add(obj, position);
          });
          return this;
        }
        if (_isString(child)) {
          return this.addLabel(child, position);
        }
        if (_isFunction(child)) {
          child = Tween.delayedCall(0, child);
        } else {
          return this;
        }
      }
      return this !== child ? _addToTimeline(this, child, position) : this;
    };
    _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
      if (nested === void 0) {
        nested = true;
      }
      if (tweens === void 0) {
        tweens = true;
      }
      if (timelines === void 0) {
        timelines = true;
      }
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = -_bigNum;
      }
      var a = [], child = this._first;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          if (child instanceof Tween) {
            tweens && a.push(child);
          } else {
            timelines && a.push(child);
            nested && a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
        child = child._next;
      }
      return a;
    };
    _proto2.getById = function getById2(id) {
      var animations = this.getChildren(1, 1, 1), i = animations.length;
      while (i--) {
        if (animations[i].vars.id === id) {
          return animations[i];
        }
      }
    };
    _proto2.remove = function remove(child) {
      if (_isString(child)) {
        return this.removeLabel(child);
      }
      if (_isFunction(child)) {
        return this.killTweensOf(child);
      }
      child.parent === this && _removeLinkedListItem(this, child);
      if (child === this._recent) {
        this._recent = this._last;
      }
      return _uncache(this);
    };
    _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
      if (!arguments.length) {
        return this._tTime;
      }
      this._forcing = 1;
      if (!this._dp && this._ts) {
        this._start = _roundPrecise(_ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts));
      }
      _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);
      this._forcing = 0;
      return this;
    };
    _proto2.addLabel = function addLabel(label, position) {
      this.labels[label] = _parsePosition(this, position);
      return this;
    };
    _proto2.removeLabel = function removeLabel(label) {
      delete this.labels[label];
      return this;
    };
    _proto2.addPause = function addPause(position, callback, params) {
      var t = Tween.delayedCall(0, callback || _emptyFunc, params);
      t.data = "isPause";
      this._hasPause = 1;
      return _addToTimeline(this, t, _parsePosition(this, position));
    };
    _proto2.removePause = function removePause(position) {
      var child = this._first;
      position = _parsePosition(this, position);
      while (child) {
        if (child._start === position && child.data === "isPause") {
          _removeFromParent(child);
        }
        child = child._next;
      }
    };
    _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      var tweens = this.getTweensOf(targets, onlyActive), i = tweens.length;
      while (i--) {
        _overwritingTween !== tweens[i] && tweens[i].kill(targets, props);
      }
      return this;
    };
    _proto2.getTweensOf = function getTweensOf2(targets, onlyActive) {
      var a = [], parsedTargets = toArray(targets), child = this._first, isGlobalTime = _isNumber(onlyActive), children;
      while (child) {
        if (child instanceof Tween) {
          if (_arrayContainsAny(child._targets, parsedTargets) && (isGlobalTime ? (!_overwritingTween || child._initted && child._ts) && child.globalTime(0) <= onlyActive && child.globalTime(child.totalDuration()) > onlyActive : !onlyActive || child.isActive())) {
            a.push(child);
          }
        } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
          a.push.apply(a, children);
        }
        child = child._next;
      }
      return a;
    };
    _proto2.tweenTo = function tweenTo(position, vars) {
      vars = vars || {};
      var tl = this, endTime = _parsePosition(tl, position), _vars = vars, startAt = _vars.startAt, _onStart = _vars.onStart, onStartParams = _vars.onStartParams, immediateRender = _vars.immediateRender, initted, tween = Tween.to(tl, _setDefaults({
        ease: vars.ease || "none",
        lazy: false,
        immediateRender: false,
        time: endTime,
        overwrite: "auto",
        duration: vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale()) || _tinyNum,
        onStart: function onStart() {
          tl.pause();
          if (!initted) {
            var duration = vars.duration || Math.abs((endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale());
            tween._dur !== duration && _setDuration(tween, duration, 0, 1).render(tween._time, true, true);
            initted = 1;
          }
          _onStart && _onStart.apply(tween, onStartParams || []);
        }
      }, vars));
      return immediateRender ? tween.render(0) : tween;
    };
    _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
      return this.tweenTo(toPosition, _setDefaults({
        startAt: {
          time: _parsePosition(this, fromPosition)
        }
      }, vars));
    };
    _proto2.recent = function recent() {
      return this._recent;
    };
    _proto2.nextLabel = function nextLabel(afterTime) {
      if (afterTime === void 0) {
        afterTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, afterTime));
    };
    _proto2.previousLabel = function previousLabel(beforeTime) {
      if (beforeTime === void 0) {
        beforeTime = this._time;
      }
      return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
    };
    _proto2.currentLabel = function currentLabel(value) {
      return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
    };
    _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
      if (ignoreBeforeTime === void 0) {
        ignoreBeforeTime = 0;
      }
      var child = this._first, labels = this.labels, p;
      while (child) {
        if (child._start >= ignoreBeforeTime) {
          child._start += amount;
          child._end += amount;
        }
        child = child._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return _uncache(this);
    };
    _proto2.invalidate = function invalidate(soft) {
      var child = this._first;
      this._lock = 0;
      while (child) {
        child.invalidate(soft);
        child = child._next;
      }
      return _Animation.prototype.invalidate.call(this, soft);
    };
    _proto2.clear = function clear(includeLabels) {
      if (includeLabels === void 0) {
        includeLabels = true;
      }
      var child = this._first, next;
      while (child) {
        next = child._next;
        this.remove(child);
        child = next;
      }
      this._dp && (this._time = this._tTime = this._pTime = 0);
      includeLabels && (this.labels = {});
      return _uncache(this);
    };
    _proto2.totalDuration = function totalDuration(value) {
      var max = 0, self2 = this, child = self2._last, prevStart = _bigNum, prev, start, parent2;
      if (arguments.length) {
        return self2.timeScale((self2._repeat < 0 ? self2.duration() : self2.totalDuration()) / (self2.reversed() ? -value : value));
      }
      if (self2._dirty) {
        parent2 = self2.parent;
        while (child) {
          prev = child._prev;
          child._dirty && child.totalDuration();
          start = child._start;
          if (start > prevStart && self2._sort && child._ts && !self2._lock) {
            self2._lock = 1;
            _addToTimeline(self2, child, start - child._delay, 1)._lock = 0;
          } else {
            prevStart = start;
          }
          if (start < 0 && child._ts) {
            max -= start;
            if (!parent2 && !self2._dp || parent2 && parent2.smoothChildTiming) {
              self2._start += start / self2._ts;
              self2._time -= start;
              self2._tTime -= start;
            }
            self2.shiftChildren(-start, false, -Infinity);
            prevStart = 0;
          }
          child._end > max && child._ts && (max = child._end);
          child = prev;
        }
        _setDuration(self2, self2 === _globalTimeline && self2._time > max ? self2._time : max, 1, 1);
        self2._dirty = 0;
      }
      return self2._tDur;
    };
    Timeline2.updateRoot = function updateRoot(time) {
      if (_globalTimeline._ts) {
        _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
        _lastRenderedFrame = _ticker.frame;
      }
      if (_ticker.frame >= _nextGCFrame) {
        _nextGCFrame += _config.autoSleep || 120;
        var child = _globalTimeline._first;
        if (!child || !child._ts) {
          if (_config.autoSleep && _ticker._listeners.length < 2) {
            while (child && !child._ts) {
              child = child._next;
            }
            child || _ticker.sleep();
          }
        }
      }
    };
    return Timeline2;
  }(Animation);
  _setDefaults(Timeline.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
  });
  var _addComplexStringPropTween = function _addComplexStringPropTween2(target, prop, start, end, setter, stringFilter, funcParam) {
    var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter), index = 0, matchIndex = 0, result, startNums, color, endNum, chunk, startNum, hasRandom, a;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (hasRandom = ~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }
    if (stringFilter) {
      a = [start, end];
      stringFilter(a, target, prop);
      start = a[0];
      end = a[1];
    }
    startNums = start.match(_complexStringNumExp) || [];
    while (result = _complexStringNumExp.exec(end)) {
      endNum = result[0];
      chunk = end.substring(index, result.index);
      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }
      if (endNum !== startNums[matchIndex++]) {
        startNum = parseFloat(startNums[matchIndex - 1]) || 0;
        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: endNum.charAt(1) === "=" ? _parseRelative(startNum, endNum) - startNum : parseFloat(endNum) - startNum,
          m: color && color < 4 ? Math.round : 0
        };
        index = _complexStringNumExp.lastIndex;
      }
    }
    pt.c = index < end.length ? end.substring(index, end.length) : "";
    pt.fp = funcParam;
    if (_relExp.test(end) || hasRandom) {
      pt.e = 0;
    }
    this._pt = pt;
    return pt;
  };
  var _addPropTween = function _addPropTween2(target, prop, start, end, index, targets, modifier, stringFilter, funcParam, optional) {
    _isFunction(end) && (end = end(index || 0, target, targets));
    var currentValue = target[prop], parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](), setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc, pt;
    if (_isString(end)) {
      if (~end.indexOf("random(")) {
        end = _replaceRandom(end);
      }
      if (end.charAt(1) === "=") {
        pt = _parseRelative(parsedStart, end) + (getUnit(parsedStart) || 0);
        if (pt || pt === 0) {
          end = pt;
        }
      }
    }
    if (!optional || parsedStart !== end || _forceAllPropTweens) {
      if (!isNaN(parsedStart * end) && end !== "") {
        pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);
        funcParam && (pt.fp = funcParam);
        modifier && pt.modifier(modifier, this, target);
        return this._pt = pt;
      }
      !currentValue && !(prop in target) && _missingPlugin(prop, end);
      return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
    }
  };
  var _processVars = function _processVars2(vars, index, target, targets, tween) {
    _isFunction(vars) && (vars = _parseFuncOrString(vars, tween, index, target, targets));
    if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars) || _isTypedArray(vars)) {
      return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
    }
    var copy = {}, p;
    for (p in vars) {
      copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
    }
    return copy;
  };
  var _checkPlugin = function _checkPlugin2(property, vars, tween, index, target, targets) {
    var plugin, pt, ptLookup, i;
    if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
      tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);
      if (tween !== _quickTween) {
        ptLookup = tween._ptLookup[tween._targets.indexOf(target)];
        i = plugin._props.length;
        while (i--) {
          ptLookup[plugin._props[i]] = pt;
        }
      }
    }
    return plugin;
  };
  var _overwritingTween;
  var _forceAllPropTweens;
  var _initTween = function _initTween2(tween, time, tTime) {
    var vars = tween.vars, ease = vars.ease, startAt = vars.startAt, immediateRender = vars.immediateRender, lazy = vars.lazy, onUpdate = vars.onUpdate, runBackwards = vars.runBackwards, yoyoEase = vars.yoyoEase, keyframes = vars.keyframes, autoRevert = vars.autoRevert, dur = tween._dur, prevStartAt = tween._startAt, targets = tween._targets, parent2 = tween.parent, fullTargets = parent2 && parent2.data === "nested" ? parent2.vars.targets : targets, autoOverwrite = tween._overwrite === "auto" && !_suppressOverwrites, tl = tween.timeline, cleanVars, i, p, pt, target, hasPriority, gsData, harness, plugin, ptLookup, index, harnessVars, overwritten;
    tl && (!keyframes || !ease) && (ease = "none");
    tween._ease = _parseEase(ease, _defaults.ease);
    tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;
    if (yoyoEase && tween._yoyo && !tween._repeat) {
      yoyoEase = tween._yEase;
      tween._yEase = tween._ease;
      tween._ease = yoyoEase;
    }
    tween._from = !tl && !!vars.runBackwards;
    if (!tl || keyframes && !vars.stagger) {
      harness = targets[0] ? _getCache(targets[0]).harness : 0;
      harnessVars = harness && vars[harness.prop];
      cleanVars = _copyExcluding(vars, _reservedProps);
      if (prevStartAt) {
        prevStartAt._zTime < 0 && prevStartAt.progress(1);
        time < 0 && runBackwards && immediateRender && !autoRevert ? prevStartAt.render(-1, true) : prevStartAt.revert(runBackwards && dur ? _revertConfigNoKill : _startAtRevertConfig);
        prevStartAt._lazy = 0;
      }
      if (startAt) {
        _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
          data: "isStart",
          overwrite: false,
          parent: parent2,
          immediateRender: true,
          lazy: !prevStartAt && _isNotFalse(lazy),
          startAt: null,
          delay: 0,
          onUpdate: onUpdate && function() {
            return _callback(tween, "onUpdate");
          },
          stagger: 0
        }, startAt)));
        tween._startAt._dp = 0;
        tween._startAt._sat = tween;
        time < 0 && (_reverting || !immediateRender && !autoRevert) && tween._startAt.revert(_revertConfigNoKill);
        if (immediateRender) {
          if (dur && time <= 0 && tTime <= 0) {
            time && (tween._zTime = time);
            return;
          }
        }
      } else if (runBackwards && dur) {
        if (!prevStartAt) {
          time && (immediateRender = false);
          p = _setDefaults({
            overwrite: false,
            data: "isFromStart",
            //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
            lazy: immediateRender && !prevStartAt && _isNotFalse(lazy),
            immediateRender,
            //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
            stagger: 0,
            parent: parent2
            //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y: gsap.utils.wrap([-100,100]), stagger: 0.5})
          }, cleanVars);
          harnessVars && (p[harness.prop] = harnessVars);
          _removeFromParent(tween._startAt = Tween.set(targets, p));
          tween._startAt._dp = 0;
          tween._startAt._sat = tween;
          time < 0 && (_reverting ? tween._startAt.revert(_revertConfigNoKill) : tween._startAt.render(-1, true));
          tween._zTime = time;
          if (!immediateRender) {
            _initTween2(tween._startAt, _tinyNum, _tinyNum);
          } else if (!time) {
            return;
          }
        }
      }
      tween._pt = tween._ptCache = 0;
      lazy = dur && _isNotFalse(lazy) || lazy && !dur;
      for (i = 0; i < targets.length; i++) {
        target = targets[i];
        gsData = target._gsap || _harness(targets)[i]._gsap;
        tween._ptLookup[i] = ptLookup = {};
        _lazyLookup[gsData.id] && _lazyTweens.length && _lazyRender();
        index = fullTargets === targets ? i : fullTargets.indexOf(target);
        if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
          tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);
          plugin._props.forEach(function(name) {
            ptLookup[name] = pt;
          });
          plugin.priority && (hasPriority = 1);
        }
        if (!harness || harnessVars) {
          for (p in cleanVars) {
            if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
              plugin.priority && (hasPriority = 1);
            } else {
              ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
            }
          }
        }
        tween._op && tween._op[i] && tween.kill(target, tween._op[i]);
        if (autoOverwrite && tween._pt) {
          _overwritingTween = tween;
          _globalTimeline.killTweensOf(target, ptLookup, tween.globalTime(time));
          overwritten = !tween.parent;
          _overwritingTween = 0;
        }
        tween._pt && lazy && (_lazyLookup[gsData.id] = 1);
      }
      hasPriority && _sortPropTweensByPriority(tween);
      tween._onInit && tween._onInit(tween);
    }
    tween._onUpdate = onUpdate;
    tween._initted = (!tween._op || tween._pt) && !overwritten;
    keyframes && time <= 0 && tl.render(_bigNum, true, true);
  };
  var _updatePropTweens = function _updatePropTweens2(tween, property, value, start, startIsRelative, ratio, time, skipRecursion) {
    var ptCache = (tween._pt && tween._ptCache || (tween._ptCache = {}))[property], pt, rootPT, lookup, i;
    if (!ptCache) {
      ptCache = tween._ptCache[property] = [];
      lookup = tween._ptLookup;
      i = tween._targets.length;
      while (i--) {
        pt = lookup[i][property];
        if (pt && pt.d && pt.d._pt) {
          pt = pt.d._pt;
          while (pt && pt.p !== property && pt.fp !== property) {
            pt = pt._next;
          }
        }
        if (!pt) {
          _forceAllPropTweens = 1;
          tween.vars[property] = "+=0";
          _initTween(tween, time);
          _forceAllPropTweens = 0;
          return skipRecursion ? _warn(property + " not eligible for reset") : 1;
        }
        ptCache.push(pt);
      }
    }
    i = ptCache.length;
    while (i--) {
      rootPT = ptCache[i];
      pt = rootPT._pt || rootPT;
      pt.s = (start || start === 0) && !startIsRelative ? start : pt.s + (start || 0) + ratio * pt.c;
      pt.c = value - pt.s;
      rootPT.e && (rootPT.e = _round(value) + getUnit(rootPT.e));
      rootPT.b && (rootPT.b = pt.s + getUnit(rootPT.b));
    }
  };
  var _addAliasesToVars = function _addAliasesToVars2(targets, vars) {
    var harness = targets[0] ? _getCache(targets[0]).harness : 0, propertyAliases = harness && harness.aliases, copy, p, i, aliases;
    if (!propertyAliases) {
      return vars;
    }
    copy = _merge({}, vars);
    for (p in propertyAliases) {
      if (p in copy) {
        aliases = propertyAliases[p].split(",");
        i = aliases.length;
        while (i--) {
          copy[aliases[i]] = copy[p];
        }
      }
    }
    return copy;
  };
  var _parseKeyframe = function _parseKeyframe2(prop, obj, allProps, easeEach) {
    var ease = obj.ease || easeEach || "power1.inOut", p, a;
    if (_isArray(obj)) {
      a = allProps[prop] || (allProps[prop] = []);
      obj.forEach(function(value, i) {
        return a.push({
          t: i / (obj.length - 1) * 100,
          v: value,
          e: ease
        });
      });
    } else {
      for (p in obj) {
        a = allProps[p] || (allProps[p] = []);
        p === "ease" || a.push({
          t: parseFloat(prop),
          v: obj[p],
          e: ease
        });
      }
    }
  };
  var _parseFuncOrString = function _parseFuncOrString2(value, tween, i, target, targets) {
    return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
  };
  var _staggerTweenProps = _callbackNames + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert";
  var _staggerPropsToSkip = {};
  _forEachName(_staggerTweenProps + ",id,stagger,delay,duration,paused,scrollTrigger", function(name) {
    return _staggerPropsToSkip[name] = 1;
  });
  var Tween = /* @__PURE__ */ function(_Animation2) {
    _inheritsLoose(Tween2, _Animation2);
    function Tween2(targets, vars, position, skipInherit) {
      var _this3;
      if (typeof vars === "number") {
        position.duration = vars;
        vars = position;
        position = null;
      }
      _this3 = _Animation2.call(this, skipInherit ? vars : _inheritDefaults(vars)) || this;
      var _this3$vars = _this3.vars, duration = _this3$vars.duration, delay = _this3$vars.delay, immediateRender = _this3$vars.immediateRender, stagger = _this3$vars.stagger, overwrite = _this3$vars.overwrite, keyframes = _this3$vars.keyframes, defaults2 = _this3$vars.defaults, scrollTrigger = _this3$vars.scrollTrigger, yoyoEase = _this3$vars.yoyoEase, parent2 = vars.parent || _globalTimeline, parsedTargets = (_isArray(targets) || _isTypedArray(targets) ? _isNumber(targets[0]) : "length" in vars) ? [targets] : toArray(targets), tl, i, copy, l, p, curTarget, staggerFunc, staggerVarsToMerge;
      _this3._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://gsap.com", !_config.nullTargetWarn) || [];
      _this3._ptLookup = [];
      _this3._overwrite = overwrite;
      if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
        vars = _this3.vars;
        tl = _this3.timeline = new Timeline({
          data: "nested",
          defaults: defaults2 || {},
          targets: parent2 && parent2.data === "nested" ? parent2.vars.targets : parsedTargets
        });
        tl.kill();
        tl.parent = tl._dp = _assertThisInitialized(_this3);
        tl._start = 0;
        if (stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
          l = parsedTargets.length;
          staggerFunc = stagger && distribute(stagger);
          if (_isObject(stagger)) {
            for (p in stagger) {
              if (~_staggerTweenProps.indexOf(p)) {
                staggerVarsToMerge || (staggerVarsToMerge = {});
                staggerVarsToMerge[p] = stagger[p];
              }
            }
          }
          for (i = 0; i < l; i++) {
            copy = _copyExcluding(vars, _staggerPropsToSkip);
            copy.stagger = 0;
            yoyoEase && (copy.yoyoEase = yoyoEase);
            staggerVarsToMerge && _merge(copy, staggerVarsToMerge);
            curTarget = parsedTargets[i];
            copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this3), i, curTarget, parsedTargets);
            copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this3), i, curTarget, parsedTargets) || 0) - _this3._delay;
            if (!stagger && l === 1 && copy.delay) {
              _this3._delay = delay = copy.delay;
              _this3._start += delay;
              copy.delay = 0;
            }
            tl.to(curTarget, copy, staggerFunc ? staggerFunc(i, curTarget, parsedTargets) : 0);
            tl._ease = _easeMap.none;
          }
          tl.duration() ? duration = delay = 0 : _this3.timeline = 0;
        } else if (keyframes) {
          _inheritDefaults(_setDefaults(tl.vars.defaults, {
            ease: "none"
          }));
          tl._ease = _parseEase(keyframes.ease || vars.ease || "none");
          var time = 0, a, kf, v2;
          if (_isArray(keyframes)) {
            keyframes.forEach(function(frame) {
              return tl.to(parsedTargets, frame, ">");
            });
            tl.duration();
          } else {
            copy = {};
            for (p in keyframes) {
              p === "ease" || p === "easeEach" || _parseKeyframe(p, keyframes[p], copy, keyframes.easeEach);
            }
            for (p in copy) {
              a = copy[p].sort(function(a2, b) {
                return a2.t - b.t;
              });
              time = 0;
              for (i = 0; i < a.length; i++) {
                kf = a[i];
                v2 = {
                  ease: kf.e,
                  duration: (kf.t - (i ? a[i - 1].t : 0)) / 100 * duration
                };
                v2[p] = kf.v;
                tl.to(parsedTargets, v2, time);
                time += v2.duration;
              }
            }
            tl.duration() < duration && tl.to({}, {
              duration: duration - tl.duration()
            });
          }
        }
        duration || _this3.duration(duration = tl.duration());
      } else {
        _this3.timeline = 0;
      }
      if (overwrite === true && !_suppressOverwrites) {
        _overwritingTween = _assertThisInitialized(_this3);
        _globalTimeline.killTweensOf(parsedTargets);
        _overwritingTween = 0;
      }
      _addToTimeline(parent2, _assertThisInitialized(_this3), position);
      vars.reversed && _this3.reverse();
      vars.paused && _this3.paused(true);
      if (immediateRender || !duration && !keyframes && _this3._start === _roundPrecise(parent2._time) && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this3)) && parent2.data !== "nested") {
        _this3._tTime = -_tinyNum;
        _this3.render(Math.max(0, -delay) || 0);
      }
      scrollTrigger && _scrollTrigger(_assertThisInitialized(_this3), scrollTrigger);
      return _this3;
    }
    var _proto3 = Tween2.prototype;
    _proto3.render = function render4(totalTime, suppressEvents, force) {
      var prevTime = this._time, tDur = this._tDur, dur = this._dur, isNegative = totalTime < 0, tTime = totalTime > tDur - _tinyNum && !isNegative ? tDur : totalTime < _tinyNum ? 0 : totalTime, time, pt, iteration, cycleDuration, prevIteration, isYoyo, ratio, timeline2, yoyoEase;
      if (!dur) {
        _renderZeroDurationTween(this, totalTime, suppressEvents, force);
      } else if (tTime !== this._tTime || !totalTime || force || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== isNegative || this._lazy) {
        time = tTime;
        timeline2 = this.timeline;
        if (this._repeat) {
          cycleDuration = dur + this._rDelay;
          if (this._repeat < -1 && isNegative) {
            return this.totalTime(cycleDuration * 100 + totalTime, suppressEvents, force);
          }
          time = _roundPrecise(tTime % cycleDuration);
          if (tTime === tDur) {
            iteration = this._repeat;
            time = dur;
          } else {
            prevIteration = _roundPrecise(tTime / cycleDuration);
            iteration = ~~prevIteration;
            if (iteration && iteration === prevIteration) {
              time = dur;
              iteration--;
            } else if (time > dur) {
              time = dur;
            }
          }
          isYoyo = this._yoyo && iteration & 1;
          if (isYoyo) {
            yoyoEase = this._yEase;
            time = dur - time;
          }
          prevIteration = _animationCycle(this._tTime, cycleDuration);
          if (time === prevTime && !force && this._initted && iteration === prevIteration) {
            this._tTime = tTime;
            return this;
          }
          if (iteration !== prevIteration) {
            timeline2 && this._yEase && _propagateYoyoEase(timeline2, isYoyo);
            if (this.vars.repeatRefresh && !isYoyo && !this._lock && time !== cycleDuration && this._initted) {
              this._lock = force = 1;
              this.render(_roundPrecise(cycleDuration * iteration), true).invalidate()._lock = 0;
            }
          }
        }
        if (!this._initted) {
          if (_attemptInitTween(this, isNegative ? totalTime : time, force, suppressEvents, tTime)) {
            this._tTime = 0;
            return this;
          }
          if (prevTime !== this._time && !(force && this.vars.repeatRefresh && iteration !== prevIteration)) {
            return this;
          }
          if (dur !== this._dur) {
            return this.render(totalTime, suppressEvents, force);
          }
        }
        this._tTime = tTime;
        this._time = time;
        if (!this._act && this._ts) {
          this._act = 1;
          this._lazy = 0;
        }
        this.ratio = ratio = (yoyoEase || this._ease)(time / dur);
        if (this._from) {
          this.ratio = ratio = 1 - ratio;
        }
        if (!prevTime && tTime && !suppressEvents && !prevIteration) {
          _callback(this, "onStart");
          if (this._tTime !== tTime) {
            return this;
          }
        }
        pt = this._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
        timeline2 && timeline2.render(totalTime < 0 ? totalTime : timeline2._dur * timeline2._ease(time / this._dur), suppressEvents, force) || this._startAt && (this._zTime = totalTime);
        if (this._onUpdate && !suppressEvents) {
          isNegative && _rewindStartAt(this, totalTime, suppressEvents, force);
          _callback(this, "onUpdate");
        }
        this._repeat && iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent && _callback(this, "onRepeat");
        if ((tTime === this._tDur || !tTime) && this._tTime === tTime) {
          isNegative && !this._onUpdate && _rewindStartAt(this, totalTime, true, true);
          (totalTime || !dur) && (tTime === this._tDur && this._ts > 0 || !tTime && this._ts < 0) && _removeFromParent(this, 1);
          if (!suppressEvents && !(isNegative && !prevTime) && (tTime || prevTime || isYoyo)) {
            _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);
            this._prom && !(tTime < tDur && this.timeScale() > 0) && this._prom();
          }
        }
      }
      return this;
    };
    _proto3.targets = function targets() {
      return this._targets;
    };
    _proto3.invalidate = function invalidate(soft) {
      (!soft || !this.vars.runBackwards) && (this._startAt = 0);
      this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0;
      this._ptLookup = [];
      this.timeline && this.timeline.invalidate(soft);
      return _Animation2.prototype.invalidate.call(this, soft);
    };
    _proto3.resetTo = function resetTo(property, value, start, startIsRelative, skipRecursion) {
      _tickerActive || _ticker.wake();
      this._ts || this.play();
      var time = Math.min(this._dur, (this._dp._time - this._start) * this._ts), ratio;
      this._initted || _initTween(this, time);
      ratio = this._ease(time / this._dur);
      if (_updatePropTweens(this, property, value, start, startIsRelative, ratio, time, skipRecursion)) {
        return this.resetTo(property, value, start, startIsRelative, 1);
      }
      _alignPlayhead(this, 0);
      this.parent || _addLinkedListItem(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0);
      return this.render(0);
    };
    _proto3.kill = function kill2(targets, vars) {
      if (vars === void 0) {
        vars = "all";
      }
      if (!targets && (!vars || vars === "all")) {
        this._lazy = this._pt = 0;
        this.parent ? _interrupt(this) : this.scrollTrigger && this.scrollTrigger.kill(!!_reverting);
        return this;
      }
      if (this.timeline) {
        var tDur = this.timeline.totalDuration();
        this.timeline.killTweensOf(targets, vars, _overwritingTween && _overwritingTween.vars.overwrite !== true)._first || _interrupt(this);
        this.parent && tDur !== this.timeline.totalDuration() && _setDuration(this, this._dur * this.timeline._tDur / tDur, 0, 1);
        return this;
      }
      var parsedTargets = this._targets, killingTargets = targets ? toArray(targets) : parsedTargets, propTweenLookup = this._ptLookup, firstPT = this._pt, overwrittenProps, curLookup, curOverwriteProps, props, p, pt, i;
      if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
        vars === "all" && (this._pt = 0);
        return _interrupt(this);
      }
      overwrittenProps = this._op = this._op || [];
      if (vars !== "all") {
        if (_isString(vars)) {
          p = {};
          _forEachName(vars, function(name) {
            return p[name] = 1;
          });
          vars = p;
        }
        vars = _addAliasesToVars(parsedTargets, vars);
      }
      i = parsedTargets.length;
      while (i--) {
        if (~killingTargets.indexOf(parsedTargets[i])) {
          curLookup = propTweenLookup[i];
          if (vars === "all") {
            overwrittenProps[i] = vars;
            props = curLookup;
            curOverwriteProps = {};
          } else {
            curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
            props = vars;
          }
          for (p in props) {
            pt = curLookup && curLookup[p];
            if (pt) {
              if (!("kill" in pt.d) || pt.d.kill(p) === true) {
                _removeLinkedListItem(this, pt, "_pt");
              }
              delete curLookup[p];
            }
            if (curOverwriteProps !== "all") {
              curOverwriteProps[p] = 1;
            }
          }
        }
      }
      this._initted && !this._pt && firstPT && _interrupt(this);
      return this;
    };
    Tween2.to = function to(targets, vars) {
      return new Tween2(targets, vars, arguments[2]);
    };
    Tween2.from = function from(targets, vars) {
      return _createTweenType(1, arguments);
    };
    Tween2.delayedCall = function delayedCall(delay, callback, params, scope) {
      return new Tween2(callback, 0, {
        immediateRender: false,
        lazy: false,
        overwrite: false,
        delay,
        onComplete: callback,
        onReverseComplete: callback,
        onCompleteParams: params,
        onReverseCompleteParams: params,
        callbackScope: scope
      });
    };
    Tween2.fromTo = function fromTo(targets, fromVars, toVars) {
      return _createTweenType(2, arguments);
    };
    Tween2.set = function set2(targets, vars) {
      vars.duration = 0;
      vars.repeatDelay || (vars.repeat = 0);
      return new Tween2(targets, vars);
    };
    Tween2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
      return _globalTimeline.killTweensOf(targets, props, onlyActive);
    };
    return Tween2;
  }(Animation);
  _setDefaults(Tween.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
  });
  _forEachName("staggerTo,staggerFrom,staggerFromTo", function(name) {
    Tween[name] = function() {
      var tl = new Timeline(), params = _slice.call(arguments, 0);
      params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
      return tl[name].apply(tl, params);
    };
  });
  var _setterPlain = function _setterPlain2(target, property, value) {
    return target[property] = value;
  };
  var _setterFunc = function _setterFunc2(target, property, value) {
    return target[property](value);
  };
  var _setterFuncWithParam = function _setterFuncWithParam2(target, property, value, data) {
    return target[property](data.fp, value);
  };
  var _setterAttribute = function _setterAttribute2(target, property, value) {
    return target.setAttribute(property, value);
  };
  var _getSetter = function _getSetter2(target, property) {
    return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
  };
  var _renderPlain = function _renderPlain2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e6) / 1e6, data);
  };
  var _renderBoolean = function _renderBoolean2(ratio, data) {
    return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
  };
  var _renderComplexString = function _renderComplexString2(ratio, data) {
    var pt = data._pt, s = "";
    if (!ratio && data.b) {
      s = data.b;
    } else if (ratio === 1 && data.e) {
      s = data.e;
    } else {
      while (pt) {
        s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : Math.round((pt.s + pt.c * ratio) * 1e4) / 1e4) + s;
        pt = pt._next;
      }
      s += data.c;
    }
    data.set(data.t, data.p, s, data);
  };
  var _renderPropTweens = function _renderPropTweens2(ratio, data) {
    var pt = data._pt;
    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }
  };
  var _addPluginModifier = function _addPluginModifier2(modifier, tween, target, property) {
    var pt = this._pt, next;
    while (pt) {
      next = pt._next;
      pt.p === property && pt.modifier(modifier, tween, target);
      pt = next;
    }
  };
  var _killPropTweensOf = function _killPropTweensOf2(property) {
    var pt = this._pt, hasNonDependentRemaining, next;
    while (pt) {
      next = pt._next;
      if (pt.p === property && !pt.op || pt.op === property) {
        _removeLinkedListItem(this, pt, "_pt");
      } else if (!pt.dep) {
        hasNonDependentRemaining = 1;
      }
      pt = next;
    }
    return !hasNonDependentRemaining;
  };
  var _setterWithModifier = function _setterWithModifier2(target, property, value, data) {
    data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
  };
  var _sortPropTweensByPriority = function _sortPropTweensByPriority2(parent2) {
    var pt = parent2._pt, next, pt2, first, last;
    while (pt) {
      next = pt._next;
      pt2 = first;
      while (pt2 && pt2.pr > pt.pr) {
        pt2 = pt2._next;
      }
      if (pt._prev = pt2 ? pt2._prev : last) {
        pt._prev._next = pt;
      } else {
        first = pt;
      }
      if (pt._next = pt2) {
        pt2._prev = pt;
      } else {
        last = pt;
      }
      pt = next;
    }
    parent2._pt = first;
  };
  var PropTween = /* @__PURE__ */ function() {
    function PropTween2(next, target, prop, start, change, renderer, data, setter, priority) {
      this.t = target;
      this.s = start;
      this.c = change;
      this.p = prop;
      this.r = renderer || _renderPlain;
      this.d = data || this;
      this.set = setter || _setterPlain;
      this.pr = priority || 0;
      this._next = next;
      if (next) {
        next._prev = this;
      }
    }
    var _proto4 = PropTween2.prototype;
    _proto4.modifier = function modifier(func, tween, target) {
      this.mSet = this.mSet || this.set;
      this.set = _setterWithModifier;
      this.m = func;
      this.mt = target;
      this.tween = tween;
    };
    return PropTween2;
  }();
  _forEachName(_callbackNames + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(name) {
    return _reservedProps[name] = 1;
  });
  _globals.TweenMax = _globals.TweenLite = Tween;
  _globals.TimelineLite = _globals.TimelineMax = Timeline;
  _globalTimeline = new Timeline({
    sortChildren: false,
    defaults: _defaults,
    autoRemoveChildren: true,
    id: "root",
    smoothChildTiming: true
  });
  _config.stringFilter = _colorStringFilter;
  var _media = [];
  var _listeners = {};
  var _emptyArray = [];
  var _lastMediaTime = 0;
  var _contextID = 0;
  var _dispatch = function _dispatch2(type) {
    return (_listeners[type] || _emptyArray).map(function(f) {
      return f();
    });
  };
  var _onMediaChange = function _onMediaChange2() {
    var time = Date.now(), matches = [];
    if (time - _lastMediaTime > 2) {
      _dispatch("matchMediaInit");
      _media.forEach(function(c) {
        var queries = c.queries, conditions = c.conditions, match, p, anyMatch, toggled;
        for (p in queries) {
          match = _win.matchMedia(queries[p]).matches;
          match && (anyMatch = 1);
          if (match !== conditions[p]) {
            conditions[p] = match;
            toggled = 1;
          }
        }
        if (toggled) {
          c.revert();
          anyMatch && matches.push(c);
        }
      });
      _dispatch("matchMediaRevert");
      matches.forEach(function(c) {
        return c.onMatch(c, function(func) {
          return c.add(null, func);
        });
      });
      _lastMediaTime = time;
      _dispatch("matchMedia");
    }
  };
  var Context = /* @__PURE__ */ function() {
    function Context2(func, scope) {
      this.selector = scope && selector(scope);
      this.data = [];
      this._r = [];
      this.isReverted = false;
      this.id = _contextID++;
      func && this.add(func);
    }
    var _proto5 = Context2.prototype;
    _proto5.add = function add(name, func, scope) {
      if (_isFunction(name)) {
        scope = func;
        func = name;
        name = _isFunction;
      }
      var self2 = this, f = function f2() {
        var prev = _context, prevSelector = self2.selector, result;
        prev && prev !== self2 && prev.data.push(self2);
        scope && (self2.selector = selector(scope));
        _context = self2;
        result = func.apply(self2, arguments);
        _isFunction(result) && self2._r.push(result);
        _context = prev;
        self2.selector = prevSelector;
        self2.isReverted = false;
        return result;
      };
      self2.last = f;
      return name === _isFunction ? f(self2, function(func2) {
        return self2.add(null, func2);
      }) : name ? self2[name] = f : f;
    };
    _proto5.ignore = function ignore(func) {
      var prev = _context;
      _context = null;
      func(this);
      _context = prev;
    };
    _proto5.getTweens = function getTweens() {
      var a = [];
      this.data.forEach(function(e) {
        return e instanceof Context2 ? a.push.apply(a, e.getTweens()) : e instanceof Tween && !(e.parent && e.parent.data === "nested") && a.push(e);
      });
      return a;
    };
    _proto5.clear = function clear() {
      this._r.length = this.data.length = 0;
    };
    _proto5.kill = function kill2(revert, matchMedia2) {
      var _this4 = this;
      if (revert) {
        (function() {
          var tweens = _this4.getTweens(), i2 = _this4.data.length, t;
          while (i2--) {
            t = _this4.data[i2];
            if (t.data === "isFlip") {
              t.revert();
              t.getChildren(true, true, false).forEach(function(tween) {
                return tweens.splice(tweens.indexOf(tween), 1);
              });
            }
          }
          tweens.map(function(t2) {
            return {
              g: t2._dur || t2._delay || t2._sat && !t2._sat.vars.immediateRender ? t2.globalTime(0) : -Infinity,
              t: t2
            };
          }).sort(function(a, b) {
            return b.g - a.g || -Infinity;
          }).forEach(function(o) {
            return o.t.revert(revert);
          });
          i2 = _this4.data.length;
          while (i2--) {
            t = _this4.data[i2];
            if (t instanceof Timeline) {
              if (t.data !== "nested") {
                t.scrollTrigger && t.scrollTrigger.revert();
                t.kill();
              }
            } else {
              !(t instanceof Tween) && t.revert && t.revert(revert);
            }
          }
          _this4._r.forEach(function(f) {
            return f(revert, _this4);
          });
          _this4.isReverted = true;
        })();
      } else {
        this.data.forEach(function(e) {
          return e.kill && e.kill();
        });
      }
      this.clear();
      if (matchMedia2) {
        var i = _media.length;
        while (i--) {
          _media[i].id === this.id && _media.splice(i, 1);
        }
      }
    };
    _proto5.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    return Context2;
  }();
  var MatchMedia = /* @__PURE__ */ function() {
    function MatchMedia2(scope) {
      this.contexts = [];
      this.scope = scope;
      _context && _context.data.push(this);
    }
    var _proto6 = MatchMedia2.prototype;
    _proto6.add = function add(conditions, func, scope) {
      _isObject(conditions) || (conditions = {
        matches: conditions
      });
      var context3 = new Context(0, scope || this.scope), cond = context3.conditions = {}, mq, p, active;
      _context && !context3.selector && (context3.selector = _context.selector);
      this.contexts.push(context3);
      func = context3.add("onMatch", func);
      context3.queries = conditions;
      for (p in conditions) {
        if (p === "all") {
          active = 1;
        } else {
          mq = _win.matchMedia(conditions[p]);
          if (mq) {
            _media.indexOf(context3) < 0 && _media.push(context3);
            (cond[p] = mq.matches) && (active = 1);
            mq.addListener ? mq.addListener(_onMediaChange) : mq.addEventListener("change", _onMediaChange);
          }
        }
      }
      active && func(context3, function(f) {
        return context3.add(null, f);
      });
      return this;
    };
    _proto6.revert = function revert(config3) {
      this.kill(config3 || {});
    };
    _proto6.kill = function kill2(revert) {
      this.contexts.forEach(function(c) {
        return c.kill(revert, true);
      });
    };
    return MatchMedia2;
  }();
  var _gsap = {
    registerPlugin: function registerPlugin() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      args.forEach(function(config3) {
        return _createPlugin(config3);
      });
    },
    timeline: function timeline(vars) {
      return new Timeline(vars);
    },
    getTweensOf: function getTweensOf(targets, onlyActive) {
      return _globalTimeline.getTweensOf(targets, onlyActive);
    },
    getProperty: function getProperty(target, property, unit, uncache) {
      _isString(target) && (target = toArray(target)[0]);
      var getter = _getCache(target || {}).get, format = unit ? _passThrough : _numericIfPossible;
      unit === "native" && (unit = "");
      return !target ? target : !property ? function(property2, unit2, uncache2) {
        return format((_plugins[property2] && _plugins[property2].get || getter)(target, property2, unit2, uncache2));
      } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    },
    quickSetter: function quickSetter(target, property, unit) {
      target = toArray(target);
      if (target.length > 1) {
        var setters = target.map(function(t) {
          return gsap.quickSetter(t, property, unit);
        }), l = setters.length;
        return function(value) {
          var i = l;
          while (i--) {
            setters[i](value);
          }
        };
      }
      target = target[0] || {};
      var Plugin = _plugins[property], cache = _getCache(target), p = cache.harness && (cache.harness.aliases || {})[property] || property, setter = Plugin ? function(value) {
        var p2 = new Plugin();
        _quickTween._pt = 0;
        p2.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
        p2.render(1, p2);
        _quickTween._pt && _renderPropTweens(1, _quickTween);
      } : cache.set(target, p);
      return Plugin ? setter : function(value) {
        return setter(target, p, unit ? value + unit : value, cache, 1);
      };
    },
    quickTo: function quickTo(target, property, vars) {
      var _setDefaults22;
      var tween = gsap.to(target, _setDefaults((_setDefaults22 = {}, _setDefaults22[property] = "+=0.1", _setDefaults22.paused = true, _setDefaults22.stagger = 0, _setDefaults22), vars || {})), func = function func2(value, start, startIsRelative) {
        return tween.resetTo(property, value, start, startIsRelative);
      };
      func.tween = tween;
      return func;
    },
    isTweening: function isTweening(targets) {
      return _globalTimeline.getTweensOf(targets, true).length > 0;
    },
    defaults: function defaults(value) {
      value && value.ease && (value.ease = _parseEase(value.ease, _defaults.ease));
      return _mergeDeep(_defaults, value || {});
    },
    config: function config2(value) {
      return _mergeDeep(_config, value || {});
    },
    registerEffect: function registerEffect(_ref3) {
      var name = _ref3.name, effect = _ref3.effect, plugins = _ref3.plugins, defaults2 = _ref3.defaults, extendTimeline = _ref3.extendTimeline;
      (plugins || "").split(",").forEach(function(pluginName) {
        return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
      });
      _effects[name] = function(targets, vars, tl) {
        return effect(toArray(targets), _setDefaults(vars || {}, defaults2), tl);
      };
      if (extendTimeline) {
        Timeline.prototype[name] = function(targets, vars, position) {
          return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}, this), position);
        };
      }
    },
    registerEase: function registerEase(name, ease) {
      _easeMap[name] = _parseEase(ease);
    },
    parseEase: function parseEase(ease, defaultEase) {
      return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
    },
    getById: function getById(id) {
      return _globalTimeline.getById(id);
    },
    exportRoot: function exportRoot(vars, includeDelayedCalls) {
      if (vars === void 0) {
        vars = {};
      }
      var tl = new Timeline(vars), child, next;
      tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
      _globalTimeline.remove(tl);
      tl._dp = 0;
      tl._time = tl._tTime = _globalTimeline._time;
      child = _globalTimeline._first;
      while (child) {
        next = child._next;
        if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
          _addToTimeline(tl, child, child._start - child._delay);
        }
        child = next;
      }
      _addToTimeline(_globalTimeline, tl, 0);
      return tl;
    },
    context: function context(func, scope) {
      return func ? new Context(func, scope) : _context;
    },
    matchMedia: function matchMedia(scope) {
      return new MatchMedia(scope);
    },
    matchMediaRefresh: function matchMediaRefresh() {
      return _media.forEach(function(c) {
        var cond = c.conditions, found, p;
        for (p in cond) {
          if (cond[p]) {
            cond[p] = false;
            found = 1;
          }
        }
        found && c.revert();
      }) || _onMediaChange();
    },
    addEventListener: function addEventListener(type, callback) {
      var a = _listeners[type] || (_listeners[type] = []);
      ~a.indexOf(callback) || a.push(callback);
    },
    removeEventListener: function removeEventListener(type, callback) {
      var a = _listeners[type], i = a && a.indexOf(callback);
      i >= 0 && a.splice(i, 1);
    },
    utils: {
      wrap,
      wrapYoyo,
      distribute,
      random,
      snap,
      normalize,
      getUnit,
      clamp,
      splitColor,
      toArray,
      selector,
      mapRange,
      pipe,
      unitize,
      interpolate,
      shuffle
    },
    install: _install,
    effects: _effects,
    ticker: _ticker,
    updateRoot: Timeline.updateRoot,
    plugins: _plugins,
    globalTimeline: _globalTimeline,
    core: {
      PropTween,
      globals: _addGlobal,
      Tween,
      Timeline,
      Animation,
      getCache: _getCache,
      _removeLinkedListItem,
      reverting: function reverting() {
        return _reverting;
      },
      context: function context2(toAdd) {
        if (toAdd && _context) {
          _context.data.push(toAdd);
          toAdd._ctx = _context;
        }
        return _context;
      },
      suppressOverwrites: function suppressOverwrites(value) {
        return _suppressOverwrites = value;
      }
    }
  };
  _forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function(name) {
    return _gsap[name] = Tween[name];
  });
  _ticker.add(Timeline.updateRoot);
  _quickTween = _gsap.to({}, {
    duration: 0
  });
  var _getPluginPropTween = function _getPluginPropTween2(plugin, prop) {
    var pt = plugin._pt;
    while (pt && pt.p !== prop && pt.op !== prop && pt.fp !== prop) {
      pt = pt._next;
    }
    return pt;
  };
  var _addModifiers = function _addModifiers2(tween, modifiers) {
    var targets = tween._targets, p, i, pt;
    for (p in modifiers) {
      i = targets.length;
      while (i--) {
        pt = tween._ptLookup[i][p];
        if (pt && (pt = pt.d)) {
          if (pt._pt) {
            pt = _getPluginPropTween(pt, p);
          }
          pt && pt.modifier && pt.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  };
  var _buildModifierPlugin = function _buildModifierPlugin2(name, modifier) {
    return {
      name,
      headless: 1,
      rawVars: 1,
      //don't pre-process function-based values or "random()" strings.
      init: function init5(target, vars, tween) {
        tween._onInit = function(tween2) {
          var temp, p;
          if (_isString(vars)) {
            temp = {};
            _forEachName(vars, function(name2) {
              return temp[name2] = 1;
            });
            vars = temp;
          }
          if (modifier) {
            temp = {};
            for (p in vars) {
              temp[p] = modifier(vars[p]);
            }
            vars = temp;
          }
          _addModifiers(tween2, vars);
        };
      }
    };
  };
  var gsap = _gsap.registerPlugin({
    name: "attr",
    init: function init(target, vars, tween, index, targets) {
      var p, pt, v2;
      this.tween = tween;
      for (p in vars) {
        v2 = target.getAttribute(p) || "";
        pt = this.add(target, "setAttribute", (v2 || 0) + "", vars[p], index, targets, 0, 0, p);
        pt.op = p;
        pt.b = v2;
        this._props.push(p);
      }
    },
    render: function render(ratio, data) {
      var pt = data._pt;
      while (pt) {
        _reverting ? pt.set(pt.t, pt.p, pt.b, pt) : pt.r(ratio, pt.d);
        pt = pt._next;
      }
    }
  }, {
    name: "endArray",
    headless: 1,
    init: function init2(target, value) {
      var i = value.length;
      while (i--) {
        this.add(target, i, target[i] || 0, value[i], 0, 0, 0, 0, 0, 1);
      }
    }
  }, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap)) || _gsap;
  Tween.version = Timeline.version = gsap.version = "3.13.0";
  _coreReady = 1;
  _windowExists() && _wake();
  var Power0 = _easeMap.Power0;
  var Power1 = _easeMap.Power1;
  var Power2 = _easeMap.Power2;
  var Power3 = _easeMap.Power3;
  var Power4 = _easeMap.Power4;
  var Linear = _easeMap.Linear;
  var Quad = _easeMap.Quad;
  var Cubic = _easeMap.Cubic;
  var Quart = _easeMap.Quart;
  var Quint = _easeMap.Quint;
  var Strong = _easeMap.Strong;
  var Elastic = _easeMap.Elastic;
  var Back = _easeMap.Back;
  var SteppedEase = _easeMap.SteppedEase;
  var Bounce = _easeMap.Bounce;
  var Sine = _easeMap.Sine;
  var Expo = _easeMap.Expo;
  var Circ = _easeMap.Circ;

  // node_modules/gsap/CSSPlugin.js
  init_live_reload();
  var _win2;
  var _doc2;
  var _docElement;
  var _pluginInitted;
  var _tempDiv;
  var _tempDivStyler;
  var _recentSetterPlugin;
  var _reverting2;
  var _windowExists3 = function _windowExists4() {
    return typeof window !== "undefined";
  };
  var _transformProps = {};
  var _RAD2DEG = 180 / Math.PI;
  var _DEG2RAD = Math.PI / 180;
  var _atan2 = Math.atan2;
  var _bigNum2 = 1e8;
  var _capsExp = /([A-Z])/g;
  var _horizontalExp = /(left|right|width|margin|padding|x)/i;
  var _complexExp = /[\s,\(]\S/;
  var _propertyAliases = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity"
  };
  var _renderCSSProp = function _renderCSSProp2(ratio, data) {
    return data.set(data.t, data.p, Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderPropWithEnd = function _renderPropWithEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio === 1 ? data.e : Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u, data);
  };
  var _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning2(ratio, data) {
    return data.set(data.t, data.p, ratio ? Math.round((data.s + data.c * ratio) * 1e4) / 1e4 + data.u : data.b, data);
  };
  var _renderRoundedCSSProp = function _renderRoundedCSSProp2(ratio, data) {
    var value = data.s + data.c * ratio;
    data.set(data.t, data.p, ~~(value + (value < 0 ? -0.5 : 0.5)) + data.u, data);
  };
  var _renderNonTweeningValue = function _renderNonTweeningValue2(ratio, data) {
    return data.set(data.t, data.p, ratio ? data.e : data.b, data);
  };
  var _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd2(ratio, data) {
    return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
  };
  var _setterCSSStyle = function _setterCSSStyle2(target, property, value) {
    return target.style[property] = value;
  };
  var _setterCSSProp = function _setterCSSProp2(target, property, value) {
    return target.style.setProperty(property, value);
  };
  var _setterTransform = function _setterTransform2(target, property, value) {
    return target._gsap[property] = value;
  };
  var _setterScale = function _setterScale2(target, property, value) {
    return target._gsap.scaleX = target._gsap.scaleY = value;
  };
  var _setterScaleWithRender = function _setterScaleWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache.scaleX = cache.scaleY = value;
    cache.renderTransform(ratio, cache);
  };
  var _setterTransformWithRender = function _setterTransformWithRender2(target, property, value, data, ratio) {
    var cache = target._gsap;
    cache[property] = value;
    cache.renderTransform(ratio, cache);
  };
  var _transformProp = "transform";
  var _transformOriginProp = _transformProp + "Origin";
  var _saveStyle = function _saveStyle2(property, isNotCSS) {
    var _this = this;
    var target = this.target, style = target.style, cache = target._gsap;
    if (property in _transformProps && style) {
      this.tfm = this.tfm || {};
      if (property !== "transform") {
        property = _propertyAliases[property] || property;
        ~property.indexOf(",") ? property.split(",").forEach(function(a) {
          return _this.tfm[a] = _get(target, a);
        }) : this.tfm[property] = cache.x ? cache[property] : _get(target, property);
        property === _transformOriginProp && (this.tfm.zOrigin = cache.zOrigin);
      } else {
        return _propertyAliases.transform.split(",").forEach(function(p) {
          return _saveStyle2.call(_this, p, isNotCSS);
        });
      }
      if (this.props.indexOf(_transformProp) >= 0) {
        return;
      }
      if (cache.svg) {
        this.svgo = target.getAttribute("data-svg-origin");
        this.props.push(_transformOriginProp, isNotCSS, "");
      }
      property = _transformProp;
    }
    (style || isNotCSS) && this.props.push(property, isNotCSS, style[property]);
  };
  var _removeIndependentTransforms = function _removeIndependentTransforms2(style) {
    if (style.translate) {
      style.removeProperty("translate");
      style.removeProperty("scale");
      style.removeProperty("rotate");
    }
  };
  var _revertStyle = function _revertStyle2() {
    var props = this.props, target = this.target, style = target.style, cache = target._gsap, i, p;
    for (i = 0; i < props.length; i += 3) {
      if (!props[i + 1]) {
        props[i + 2] ? style[props[i]] = props[i + 2] : style.removeProperty(props[i].substr(0, 2) === "--" ? props[i] : props[i].replace(_capsExp, "-$1").toLowerCase());
      } else if (props[i + 1] === 2) {
        target[props[i]](props[i + 2]);
      } else {
        target[props[i]] = props[i + 2];
      }
    }
    if (this.tfm) {
      for (p in this.tfm) {
        cache[p] = this.tfm[p];
      }
      if (cache.svg) {
        cache.renderTransform();
        target.setAttribute("data-svg-origin", this.svgo || "");
      }
      i = _reverting2();
      if ((!i || !i.isStart) && !style[_transformProp]) {
        _removeIndependentTransforms(style);
        if (cache.zOrigin && style[_transformOriginProp]) {
          style[_transformOriginProp] += " " + cache.zOrigin + "px";
          cache.zOrigin = 0;
          cache.renderTransform();
        }
        cache.uncache = 1;
      }
    }
  };
  var _getStyleSaver = function _getStyleSaver2(target, properties) {
    var saver = {
      target,
      props: [],
      revert: _revertStyle,
      save: _saveStyle
    };
    target._gsap || gsap.core.getCache(target);
    properties && target.style && target.nodeType && properties.split(",").forEach(function(p) {
      return saver.save(p);
    });
    return saver;
  };
  var _supports3D;
  var _createElement = function _createElement2(type, ns) {
    var e = _doc2.createElementNS ? _doc2.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc2.createElement(type);
    return e && e.style ? e : _doc2.createElement(type);
  };
  var _getComputedProperty = function _getComputedProperty2(target, property, skipPrefixFallback) {
    var cs = getComputedStyle(target);
    return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property) || !skipPrefixFallback && _getComputedProperty2(target, _checkPropPrefix(property) || property, 1) || "";
  };
  var _prefixes = "O,Moz,ms,Ms,Webkit".split(",");
  var _checkPropPrefix = function _checkPropPrefix2(property, element, preferPrefix) {
    var e = element || _tempDiv, s = e.style, i = 5;
    if (property in s && !preferPrefix) {
      return property;
    }
    property = property.charAt(0).toUpperCase() + property.substr(1);
    while (i-- && !(_prefixes[i] + property in s)) {
    }
    return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? _prefixes[i] : "") + property;
  };
  var _initCore = function _initCore2() {
    if (_windowExists3() && window.document) {
      _win2 = window;
      _doc2 = _win2.document;
      _docElement = _doc2.documentElement;
      _tempDiv = _createElement("div") || {
        style: {}
      };
      _tempDivStyler = _createElement("div");
      _transformProp = _checkPropPrefix(_transformProp);
      _transformOriginProp = _transformProp + "Origin";
      _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0";
      _supports3D = !!_checkPropPrefix("perspective");
      _reverting2 = gsap.core.reverting;
      _pluginInitted = 1;
    }
  };
  var _getReparentedCloneBBox = function _getReparentedCloneBBox2(target) {
    var owner = target.ownerSVGElement, svg = _createElement("svg", owner && owner.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), clone = target.cloneNode(true), bbox2;
    clone.style.display = "block";
    svg.appendChild(clone);
    _docElement.appendChild(svg);
    try {
      bbox2 = clone.getBBox();
    } catch (e) {
    }
    svg.removeChild(clone);
    _docElement.removeChild(svg);
    return bbox2;
  };
  var _getAttributeFallbacks = function _getAttributeFallbacks2(target, attributesArray) {
    var i = attributesArray.length;
    while (i--) {
      if (target.hasAttribute(attributesArray[i])) {
        return target.getAttribute(attributesArray[i]);
      }
    }
  };
  var _getBBox = function _getBBox2(target) {
    var bounds, cloned;
    try {
      bounds = target.getBBox();
    } catch (error) {
      bounds = _getReparentedCloneBBox(target);
      cloned = 1;
    }
    bounds && (bounds.width || bounds.height) || cloned || (bounds = _getReparentedCloneBBox(target));
    return bounds && !bounds.width && !bounds.x && !bounds.y ? {
      x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]) || 0,
      y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]) || 0,
      width: 0,
      height: 0
    } : bounds;
  };
  var _isSVG = function _isSVG2(e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
  };
  var _removeProperty = function _removeProperty2(target, property) {
    if (property) {
      var style = target.style, first2Chars;
      if (property in _transformProps && property !== _transformOriginProp) {
        property = _transformProp;
      }
      if (style.removeProperty) {
        first2Chars = property.substr(0, 2);
        if (first2Chars === "ms" || property.substr(0, 6) === "webkit") {
          property = "-" + property;
        }
        style.removeProperty(first2Chars === "--" ? property : property.replace(_capsExp, "-$1").toLowerCase());
      } else {
        style.removeAttribute(property);
      }
    }
  };
  var _addNonTweeningPT = function _addNonTweeningPT2(plugin, target, property, beginning, end, onlySetAtEnd) {
    var pt = new PropTween(plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
    plugin._pt = pt;
    pt.b = beginning;
    pt.e = end;
    plugin._props.push(property);
    return pt;
  };
  var _nonConvertibleUnits = {
    deg: 1,
    rad: 1,
    turn: 1
  };
  var _nonStandardLayouts = {
    grid: 1,
    flex: 1
  };
  var _convertToUnit = function _convertToUnit2(target, property, value, unit) {
    var curValue = parseFloat(value) || 0, curUnit = (value + "").trim().substr((curValue + "").length) || "px", style = _tempDiv.style, horizontal = _horizontalExp.test(property), isRootSVG = target.tagName.toLowerCase() === "svg", measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"), amount = 100, toPixels = unit === "px", toPercent = unit === "%", px, parent2, cache, isSVG;
    if (unit === curUnit || !curValue || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
      return curValue;
    }
    curUnit !== "px" && !toPixels && (curValue = _convertToUnit2(target, property, value, "px"));
    isSVG = target.getCTM && _isSVG(target);
    if ((toPercent || curUnit === "%") && (_transformProps[property] || ~property.indexOf("adius"))) {
      px = isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty];
      return _round(toPercent ? curValue / px * amount : curValue / 100 * px);
    }
    style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
    parent2 = unit !== "rem" && ~property.indexOf("adius") || unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;
    if (isSVG) {
      parent2 = (target.ownerSVGElement || {}).parentNode;
    }
    if (!parent2 || parent2 === _doc2 || !parent2.appendChild) {
      parent2 = _doc2.body;
    }
    cache = parent2._gsap;
    if (cache && toPercent && cache.width && horizontal && cache.time === _ticker.time && !cache.uncache) {
      return _round(curValue / cache.width * amount);
    } else {
      if (toPercent && (property === "height" || property === "width")) {
        var v2 = target.style[property];
        target.style[property] = amount + unit;
        px = target[measureProperty];
        v2 ? target.style[property] = v2 : _removeProperty(target, property);
      } else {
        (toPercent || curUnit === "%") && !_nonStandardLayouts[_getComputedProperty(parent2, "display")] && (style.position = _getComputedProperty(target, "position"));
        parent2 === target && (style.position = "static");
        parent2.appendChild(_tempDiv);
        px = _tempDiv[measureProperty];
        parent2.removeChild(_tempDiv);
        style.position = "absolute";
      }
      if (horizontal && toPercent) {
        cache = _getCache(parent2);
        cache.time = _ticker.time;
        cache.width = parent2[measureProperty];
      }
    }
    return _round(toPixels ? px * curValue / amount : px && curValue ? amount / px * curValue : 0);
  };
  var _get = function _get2(target, property, unit, uncache) {
    var value;
    _pluginInitted || _initCore();
    if (property in _propertyAliases && property !== "transform") {
      property = _propertyAliases[property];
      if (~property.indexOf(",")) {
        property = property.split(",")[0];
      }
    }
    if (_transformProps[property] && property !== "transform") {
      value = _parseTransform(target, uncache);
      value = property !== "transformOrigin" ? value[property] : value.svg ? value.origin : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + " " + value.zOrigin + "px";
    } else {
      value = target.style[property];
      if (!value || value === "auto" || uncache || ~(value + "").indexOf("calc(")) {
        value = _specialProps[property] && _specialProps[property](target, property, unit) || _getComputedProperty(target, property) || _getProperty(target, property) || (property === "opacity" ? 1 : 0);
      }
    }
    return unit && !~(value + "").trim().indexOf(" ") ? _convertToUnit(target, property, value, unit) + unit : value;
  };
  var _tweenComplexCSSString = function _tweenComplexCSSString2(target, prop, start, end) {
    if (!start || start === "none") {
      var p = _checkPropPrefix(prop, target, 1), s = p && _getComputedProperty(target, p, 1);
      if (s && s !== start) {
        prop = p;
        start = s;
      } else if (prop === "borderColor") {
        start = _getComputedProperty(target, "borderTopColor");
      }
    }
    var pt = new PropTween(this._pt, target.style, prop, 0, 1, _renderComplexString), index = 0, matchIndex = 0, a, result, startValues, startNum, color, startValue, endValue, endNum, chunk, endUnit, startUnit, endValues;
    pt.b = start;
    pt.e = end;
    start += "";
    end += "";
    if (end.substring(0, 6) === "var(--") {
      end = _getComputedProperty(target, end.substring(4, end.indexOf(")")));
    }
    if (end === "auto") {
      startValue = target.style[prop];
      target.style[prop] = end;
      end = _getComputedProperty(target, prop) || end;
      startValue ? target.style[prop] = startValue : _removeProperty(target, prop);
    }
    a = [start, end];
    _colorStringFilter(a);
    start = a[0];
    end = a[1];
    startValues = start.match(_numWithUnitExp) || [];
    endValues = end.match(_numWithUnitExp) || [];
    if (endValues.length) {
      while (result = _numWithUnitExp.exec(end)) {
        endValue = result[0];
        chunk = end.substring(index, result.index);
        if (color) {
          color = (color + 1) % 5;
        } else if (chunk.substr(-5) === "rgba(" || chunk.substr(-5) === "hsla(") {
          color = 1;
        }
        if (endValue !== (startValue = startValues[matchIndex++] || "")) {
          startNum = parseFloat(startValue) || 0;
          startUnit = startValue.substr((startNum + "").length);
          endValue.charAt(1) === "=" && (endValue = _parseRelative(startNum, endValue) + startUnit);
          endNum = parseFloat(endValue);
          endUnit = endValue.substr((endNum + "").length);
          index = _numWithUnitExp.lastIndex - endUnit.length;
          if (!endUnit) {
            endUnit = endUnit || _config.units[prop] || startUnit;
            if (index === end.length) {
              end += endUnit;
              pt.e += endUnit;
            }
          }
          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, prop, startValue, endUnit) || 0;
          }
          pt._pt = {
            _next: pt._pt,
            p: chunk || matchIndex === 1 ? chunk : ",",
            //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
            s: startNum,
            c: endNum - startNum,
            m: color && color < 4 || prop === "zIndex" ? Math.round : 0
          };
        }
      }
      pt.c = index < end.length ? end.substring(index, end.length) : "";
    } else {
      pt.r = prop === "display" && end === "none" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
    }
    _relExp.test(end) && (pt.e = 0);
    this._pt = pt;
    return pt;
  };
  var _keywordToPercent = {
    top: "0%",
    bottom: "100%",
    left: "0%",
    right: "100%",
    center: "50%"
  };
  var _convertKeywordsToPercentages = function _convertKeywordsToPercentages2(value) {
    var split = value.split(" "), x = split[0], y = split[1] || "50%";
    if (x === "top" || x === "bottom" || y === "left" || y === "right") {
      value = x;
      x = y;
      y = value;
    }
    split[0] = _keywordToPercent[x] || x;
    split[1] = _keywordToPercent[y] || y;
    return split.join(" ");
  };
  var _renderClearProps = function _renderClearProps2(ratio, data) {
    if (data.tween && data.tween._time === data.tween._dur) {
      var target = data.t, style = target.style, props = data.u, cache = target._gsap, prop, clearTransforms, i;
      if (props === "all" || props === true) {
        style.cssText = "";
        clearTransforms = 1;
      } else {
        props = props.split(",");
        i = props.length;
        while (--i > -1) {
          prop = props[i];
          if (_transformProps[prop]) {
            clearTransforms = 1;
            prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
          }
          _removeProperty(target, prop);
        }
      }
      if (clearTransforms) {
        _removeProperty(target, _transformProp);
        if (cache) {
          cache.svg && target.removeAttribute("transform");
          style.scale = style.rotate = style.translate = "none";
          _parseTransform(target, 1);
          cache.uncache = 1;
          _removeIndependentTransforms(style);
        }
      }
    }
  };
  var _specialProps = {
    clearProps: function clearProps(plugin, target, property, endValue, tween) {
      if (tween.data !== "isFromStart") {
        var pt = plugin._pt = new PropTween(plugin._pt, target, property, 0, 0, _renderClearProps);
        pt.u = endValue;
        pt.pr = -10;
        pt.tween = tween;
        plugin._props.push(property);
        return 1;
      }
    }
    /* className feature (about 0.4kb gzipped).
    , className(plugin, target, property, endValue, tween) {
    	let _renderClassName = (ratio, data) => {
    			data.css.render(ratio, data.css);
    			if (!ratio || ratio === 1) {
    				let inline = data.rmv,
    					target = data.t,
    					p;
    				target.setAttribute("class", ratio ? data.e : data.b);
    				for (p in inline) {
    					_removeProperty(target, p);
    				}
    			}
    		},
    		_getAllStyles = (target) => {
    			let styles = {},
    				computed = getComputedStyle(target),
    				p;
    			for (p in computed) {
    				if (isNaN(p) && p !== "cssText" && p !== "length") {
    					styles[p] = computed[p];
    				}
    			}
    			_setDefaults(styles, _parseTransform(target, 1));
    			return styles;
    		},
    		startClassList = target.getAttribute("class"),
    		style = target.style,
    		cssText = style.cssText,
    		cache = target._gsap,
    		classPT = cache.classPT,
    		inlineToRemoveAtEnd = {},
    		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
    		changingVars = {},
    		startVars = _getAllStyles(target),
    		transformRelated = /(transform|perspective)/i,
    		endVars, p;
    	if (classPT) {
    		classPT.r(1, classPT.d);
    		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
    	}
    	target.setAttribute("class", data.e);
    	endVars = _getAllStyles(target, true);
    	target.setAttribute("class", startClassList);
    	for (p in endVars) {
    		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
    			changingVars[p] = endVars[p];
    			if (!style[p] && style[p] !== "0") {
    				inlineToRemoveAtEnd[p] = 1;
    			}
    		}
    	}
    	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
    	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://gsap.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
    		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
    	}
    	_parseTransform(target, true); //to clear the caching of transforms
    	data.css = new gsap.plugins.css();
    	data.css.init(target, changingVars, tween);
    	plugin._props.push(...data.css._props);
    	return 1;
    }
    */
  };
  var _identity2DMatrix = [1, 0, 0, 1, 0, 0];
  var _rotationalProperties = {};
  var _isNullTransform = function _isNullTransform2(value) {
    return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
  };
  var _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray2(target) {
    var matrixString = _getComputedProperty(target, _transformProp);
    return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_numExp).map(_round);
  };
  var _getMatrix = function _getMatrix2(target, force2D) {
    var cache = target._gsap || _getCache(target), style = target.style, matrix = _getComputedTransformMatrixAsArray(target), parent2, nextSibling, temp, addedToDOM;
    if (cache.svg && target.getAttribute("transform")) {
      temp = target.transform.baseVal.consolidate().matrix;
      matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
      return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
    } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
      temp = style.display;
      style.display = "block";
      parent2 = target.parentNode;
      if (!parent2 || !target.offsetParent && !target.getBoundingClientRect().width) {
        addedToDOM = 1;
        nextSibling = target.nextElementSibling;
        _docElement.appendChild(target);
      }
      matrix = _getComputedTransformMatrixAsArray(target);
      temp ? style.display = temp : _removeProperty(target, "display");
      if (addedToDOM) {
        nextSibling ? parent2.insertBefore(target, nextSibling) : parent2 ? parent2.appendChild(target) : _docElement.removeChild(target);
      }
    }
    return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
  };
  var _applySVGOrigin = function _applySVGOrigin2(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
    var cache = target._gsap, matrix = matrixArray || _getMatrix(target, true), xOriginOld = cache.xOrigin || 0, yOriginOld = cache.yOrigin || 0, xOffsetOld = cache.xOffset || 0, yOffsetOld = cache.yOffset || 0, a = matrix[0], b = matrix[1], c = matrix[2], d = matrix[3], tx = matrix[4], ty = matrix[5], originSplit = origin.split(" "), xOrigin = parseFloat(originSplit[0]) || 0, yOrigin = parseFloat(originSplit[1]) || 0, bounds, determinant, x, y;
    if (!originIsAbsolute) {
      bounds = _getBBox(target);
      xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
      yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
    } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
      x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
      y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
      xOrigin = x;
      yOrigin = y;
    }
    if (smooth || smooth !== false && cache.smooth) {
      tx = xOrigin - xOriginOld;
      ty = yOrigin - yOriginOld;
      cache.xOffset = xOffsetOld + (tx * a + ty * c) - tx;
      cache.yOffset = yOffsetOld + (tx * b + ty * d) - ty;
    } else {
      cache.xOffset = cache.yOffset = 0;
    }
    cache.xOrigin = xOrigin;
    cache.yOrigin = yOrigin;
    cache.smooth = !!smooth;
    cache.origin = origin;
    cache.originIsAbsolute = !!originIsAbsolute;
    target.style[_transformOriginProp] = "0px 0px";
    if (pluginToAddPropTweensTo) {
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);
      _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
    }
    target.setAttribute("data-svg-origin", xOrigin + " " + yOrigin);
  };
  var _parseTransform = function _parseTransform2(target, uncache) {
    var cache = target._gsap || new GSCache(target);
    if ("x" in cache && !uncache && !cache.uncache) {
      return cache;
    }
    var style = target.style, invertedScaleX = cache.scaleX < 0, px = "px", deg = "deg", cs = getComputedStyle(target), origin = _getComputedProperty(target, _transformOriginProp) || "0", x, y, z, scaleX, scaleY, rotation, rotationX, rotationY, skewX, skewY, perspective, xOrigin, yOrigin, matrix, angle, cos, sin, a, b, c, d, a12, a22, t1, t2, t3, a13, a23, a33, a42, a43, a32;
    x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
    scaleX = scaleY = 1;
    cache.svg = !!(target.getCTM && _isSVG(target));
    if (cs.translate) {
      if (cs.translate !== "none" || cs.scale !== "none" || cs.rotate !== "none") {
        style[_transformProp] = (cs.translate !== "none" ? "translate3d(" + (cs.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (cs.rotate !== "none" ? "rotate(" + cs.rotate + ") " : "") + (cs.scale !== "none" ? "scale(" + cs.scale.split(" ").join(",") + ") " : "") + (cs[_transformProp] !== "none" ? cs[_transformProp] : "");
      }
      style.scale = style.rotate = style.translate = "none";
    }
    matrix = _getMatrix(target, cache.svg);
    if (cache.svg) {
      if (cache.uncache) {
        t2 = target.getBBox();
        origin = cache.xOrigin - t2.x + "px " + (cache.yOrigin - t2.y) + "px";
        t1 = "";
      } else {
        t1 = !uncache && target.getAttribute("data-svg-origin");
      }
      _applySVGOrigin(target, t1 || origin, !!t1 || cache.originIsAbsolute, cache.smooth !== false, matrix);
    }
    xOrigin = cache.xOrigin || 0;
    yOrigin = cache.yOrigin || 0;
    if (matrix !== _identity2DMatrix) {
      a = matrix[0];
      b = matrix[1];
      c = matrix[2];
      d = matrix[3];
      x = a12 = matrix[4];
      y = a22 = matrix[5];
      if (matrix.length === 6) {
        scaleX = Math.sqrt(a * a + b * b);
        scaleY = Math.sqrt(d * d + c * c);
        rotation = a || b ? _atan2(b, a) * _RAD2DEG : 0;
        skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : 0;
        skewX && (scaleY *= Math.abs(Math.cos(skewX * _DEG2RAD)));
        if (cache.svg) {
          x -= xOrigin - (xOrigin * a + yOrigin * c);
          y -= yOrigin - (xOrigin * b + yOrigin * d);
        }
      } else {
        a32 = matrix[6];
        a42 = matrix[7];
        a13 = matrix[8];
        a23 = matrix[9];
        a33 = matrix[10];
        a43 = matrix[11];
        x = matrix[12];
        y = matrix[13];
        z = matrix[14];
        angle = _atan2(a32, a33);
        rotationX = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
        }
        angle = _atan2(-c, a33);
        rotationY = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(-angle);
          sin = Math.sin(-angle);
          t1 = a * cos - a13 * sin;
          t2 = b * cos - a23 * sin;
          t3 = c * cos - a33 * sin;
          a43 = d * sin + a43 * cos;
          a = t1;
          b = t2;
          c = t3;
        }
        angle = _atan2(b, a);
        rotation = angle * _RAD2DEG;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a * cos + b * sin;
          t2 = a12 * cos + a22 * sin;
          b = b * cos - a * sin;
          a22 = a22 * cos - a12 * sin;
          a = t1;
          a12 = t2;
        }
        if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
          rotationX = rotation = 0;
          rotationY = 180 - rotationY;
        }
        scaleX = _round(Math.sqrt(a * a + b * b + c * c));
        scaleY = _round(Math.sqrt(a22 * a22 + a32 * a32));
        angle = _atan2(a12, a22);
        skewX = Math.abs(angle) > 2e-4 ? angle * _RAD2DEG : 0;
        perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
      }
      if (cache.svg) {
        t1 = target.getAttribute("transform");
        cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
        t1 && target.setAttribute("transform", t1);
      }
    }
    if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
      if (invertedScaleX) {
        scaleX *= -1;
        skewX += rotation <= 0 ? 180 : -180;
        rotation += rotation <= 0 ? 180 : -180;
      } else {
        scaleY *= -1;
        skewX += skewX <= 0 ? 180 : -180;
      }
    }
    uncache = uncache || cache.uncache;
    cache.x = x - ((cache.xPercent = x && (!uncache && cache.xPercent || (Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0))) ? target.offsetWidth * cache.xPercent / 100 : 0) + px;
    cache.y = y - ((cache.yPercent = y && (!uncache && cache.yPercent || (Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0))) ? target.offsetHeight * cache.yPercent / 100 : 0) + px;
    cache.z = z + px;
    cache.scaleX = _round(scaleX);
    cache.scaleY = _round(scaleY);
    cache.rotation = _round(rotation) + deg;
    cache.rotationX = _round(rotationX) + deg;
    cache.rotationY = _round(rotationY) + deg;
    cache.skewX = skewX + deg;
    cache.skewY = skewY + deg;
    cache.transformPerspective = perspective + px;
    if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || !uncache && cache.zOrigin || 0) {
      style[_transformOriginProp] = _firstTwoOnly(origin);
    }
    cache.xOffset = cache.yOffset = 0;
    cache.force3D = _config.force3D;
    cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
    cache.uncache = 0;
    return cache;
  };
  var _firstTwoOnly = function _firstTwoOnly2(value) {
    return (value = value.split(" "))[0] + " " + value[1];
  };
  var _addPxTranslate = function _addPxTranslate2(target, start, value) {
    var unit = getUnit(start);
    return _round(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
  };
  var _renderNon3DTransforms = function _renderNon3DTransforms2(ratio, cache) {
    cache.z = "0px";
    cache.rotationY = cache.rotationX = "0deg";
    cache.force3D = 0;
    _renderCSSTransforms(ratio, cache);
  };
  var _zeroDeg = "0deg";
  var _zeroPx = "0px";
  var _endParenthesis = ") ";
  var _renderCSSTransforms = function _renderCSSTransforms2(ratio, cache) {
    var _ref = cache || this, xPercent = _ref.xPercent, yPercent = _ref.yPercent, x = _ref.x, y = _ref.y, z = _ref.z, rotation = _ref.rotation, rotationY = _ref.rotationY, rotationX = _ref.rotationX, skewX = _ref.skewX, skewY = _ref.skewY, scaleX = _ref.scaleX, scaleY = _ref.scaleY, transformPerspective = _ref.transformPerspective, force3D = _ref.force3D, target = _ref.target, zOrigin = _ref.zOrigin, transforms = "", use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true;
    if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
      var angle = parseFloat(rotationY) * _DEG2RAD, a13 = Math.sin(angle), a33 = Math.cos(angle), cos;
      angle = parseFloat(rotationX) * _DEG2RAD;
      cos = Math.cos(angle);
      x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
      y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
      z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
    }
    if (transformPerspective !== _zeroPx) {
      transforms += "perspective(" + transformPerspective + _endParenthesis;
    }
    if (xPercent || yPercent) {
      transforms += "translate(" + xPercent + "%, " + yPercent + "%) ";
    }
    if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
      transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
    }
    if (rotation !== _zeroDeg) {
      transforms += "rotate(" + rotation + _endParenthesis;
    }
    if (rotationY !== _zeroDeg) {
      transforms += "rotateY(" + rotationY + _endParenthesis;
    }
    if (rotationX !== _zeroDeg) {
      transforms += "rotateX(" + rotationX + _endParenthesis;
    }
    if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
      transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
    }
    if (scaleX !== 1 || scaleY !== 1) {
      transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
    }
    target.style[_transformProp] = transforms || "translate(0, 0)";
  };
  var _renderSVGTransforms = function _renderSVGTransforms2(ratio, cache) {
    var _ref2 = cache || this, xPercent = _ref2.xPercent, yPercent = _ref2.yPercent, x = _ref2.x, y = _ref2.y, rotation = _ref2.rotation, skewX = _ref2.skewX, skewY = _ref2.skewY, scaleX = _ref2.scaleX, scaleY = _ref2.scaleY, target = _ref2.target, xOrigin = _ref2.xOrigin, yOrigin = _ref2.yOrigin, xOffset = _ref2.xOffset, yOffset = _ref2.yOffset, forceCSS = _ref2.forceCSS, tx = parseFloat(x), ty = parseFloat(y), a11, a21, a12, a22, temp;
    rotation = parseFloat(rotation);
    skewX = parseFloat(skewX);
    skewY = parseFloat(skewY);
    if (skewY) {
      skewY = parseFloat(skewY);
      skewX += skewY;
      rotation += skewY;
    }
    if (rotation || skewX) {
      rotation *= _DEG2RAD;
      skewX *= _DEG2RAD;
      a11 = Math.cos(rotation) * scaleX;
      a21 = Math.sin(rotation) * scaleX;
      a12 = Math.sin(rotation - skewX) * -scaleY;
      a22 = Math.cos(rotation - skewX) * scaleY;
      if (skewX) {
        skewY *= _DEG2RAD;
        temp = Math.tan(skewX - skewY);
        temp = Math.sqrt(1 + temp * temp);
        a12 *= temp;
        a22 *= temp;
        if (skewY) {
          temp = Math.tan(skewY);
          temp = Math.sqrt(1 + temp * temp);
          a11 *= temp;
          a21 *= temp;
        }
      }
      a11 = _round(a11);
      a21 = _round(a21);
      a12 = _round(a12);
      a22 = _round(a22);
    } else {
      a11 = scaleX;
      a22 = scaleY;
      a21 = a12 = 0;
    }
    if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
      tx = _convertToUnit(target, "x", x, "px");
      ty = _convertToUnit(target, "y", y, "px");
    }
    if (xOrigin || yOrigin || xOffset || yOffset) {
      tx = _round(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
      ty = _round(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
    }
    if (xPercent || yPercent) {
      temp = target.getBBox();
      tx = _round(tx + xPercent / 100 * temp.width);
      ty = _round(ty + yPercent / 100 * temp.height);
    }
    temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
    target.setAttribute("transform", temp);
    forceCSS && (target.style[_transformProp] = temp);
  };
  var _addRotationalPropTween = function _addRotationalPropTween2(plugin, target, property, startNum, endValue) {
    var cap = 360, isString = _isString(endValue), endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1), change = endNum - startNum, finalValue = startNum + change + "deg", direction, pt;
    if (isString) {
      direction = endValue.split("_")[1];
      if (direction === "short") {
        change %= cap;
        if (change !== change % (cap / 2)) {
          change += change < 0 ? cap : -cap;
        }
      }
      if (direction === "cw" && change < 0) {
        change = (change + cap * _bigNum2) % cap - ~~(change / cap) * cap;
      } else if (direction === "ccw" && change > 0) {
        change = (change - cap * _bigNum2) % cap - ~~(change / cap) * cap;
      }
    }
    plugin._pt = pt = new PropTween(plugin._pt, target, property, startNum, change, _renderPropWithEnd);
    pt.e = finalValue;
    pt.u = "deg";
    plugin._props.push(property);
    return pt;
  };
  var _assign = function _assign2(target, source) {
    for (var p in source) {
      target[p] = source[p];
    }
    return target;
  };
  var _addRawTransformPTs = function _addRawTransformPTs2(plugin, transforms, target) {
    var startCache = _assign({}, target._gsap), exclude = "perspective,force3D,transformOrigin,svgOrigin", style = target.style, endCache, p, startValue, endValue, startNum, endNum, startUnit, endUnit;
    if (startCache.svg) {
      startValue = target.getAttribute("transform");
      target.setAttribute("transform", "");
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      _removeProperty(target, _transformProp);
      target.setAttribute("transform", startValue);
    } else {
      startValue = getComputedStyle(target)[_transformProp];
      style[_transformProp] = transforms;
      endCache = _parseTransform(target, 1);
      style[_transformProp] = startValue;
    }
    for (p in _transformProps) {
      startValue = startCache[p];
      endValue = endCache[p];
      if (startValue !== endValue && exclude.indexOf(p) < 0) {
        startUnit = getUnit(startValue);
        endUnit = getUnit(endValue);
        startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
        endNum = parseFloat(endValue);
        plugin._pt = new PropTween(plugin._pt, endCache, p, startNum, endNum - startNum, _renderCSSProp);
        plugin._pt.u = endUnit || 0;
        plugin._props.push(p);
      }
    }
    _assign(endCache, startCache);
  };
  _forEachName("padding,margin,Width,Radius", function(name, index) {
    var t = "Top", r = "Right", b = "Bottom", l = "Left", props = (index < 3 ? [t, r, b, l] : [t + l, t + r, b + r, b + l]).map(function(side) {
      return index < 2 ? name + side : "border" + side + name;
    });
    _specialProps[index > 1 ? "border" + name : name] = function(plugin, target, property, endValue, tween) {
      var a, vars;
      if (arguments.length < 4) {
        a = props.map(function(prop) {
          return _get(plugin, prop, property);
        });
        vars = a.join(" ");
        return vars.split(a[0]).length === 5 ? a[0] : vars;
      }
      a = (endValue + "").split(" ");
      vars = {};
      props.forEach(function(prop, i) {
        return vars[prop] = a[i] = a[i] || a[(i - 1) / 2 | 0];
      });
      plugin.init(target, vars, tween);
    };
  });
  var CSSPlugin = {
    name: "css",
    register: _initCore,
    targetTest: function targetTest(target) {
      return target.style && target.nodeType;
    },
    init: function init3(target, vars, tween, index, targets) {
      var props = this._props, style = target.style, startAt = tween.vars.startAt, startValue, endValue, endNum, startNum, type, specialProp, p, startUnit, endUnit, relative, isTransformRelated, transformPropTween, cache, smooth, hasPriority, inlineProps;
      _pluginInitted || _initCore();
      this.styles = this.styles || _getStyleSaver(target);
      inlineProps = this.styles.props;
      this.tween = tween;
      for (p in vars) {
        if (p === "autoRound") {
          continue;
        }
        endValue = vars[p];
        if (_plugins[p] && _checkPlugin(p, vars, tween, index, target, targets)) {
          continue;
        }
        type = typeof endValue;
        specialProp = _specialProps[p];
        if (type === "function") {
          endValue = endValue.call(tween, index, target, targets);
          type = typeof endValue;
        }
        if (type === "string" && ~endValue.indexOf("random(")) {
          endValue = _replaceRandom(endValue);
        }
        if (specialProp) {
          specialProp(this, target, p, endValue, tween) && (hasPriority = 1);
        } else if (p.substr(0, 2) === "--") {
          startValue = (getComputedStyle(target).getPropertyValue(p) + "").trim();
          endValue += "";
          _colorExp.lastIndex = 0;
          if (!_colorExp.test(startValue)) {
            startUnit = getUnit(startValue);
            endUnit = getUnit(endValue);
          }
          endUnit ? startUnit !== endUnit && (startValue = _convertToUnit(target, p, startValue, endUnit) + endUnit) : startUnit && (endValue += startUnit);
          this.add(style, "setProperty", startValue, endValue, index, targets, 0, 0, p);
          props.push(p);
          inlineProps.push(p, 0, style[p]);
        } else if (type !== "undefined") {
          if (startAt && p in startAt) {
            startValue = typeof startAt[p] === "function" ? startAt[p].call(tween, index, target, targets) : startAt[p];
            _isString(startValue) && ~startValue.indexOf("random(") && (startValue = _replaceRandom(startValue));
            getUnit(startValue + "") || startValue === "auto" || (startValue += _config.units[p] || getUnit(_get(target, p)) || "");
            (startValue + "").charAt(1) === "=" && (startValue = _get(target, p));
          } else {
            startValue = _get(target, p);
          }
          startNum = parseFloat(startValue);
          relative = type === "string" && endValue.charAt(1) === "=" && endValue.substr(0, 2);
          relative && (endValue = endValue.substr(2));
          endNum = parseFloat(endValue);
          if (p in _propertyAliases) {
            if (p === "autoAlpha") {
              if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
                startNum = 0;
              }
              inlineProps.push("visibility", 0, style.visibility);
              _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
            }
            if (p !== "scale" && p !== "transform") {
              p = _propertyAliases[p];
              ~p.indexOf(",") && (p = p.split(",")[0]);
            }
          }
          isTransformRelated = p in _transformProps;
          if (isTransformRelated) {
            this.styles.save(p);
            if (type === "string" && endValue.substring(0, 6) === "var(--") {
              endValue = _getComputedProperty(target, endValue.substring(4, endValue.indexOf(")")));
              endNum = parseFloat(endValue);
            }
            if (!transformPropTween) {
              cache = target._gsap;
              cache.renderTransform && !vars.parseTransform || _parseTransform(target, vars.parseTransform);
              smooth = vars.smoothOrigin !== false && cache.smooth;
              transformPropTween = this._pt = new PropTween(this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache, 0, -1);
              transformPropTween.dep = 1;
            }
            if (p === "scale") {
              this._pt = new PropTween(this._pt, cache, "scaleY", cache.scaleY, (relative ? _parseRelative(cache.scaleY, relative + endNum) : endNum) - cache.scaleY || 0, _renderCSSProp);
              this._pt.u = 0;
              props.push("scaleY", p);
              p += "X";
            } else if (p === "transformOrigin") {
              inlineProps.push(_transformOriginProp, 0, style[_transformOriginProp]);
              endValue = _convertKeywordsToPercentages(endValue);
              if (cache.svg) {
                _applySVGOrigin(target, endValue, 0, smooth, 0, this);
              } else {
                endUnit = parseFloat(endValue.split(" ")[2]) || 0;
                endUnit !== cache.zOrigin && _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
                _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
              }
              continue;
            } else if (p === "svgOrigin") {
              _applySVGOrigin(target, endValue, 1, smooth, 0, this);
              continue;
            } else if (p in _rotationalProperties) {
              _addRotationalPropTween(this, cache, p, startNum, relative ? _parseRelative(startNum, relative + endValue) : endValue);
              continue;
            } else if (p === "smoothOrigin") {
              _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);
              continue;
            } else if (p === "force3D") {
              cache[p] = endValue;
              continue;
            } else if (p === "transform") {
              _addRawTransformPTs(this, endValue, target);
              continue;
            }
          } else if (!(p in style)) {
            p = _checkPropPrefix(p) || p;
          }
          if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
            startUnit = (startValue + "").substr((startNum + "").length);
            endNum || (endNum = 0);
            endUnit = getUnit(endValue) || (p in _config.units ? _config.units[p] : startUnit);
            startUnit !== endUnit && (startNum = _convertToUnit(target, p, startValue, endUnit));
            this._pt = new PropTween(this._pt, isTransformRelated ? cache : style, p, startNum, (relative ? _parseRelative(startNum, relative + endNum) : endNum) - startNum, !isTransformRelated && (endUnit === "px" || p === "zIndex") && vars.autoRound !== false ? _renderRoundedCSSProp : _renderCSSProp);
            this._pt.u = endUnit || 0;
            if (startUnit !== endUnit && endUnit !== "%") {
              this._pt.b = startValue;
              this._pt.r = _renderCSSPropWithBeginning;
            }
          } else if (!(p in style)) {
            if (p in target) {
              this.add(target, p, startValue || target[p], relative ? relative + endValue : endValue, index, targets);
            } else if (p !== "parseTransform") {
              _missingPlugin(p, endValue);
              continue;
            }
          } else {
            _tweenComplexCSSString.call(this, target, p, startValue, relative ? relative + endValue : endValue);
          }
          isTransformRelated || (p in style ? inlineProps.push(p, 0, style[p]) : typeof target[p] === "function" ? inlineProps.push(p, 2, target[p]()) : inlineProps.push(p, 1, startValue || target[p]));
          props.push(p);
        }
      }
      hasPriority && _sortPropTweensByPriority(this);
    },
    render: function render2(ratio, data) {
      if (data.tween._time || !_reverting2()) {
        var pt = data._pt;
        while (pt) {
          pt.r(ratio, pt.d);
          pt = pt._next;
        }
      } else {
        data.styles.revert();
      }
    },
    get: _get,
    aliases: _propertyAliases,
    getSetter: function getSetter(target, property, plugin) {
      var p = _propertyAliases[property];
      p && p.indexOf(",") < 0 && (property = p);
      return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !_isUndefined(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : _getSetter(target, property);
    },
    core: {
      _removeProperty,
      _getMatrix
    }
  };
  gsap.utils.checkPrefix = _checkPropPrefix;
  gsap.core.getStyleSaver = _getStyleSaver;
  (function(positionAndScale, rotation, others, aliases) {
    var all = _forEachName(positionAndScale + "," + rotation + "," + others, function(name) {
      _transformProps[name] = 1;
    });
    _forEachName(rotation, function(name) {
      _config.units[name] = "deg";
      _rotationalProperties[name] = 1;
    });
    _propertyAliases[all[13]] = positionAndScale + "," + rotation;
    _forEachName(aliases, function(name) {
      var split = name.split(":");
      _propertyAliases[split[1]] = all[split[0]];
    });
  })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
  _forEachName("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(name) {
    _config.units[name] = "px";
  });
  gsap.registerPlugin(CSSPlugin);

  // node_modules/gsap/index.js
  var gsapWithCSS = gsap.registerPlugin(CSSPlugin) || gsap;
  var TweenMaxWithCSS = gsapWithCSS.core.Tween;

  // node_modules/gsap/ScrollToPlugin.js
  init_live_reload();
  var gsap2;
  var _coreInitted2;
  var _window;
  var _docEl;
  var _body;
  var _toArray;
  var _config2;
  var ScrollTrigger;
  var _windowExists5 = function _windowExists6() {
    return typeof window !== "undefined";
  };
  var _getGSAP = function _getGSAP2() {
    return gsap2 || _windowExists5() && (gsap2 = window.gsap) && gsap2.registerPlugin && gsap2;
  };
  var _isString3 = function _isString4(value) {
    return typeof value === "string";
  };
  var _isFunction3 = function _isFunction4(value) {
    return typeof value === "function";
  };
  var _max = function _max2(element, axis) {
    var dim = axis === "x" ? "Width" : "Height", scroll = "scroll" + dim, client = "client" + dim;
    return element === _window || element === _docEl || element === _body ? Math.max(_docEl[scroll], _body[scroll]) - (_window["inner" + dim] || _docEl[client] || _body[client]) : element[scroll] - element["offset" + dim];
  };
  var _buildGetter = function _buildGetter2(e, axis) {
    var p = "scroll" + (axis === "x" ? "Left" : "Top");
    if (e === _window) {
      if (e.pageXOffset != null) {
        p = "page" + axis.toUpperCase() + "Offset";
      } else {
        e = _docEl[p] != null ? _docEl : _body;
      }
    }
    return function() {
      return e[p];
    };
  };
  var _clean = function _clean2(value, index, target, targets) {
    _isFunction3(value) && (value = value(index, target, targets));
    if (typeof value !== "object") {
      return _isString3(value) && value !== "max" && value.charAt(1) !== "=" ? {
        x: value,
        y: value
      } : {
        y: value
      };
    } else if (value.nodeType) {
      return {
        y: value,
        x: value
      };
    } else {
      var result = {}, p;
      for (p in value) {
        result[p] = p !== "onAutoKill" && _isFunction3(value[p]) ? value[p](index, target, targets) : value[p];
      }
      return result;
    }
  };
  var _getOffset = function _getOffset2(element, container) {
    element = _toArray(element)[0];
    if (!element || !element.getBoundingClientRect) {
      return console.warn("scrollTo target doesn't exist. Using 0") || {
        x: 0,
        y: 0
      };
    }
    var rect = element.getBoundingClientRect(), isRoot = !container || container === _window || container === _body, cRect = isRoot ? {
      top: _docEl.clientTop - (_window.pageYOffset || _docEl.scrollTop || _body.scrollTop || 0),
      left: _docEl.clientLeft - (_window.pageXOffset || _docEl.scrollLeft || _body.scrollLeft || 0)
    } : container.getBoundingClientRect(), offsets = {
      x: rect.left - cRect.left,
      y: rect.top - cRect.top
    };
    if (!isRoot && container) {
      offsets.x += _buildGetter(container, "x")();
      offsets.y += _buildGetter(container, "y")();
    }
    return offsets;
  };
  var _parseVal = function _parseVal2(value, target, axis, currentVal, offset) {
    return !isNaN(value) && typeof value !== "object" ? parseFloat(value) - offset : _isString3(value) && value.charAt(1) === "=" ? parseFloat(value.substr(2)) * (value.charAt(0) === "-" ? -1 : 1) + currentVal - offset : value === "max" ? _max(target, axis) - offset : Math.min(_max(target, axis), _getOffset(value, target)[axis] - offset);
  };
  var _initCore3 = function _initCore4() {
    gsap2 = _getGSAP();
    if (_windowExists5() && gsap2 && typeof document !== "undefined" && document.body) {
      _window = window;
      _body = document.body;
      _docEl = document.documentElement;
      _toArray = gsap2.utils.toArray;
      gsap2.config({
        autoKillThreshold: 7
      });
      _config2 = gsap2.config();
      _coreInitted2 = 1;
    }
  };
  var ScrollToPlugin = {
    version: "3.13.0",
    name: "scrollTo",
    rawVars: 1,
    register: function register(core) {
      gsap2 = core;
      _initCore3();
    },
    init: function init4(target, value, tween, index, targets) {
      _coreInitted2 || _initCore3();
      var data = this, snapType = gsap2.getProperty(target, "scrollSnapType");
      data.isWin = target === _window;
      data.target = target;
      data.tween = tween;
      value = _clean(value, index, target, targets);
      data.vars = value;
      data.autoKill = !!("autoKill" in value ? value : _config2).autoKill;
      data.getX = _buildGetter(target, "x");
      data.getY = _buildGetter(target, "y");
      data.x = data.xPrev = data.getX();
      data.y = data.yPrev = data.getY();
      ScrollTrigger || (ScrollTrigger = gsap2.core.globals().ScrollTrigger);
      gsap2.getProperty(target, "scrollBehavior") === "smooth" && gsap2.set(target, {
        scrollBehavior: "auto"
      });
      if (snapType && snapType !== "none") {
        data.snap = 1;
        data.snapInline = target.style.scrollSnapType;
        target.style.scrollSnapType = "none";
      }
      if (value.x != null) {
        data.add(data, "x", data.x, _parseVal(value.x, target, "x", data.x, value.offsetX || 0), index, targets);
        data._props.push("scrollTo_x");
      } else {
        data.skipX = 1;
      }
      if (value.y != null) {
        data.add(data, "y", data.y, _parseVal(value.y, target, "y", data.y, value.offsetY || 0), index, targets);
        data._props.push("scrollTo_y");
      } else {
        data.skipY = 1;
      }
    },
    render: function render3(ratio, data) {
      var pt = data._pt, target = data.target, tween = data.tween, autoKill = data.autoKill, xPrev = data.xPrev, yPrev = data.yPrev, isWin = data.isWin, snap3 = data.snap, snapInline = data.snapInline, x, y, yDif, xDif, threshold;
      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }
      x = isWin || !data.skipX ? data.getX() : xPrev;
      y = isWin || !data.skipY ? data.getY() : yPrev;
      yDif = y - yPrev;
      xDif = x - xPrev;
      threshold = _config2.autoKillThreshold;
      if (data.x < 0) {
        data.x = 0;
      }
      if (data.y < 0) {
        data.y = 0;
      }
      if (autoKill) {
        if (!data.skipX && (xDif > threshold || xDif < -threshold) && x < _max(target, "x")) {
          data.skipX = 1;
        }
        if (!data.skipY && (yDif > threshold || yDif < -threshold) && y < _max(target, "y")) {
          data.skipY = 1;
        }
        if (data.skipX && data.skipY) {
          tween.kill();
          data.vars.onAutoKill && data.vars.onAutoKill.apply(tween, data.vars.onAutoKillParams || []);
        }
      }
      if (isWin) {
        _window.scrollTo(!data.skipX ? data.x : x, !data.skipY ? data.y : y);
      } else {
        data.skipY || (target.scrollTop = data.y);
        data.skipX || (target.scrollLeft = data.x);
      }
      if (snap3 && (ratio === 1 || ratio === 0)) {
        y = target.scrollTop;
        x = target.scrollLeft;
        snapInline ? target.style.scrollSnapType = snapInline : target.style.removeProperty("scroll-snap-type");
        target.scrollTop = y + 1;
        target.scrollLeft = x + 1;
        target.scrollTop = y;
        target.scrollLeft = x;
      }
      data.xPrev = data.x;
      data.yPrev = data.y;
      ScrollTrigger && ScrollTrigger.update();
    },
    kill: function kill(property) {
      var both = property === "scrollTo", i = this._props.indexOf(property);
      if (both || property === "scrollTo_x") {
        this.skipX = 1;
      }
      if (both || property === "scrollTo_y") {
        this.skipY = 1;
      }
      i > -1 && this._props.splice(i, 1);
      return !this._props.length;
    }
  };
  ScrollToPlugin.max = _max;
  ScrollToPlugin.getOffset = _getOffset;
  ScrollToPlugin.buildGetter = _buildGetter;
  ScrollToPlugin.config = function(vars) {
    _config2 || _initCore3() || (_config2 = gsap2.config());
    for (var p in vars) {
      _config2[p] = vars[p];
    }
  };
  _getGSAP() && gsap2.registerPlugin(ScrollToPlugin);

  // src/modules/gsap-loader.js
  gsapWithCSS.registerPlugin(ScrollToPlugin);
  window.__GLOBAL_GSAP = gsapWithCSS;
  var gsap3 = window.__GLOBAL_GSAP;

  // src/modules/boundaries.js
  init_live_reload();

  // node_modules/idb-keyval/dist/index.js
  init_live_reload();
  function promisifyRequest(request) {
    return new Promise((resolve, reject) => {
      request.oncomplete = request.onsuccess = () => resolve(request.result);
      request.onabort = request.onerror = () => reject(request.error);
    });
  }
  function createStore2(dbName, storeName) {
    let dbp;
    const getDB = () => {
      if (dbp)
        return dbp;
      const request = indexedDB.open(dbName);
      request.onupgradeneeded = () => request.result.createObjectStore(storeName);
      dbp = promisifyRequest(request);
      dbp.then((db) => {
        db.onclose = () => dbp = void 0;
      }, () => {
      });
      return dbp;
    };
    return (txMode, callback) => getDB().then((db) => callback(db.transaction(storeName, txMode).objectStore(storeName)));
  }
  var defaultGetStoreFunc;
  function defaultGetStore() {
    if (!defaultGetStoreFunc) {
      defaultGetStoreFunc = createStore2("keyval-store", "keyval");
    }
    return defaultGetStoreFunc;
  }
  function get(key, customStore = defaultGetStore()) {
    return customStore("readonly", (store) => promisifyRequest(store.get(key)));
  }
  function set(key, value, customStore = defaultGetStore()) {
    return customStore("readwrite", (store) => {
      store.put(value, key);
      return promisifyRequest(store.transaction);
    });
  }

  // node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js
  init_live_reload();

  // node_modules/point-in-polygon-hao/dist/esm/index.js
  init_live_reload();

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/index.js
  init_live_reload();

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/orient2d.js
  init_live_reload();

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/util.js
  init_live_reload();
  var epsilon = 11102230246251565e-32;
  var splitter = 134217729;
  var resulterrbound = (3 + 8 * epsilon) * epsilon;
  function sum(elen, e, flen, f, h) {
    let Q, Qnew, hh, bvirt;
    let enow = e[0];
    let fnow = f[0];
    let eindex = 0;
    let findex = 0;
    if (fnow > enow === fnow > -enow) {
      Q = enow;
      enow = e[++eindex];
    } else {
      Q = fnow;
      fnow = f[++findex];
    }
    let hindex = 0;
    if (eindex < elen && findex < flen) {
      if (fnow > enow === fnow > -enow) {
        Qnew = enow + Q;
        hh = Q - (Qnew - enow);
        enow = e[++eindex];
      } else {
        Qnew = fnow + Q;
        hh = Q - (Qnew - fnow);
        fnow = f[++findex];
      }
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
      while (eindex < elen && findex < flen) {
        if (fnow > enow === fnow > -enow) {
          Qnew = Q + enow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (enow - bvirt);
          enow = e[++eindex];
        } else {
          Qnew = Q + fnow;
          bvirt = Qnew - Q;
          hh = Q - (Qnew - bvirt) + (fnow - bvirt);
          fnow = f[++findex];
        }
        Q = Qnew;
        if (hh !== 0) {
          h[hindex++] = hh;
        }
      }
    }
    while (eindex < elen) {
      Qnew = Q + enow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (enow - bvirt);
      enow = e[++eindex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    while (findex < flen) {
      Qnew = Q + fnow;
      bvirt = Qnew - Q;
      hh = Q - (Qnew - bvirt) + (fnow - bvirt);
      fnow = f[++findex];
      Q = Qnew;
      if (hh !== 0) {
        h[hindex++] = hh;
      }
    }
    if (Q !== 0 || hindex === 0) {
      h[hindex++] = Q;
    }
    return hindex;
  }
  function estimate(elen, e) {
    let Q = e[0];
    for (let i = 1; i < elen; i++) Q += e[i];
    return Q;
  }
  function vec(n) {
    return new Float64Array(n);
  }

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/orient2d.js
  var ccwerrboundA = (3 + 16 * epsilon) * epsilon;
  var ccwerrboundB = (2 + 12 * epsilon) * epsilon;
  var ccwerrboundC = (9 + 64 * epsilon) * epsilon * epsilon;
  var B = vec(4);
  var C1 = vec(8);
  var C2 = vec(12);
  var D = vec(16);
  var u = vec(4);
  function orient2dadapt(ax, ay, bx, by, cx, cy, detsum) {
    let acxtail, acytail, bcxtail, bcytail;
    let bvirt, c, ahi, alo, bhi, blo, _i, _j, _0, s1, s0, t1, t0, u32;
    const acx = ax - cx;
    const bcx = bx - cx;
    const acy = ay - cy;
    const bcy = by - cy;
    s1 = acx * bcy;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcx;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    B[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    B[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    B[2] = _j - (u32 - bvirt) + (_i - bvirt);
    B[3] = u32;
    let det = estimate(4, B);
    let errbound = ccwerrboundB * detsum;
    if (det >= errbound || -det >= errbound) {
      return det;
    }
    bvirt = ax - acx;
    acxtail = ax - (acx + bvirt) + (bvirt - cx);
    bvirt = bx - bcx;
    bcxtail = bx - (bcx + bvirt) + (bvirt - cx);
    bvirt = ay - acy;
    acytail = ay - (acy + bvirt) + (bvirt - cy);
    bvirt = by - bcy;
    bcytail = by - (bcy + bvirt) + (bvirt - cy);
    if (acxtail === 0 && acytail === 0 && bcxtail === 0 && bcytail === 0) {
      return det;
    }
    errbound = ccwerrboundC * detsum + resulterrbound * Math.abs(det);
    det += acx * bcytail + bcy * acxtail - (acy * bcxtail + bcx * acytail);
    if (det >= errbound || -det >= errbound) return det;
    s1 = acxtail * bcy;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcy;
    bhi = c - (c - bcy);
    blo = bcy - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcx;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcx;
    bhi = c - (c - bcx);
    blo = bcx - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C1len = sum(4, B, 4, u, C1);
    s1 = acx * bcytail;
    c = splitter * acx;
    ahi = c - (c - acx);
    alo = acx - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acy * bcxtail;
    c = splitter * acy;
    ahi = c - (c - acy);
    alo = acy - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const C2len = sum(C1len, C1, 4, u, C2);
    s1 = acxtail * bcytail;
    c = splitter * acxtail;
    ahi = c - (c - acxtail);
    alo = acxtail - ahi;
    c = splitter * bcytail;
    bhi = c - (c - bcytail);
    blo = bcytail - bhi;
    s0 = alo * blo - (s1 - ahi * bhi - alo * bhi - ahi * blo);
    t1 = acytail * bcxtail;
    c = splitter * acytail;
    ahi = c - (c - acytail);
    alo = acytail - ahi;
    c = splitter * bcxtail;
    bhi = c - (c - bcxtail);
    blo = bcxtail - bhi;
    t0 = alo * blo - (t1 - ahi * bhi - alo * bhi - ahi * blo);
    _i = s0 - t0;
    bvirt = s0 - _i;
    u[0] = s0 - (_i + bvirt) + (bvirt - t0);
    _j = s1 + _i;
    bvirt = _j - s1;
    _0 = s1 - (_j - bvirt) + (_i - bvirt);
    _i = _0 - t1;
    bvirt = _0 - _i;
    u[1] = _0 - (_i + bvirt) + (bvirt - t1);
    u32 = _j + _i;
    bvirt = u32 - _j;
    u[2] = _j - (u32 - bvirt) + (_i - bvirt);
    u[3] = u32;
    const Dlen = sum(C2len, C2, 4, u, D);
    return D[Dlen - 1];
  }
  function orient2d(ax, ay, bx, by, cx, cy) {
    const detleft = (ay - cy) * (bx - cx);
    const detright = (ax - cx) * (by - cy);
    const det = detleft - detright;
    const detsum = Math.abs(detleft + detright);
    if (Math.abs(det) >= ccwerrboundA * detsum) return det;
    return -orient2dadapt(ax, ay, bx, by, cx, cy, detsum);
  }

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/orient3d.js
  init_live_reload();
  var o3derrboundA = (7 + 56 * epsilon) * epsilon;
  var o3derrboundB = (3 + 28 * epsilon) * epsilon;
  var o3derrboundC = (26 + 288 * epsilon) * epsilon * epsilon;
  var bc = vec(4);
  var ca = vec(4);
  var ab = vec(4);
  var at_b = vec(4);
  var at_c = vec(4);
  var bt_c = vec(4);
  var bt_a = vec(4);
  var ct_a = vec(4);
  var ct_b = vec(4);
  var bct = vec(8);
  var cat = vec(8);
  var abt = vec(8);
  var u2 = vec(4);
  var _8 = vec(8);
  var _8b = vec(8);
  var _16 = vec(8);
  var _12 = vec(12);
  var fin = vec(192);
  var fin2 = vec(192);

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/incircle.js
  init_live_reload();
  var iccerrboundA = (10 + 96 * epsilon) * epsilon;
  var iccerrboundB = (4 + 48 * epsilon) * epsilon;
  var iccerrboundC = (44 + 576 * epsilon) * epsilon * epsilon;
  var bc2 = vec(4);
  var ca2 = vec(4);
  var ab2 = vec(4);
  var aa = vec(4);
  var bb = vec(4);
  var cc = vec(4);
  var u3 = vec(4);
  var v = vec(4);
  var axtbc = vec(8);
  var aytbc = vec(8);
  var bxtca = vec(8);
  var bytca = vec(8);
  var cxtab = vec(8);
  var cytab = vec(8);
  var abt2 = vec(8);
  var bct2 = vec(8);
  var cat2 = vec(8);
  var abtt = vec(4);
  var bctt = vec(4);
  var catt = vec(4);
  var _82 = vec(8);
  var _162 = vec(16);
  var _16b = vec(16);
  var _16c = vec(16);
  var _32 = vec(32);
  var _32b = vec(32);
  var _48 = vec(48);
  var _64 = vec(64);
  var fin3 = vec(1152);
  var fin22 = vec(1152);

  // node_modules/point-in-polygon-hao/node_modules/robust-predicates/esm/insphere.js
  init_live_reload();
  var isperrboundA = (16 + 224 * epsilon) * epsilon;
  var isperrboundB = (5 + 72 * epsilon) * epsilon;
  var isperrboundC = (71 + 1408 * epsilon) * epsilon * epsilon;
  var ab3 = vec(4);
  var bc3 = vec(4);
  var cd = vec(4);
  var de = vec(4);
  var ea = vec(4);
  var ac = vec(4);
  var bd = vec(4);
  var ce = vec(4);
  var da = vec(4);
  var eb = vec(4);
  var abc = vec(24);
  var bcd = vec(24);
  var cde = vec(24);
  var dea = vec(24);
  var eab = vec(24);
  var abd = vec(24);
  var bce = vec(24);
  var cda = vec(24);
  var deb = vec(24);
  var eac = vec(24);
  var adet = vec(1152);
  var bdet = vec(1152);
  var cdet = vec(1152);
  var ddet = vec(1152);
  var edet = vec(1152);
  var abdet = vec(2304);
  var cddet = vec(2304);
  var cdedet = vec(3456);
  var deter = vec(5760);
  var _83 = vec(8);
  var _8b2 = vec(8);
  var _8c = vec(8);
  var _163 = vec(16);
  var _24 = vec(24);
  var _482 = vec(48);
  var _48b = vec(48);
  var _96 = vec(96);
  var _192 = vec(192);
  var _384x = vec(384);
  var _384y = vec(384);
  var _384z = vec(384);
  var _768 = vec(768);
  var xdet = vec(96);
  var ydet = vec(96);
  var zdet = vec(96);
  var fin4 = vec(1152);

  // node_modules/point-in-polygon-hao/dist/esm/index.js
  function pointInPolygon(p, polygon) {
    var i;
    var ii;
    var k = 0;
    var f;
    var u1;
    var v1;
    var u22;
    var v2;
    var currentP;
    var nextP;
    var x = p[0];
    var y = p[1];
    var numContours = polygon.length;
    for (i = 0; i < numContours; i++) {
      ii = 0;
      var contour = polygon[i];
      var contourLen = contour.length - 1;
      currentP = contour[0];
      if (currentP[0] !== contour[contourLen][0] && currentP[1] !== contour[contourLen][1]) {
        throw new Error("First and last coordinates in a ring must be the same");
      }
      u1 = currentP[0] - x;
      v1 = currentP[1] - y;
      for (ii; ii < contourLen; ii++) {
        nextP = contour[ii + 1];
        u22 = nextP[0] - x;
        v2 = nextP[1] - y;
        if (v1 === 0 && v2 === 0) {
          if (u22 <= 0 && u1 >= 0 || u1 <= 0 && u22 >= 0) {
            return 0;
          }
        } else if (v2 >= 0 && v1 <= 0 || v2 <= 0 && v1 >= 0) {
          f = orient2d(u1, u22, v1, v2, 0, 0);
          if (f === 0) {
            return 0;
          }
          if (f > 0 && v2 > 0 && v1 <= 0 || f < 0 && v2 <= 0 && v1 > 0) {
            k++;
          }
        }
        currentP = nextP;
        v1 = v2;
        u1 = u22;
      }
    }
    if (k % 2 === 0) {
      return false;
    }
    return true;
  }

  // node_modules/@turf/invariant/dist/esm/index.js
  init_live_reload();
  function getCoord(coord) {
    if (!coord) {
      throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
      if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
        return [...coord.geometry.coordinates];
      }
      if (coord.type === "Point") {
        return [...coord.coordinates];
      }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
      return [...coord];
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
  }
  function getGeom(geojson) {
    if (geojson.type === "Feature") {
      return geojson.geometry;
    }
    return geojson;
  }

  // node_modules/@turf/boolean-point-in-polygon/dist/esm/index.js
  function booleanPointInPolygon(point2, polygon, options = {}) {
    if (!point2) {
      throw new Error("point is required");
    }
    if (!polygon) {
      throw new Error("polygon is required");
    }
    const pt = getCoord(point2);
    const geom = getGeom(polygon);
    const type = geom.type;
    const bbox2 = polygon.bbox;
    let polys = geom.coordinates;
    if (bbox2 && inBBox(pt, bbox2) === false) {
      return false;
    }
    if (type === "Polygon") {
      polys = [polys];
    }
    let result = false;
    for (var i = 0; i < polys.length; ++i) {
      const polyResult = pointInPolygon(pt, polys[i]);
      if (polyResult === 0) return options.ignoreBoundary ? false : true;
      else if (polyResult) result = true;
    }
    return result;
  }
  function inBBox(pt, bbox2) {
    return bbox2[0] <= pt[0] && bbox2[1] <= pt[1] && bbox2[2] >= pt[0] && bbox2[3] >= pt[1];
  }
  var turf_boolean_point_in_polygon_default = booleanPointInPolygon;

  // src/modules/boundaries.js
  var {
    setIsBoundariesLoaded,
    setBoundaries,
    getIsBoundariesLoaded,
    getWaterBodies,
    getWaterSheds,
    getBoundaries
  } = useDataStore.getState();
  var waterUrls = {
    watershed: {},
    waterbody: {}
  };
  var CACHE_KEY = "boundary-cache";
  var cacheVersion = "1.4.7";
  var localCacheVersion = "1.4.7";
  var baseDelivrUrl = `https://cdn.jsdelivr.net/gh/Qunthunnan/is-it-clean-boundaries@${cacheVersion}`;
  var adminUrls = {
    state: `${baseDelivrUrl}/states.json`,
    county: `${baseDelivrUrl}/counties.json`,
    town: `${baseDelivrUrl}/towns.json`
  };
  async function loadBoundaries() {
    const timer2 = Date.now();
    const watersheds = getWaterSheds();
    const waterbodies = getWaterBodies();
    try {
      const cached = await get(CACHE_KEY);
      if (cached && cached?.ver === cacheVersion && cached?.locVer === localCacheVersion) {
        console.log(`Boundaries loaded from cache in ${Date.now() - timer2} ms`);
        setBoundaries(cached);
        setIsBoundariesLoaded(true);
        return cached;
      }
      for (const watershed of watersheds) {
        waterUrls.watershed[watershed.id] = watershed.boundary ? `${baseDelivrUrl}/${watershed.boundary}` : "";
      }
      for (const waterbody of waterbodies) {
        if (!waterbody.boundaryLakes && !waterbody.boundaryRivers) continue;
        waterUrls.waterbody[waterbody.id] = {
          lakes: waterbody.boundaryLakes ? `${baseDelivrUrl}/${waterbody.boundaryLakes}` : "",
          rivers: waterbody.boundaryRivers ? `${baseDelivrUrl}/${waterbody.boundaryRivers}` : ""
        };
      }
      const data = {
        watershed: {},
        waterbody: {},
        ver: cacheVersion,
        locVer: localCacheVersion
      };
      const adminEntries = Object.entries(adminUrls);
      const watershedsEntries = Object.entries(waterUrls.watershed);
      const waterbodiesEntries = Object.entries(waterUrls.waterbody);
      await Promise.all([
        ...adminEntries.map(async ([key, url]) => {
          const response = await fetch(url, { cache: "no-cache" });
          if (!response.ok) {
            console.error(`Failed to fetch boundary ${key} from ${url}`);
            data[key] = "";
          } else {
            const json = await response.json();
            data[key] = json;
          }
        }),
        ...watershedsEntries.map(async ([key, url]) => {
          if (url) {
            const response = await fetch(url, { cache: "no-cache" });
            if (!response.ok) {
              console.error(`Failed to fetch boundary ${key} from ${url}`);
              data.watershed[key] = "";
            } else {
              const json = await response.json();
              data.watershed[key] = json;
            }
          } else {
            data.watershed[key] = "";
          }
        }),
        ...waterbodiesEntries.map(async ([key, value]) => {
          const lakesUrl = value.lakes;
          const riversUrl = value.rivers;
          const waterbodyValue = {};
          if (lakesUrl) {
            const response = await fetch(lakesUrl, { cache: "no-cache" });
            if (!response.ok) {
              console.error(`Failed to fetch boundary ${key} from ${lakesUrl}`);
              waterbodyValue.lakes = "";
            } else {
              const json = await response.json();
              waterbodyValue.lakes = json;
            }
          } else {
            waterbodyValue.lakes = "";
          }
          if (riversUrl) {
            const response = await fetch(riversUrl, { cache: "no-cache" });
            if (!response.ok) {
              console.error(`Failed to fetch boundary ${key} from ${riversUrl}`);
              waterbodyValue.rivers = "";
            } else {
              const json = await response.json();
              waterbodyValue.rivers = json;
            }
          } else {
            waterbodyValue.rivers = "";
          }
          data.waterbody[key] = waterbodyValue;
        })
      ]);
      await set(CACHE_KEY, data);
      setBoundaries(data);
      setIsBoundariesLoaded(true);
      console.log(`Boundaries fetched and cached in ${Date.now() - timer2} ms`);
      return data;
    } catch (error) {
      console.error("Error loading boundaries:", error);
      throw error;
    }
  }
  function findBoundary({ boundaryType, boundaryId, latitude, longitude }) {
    const isWater = boundaryType === "watershed" || boundaryType === "waterbody";
    console.log(`boundary type: ${boundaryType} boundaryId: ${boundaryId}`);
    const isBoundariesLoaded = getIsBoundariesLoaded();
    if (isBoundariesLoaded) {
      const boundaries = getBoundaries();
      if (isWater) {
        if (boundaryType === "watershed") {
          const watershedFeature = boundaries.watershed?.[boundaryId];
          if (!watershedFeature) {
            console.error(`Could't find any features for watershed ${boundaryId}`);
            return false;
          }
          return watershedFeature;
        }
        if (boundaryType === "waterbody") {
          const lakesFeature = boundaries.waterbody?.[boundaryId]?.lakes?.features;
          const riversFeature = boundaries.waterbody?.[boundaryId]?.rivers?.features;
          let features = [];
          if (lakesFeature) features.push(...lakesFeature);
          if (riversFeature) features.push(...riversFeature);
          if (features.length > 0) {
            const matchedFeature = {
              type: "FeatureCollection",
              features
            };
            console.log(matchedFeature);
            return matchedFeature;
          } else {
            console.error(`Could't find any features for waterbody ${boundaryId}`);
            return false;
          }
        }
      } else {
        const pt = point([longitude, latitude]);
        const match = boundaries[boundaryType].features.find(
          (feature2) => turf_boolean_point_in_polygon_default(pt, feature2)
        );
        return match || null;
      }
    }
    console.log("Boundaries still not downloaded");
    return false;
  }

  // src/store/features-store.js
  init_live_reload();
  var useFeaturesStore = createStore((set2, get2) => ({
    sites: /* @__PURE__ */ new Map(),
    featuresProps: {},
    featuresDrawed: 0,
    setSitesFeatures: (sites) => set2(() => ({ sites })),
    setFeaturesProps: (featuresProps) => set2(() => ({ featuresProps })),
    setFeaturesDrawed: (featuresDrawed) => set2(() => ({ featuresDrawed })),
    getFeaturesDrawed: () => get2().featuresDrawed,
    getSiteFeatures: () => get2().sites,
    getFeaturesProps: () => get2().featuresProps
  }));
  var features_store_default = useFeaturesStore;

  // src/blocks-layout/popupOutlook.html
  init_live_reload();
  var popupOutlook_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" style="display:IMG_DISPLAY" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">SITE_PREDICTION</span><div class="site-popup_measurements"><div style="width:FIRST_MEASURE_WIDTH;background-color:FIRST_MEASURE_COLOR" class="site-popup_measure"></div><div style="width:SECOND_MEASURE_WIDTH;background-color:SECOND_MEASURE_COLOR" class="site-popup_measure"></div><div style="width:THIRD_MEASURE_WIDTH;background-color:THIRD_MEASURE_COLOR" class="site-popup_measure"></div></div><a target="_blank" class="site-popup_link" href="SITE_LINK">View more details \u2192</a></div></div>';

  // src/blocks-layout/popupGeneral.html
  init_live_reload();
  var popupGeneral_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">LAST_SAMPLE_TAKEN: SITE_QUALITY</span><div class="site-popup_measurements"><div style="width:100%;background-color:QUALITY_GENERAL_COLOR" class="site-popup_measure"></div></div><a class="site-popup_link" target="_blank" href="SITE_LINK">View more details \u2192</a></div></div>';

  // src/blocks-layout/popupNoData.html
  init_live_reload();
  var popupNoData_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">No sample data on this monitoring site</span> <a class="site-popup_link" href="SITE_LINK">View more details \u2192</a></div></div>';

  // src/blocks-layout/popupOutlookEs.html
  init_live_reload();
  var popupOutlookEs_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" style="display:IMG_DISPLAY" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">SITE_PREDICTION</span><div class="site-popup_measurements"><div style="width:FIRST_MEASURE_WIDTH;background-color:FIRST_MEASURE_COLOR" class="site-popup_measure"></div><div style="width:SECOND_MEASURE_WIDTH;background-color:SECOND_MEASURE_COLOR" class="site-popup_measure"></div><div style="width:THIRD_MEASURE_WIDTH;background-color:THIRD_MEASURE_COLOR" class="site-popup_measure"></div></div><a target="_blank" class="site-popup_link" href="SITE_LINK">Ver m\xE1s detalles \u2192</a></div></div>';

  // src/blocks-layout/popupGeneralEs.html
  init_live_reload();
  var popupGeneralEs_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">LAST_SAMPLE_TAKEN: SITE_QUALITY</span><div class="site-popup_measurements"><div style="width:100%;background-color:QUALITY_GENERAL_COLOR" class="site-popup_measure"></div></div><a class="site-popup_link" href="SITE_LINK">Ver m\xE1s detalles \u2192</a></div></div>';

  // src/blocks-layout/popupNoDataEs.html
  init_live_reload();
  var popupNoDataEs_default = '<div class="site-popup"><a href="SITE_LINK" target="_blank" class="site-popup_image-wrapper">IMG_SRC</a><div class="site-popup_text-wrapper"><a href="SITE_LINK" target="_blank" class="site-popup_heading">SITE_NAME</a> <span class="site-popup_descr">No hay datos de muestreo en este punto de control</span> <a class="site-popup_link" href="SITE_LINK">Ver m\xE1s detalles \u2192</a></div></div>';

  // src/utils/html-to-element.js
  init_live_reload();
  function htmlToElement(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(html.trim(), "text/html");
    return doc.body.firstElementChild;
  }
  var html_to_element_default = htmlToElement;

  // src/modules/markers.js
  var { getIsOutlook } = useTabsStore.getState();
  var { getIsBoundariesLoaded: getIsBoundariesLoaded2, getLang, getAccessibility } = useDataStore.getState();
  var { setSitesFeatures, getSiteFeatures, setFeaturesProps, getFeaturesProps } = features_store_default.getState();
  var sitePopupClass = "site-popup";
  var measurmentsClass = "site-popup_measurements";
  var lastDrawnFeatureId = null;
  var currentHightlightedId = null;
  var currentlyHoveredId = null;
  var hoverPopup = null;
  var activeSitePopup = null;
  var mapUpdatesQueue = [];
  var imageBarQueue = [];
  var initializedSources = {};
  function addDynamicMarkerIcon(iconId) {
    const svgUrl = icons.get(iconId);
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        map.addImage(iconId, img);
        resolve();
      };
      img.onerror = reject;
      img.src = svgUrl;
    });
  }
  async function addAllIconsToMap() {
    for (const [id, url] of icons) {
      await addDynamicMarkerIcon(id);
    }
  }
  async function createMarkerLayer(data) {
    const access = getAccessibility();
    const featuresProps = {};
    const features = data.map((site) => {
      const siteType = getSiteType(site);
      featuresProps[site.id] = {
        id: site.id,
        name: site.name,
        wasRain: site.wasRain,
        date: site.date,
        predictionWet: site.predictionWet,
        predictionDry: site.predictionDry,
        quality: siteType.quality,
        qualityValue: site.quality,
        relevance: siteType.relevance,
        state: site.state,
        county: site.county,
        town: site.town,
        watershed: site.watershed,
        waterbody: site.waterbody,
        latitude: site.latitude,
        longitude: site.longitude,
        slug: site.slug,
        image: site.image
      };
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [site.longitude, site.latitude]
        },
        id: site.id,
        properties: {
          id: site.id,
          icon: `marker-${siteType.quality}-${siteType.relevance}${access ? "-access" : ""}`,
          originalIcon: `marker-${siteType.quality}-${siteType.relevance}${access ? "-access" : ""}`,
          iconScale: 1
        }
      };
    });
    const featuresMap = /* @__PURE__ */ new Map();
    features.forEach((feature2) => {
      featuresMap.set(feature2.id, feature2);
    });
    setSitesFeatures(featuresMap);
    setFeaturesProps(featuresProps);
    async function addMarkers() {
      await addAllIconsToMap();
      if (!map.getSource("site-points")) {
        map.addSource("site-points", {
          type: "geojson",
          data: {
            type: "FeatureCollection",
            features
          },
          promoteId: "id"
        });
      }
      if (!map.getLayer("site-points-layer")) {
        map.addLayer({
          id: "site-points-layer",
          type: "symbol",
          source: "site-points",
          layout: {
            "icon-image": ["get", "icon"],
            "icon-size": ["get", "iconScale"],
            "icon-anchor": "bottom",
            "icon-allow-overlap": true,
            "icon-ignore-placement": true
          }
        });
        zoomToFilteredSites(data);
        map.on("click", "site-points-layer", (e) => {
          const isMobile = window.innerWidth <= 767;
          const isTouch = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
          const featuresProps2 = getFeaturesProps();
          const featureId = e.features[0].properties.id;
          const props = featuresProps2[featureId];
          const mapContainer = map.getCanvas();
          const popupHtml = formatSitePopup(props);
          const pixel = map.project([props.longitude, props.latitude]);
          const { anchor, offset } = getPopupAnchorAndOffset(pixel, props.relevance);
          new import_mapbox_gl.default.Popup({ anchor: isMobile ? "bottom" : anchor }).setLngLat([props.longitude, props.latitude]).setOffset(offset).setHTML(popupHtml).addTo(map);
          activeSitePopup = { ...props };
          const sitePopup = document.querySelector(`.${sitePopupClass}`);
          const popupWrapper = document.querySelector(`.mapboxgl-popup-content:has(.site-popup)`);
          if (sitePopup && popupWrapper) {
            const popupHeight = sitePopup.scrollHeight;
            const openTween = gsap3.to(popupWrapper, {
              height: popupHeight,
              duration: 0.3,
              ease: "power1.out"
            });
            const measurments = sitePopup.querySelector(`.${measurmentsClass}`);
            if (measurments)
              gsap3.to(measurments, {
                width: "100%",
                duration: 0.5,
                ease: "power1.out"
              });
            openTween.eventCallback("onComplete", () => {
              sitePopup.classList.add(`${sitePopupClass}--active`);
            });
          }
          if (isTouch) {
            const feature2 = e.features?.[0];
            const newId = feature2?.id;
            if (newId !== currentlyHoveredId) {
              if (currentlyHoveredId !== null) {
                unhighlightMapSite(currentlyHoveredId);
              }
              if (newId !== null && newId !== void 0) {
                highlightMapSite(newId, feature2);
              }
              currentlyHoveredId = newId;
            }
          }
          const closeBtn = document.querySelector(".mapboxgl-popup-close-button");
          const clearActivePopupState = (e2) => {
            const popupEl = document.querySelector(".mapboxgl-popup-content");
            if (popupEl && popupEl.contains(e2.target)) {
              return;
            }
            if (isTouch) unhighlightMapSite(currentlyHoveredId);
            activeSitePopup = null;
            mapContainer.removeEventListener("click", clearActivePopupState);
            closeBtn.removeEventListener("click", clearActivePopupState);
          };
          mapContainer.addEventListener("click", clearActivePopupState);
          closeBtn.addEventListener("click", clearActivePopupState);
        });
        map.on("mousemove", "site-points-layer", (e) => {
          const isTouch = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
          if (!isTouch) {
            map.getCanvas().style.cursor = "pointer";
            const feature2 = e.features?.[0];
            const newId = feature2?.id;
            if (newId !== currentlyHoveredId) {
              if (currentlyHoveredId !== null) {
                unhighlightMapSite(currentlyHoveredId);
              }
              if (newId !== null && newId !== void 0) {
                highlightMapSite(newId, feature2);
              }
              currentlyHoveredId = newId;
            }
          }
        });
        map.on("mouseleave", "site-points-layer", (e) => {
          const isTouch = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
          if (!isTouch) {
            map.getCanvas().style.cursor = "";
            if (currentlyHoveredId !== null) {
              unhighlightMapSite(currentlyHoveredId);
              currentlyHoveredId = null;
            }
          }
        });
      }
    }
    if (map.isStyleLoaded()) {
      await addMarkers();
    } else {
      map.on("load", addMarkers);
    }
  }
  function updateMarkers(sites, isZoom) {
    const access = getAccessibility();
    const featuresProps = {};
    const newFeatures = sites.map((site) => {
      const siteType = getSiteType(site);
      featuresProps[site.id] = {
        name: site.name,
        wasRain: site.wasRain,
        date: site.date,
        predictionWet: site.predictionWet,
        predictionDry: site.predictionDry,
        quality: siteType.quality,
        qualityValue: site.value,
        relevance: siteType.relevance,
        watershed: site.watershed,
        waterbody: site.waterbody,
        state: site.state,
        county: site.county,
        town: site.town,
        latitude: site.latitude,
        longitude: site.longitude,
        image: site.image,
        slug: site.slug
      };
      return {
        type: "Feature",
        geometry: {
          type: "Point",
          coordinates: [site.longitude, site.latitude]
        },
        id: site.id,
        properties: {
          id: site.id,
          icon: `marker-${siteType.quality}-${siteType.relevance}${access ? "-access" : ""}`,
          originalIcon: `marker-${siteType.quality}-${siteType.relevance}${access ? "-access" : ""}`,
          iconScale: 1
        }
      };
    });
    const featuresMap = /* @__PURE__ */ new Map();
    newFeatures.forEach((feature2) => {
      featuresMap.set(feature2.id, feature2);
    });
    setSitesFeatures(featuresMap);
    waitForSourceAndUpdate("site-points", updateSourceData);
    function updateSourceData() {
      map.getSource("site-points").setData({
        type: "FeatureCollection",
        features: newFeatures
      });
      if (isZoom) zoomToFilteredSites(sites);
    }
  }
  function waitForSourceAndUpdate(sourceId, callback) {
    if (!initializedSources[sourceId] && initializedSources[sourceId] !== false)
      initializedSources[sourceId] = false;
    if (isReady()) {
      initializedSources[sourceId] = true;
      callback();
      return;
    }
    mapUpdatesQueue.push(callback);
    function isReady() {
      return initializedSources[sourceId] || map.getSource(sourceId);
    }
    function done() {
      initializedSources[sourceId] = true;
      map.off("sourcedata", onSourceData);
      const queue = [...mapUpdatesQueue];
      mapUpdatesQueue.length = 0;
      for (const fn of queue) fn();
    }
    function onSourceData(e) {
      if (e.sourceId === sourceId && isReady()) {
        done();
      }
    }
    map.on("sourcedata", onSourceData);
  }
  function waitForFeaturesRendered(sourceId, callback) {
    function getOnMapFeatures() {
      const bounds = map.getBounds();
      const topLeft = map.project(bounds.getNorthWest());
      const bottomRight = map.project(bounds.getSouthEast());
      const pixelBounds = [
        [topLeft.x, topLeft.y],
        [bottomRight.x, bottomRight.y]
      ];
      const features = [
        ...map.queryRenderedFeatures(pixelBounds, {
          layers: ["site-points-layer"]
        })
      ];
      return features;
    }
    if (isReady()) {
      const features = getOnMapFeatures();
      if (features > 0) {
        callback(features);
        return;
      }
    }
    imageBarQueue.push(callback);
    function isReady() {
      return map.getSource(sourceId) && map.isSourceLoaded(sourceId) && map.isStyleLoaded();
    }
    function done() {
      map.off("idle", onIdle);
      const features = getOnMapFeatures();
      const queue = [...imageBarQueue];
      imageBarQueue.length = 0;
      for (const fn of queue) fn(features);
    }
    function onIdle() {
      if (isReady()) {
        done();
      }
    }
    map.on("idle", onIdle);
  }
  function updateBoundaryOutline({ checkPoints, boundaryId, boundaryType, clearOnly = false }) {
    const sourceId = "highlighted-feature";
    const layerId = "highlighted-feature-outline";
    if (clearOnly) {
      if (map.getLayer(layerId)) map.removeLayer(layerId);
      if (map.getSource(sourceId)) map.removeSource(sourceId);
      lastDrawnFeatureId = null;
      return;
    }
    if (!checkPoints || checkPoints.length === 0) return;
    let matchedFeature = null;
    for (const point2 of checkPoints) {
      matchedFeature = findBoundary({
        boundaryType,
        boundaryId,
        latitude: point2.latitude,
        longitude: point2.longitude
      });
      if (matchedFeature || matchedFeature === false) break;
    }
    if (!matchedFeature) {
      const isBoundariesLoaded = getIsBoundariesLoaded2();
      console.log(
        `${isBoundariesLoaded ? `No matching boundary found for ${boundaryType}, zooming to points` : `Boundaries still downloading, zooming to points`}`
      );
      zoomToFilteredSites(checkPoints);
      return;
    }
    const featureId = matchedFeature?.id || matchedFeature?.properties?.id || JSON.stringify(matchedFeature);
    if (featureId === lastDrawnFeatureId) {
      map.fire("manualUpdate");
      if (boundaryType === "waterbody") zoomToFilteredSites(checkPoints);
      return;
    }
    if (map.getLayer(layerId)) map.removeLayer(layerId);
    if (map.getSource(sourceId)) map.removeSource(sourceId);
    try {
      map.addSource(sourceId, {
        type: "geojson",
        data: matchedFeature
      });
      lastDrawnFeatureId = featureId;
    } catch (error) {
      console.error(`Error with boundary file ${boundaryId}`);
      zoomToFilteredSites(checkPoints);
    }
    map.addLayer(
      {
        id: layerId,
        type: "line",
        source: sourceId,
        paint: {
          "line-color": "#FF5733",
          "line-width": 1,
          "line-opacity": 0
        }
      },
      "site-points-layer"
    );
    map.setPaintProperty(layerId, "line-opacity-transition", {
      duration: 1250,
      delay: 0
    });
    map.setPaintProperty(layerId, "line-opacity", 1);
    try {
      if (boundaryType !== "waterbody") zoomToFilteredFeature(matchedFeature);
      else zoomToFilteredSites(checkPoints);
    } catch (error) {
      console.error(`Error with boundary file ${boundaryId}`);
      zoomToFilteredSites(checkPoints);
    }
  }
  function rebuildPopup() {
    const popup = document.querySelector(`.${sitePopupClass}`);
    if (!popup || !activeSitePopup || activeSitePopup.wasRain && Object.values(activeSitePopup.predictionWet).filter((value) => value > 0).length === 0 || !activeSitePopup.wasRain && Object.values(activeSitePopup.predictionDry).filter((value) => value > 0).length === 0)
      return;
    const tween = gsap3.to(popup, {
      opacity: 0,
      duration: 0.3,
      ease: "power1.out"
    });
    tween.eventCallback("onComplete", () => {
      const newPopup = html_to_element_default(formatSitePopup(activeSitePopup));
      newPopup.classList.add(`${sitePopupClass}--active`);
      newPopup.style.opacity = 0;
      popup.replaceWith(newPopup);
      gsap3.to(newPopup, {
        opacity: 1,
        duration: 0.3,
        ease: "power1.out"
      });
      const measurments = newPopup.querySelector(`.${measurmentsClass}`);
      if (measurments)
        gsap3.to(measurments, {
          width: "100%",
          duration: 0.5,
          ease: "power1.out"
        });
    });
  }
  function formatSitePopup(site) {
    console.log(`Format site: `);
    console.log(site);
    const lang = getLang();
    console.log(lang);
    const outlookHtml = lang === "es" ? popupOutlookEs_default : popupOutlook_default;
    const generalHtml = lang === "es" ? popupGeneralEs_default : popupGeneral_default;
    const noDataHtml = lang === "es" ? popupNoDataEs_default : popupNoData_default;
    const colors = {
      clean: "#1E90FF",
      boat: "#FFBB00",
      notClean: "#ED332F"
    };
    const formatter = new Intl.DateTimeFormat("en-GB", {
      day: "2-digit",
      month: "short",
      year: "numeric"
    });
    const siteType = getSiteType(site);
    const isOutlook = getIsOutlook();
    const popupHtml = isOutlook && getHigestPrediction(site) ? outlookHtml : site.date ? generalHtml : noDataHtml;
    let predictionSortedEntries;
    let predictionText;
    if (getHigestPrediction(site)) {
      predictionSortedEntries = calculatePredictionPercentages(
        Object.entries(getTargetPrediction(site)).sort((a, b) => b[1] - a[1])
      );
      predictionSortedEntries = formatPercentages(predictionSortedEntries);
      predictionText = generateTextPrediction(predictionSortedEntries);
    }
    return popupHtml.replace("SITE_NAME", site.name).replace(
      "IMG_SRC",
      site.image ? `<img class="popup-image" src="${site.image}" alt="site image" />` : ""
    ).replace("SITE_PREDICTION", predictionText).replace("SITE_QUALITY", getSiteQuality(site)).replace("QUALITY_GENERAL_COLOR", colors[siteType.quality]).replace("LAST_SAMPLE_TAKEN", formatter.format(site.date)).replace("LAST_SAMPLE_VALUE", `${site.qualityValue} MPN/100mL`).replace("FIRST_MEASURE_WIDTH", `calc(${predictionSortedEntries?.[0]?.[1]}% - 4px)`).replace("FIRST_MEASURE_COLOR", colors[predictionSortedEntries?.[0]?.[0]]).replace("SECOND_MEASURE_WIDTH", `${predictionSortedEntries?.[1]?.[1]}%`).replace("SECOND_MEASURE_COLOR", colors[predictionSortedEntries?.[1]?.[0]]).replace("THIRD_MEASURE_WIDTH", `${predictionSortedEntries?.[2]?.[1]}%`).replace("THIRD_MEASURE_COLOR", colors[predictionSortedEntries?.[2]?.[0]]).replaceAll(
      "SITE_LINK",
      `${window.location.origin}${lang !== "en" ? `/${lang}` : ""}/sites/${site.slug}`
    );
  }
  function getTargetPrediction(site) {
    return site.wasRain ? site.predictionWet : site.predictionDry;
  }
  function getSiteQuality(site) {
    const lang = getLang();
    const textVariants = {
      en: {
        clean: "Clean for swimming",
        boat: "Clean for boating only",
        notClean: "Not clean",
        chance: "chance"
      },
      es: {
        clean: "Limpio para nadar",
        boat: "Limpio solo para navegaci\xF3n",
        notClean: "No limpio",
        chance: "de posibilidades"
      }
    };
    const siteType = getSiteType(site);
    const phrase = textVariants[lang][siteType.quality];
    return phrase;
  }
  function generateTextPrediction(predictionEntries) {
    const lang = getLang();
    const textVariants = {
      en: {
        clean: "Clean for swimming",
        boat: "Clean for boating only",
        notClean: "Not clean",
        chance: "chance"
      },
      es: {
        clean: "Limpio para nadar",
        boat: "Limpio solo para navegaci\xF3n",
        notClean: "No limpio",
        chance: "de posibilidades"
      }
    };
    const [quality, probability] = predictionEntries[0];
    const langTexts = textVariants[lang] || textVariants.en;
    const phrase = langTexts[quality] || ["Unknown"];
    const chanceText = langTexts.chance;
    return quality === "notClean" ? `${phrase} (${Math.floor(probability)}% ${chanceText})` : `${phrase} (${Math.floor(probability)}% ${chanceText})`;
  }
  function calculatePredictionPercentages(predictionEntries) {
    const percentageSum = predictionEntries.reduce((acc, curr) => {
      const accVal = Array.isArray(acc) ? acc[1] : acc;
      return accVal + curr[1];
    });
    const multiplier = 100 / percentageSum;
    return predictionEntries.map((entry) => [entry[0], entry[1] * multiplier]);
  }
  function formatPercentages(predictionEntries) {
    const newEntries = [...predictionEntries];
    newEntries.forEach(([key, value], index) => {
      if (value === 100) {
        if (index - 1 < 0) newEntries[index + 1][1] += 1;
        else newEntries[index - 1][1] += 1;
        newEntries[index][1] = 99;
      }
      if (value === 0) {
        const maxIndex = findMaxIndex(Object.values(Object.fromEntries(newEntries)));
        newEntries[maxIndex][1] -= 1;
        newEntries[index][1] += 1;
      }
    });
    return newEntries;
    function findMaxIndex(arr) {
      let max = 0;
      let maxIndex = 0;
      arr.forEach((value, index) => {
        if (max < value) {
          max = value;
          maxIndex = index;
        }
      });
      return maxIndex;
    }
  }
  function zoomToFilteredFeature(feature2) {
    const boudaryBox = turf_bbox_default(feature2);
    const bounds = new import_mapbox_gl.default.LngLatBounds(
      [boudaryBox[0], boudaryBox[1]],
      [boudaryBox[2], boudaryBox[3]]
    );
    map.fitBounds(bounds, {
      padding: {
        top: 50,
        left: 50,
        right: 50,
        bottom: 183
      },
      duration: 800,
      maxZoom: 12
    });
  }
  function zoomToFilteredSites(sites) {
    if (!sites.length) return;
    const coordinates = sites.map((site) => [site.longitude, site.latitude]);
    const bounds = new import_mapbox_gl.default.LngLatBounds();
    coordinates.forEach((coord) => bounds.extend(coord));
    map.fitBounds(bounds, {
      padding: {
        top: 50,
        left: 50,
        right: 50,
        bottom: 183
      },
      duration: 800,
      maxZoom: 14
    });
  }
  function getSiteType(site) {
    if (!site) {
      console.error("Site is required parameter");
      return;
    }
    const type = {
      relevance: "",
      quality: ""
    };
    const isOutlook = getIsOutlook();
    const month = 1e3 * 60 * 60 * 24 * 30;
    const year = 1e3 * 60 * 60 * 24 * 365;
    if (!site.date) {
      type.relevance = "old";
    } else {
      const difference = Date.now() - site.date.getTime();
      if (difference < month) type.relevance = "month";
      if (difference > month && difference < year) type.relevance = "year";
      if (!type.relevance) type.relevance = "old";
    }
    const prediction = getHigestPrediction(site);
    if (isOutlook && prediction) {
      type.quality = prediction;
    } else {
      const clearColiValue = 235;
      const boatingColiValue = 575;
      const quality = typeof site.quality === "string" ? site.qualityValue : site.quality;
      if (quality < clearColiValue) type.quality = "clean";
      if (quality > clearColiValue && quality < boatingColiValue) type.quality = "boat";
      if (!type.quality) type.quality = "notClean";
    }
    return type;
  }
  function animateMarkerScale(featureId, toSize) {
    const features = getSiteFeatures();
    const match = features.get(featureId);
    if (!match && toSize === 1) {
      return;
    }
    if (!match) {
      console.error(`Not found feature with id ${featureId} in animateMarkerScale`);
      return;
    }
    const originalIcon = match.properties.originalIcon;
    const targetIcon = toSize === 1 ? originalIcon : `${originalIcon}-hightlighted`;
    const updatedFeaturesMap = new Map(features);
    updatedFeaturesMap.set(featureId, {
      ...match,
      properties: { ...match.properties, icon: targetIcon }
    });
    map.getSource("site-points").setData({
      type: "FeatureCollection",
      features: Array.from(updatedFeaturesMap.values())
    });
    setSitesFeatures(updatedFeaturesMap);
  }
  function highlightMapSite(siteId, feature2) {
    if (currentHightlightedId && currentHightlightedId !== siteId) {
      animateMarkerScale(siteId, 1);
      destroyHoverPopup();
    }
    if (!activeSitePopup) makeHoverPopup(feature2);
    animateMarkerScale(siteId, 1.5);
    currentHightlightedId = siteId;
  }
  function getPopupAnchorAndOffset(pixel, relevance) {
    const { clientWidth, clientHeight } = map.getCanvas();
    const verticalYValues = { top: 3, bottom: -40 };
    if (relevance === "old") {
      verticalYValues.bottom = -20;
    }
    const vertical = pixel.y < clientHeight * 0.33 ? "top" : pixel.y > clientHeight * 0.66 ? "bottom" : "";
    const horizontal = pixel.x < clientWidth * 0.33 ? "left" : pixel.x > clientWidth * 0.66 ? "right" : "";
    const anchor = vertical && horizontal ? `${vertical}-${horizontal}` : vertical || horizontal || "bottom";
    const offsetY = vertical === "top" ? verticalYValues.top : vertical === "bottom" ? verticalYValues.bottom : verticalYValues.bottom;
    const offsetX = horizontal === "left" ? 20 : horizontal === "right" ? -20 : 0;
    return {
      anchor,
      offset: [offsetX, offsetY]
    };
  }
  function makeHoverPopup(feature2) {
    const coordinates = feature2?.geometry?.coordinates || [feature2.longitude, feature2.latitude];
    if (feature2) {
      const props = getFeaturesProps()[feature2.id];
      if (!props) return;
      const pixel = map.project(coordinates);
      const { anchor, offset } = getPopupAnchorAndOffset(pixel, props.relevance);
      if (!hoverPopup) {
        hoverPopup = new import_mapbox_gl.default.Popup({
          closeButton: false,
          closeOnClick: false,
          className: "hover-popup",
          anchor
        });
      }
      hoverPopup.setLngLat(coordinates).setHTML(`<span class="hover-popup">${props.name}</span>`).setOffset(offset).addTo(map);
    } else {
      console.error("Cannot create hover popup without feature");
    }
  }
  function destroyHoverPopup() {
    if (hoverPopup) {
      hoverPopup.remove();
      hoverPopup = null;
    }
  }
  function unhighlightMapSite(siteId = currentHightlightedId) {
    if (siteId) {
      destroyHoverPopup();
      animateMarkerScale(siteId, 1);
    } else {
      console.error("Unexpected null in unhighlightMapSite");
    }
  }

  // src/utils/sleep.js
  init_live_reload();
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  var sleep_default = sleep;

  // src/modules/handle-url-queries.js
  init_live_reload();
  var {
    getWaterSheds: getWaterSheds2,
    getWaterBodies: getWaterBodies2,
    getOrganizations,
    getSites,
    getStates,
    getCounties,
    getTowns,
    setAccessibility
  } = useDataStore.getState();
  var {
    setStateFilter,
    setCountyFilter,
    setTownFilter,
    setWaterShedFilter,
    setWaterBodyFilter,
    setOrganizationFilter,
    setSiteFilter,
    setCleanFilter,
    setBoatingFilter,
    setNotCleanFilter,
    setMonthFilter,
    setYearFilter,
    setOldFilter
  } = useFiltersStore.getState();
  var { setIsAdministrative, setIsOutlook } = useTabsStore.getState();
  function setUrlQuery(param, value) {
    const url = new URL(window.location.href);
    if (value === null || value === void 0 || value === "") {
      url.searchParams.delete(param);
    } else {
      url.searchParams.set(param, value);
    }
    window.history.replaceState({}, "", url);
  }

  // src/modules/filter.js
  var { setSelectedInputLevel, getAllFilters, getSelectedInputLevel, getInputHandlers } = useFiltersStore.getState();
  var filtersInputsMap = {
    watershed: "watershed",
    waterbody: "waterbody",
    state: "state",
    county: "county",
    town: "town",
    organization: "organization",
    site: "site",
    clean: "clean",
    boating: "boating",
    "not-clean": "notClean",
    month: "month",
    year: "year",
    old: "old"
  };
  var {
    getWaterSheds: getWaterSheds3,
    getWaterBodies: getWaterBodies3,
    getOrganizations: getOrganizations2,
    getSites: getSites2,
    getStates: getStates2,
    getCounties: getCounties2,
    getTowns: getTowns2,
    getInitialized
  } = useDataStore.getState();
  var { getIsAdministrative } = useTabsStore.getState();
  var dataInputsMap = {
    states: "states-select",
    counties: "counties-select",
    towns: "towns-select",
    watersheds: "watersheds-select",
    waterbodies: "waterbodies-select",
    organizations: "monitoring-select",
    sites: "sites-select"
  };
  function createOption(text, value, classes) {
    const option = document.createElement("option");
    option.value = value;
    option.textContent = text;
    option.classList.add(...classes);
    return option;
  }
  function createDataState() {
    return {
      states: getStates2(),
      counties: getCounties2(),
      towns: getTowns2(),
      watersheds: getWaterSheds3(),
      waterbodies: getWaterBodies3(),
      organizations: getOrganizations2(),
      sites: getSites2()
    };
  }
  function resetInput(input) {
    if (input.element.type !== "checkbox") {
      const dataState = createDataState();
      input.element.innerHTML = "";
      input.element.append(input.emptyOption);
      const dataId = Object.entries(dataInputsMap).find(
        ([key, value]) => value === input.element.id
      )[0];
      try {
        dataState[dataId].forEach((element) => {
          const option = document.createElement("option");
          option.classList.add("map_filter-option", `map_filter-option--${dataId}`);
          option.value = element.id;
          option.textContent = element.name;
          input.element.append(option);
        });
        input.setFunction("");
        input.element.classList.remove("input--active");
        setUrlQuery(input.inputParam, "");
      } catch (error) {
        throw error;
      }
    }
  }
  function handleZeroResults(select) {
    if (select.element.id === "sites-select") {
      select.element.innerHTML = "";
      const entity = Object.entries(dataInputsMap).find(
        ([key, value]) => value === select.element.id
      )[0];
      const option = createOption(`No ${entity}..`, "none", [
        "map_filter-option",
        "map_filter-option--sites"
      ]);
      select.element.append(option);
      select.setFunction("");
      select.element.classList.remove("input--active");
      setUrlQuery(select.inputParam, "");
    } else {
      console.error(`Unexpected 0 results in ${select.element.id}`);
    }
  }
  function handleOneResult(select, option) {
    const selectedInputLevel = getSelectedInputLevel();
    if (select.dependencyLevel < selectedInputLevel) {
      select.element.value = option.value;
    } else {
      select.element.innerHTML = "";
      select.element.append(option);
      console.log(`Set level: ${select.dependencyLevel}`);
      setSelectedInputLevel(select.dependencyLevel);
    }
    select.setFunction(option.value);
    select.element.classList.add("input--active");
    setUrlQuery(select.inputParam, option.value);
  }
  function reRenderInputs(state) {
    if (state) {
      const handlers = getInputHandlers();
      const inputsToDipatch = [];
      filtersInputs.forEach((input, index) => {
        const filterKey = filtersInputsMap[input.inputParam];
        if (state[filterKey] !== initialFiltersState[filterKey]) {
          inputsToDipatch.push({ input, handler: handlers[index] });
        }
      });
      const sortedDipatches = [...inputsToDipatch];
      sortedDipatches.sort((a, b) => a.input.dependencyLevel - b.input.dependencyLevel);
      async function dipatchHandlersFromState() {
        for (dispatch of sortedDipatches) {
          const { input, handler } = dispatch;
          const event = {
            target: input.element
          };
          const filterKey = filtersInputsMap[input.inputParam];
          if (input.element.type === "checkbox") {
            input.element.checked = state[filterKey];
          } else {
            const options = input.element.querySelectorAll(".map_filter-option");
            options.forEach((option) => {
              if (option.value === state[filterKey]) {
                option.selected = true;
              }
            });
          }
          handler(event);
          console.log("handler");
          await sleep_default(100);
        }
      }
      const initialized = getInitialized();
      if (initialized) dipatchHandlersFromState();
      else {
        map.once("initialized", dipatchHandlersFromState);
      }
    } else {
      filtersInputs.forEach((input) => {
        resetInput(input);
      });
    }
  }
  function sortingInput(select) {
    const selectedInputLevel = getSelectedInputLevel();
    const filteredOptions = select.optionsFilterFunction();
    try {
      switch (filteredOptions.length) {
        case 0: {
          handleZeroResults(select);
          break;
        }
        case 1: {
          handleOneResult(select, filteredOptions[0]);
          break;
        }
        default: {
          if (selectedInputLevel < select.dependencyLevel) {
            fillSelectWithOptions(select, filteredOptions);
          }
          break;
        }
      }
    } catch (error) {
      throw error;
    }
  }
  function fillSelectWithOptions(select, options) {
    select.element.innerHTML = ``;
    select.element.append(select.emptyOption);
    options.forEach((option) => {
      select.element.append(option);
    });
    select.setFunction("");
    select.element.classList.remove("input--active");
    setUrlQuery(select.inputParam, "");
  }
  function processInputsResets(selectedInput) {
    const selectedInputLevel = getSelectedInputLevel();
    const inputs = getSortedIputsByDependency(getNextInputs(selectedInputLevel));
    for (const input of inputs) {
      resetInput(input);
    }
    processInputsSorting(selectedInput);
  }
  function processInputsSorting(selectedInput) {
    const selectedInputLevel = getSelectedInputLevel();
    const inputs = getSortedIputsByDependency();
    if (selectedInput.element.type !== "checkbox" && selectedInput.inputParam !== "organization")
      for (const input of inputs) {
        if (input.dependencyLevel < selectedInputLevel) resetInput(input);
      }
    for (const input of inputs) {
      if (input.element.type === "checkbox" || input.dependencyLevel === selectedInputLevel) {
        continue;
      }
      sortingInput(input);
    }
  }
  function filterSites() {
    const dataState = createDataState();
    const filterState = getAllFilters();
    console.log("Filter state:");
    console.log(filterState);
    const isAdministrative = getIsAdministrative();
    const filterResult = dataState.sites.filter((site) => {
      if (isAdministrative) {
        if (filterState.state && filterState.state !== "none" && site.state !== filterState.state) {
          return false;
        }
        if (filterState.county && filterState.county !== "none" && site.county !== filterState.county) {
          return false;
        }
        if (filterState.town && filterState.town !== "none" && site.town !== filterState.town) {
          return false;
        }
      } else {
        if (filterState.watershed && filterState.watershed !== "none" && site.watershed !== filterState.watershed) {
          return false;
        }
        if (filterState.waterbody && filterState.waterbody !== "none" && site.waterbody !== filterState.waterbody) {
          return false;
        }
      }
      if (filterState.organization && filterState.organization !== "none" && !site.organizations.some((item) => item === filterState.organization)) {
        return false;
      }
      if (filterState.site && filterState.site !== "none" && site.id !== filterState.site) {
        return false;
      }
      return true;
    }).filter((site) => {
      const siteType = getSiteType(site);
      const hasClear = filterState.clean && siteType.quality === "clean";
      const hasBoating = filterState.boating && siteType.quality === "boat";
      const hasNotClean = filterState.notClean && siteType.quality === "notClean";
      const result = !filterState.clean && !filterState.boating && !filterState.notClean || hasClear || hasBoating || hasNotClean;
      return result;
    }).filter((site) => {
      const siteType = getSiteType(site);
      const hasMonth = filterState.month && siteType.relevance === "month";
      const hasYear = filterState.year && siteType.relevance === "year";
      const hasOld = filterState.old && siteType.relevance === "old";
      return !filterState.month && !filterState.year && !filterState.old || hasMonth || hasYear || hasOld;
    });
    console.log("Curent sites:");
    console.log(filterResult);
    return filterResult;
  }
  function getHigestPrediction(site) {
    const targetPrediction = site.wasRain ? site.predictionWet : site.predictionDry;
    const isSomeNaN = Object.values(targetPrediction).some((value) => isNaN(value));
    const valuesNotZeroes = Object.values(targetPrediction).filter((value) => value > 0).length > 0;
    const highestPrediction = Object.entries(targetPrediction).sort((a, b) => b[1] - a[1])[0][0];
    return isSomeNaN || !valuesNotZeroes ? void 0 : highestPrediction;
  }
  function filterStateOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    const isAdministrative = getIsAdministrative();
    const { county, town, site } = filterState;
    const { states } = dataState;
    const filteredStates = [];
    if (isAdministrative) {
      filteredStates.push(
        ...states.filter((state) => {
          if (county && county !== "none" && !state.counties.some((item) => item === county))
            return false;
          if (site && site !== "none" && !state.sites.some((item) => item === site)) return false;
          if (town && town !== "none" && !state.towns.some((item) => item === town)) return false;
          return true;
        })
      );
    } else {
      filteredStates.push(...states);
    }
    return filteredStates.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--states");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterCountyOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    const isAdministrative = getIsAdministrative();
    const { state, town, site } = filterState;
    const { counties } = dataState;
    const filteredCounties = [];
    if (isAdministrative) {
      filteredCounties.push(
        ...counties.filter((county) => {
          if (state && state !== "none" && !(county.state === state)) return false;
          if (town && town !== "none" && !county.towns.some((item) => item === town)) return false;
          if (site && site !== "none" && !county.sites.some((item) => item === site)) return false;
          return true;
        })
      );
    } else {
      filteredCounties.push(...counties);
    }
    return filteredCounties.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--counties");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterTownOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    const isAdministrative = getIsAdministrative();
    const { state, county, site } = filterState;
    const { towns } = dataState;
    const filteredTowns = [];
    if (isAdministrative) {
      filteredTowns.push(
        ...towns.filter((town) => {
          if (state && state !== "none" && !(town.state === state)) return false;
          if (county && county !== "none" && !(town.county === county)) return false;
          if (site && site !== "none" && !town.sites.some((item) => item === site)) return false;
          return true;
        })
      );
    } else {
      filteredTowns.push(...towns);
    }
    return filteredTowns.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--towns");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterWatershedOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    const isAdministrative = getIsAdministrative();
    const { waterbody, site } = filterState;
    const { watersheds } = dataState;
    const filteredWatersheds = [];
    if (!isAdministrative) {
      filteredWatersheds.push(
        ...watersheds.filter((watershed) => {
          if (waterbody && waterbody !== "none" && !watershed.waterbodies.some((item) => item === waterbody))
            return false;
          if (site && site !== "none" && !watershed.sites.some((item) => item === site)) return false;
          return true;
        })
      );
    } else {
      filteredWatersheds.push(...watersheds);
    }
    return filteredWatersheds.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--watersheds");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterWaterbodyOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    const isAdministrative = getIsAdministrative();
    const { watershed, site } = filterState;
    const { waterbodies } = dataState;
    const filteredWaterbodies = [];
    if (!isAdministrative) {
      filteredWaterbodies.push(
        ...waterbodies.filter((waterbody) => {
          if (watershed && watershed !== "none" && !(waterbody.watershed === watershed)) return false;
          if (site && site !== "none" && !waterbody.sites.some((item) => item === site)) return false;
          return true;
        })
      );
    } else {
      filteredWaterbodies.push(...waterbodies);
    }
    return filteredWaterbodies.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--waterbodies");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterOrganizationOptions() {
    const filterState = getAllFilters();
    const dataState = createDataState();
    function isLinkedWithOrganization(siteIds, organizationId) {
      return siteIds.some((siteId) => {
        const siteObj = sites.find((s) => s.id === siteId);
        return siteObj?.organizations.includes(organizationId);
      });
    }
    const { site, watershed, waterbody, state, county, town } = filterState;
    const { organizations, sites, watersheds, waterbodies, states, counties, towns } = dataState;
    const filteredOrganizations = organizations.filter((organization) => {
      if (state && state !== "none") {
        const matchedState = states.find((s) => s.id === state);
        if (!matchedState) return false;
        const stateSiteIds = matchedState.sites;
        const isLinked = isLinkedWithOrganization(stateSiteIds, organization.id);
        if (!isLinked) return false;
      }
      if (county && county !== "none") {
        const matchedCounty = counties.find((c) => c.id === county);
        if (!matchedCounty) return false;
        const countySiteIds = matchedCounty.sites;
        const isLinked = isLinkedWithOrganization(countySiteIds, organization.id);
        if (!isLinked) return false;
      }
      if (town && town !== "none") {
        const matchedTown = towns.find((t) => t.id === town);
        if (!matchedTown) return false;
        const townSitesIds = matchedTown.sites;
        const isLinked = isLinkedWithOrganization(townSitesIds, organization.id);
        if (!isLinked) return false;
      }
      if (watershed && watershed !== "none") {
        const matchedWatershed = watersheds.find((w) => w.id === watershed);
        if (!matchedWatershed) return false;
        const watershedSiteIds = matchedWatershed.sites;
        const isLinked = isLinkedWithOrganization(watershedSiteIds, organization.id);
        if (!isLinked) return false;
      }
      if (waterbody && waterbody !== "none") {
        const matchedWaterbody = waterbodies.find((w) => w.id === waterbody);
        if (!matchedWaterbody) return false;
        const waterbodySiteIds = matchedWaterbody.sites;
        const isLinked = isLinkedWithOrganization(waterbodySiteIds, organization.id);
        if (!isLinked) return false;
      }
      if (site && site !== "none") {
        const matchedSite = sites.find((s) => s.id === site);
        if (!matchedSite) return false;
        if (!matchedSite.organizations.includes(organization.id)) return false;
      }
      return true;
    });
    return filteredOrganizations.map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--organizations");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function filterSitesOptions() {
    return filterSites().map((item) => {
      const option = document.createElement("option");
      option.classList.add("map_filter-option", "map_filter-option--sites");
      option.value = item.id;
      option.textContent = item.name;
      return option;
    });
  }
  function getSortedIputsByDependency(inputs = filtersInputs, reverse = false) {
    const inputsCopy = [...inputs];
    return reverse ? inputsCopy.sort((a, b) => b.dependencyLevel - a.dependencyLevel) : inputsCopy.sort((a, b) => a.dependencyLevel - b.dependencyLevel);
  }
  function getNextInputs(dependencyLevel) {
    return filtersInputs.filter((item) => item.dependencyLevel > dependencyLevel);
  }

  // src/modules/filters-handlers.js
  var statesSelect = document.querySelector("#states-select");
  var countiesSelect = document.querySelector("#counties-select");
  var townsSelect = document.querySelector("#towns-select");
  var waterShedsSelect = document.querySelector("#watersheds-select");
  var waterBodiesSelect = document.querySelector("#waterbodies-select");
  var organizationSelect = document.querySelector("#monitoring-select");
  var sitesSelect = document.querySelector("#sites-select");
  var cleanCheckbox = document.querySelector("#clean-swimming");
  var boatingCheckbox = document.querySelector("#clean-boating");
  var notCleanCheckbox = document.querySelector("#not-clean");
  var monthCheckbox = document.querySelector("#month");
  var yearCheckboxx = document.querySelector("#year");
  var oldCheckbox = document.querySelector("#old");
  var {
    setSelectedInputLevel: setSelectedInputLevel2,
    getSelectedInputLevel: getSelectedInputLevel2,
    pushInputHandler,
    clearInputHandlers,
    getInputHandlers: getInputHandlers2,
    setWaterShedFilter: setWaterShedFilter2,
    setWaterBodyFilter: setWaterBodyFilter2,
    setOrganizationFilter: setOrganizationFilter2,
    setStateFilter: setStateFilter2,
    setCountyFilter: setCountyFilter2,
    setTownFilter: setTownFilter2,
    setSiteFilter: setSiteFilter2,
    setCleanFilter: setCleanFilter2,
    setBoatingFilter: setBoatingFilter2,
    setNotCleanFilter: setNotCleanFilter2,
    setYearFilter: setYearFilter2,
    setMonthFilter: setMonthFilter2,
    setOldFilter: setOldFilter2,
    getAllFilters: getAllFilters2
  } = useFiltersStore.getState();
  var filtersInputs = [
    {
      element: statesSelect,
      contents: document.querySelectorAll(".map_filter-option--states"),
      emptyOption: statesSelect.querySelector(".map_filter-option"),
      dependencyLevel: 0,
      inputParam: "state",
      setFunction: setStateFilter2,
      optionsFilterFunction: filterStateOptions
    },
    {
      element: countiesSelect,
      contents: document.querySelectorAll(".map_filter-option--states"),
      emptyOption: countiesSelect.querySelector(".map_filter-option"),
      dependencyLevel: 1,
      inputParam: "county",
      setFunction: setCountyFilter2,
      optionsFilterFunction: filterCountyOptions
    },
    {
      element: townsSelect,
      contents: document.querySelectorAll(".map_filter-option--towns"),
      emptyOption: townsSelect.querySelector(".map_filter-option"),
      dependencyLevel: 2,
      inputParam: "town",
      setFunction: setTownFilter2,
      optionsFilterFunction: filterTownOptions
    },
    {
      element: waterShedsSelect,
      contents: document.querySelectorAll(".map_filter-option--watersheds"),
      emptyOption: waterShedsSelect.querySelector(".map_filter-option"),
      optionsFilterFunction: filterWatershedOptions,
      dependencyLevel: 1,
      setFunction: setWaterShedFilter2,
      inputParam: "watershed"
    },
    {
      element: waterBodiesSelect,
      contents: document.querySelectorAll(".map_filter-option--waterbodies"),
      emptyOption: waterBodiesSelect.querySelector(".map_filter-option"),
      optionsFilterFunction: filterWaterbodyOptions,
      dependencyLevel: 2,
      setFunction: setWaterBodyFilter2,
      inputParam: "waterbody"
    },
    {
      element: organizationSelect,
      contents: document.querySelectorAll(".map_filter-option--organizations"),
      emptyOption: organizationSelect.querySelector(".map_filter-option"),
      optionsFilterFunction: filterOrganizationOptions,
      dependencyLevel: 3,
      setFunction: setOrganizationFilter2,
      inputParam: "organization"
    },
    {
      element: cleanCheckbox,
      dependencyLevel: 4,
      setFunction: setCleanFilter2,
      inputParam: "clean"
    },
    {
      element: boatingCheckbox,
      dependencyLevel: 4,
      setFunction: setBoatingFilter2,
      inputParam: "boating"
    },
    {
      element: notCleanCheckbox,
      dependencyLevel: 4,
      setFunction: setNotCleanFilter2,
      inputParam: "not-clean"
    },
    {
      element: monthCheckbox,
      dependencyLevel: 4,
      setFunction: setMonthFilter2,
      inputParam: "month"
    },
    {
      element: yearCheckboxx,
      dependencyLevel: 4,
      setFunction: setYearFilter2,
      inputParam: "year"
    },
    {
      element: oldCheckbox,
      dependencyLevel: 4,
      setFunction: setOldFilter2,
      inputParam: "old"
    },
    {
      element: sitesSelect,
      contents: document.querySelectorAll(".map_filter-option--sites"),
      emptyOption: sitesSelect.querySelector(".map_filter-option"),
      optionsFilterFunction: filterSitesOptions,
      dependencyLevel: 5,
      setFunction: setSiteFilter2,
      inputParam: "site"
    }
  ];
  var createrHandler = (index) => (e) => {
    const prevSelectedLevel = getSelectedInputLevel2();
    const selectedInput = filtersInputs[index];
    let value = e.target.value;
    if (e.target.type === "checkbox") value = e.target.checked;
    if (e.target.value === "none") value = "";
    selectedInput.setFunction(value);
    if (value) selectedInput.element.classList.add("input--active");
    else selectedInput.element.classList.remove("input--active");
    setUrlQuery(selectedInput.inputParam, value);
    console.log(`Set level: ${selectedInput.dependencyLevel}`);
    setSelectedInputLevel2(selectedInput.dependencyLevel);
    if (prevSelectedLevel !== void 0 && selectedInput.dependencyLevel < prevSelectedLevel) {
      processInputsResets(selectedInput);
    } else {
      processInputsSorting(selectedInput);
    }
    const sites = filterSites();
    const points = sites.map((site) => ({ latitude: site.latitude, longitude: site.longitude }));
    const { watershed, waterbody, state, county, town } = getAllFilters2();
    const areaFilters = { watershed, waterbody, state, county, town };
    const areafiltersInputsMap = {
      watershed: "watershed",
      waterbody: "waterbody",
      state: "state",
      county: "county",
      town: "town"
    };
    const isSelectedArea = Object.values(areaFilters).some((value2) => value2);
    if (isSelectedArea) {
      if (selectedInput.inputParam === "watershed" || selectedInput.inputParam === "waterbody" || selectedInput.inputParam === "state" || selectedInput.inputParam === "county" || selectedInput.inputParam === "town") {
        let boundaryId = value;
        let boundaryType = selectedInput.inputParam;
        if (!value) {
          const activeLowerLevelAreaInputs = Object.entries(areaFilters).map(([key, areaValue]) => {
            const param = areafiltersInputsMap[key];
            const inputMeta = filtersInputs.find((input) => input.inputParam === param);
            return {
              inputParam: param,
              value: areaValue,
              dependencyLevel: inputMeta?.dependencyLevel ?? Infinity
            };
          }).filter((item) => item.value && item.dependencyLevel < selectedInput.dependencyLevel);
          if (activeLowerLevelAreaInputs.length > 0) {
            const nearest = activeLowerLevelAreaInputs.reduce(
              (a, b) => a.dependencyLevel > b.dependencyLevel ? a : b
            );
            boundaryId = nearest.value;
            boundaryType = nearest.inputParam;
          }
        }
        updateMarkers(sites);
        updateBoundaryOutline({
          checkPoints: points,
          boundaryId,
          boundaryType
        });
      } else {
        updateMarkers(sites, true);
      }
    } else {
      updateMarkers(sites, true);
      updateBoundaryOutline({ clearOnly: true });
    }
    console.log(`filtered ${sites.length} site${sites.length > 1 || sites.length === 0 ? "s" : ""}:`);
    console.log(sites);
  };
  function handleInputs(state) {
    filtersInputs.forEach((input, index) => {
      const handler = createrHandler(index);
      pushInputHandler(handler);
      input.element.addEventListener("change", handler);
    });
    const isBuildFromState = Object.entries(initialFiltersState).some(
      ([key, value]) => state[key] !== value
    );
    if (isBuildFromState) {
      reRenderInputs();
      reRenderInputs(state);
    } else {
      reRenderInputs();
    }
  }

  // src/modules/tabs-handler.js
  init_live_reload();
  var areaTab = document.querySelector(".map_tabs-menu--area");
  var qualityTab = document.querySelector(".map_tabs-menu--quality");
  var {
    getTabsHandlers,
    getTabsState,
    getIsAdministrative: getIsAdministrative2,
    getIsOutlook: getIsOutlook2,
    getIsInitialized,
    clearTabsHandlers,
    pushTabHandler,
    setIsInitialized,
    setIsOutlook: setIsOutlook2,
    setIsAdministrative: setIsAdministrative2
  } = useTabsStore.getState();
  var {
    clearWaterFilters,
    clearAdminFilters,
    getAllFilters: getAllFilters3,
    getSelectedInputLevel: getSelectedInputLevel3,
    setSelectedInputLevel: setSelectedInputLevel3
  } = useFiltersStore.getState();
  var { getInitialized: getInitialized2 } = useDataStore.getState();
  var tabs = [
    {
      element: areaTab,
      stateElement: areaTab.querySelector(".map_tab--administrative"),
      falseElement: areaTab.querySelector(".map_tab--watershed"),
      stateClass: "w--current",
      setFunction: setIsAdministrative2,
      getFunction: getIsAdministrative2,
      tabParam: "administrative"
    },
    {
      element: qualityTab,
      stateElement: qualityTab.querySelector(".map_tab--outlook"),
      falseElement: qualityTab.querySelector(".map_tab--last-samples"),
      stateClass: "w--current",
      setFunction: setIsOutlook2,
      getFunction: getIsOutlook2,
      tabParam: "quality"
    }
  ];
  var createrHandler2 = (index) => (e) => {
    const targetTab = tabs[index];
    setCurentTabState(targetTab);
  };
  var filersTabsMap = {
    administrative: "isAdministrative",
    quality: "isOutlook"
  };
  function setCurentTabState(tab) {
    const catchedState = tab.stateElement.classList.contains(tab.stateClass);
    const curentState = tab.getFunction();
    if (catchedState !== curentState) {
      tab.setFunction(catchedState);
      const isInitialized = getIsInitialized();
      if (isInitialized) {
        setUrlQuery(tab.tabParam, catchedState);
        if (tab.tabParam === "administrative") {
          reRenderInputs();
          setSelectedInputLevel3(0);
          updateBoundaryOutline({ clearOnly: true });
          const sites = filterSites();
          updateMarkers(sites, true);
        }
      }
      if (tab.tabParam === "quality") {
        rebuildPopup();
        map.fire("manualUpdate");
        const sites = filterSites();
        updateMarkers(sites);
      }
    }
  }
  function handleTabs(state) {
    let isRenderFromState = false;
    if (Object.entries(state).some(([key, value]) => initialTabsState[key] !== value)) {
      isRenderFromState = true;
    }
    tabs.forEach((tab, index) => {
      if (!isRenderFromState) setCurentTabState(tab);
      const handler = createrHandler2(index);
      pushTabHandler(handler);
      tab.element.addEventListener("click", handler);
    });
    if (isRenderFromState) renderTabsFromState();
    setIsInitialized(true);
  }
  function renderTabsFromState() {
    const state = getTabsState();
    const handlers = getTabsHandlers();
    const tabsToDipatch = [];
    tabs.forEach((tab, index) => {
      const filterKey = filersTabsMap[tab.tabParam];
      if (state[filterKey] !== initialTabsState[filterKey]) {
        tabsToDipatch.push({ tab, key: state[filterKey] });
      }
    });
    function dipatchHandlersFromState() {
      for (dispatch of tabsToDipatch) {
        const { tab, key } = dispatch;
        if (tab.stateElement.classList.contains(tab.stateClass) && !key) {
          tab.falseElement.click();
        }
        if (!tab.stateElement.classList.contains(tab.stateClass) && key) {
          tabs.stateElement.click();
        }
      }
    }
    const initialized = getInitialized2();
    if (initialized) dipatchHandlersFromState();
    else {
      map.once("initialized", dipatchHandlersFromState);
    }
  }

  // src/modules/loader.js
  init_live_reload();
  var viewport = document.querySelector("#viewport");
  var filtersContent = document.querySelector(".map_filters-content");
  var imageBar = document.querySelector(".map_image-bar");
  var mapLoader = document.querySelector(".map_loader");
  var drop = document.querySelector(".map_loader-drop");
  window.stop = false;
  function hideLoader() {
    window.stop = true;
  }

  // src/modules/image-bar.js
  init_live_reload();

  // src/store/image-bar-store.js
  init_live_reload();
  var useImageBarStore = createStore((set2, get2) => ({
    siteHandlers: /* @__PURE__ */ new Map(),
    isAnimanionPlaying: false,
    isActive: false,
    setIsAnimationPlaying: (isAnimanionPlaying) => set2(() => ({ isAnimanionPlaying })),
    pushSiteHandler: ([key, value]) => set2((state) => ({ siteHandlers: state.siteHandlers.set(key, value) })),
    clearSiteHandlers: () => set2(() => ({ siteHandlers: /* @__PURE__ */ new Map() })),
    setIsActive: (isActive) => set2(() => ({ isActive })),
    getSiteHandlers: () => get2().siteHandlers,
    getIsAnimationPlaying: () => get2().isAnimanionPlaying,
    getIsActive: () => get2().isActive
  }));
  var image_bar_store_default = useImageBarStore;

  // src/blocks-layout/image.html
  init_live_reload();
  var image_default = '<a data-site-id="SITE_ID" draggable="false" target="_blank" href="SITE_LINK" class="map_site-image">SITE_IMAGE<div class="map_site-image-name"><img heigh="14px" width="10px" src="SITE_ICON"> <span>SITE_NAME</span></div></a>';

  // src/modules/image-bar.js
  var imageBarTween = null;
  var lasImageBarDirection = null;
  var {
    pushSiteHandler,
    clearSiteHandlers,
    getSiteHandlers,
    getIsAnimationPlaying,
    setIsAnimationPlaying,
    getIsActive,
    setIsActive
  } = image_bar_store_default.getState();
  var { getFeaturesProps: getFeaturesProps2 } = features_store_default.getState();
  var { getLang: getLang2, getAccessibility: getAccessibility2 } = useDataStore.getState();
  function makeImageBar() {
    const slider = document.querySelector(".map_image-bar");
    const DRAG_THRESHOLD = 5;
    let isDragging = false;
    let startX = 0;
    let scrollLeft = 0;
    let velocity = 0;
    function onPointerMove(e) {
      if (!isDragging) return;
      const dx = e.clientX - startX;
      const prevScroll = slider.scrollLeft;
      slider.scrollLeft = scrollLeft - dx;
      velocity = slider.scrollLeft - prevScroll;
      if (Math.abs(dx) > DRAG_THRESHOLD && !getIsAnimationPlaying()) {
        setIsAnimationPlaying(true);
      }
    }
    function onPointerUp() {
      slider.classList.remove("dragging");
      isDragging = false;
      animateMomentum();
      window.removeEventListener("pointermove", onPointerMove);
      window.removeEventListener("pointerup", onPointerUp);
    }
    slider.addEventListener("pointerdown", (e) => {
      isDragging = true;
      setIsAnimationPlaying(false);
      startX = e.clientX;
      scrollLeft = slider.scrollLeft;
      velocity = 0;
      slider.classList.add("dragging");
      window.addEventListener("pointermove", onPointerMove);
      window.addEventListener("pointerup", onPointerUp);
    });
    function animateMomentum() {
      const distance = velocity * 20;
      const targetScroll = slider.scrollLeft + distance;
      gsap3.to(slider, {
        scrollTo: {
          x: targetScroll,
          autoKill: true
        },
        overwrite: true,
        duration: 1,
        ease: "power3.out",
        onComplete: () => {
          setIsAnimationPlaying(false);
        }
      });
    }
    slider.addEventListener(
      "wheel",
      (e) => {
        const mapboxScrollOverlay = document.querySelector(".mapboxgl-scroll-zoom-blocker");
        if (!mapboxScrollOverlay || getComputedStyle(mapboxScrollOverlay).opacity === "0") {
          e.preventDefault();
          const SCROLL_MULTIPLIER = 2;
          const scrollDelta = (e.deltaX + e.deltaY) * SCROLL_MULTIPLIER;
          gsap3.to(slider, {
            scrollTo: {
              x: slider.scrollLeft + scrollDelta,
              autoKill: true
            },
            duration: 0.4,
            ease: "power2.out"
          });
        }
      },
      { passive: false }
    );
    map.on("moveend", () => {
      waitForFeaturesRendered("site-points", (features) => {
        updateVisibleList(features);
      });
    });
    map.on("manualUpdate", () => {
      const visibleSites = getVisibleSites();
      updateVisibleList(visibleSites);
    });
    waitForFeaturesRendered("site-points", (features) => {
      updateVisibleList(features);
    });
  }
  function getVisibleSites() {
    const mapCanvas2 = map.getCanvas();
    const imageBar2 = document.querySelector(".map_image-bar");
    const mapWidth = mapCanvas2.clientWidth;
    const mapHeight = mapCanvas2.clientHeight;
    const imageBarHeight = imageBar2.clientHeight;
    const padding = 20;
    const visiblePixelBounds = [
      [padding, padding],
      [mapWidth - padding, mapHeight - imageBarHeight - padding]
    ];
    const features = map.queryRenderedFeatures(visiblePixelBounds, {
      layers: ["site-points-layer"]
    });
    const unique = /* @__PURE__ */ new Map();
    for (const feature2 of features) {
      const id = feature2.properties.id;
      if (!unique.has(id)) {
        unique.set(id, feature2.properties);
      }
    }
    return [...unique.values()];
  }
  var createSiteHandler = () => (e) => {
    const isAnimanionPlaying = getIsAnimationPlaying();
    if (isAnimanionPlaying) e.preventDefault();
  };
  function killSiteHandlers() {
    const handlersMap = getSiteHandlers();
    for (const [el, handlers] of handlersMap) {
      handlers.forEach((handler) => {
        el.removeEventListener("click", handler);
      });
      const siteId = el.getAttribute("data-site-id");
      unhighlightMapSite(siteId);
    }
    clearSiteHandlers();
  }
  function cropText(text) {
    if (text.length > 18) {
      return `${text.substring(0, 18).trim()}...`;
    }
    return text;
  }
  function toggleImageBar(forceState = null) {
    const container = document.querySelector(".map_image-bar");
    if (!container) return;
    const height = container.offsetHeight;
    const currentTransform = gsap3.getProperty(container, "y");
    const isCurrentlyVisible = currentTransform <= 0.1;
    const shouldShow = forceState !== null ? forceState : !isCurrentlyVisible;
    const targetY = shouldShow ? 0 : height;
    const direction = shouldShow ? "up" : "down";
    if (direction === lasImageBarDirection && imageBarTween) return;
    if (shouldShow) {
      container.style.display = "flex";
    }
    imageBarTween?.kill();
    imageBarTween = gsap3.to(container, {
      y: targetY,
      duration: 0.5,
      ease: "power3.out",
      onComplete: () => {
        if (!shouldShow) {
          container.style.display = "none";
        }
        imageBarTween = null;
        lasImageBarDirection = null;
      }
    });
    lasImageBarDirection = direction;
  }
  function updateVisibleList(sites) {
    const isActive = getIsActive();
    const featuresProps = getFeaturesProps2();
    killSiteHandlers();
    const filteredSites = sites.map((site) => {
      return {
        ...site,
        ...featuresProps[site.id]
      };
    }).filter((site) => site.image).filter((site, index) => index < 20);
    const container = document.querySelector(".map_image-bar");
    container.innerHTML = "";
    if (filteredSites.length === 0 && isActive) {
      setIsActive(false);
      toggleImageBar(false);
    }
    if (filteredSites.length > 0 && !isActive) {
      setIsActive(true);
      toggleImageBar(true);
    }
    let baseUrl = window.location.host;
    const lang = getLang2();
    if (lang === "es") ;
    baseUrl += "/es";
    filteredSites.forEach((site) => {
      const imageFormatedHtml = image_default.replace("SITE_ID", site.id).replace("SITE_LINK", `/${lang === "es" ? "es/" : ""}sites/${site.slug}`).replace(
        "SITE_IMAGE",
        site.image ? `<img src="${site.image}" class="map_site-img" alt="Monitoring site image" height="100%" width="100%">` : ""
      ).replace("SITE_ICON", getMarkerSvgFromSite(site)).replace("SITE_NAME", cropText(site.name));
      const el = html_to_element_default(imageFormatedHtml);
      const highlightFunction = (e) => {
        if (!e.pointerType || e.pointerType !== "mouse") return;
        highlightMapSite(site.id, site);
      };
      const unHighlightFunction = (e) => {
        if (!e.pointerType || e.pointerType !== "mouse") return;
        unhighlightMapSite();
      };
      function getMarkerSvgFromSite(site2) {
        const access = getAccessibility2();
        const siteType = getSiteType(site2);
        const iconUrl = icons.get(
          `marker-${siteType.quality}-${siteType.relevance}${access ? "-access" : ""}`
        );
        if (!iconUrl) {
          console.error(`Icon with id marker-${siteType.quality}-${siteType.relevance} not found`);
        }
        return iconUrl;
      }
      const handler = createSiteHandler();
      el.addEventListener("click", handler);
      el.addEventListener("pointerenter", highlightFunction);
      el.addEventListener("pointerleave", unHighlightFunction);
      pushSiteHandler([el, [handler, highlightFunction, unHighlightFunction]]);
      container.appendChild(el);
    });
  }

  // src/modules/process-styles.js
  init_live_reload();

  // src/blocks-layout/variables.css
  init_live_reload();
  var variables_default = ":root{--general-text-color:#063d57;--light-text-color:hsla(199, 87%, 18%, 0.7);--vater-main-color:#1e90ff}.mapboxgl-map{font-family:var(--font-family--font-family-1)!important}.map .map_view-wrapper{font:12px/20px var(--font-family--font-family-1)!important}.mapboxgl-ctrl-attrib-inner{padding:0 15px 0 0}.mapboxgl-ctrl-attrib-inner a{color:#000;font-size:10px}";

  // src/blocks-layout/hover-popup.css
  init_live_reload();
  var hover_popup_default = ".mapboxgl-popup-content:has(.hover-popup){border-radius:10px;padding:0;overflow:hidden;-webkit-box-shadow:0 0 17px -9px #42445a;-moz-box-shadow:0 0 17px -9px #42445a;box-shadow:0 0 17px -9px #42445a}.hover-popup{max-width:300px;display:block;color:var(--general-text-color);padding:6px 16px;font-style:16px;font-weight:600}";

  // src/blocks-layout/site-popup.css
  init_live_reload();
  var site_popup_default = ".mapboxgl-popup-content:has(.site-popup){height:0;border-radius:20px;padding:0;overflow:hidden;-webkit-box-shadow:0 0 17px -9px #42445a;-moz-box-shadow:0 0 17px -9px #42445a;box-shadow:0 0 17px -9px #42445a}.mapboxgl-popup-tip{display:none!important}.mapboxgl-popup-close-button{transition:background .5s;font-weight:100;right:5px;top:5px;font-size:19px;background:rgb(119 119 119/23%);backdrop-filter:blur(50px);color:#fff;border-radius:100%;width:30px;height:30px;align-items:center;justify-content:center;display:flex;padding:0}.site-popup{height:0;width:245px;font-size:14px;color:var(--general-text-color)}.site-popup_image-wrapper{display:block;width:100%;max-height:80px;overflow:hidden}.popup-image{width:100%;height:100%;object-fit:cover;object-position:center}.mapboxgl-popup-content:has(.popup-image) .site-popup_text-wrapper{padding:16px}.site-popup_text-wrapper{background-color:#fff;padding:35px 16px 16px}.site-popup_heading{font-size:14px;font-weight:600;text-decoration:none}.site-popup_heading,.site-popup_heading:link,.site-popup_heading:visited{color:var(--general-text-color)}.site-popup_descr{font-size:13px;display:block;margin:6px 0 0;user-select:auto}.site-popup_measurements{width:0%;display:flex;margin:4px 0 0;gap:2px}.site-popup_measure{border-radius:4px;height:12px}.site-popup_link{display:block;margin:6px 0 0;font-size:12px;color:var(--light-text-color)}.site-popup_link:link,.site-popup_link:visited{text-decoration:none;color:var(--light-text-color)}.site-popup_link:hover{color:var(--vater-main-color)}@media (max-width:767px){.mapboxgl-popup{min-width:100%;position:absolute;padding:0 15px;bottom:20px;z-index:4;transform:translate(0,0)!important}.mapboxgl-popup-content:has(.site-popup){width:100%}.mapboxgl-popup-close-button{height:40px;width:40px;top:8px;right:8px;font-size:32px}.mapboxgl-popup-content:has(.popup-image) .site-popup_text-wrapper{padding:16px 16px 37px}.site-popup_text-wrapper{padding:35px 16px 37px}.site-popup{width:100%}.site-popup_image-wrapper{max-height:120px}.site-popup_descr,.site-popup_heading,.site-popup_link{font-size:16px}.site-popup_measure{height:16px}}";

  // src/blocks-layout/image.css
  init_live_reload();
  var image_default2 = ".map_image-bar{display:none;transform:translateY(100%);cursor:grab;overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none}.map_image-bar.dragging{cursor:grabbing}.map_image-bar::-webkit-scrollbar{display:none}.map_site-image{transition:box-shadow .2s ease,transform .2s ease;position:relative;text-decoration:none;-webkit-user-drag:none;user-drag:none;user-select:none;font-size:10px;display:block;width:140px;height:100px;overflow:hidden;flex:0 0 140px;border-radius:6px;box-shadow:0 4px 30px rgba(0,0,0,.1)}.map_site-img{object-position:center;object-fit:cover;width:100%;height:100%}.map_site-image:hover{box-shadow:0 0 16px rgba(255,255,255,.3);transform:scale(1.02)}.map_site-image-name{transform:translateX(-50%);left:50%;width:100%;bottom:0;padding:0 5px 5px 10px;position:absolute}.map_site-image-name span{color:#fff;text-align:center;line-height:10px}.map_site-image-name img{margin:0 4px 0 0;object-position:center;object-fit:cover}.map_site-image img,span{-webkit-user-drag:none;user-drag:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-o-user-select:none;user-select:none}@media (max-width:767px){.map:has(.site-popup) .map_image-bar{opacity:0!important}}";

  // src/blocks-layout/map-scroll-overlay.css
  init_live_reload();
  var map_scroll_overlay_default = ".mapboxgl-scroll-zoom-blocker,.mapboxgl-touch-pan-blocker{z-index:3}";

  // src/modules/process-styles.js
  function processSyles() {
    const styles = [variables_default, map_scroll_overlay_default, hover_popup_default, site_popup_default, image_default2];
    const styleElement = document.createElement("style");
    styleElement.innerHTML = `${styles.join("")}`;
    document.body.append(styleElement);
  }
  var process_styles_default = processSyles;

  // src/modules/handle-access.js
  init_live_reload();
  var { getSites: getSites3, toggleAccessibility } = useDataStore.getState();
  function handleAccess() {
    const accessBtn = document.querySelector("#accessibility");
    if (accessBtn)
      accessBtn.addEventListener("click", (e) => {
        toggleAccessibility();
        updateMarkers(getSites3());
        map.fire("manualUpdate");
      });
  }

  // src/build-map-filters.js
  var timer = Date.now();
  var { getSites: getSites4, setInitialized } = useDataStore.getState();
  var { getTabsState: getTabsState2 } = useTabsStore.getState();
  var { getAllFilters: getAllFilters4 } = useFiltersStore.getState();
  function waitForMapLoad() {
    return new Promise((resolve) => {
      if (map.loaded()) {
        resolve();
      } else {
        map.once("load", () => resolve());
      }
    });
  }
  async function buildMapFilters() {
    await Promise.all([waitForMapLoad()]).then(async () => {
      const filtersState = getAllFilters4();
      const tabsState = getTabsState2();
      process_styles_default();
      generateAllMarkerIcons();
      loadBoundaries();
      handleInputs(filtersState);
      handleTabs(tabsState);
      const sites = getSites4();
      console.log("Sites: ", sites.length);
      await createMarkerLayer(sites);
      makeImageBar();
      handleAccess();
      waitForSourceAndUpdate("site-points", () => {
        console.log("Sorce initialized, map event fired initialized");
        map.fire("initialized");
        setInitialized(true);
        hideLoader();
      });
      console.log(`Rendered all in ${Date.now() - timer} ms`);
    }).catch(console.error);
  }
  if (!window.dataInitialized) {
    window.buildMapFilters = buildMapFilters;
  } else {
    buildMapFilters();
  }
})();
/*! Bundled license information:

mapbox-gl/dist/mapbox-gl.js:
  (**
   * martinez v0.7.4
   * Martinez polygon clipping algorithm, does boolean operation on polygons (multipolygons, polygons with holes etc): intersection, union, difference, xor
   *
   * @author Alex Milevski <info@w8r.name>
   * @license MIT
   * @preserve
   *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

gsap/gsap-core.js:
  (*!
   * GSAP 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/CSSPlugin.js:
  (*!
   * CSSPlugin 3.13.0
   * https://gsap.com
   *
   * Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)

gsap/ScrollToPlugin.js:
  (*!
   * ScrollToPlugin 3.13.0
   * https://gsap.com
   *
   * @license Copyright 2008-2025, GreenSock. All rights reserved.
   * Subject to the terms at https://gsap.com/standard-license
   * @author: Jack Doyle, jack@greensock.com
  *)
*/
//# sourceMappingURL=build-map-filters.js.map
